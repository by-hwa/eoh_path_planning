{
    "operator": "e2",
    "algorithm_description": "This hybrid algorithm integrates the bidirectional tree growth of the dual-tree RRT with the rewiring and path cost optimization from RRT*, combining efficient exploration and asymptotic optimality. It grows two trees from start and goal, extends them alternately toward random samples, uses a rewiring step to optimize local paths dynamically, and attempts connection when proximity allows. This approach improves path quality and success rate while maintaining computational efficiency and robust collision checking.",
    "planning_mechanism": "The planner alternates expansion between start and goal trees by sampling collision-free random points and steering nodes toward them. For each extension, a neighborhood rewiring step optimizes path costs locally. The algorithm attempts to connect the two trees by incremental steering with rewiring until a collision-free path uniting start and goal is found or maximum iterations are reached. Validity checks for nodes and edges are enforced strictly at every step.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        def _sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _distance(a, b):\n            return math.dist(a, b)\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: _distance(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            dist = _distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _near_nodes(tree, position, radius):\n            return [node for node in tree if _distance(node.position, position) <= radius]\n\n        def _can_connect(p1, p2):\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def _add_node(tree, new_node, parent_node):\n            parent_node.add_child(new_node)\n            new_node.cost = parent_node.cost + _distance(parent_node.position, new_node.position)\n            new_node.parent = parent_node\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n\n        def _rewire(tree, new_node):\n            neighbors = _near_nodes(tree, new_node.position, self.rewire_radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                new_cost = new_node.cost + _distance(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and _can_connect(new_node.position, neighbor.position):\n                    # Remove old edge\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n\n                    # Add new edge\n                    new_node.add_child(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    edges.append((new_node, neighbor))\n\n        def _extend(tree, point):\n            nearest = _nearest(tree, point)\n            new_pos = _steer(nearest.position, point)\n            if not _can_connect(nearest.position, new_pos):\n                return None\n            new_node = Node(new_pos)\n            min_cost = nearest.cost + _distance(nearest.position, new_pos)\n            best_parent = nearest\n\n            neighbors = _near_nodes(tree, new_pos, self.rewire_radius)\n\n            # Choose best parent from neighbors to minimize cost\n            for neighbor in neighbors:\n                c = neighbor.cost + _distance(neighbor.position, new_pos)\n                if c < min_cost and _can_connect(neighbor.position, new_pos):\n                    min_cost = c\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire around new node\n            _rewire(tree, new_node)\n            return new_node\n\n        def _connect(tree, new_node_other):\n            nearest = _nearest(tree, new_node_other.position)\n            curr_node = nearest\n\n            while True:\n                new_pos = _steer(curr_node.position, new_node_other.position)\n                if not _can_connect(curr_node.position, new_pos):\n                    return None\n\n                connect_node = Node(new_pos)\n                neighbors = _near_nodes(tree, new_pos, self.rewire_radius)\n\n                min_cost = curr_node.cost + _distance(curr_node.position, new_pos)\n                best_parent = curr_node\n\n                for neighbor in neighbors:\n                    c = neighbor.cost + _distance(neighbor.position, new_pos)\n                    if c < min_cost and _can_connect(neighbor.position, new_pos):\n                        min_cost = c\n                        best_parent = neighbor\n\n                best_parent.add_child(connect_node)\n                connect_node.parent = best_parent\n                connect_node.cost = min_cost\n                tree.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((best_parent, connect_node))\n\n                _rewire(tree, connect_node)\n\n                if _distance(connect_node.position, new_node_other.position) <= self.step_size:\n                    return connect_node\n\n                curr_node = connect_node\n\n        for iter_num in range(self.max_iter):\n            rand_point = _sample_free()\n\n            # Alternate expanding start and goal trees\n            if iter_num % 2 == 0:\n                new_node_start = _extend(tree_start, rand_point)\n                if new_node_start is None:\n                    continue\n                connect_node_goal = _connect(tree_goal, new_node_start)\n                if connect_node_goal:\n                    success_state = True\n                    path_start = new_node_start.path_from_root()\n                    path_goal = connect_node_goal.path_from_root()\n                    extracted_path = path_start + path_goal[::-1]\n                    break\n            else:\n                new_node_goal = _extend(tree_goal, rand_point)\n                if new_node_goal is None:\n                    continue\n                connect_node_start = _connect(tree_start, new_node_goal)\n                if connect_node_start:\n                    success_state = True\n                    path_goal = new_node_goal.path_from_root()\n                    path_start = connect_node_start.path_from_root()\n                    extracted_path = path_start + path_goal[::-1]\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 8.43218,
    "time_improvement": -22.0,
    "length_improvement": 25.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01331765651702881,
            "num_nodes_avg": 100.9,
            "path_length_avg": 160.7913922442542,
            "success_improvement": 0.0,
            "time_improvement": -32.004036336481114,
            "length_improvement": 19.638007602273778,
            "objective_score": -5.673609380489578
        },
        {
            "map_id": 1,
            "success_rate": 0.8,
            "time_avg": 0.02202715873718262,
            "num_nodes_avg": 209.4,
            "path_length_avg": 217.93141644497078,
            "success_improvement": -19.999999999999996,
            "time_improvement": -53.992549441208105,
            "length_improvement": 27.68298307560509,
            "objective_score": -20.66116821724141
        },
        {
            "map_id": 2,
            "success_rate": 0.8,
            "time_avg": 0.023168563842773438,
            "num_nodes_avg": 214.7,
            "path_length_avg": 119.99487511069171,
            "success_improvement": -19.999999999999996,
            "time_improvement": 19.250204209499422,
            "length_improvement": 26.31591806914092,
            "objective_score": 1.0382448766780126
        }
    ],
    "success_rate": 0.8666666666666667
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is a bidirectional RRT* variant integrating informed sampling and adaptive rewiring to boost planning efficiency, path optimality, and success rate. It uses heuristic guiding from the start towards the goal with dynamic radius-based rewiring and path smoothing to achieve shorter and smoother paths.",
    "planning_mechanism": "The planner simultaneously grows two trees from start and goal within the map. Sampling focuses within an ellipsoidal informed subset to bias towards promising regions. New nodes are added after collision checks, then nearby nodes within an adaptive radius are rewired for lower-cost connections. Trees attempt connection after each extension, resulting in a high-quality solution. Finally, path extraction and smoothing refine the solution for shorter, smoother trajectories.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost(self, new_cost):\n        self.cost = new_cost\n        for c in self.children:\n            c.update_cost(c.parent.cost + self._distance(c.parent.position, c.position))\n\n    @staticmethod\n    def _distance(a, b):\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        c_best = math.dist(start_position, goal_position) * 2  # Initial cost upper bound\n        c_min = math.dist(start_position, goal_position)\n\n        def informed_sample():\n            # Sample inside an ellipsoid around start-goal to improve efficiency\n            x_start = start_position\n            x_goal = goal_position\n            while True:\n                # Sample uniformly in unit ball in dimension d\n                d = 3 if is_3d else 2\n                while True:\n                    sample = tuple(random.uniform(-1,1) for _ in range(d))\n                    radius = math.sqrt(sum(s*s for s in sample))\n                    if radius <= 1:\n                        break\n                # Scale to ellipsoid\n                L = [0]*d\n                for i in range(d):\n                    L[i] = (c_best/2 if i==0 else math.sqrt(c_best**2 - c_min**2)/2)\n                # Rotation matrix aligning x-axis with vector from start to goal\n                def rotation_vector_angle(theta):\n                    if d==2:\n                        # 2D rotate by angle theta\n                        cos_t = math.cos(theta)\n                        sin_t = math.sin(theta)\n                        return [[cos_t, -sin_t],\n                                [sin_t,  cos_t]]\n                    else:\n                        # For 3D, compute rotation matrix by Rodrigues' formula\n                        vec1 = (1,0,0)\n                        vec2 = tuple(x_goal[i]-x_start[i] for i in range(3))\n                        norm_vec2 = math.dist((0,0,0), vec2)\n                        if norm_vec2 == 0:\n                            return [[1,0,0],[0,1,0],[0,0,1]]\n                        axis = (vec1[1]*vec2[2]-vec1[2]*vec2[1],\n                                vec1[2]*vec2[0]-vec1[0]*vec2[2],\n                                vec1[0]*vec2[1]-vec1[1]*vec2[0])\n                        axis_norm = math.dist((0,0,0), axis)\n                        if axis_norm == 0:\n                            return [[1,0,0],[0,1,0],[0,0,1]]\n                        axis = tuple(a/axis_norm for a in axis)\n                        angle = math.acos((vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2])/norm_vec2)\n                        K = [[0,-axis[2],axis[1]],\n                             [axis[2],0,-axis[0]],\n                             [-axis[1],axis[0],0]]\n                        I = [[1,0,0],[0,1,0],[0,0,1]]\n                        # Rodrigues rotation matrix R = I + sin\u03b8*K + (1-cos\u03b8)*K^2\n                        R = [[0]*3 for _ in range(3)]\n                        # Matrix addition helper\n                        def mat_add(A,B):\n                            return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                        # Matrix scalar mult helper\n                        def mat_scalar_mul(A, s):\n                            return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                        # Matrix multiplication helper\n                        def mat_mul(A,B):\n                            return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        K2 = mat_mul(K,K)\n                        R = mat_add(mat_add(I, mat_scalar_mul(K, math.sin(angle))), mat_scalar_mul(K2, 1 - math.cos(angle)))\n                        return R\n                d_vec = tuple(x_goal[i] - x_start[i] for i in range(d))\n                norm_d = math.dist((0,)*d, d_vec)\n                # To avoid complexity, use identity matrix if direction vector is axis-aligned\n                if d == 2:\n                    angle = math.atan2(d_vec[1], d_vec[0]) if norm_d > 1e-8 else 0\n                    R = rotation_vector_angle(angle)\n                    scaled = tuple(L[i]*sample[i] for i in range(d))\n                    rotated = (R[0][0]*scaled[0] + R[0][1]*scaled[1],\n                               R[1][0]*scaled[0] + R[1][1]*scaled[1])\n                    pos = tuple(rotated[i] + (x_start[i] + x_goal[i]) / 2 for i in range(d))\n                else:\n                    R = rotation_vector_angle(0)  # Identity for now for simplification\n                    scaled = tuple(L[i]*sample[i] for i in range(d))\n                    pos = tuple(scaled[i] + (x_start[i] + x_goal[i]) / 2 for i in range(d))\n                if self._inside_bounds(pos, bounds) and not self._is_in_obstacle(pos, obstacles, is_3d):\n                    return pos\n\n        def improved_sample():\n            # With probability p, sample informed; else, uniform\n            p = 0.7\n            if c_best < float(\"inf\") and random.random() < p:\n                return informed_sample()\n            else:\n                return self._uniform_sample(bounds, obstacles, is_3d)\n\n        # Main loop\n        for iteration in range(self.max_iter):\n            rand_point = improved_sample()\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = self._nearest(tree_a, rand_point)\n                new_pos = self._steer(nearest_node.position, rand_point, self.step_size)\n                if not self._inside_bounds(new_pos, bounds):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.parent = nearest_node\n                new_node.cost = new_cost\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Rewire nearby nodes within rewire_radius to improve path costs\n                near_nodes = self._near(tree_a, new_pos, self.rewire_radius)\n                for near_node in near_nodes:\n                    if near_node == nearest_node:\n                        continue\n                    potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                    if potential_cost < near_node.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                            # Rewire near_node\n                            if near_node.parent is not None:\n                                # Remove old edge\n                                try:\n                                    edges.remove((near_node.parent, near_node))\n                                    near_node.parent.children.remove(near_node)\n                                except (ValueError, AttributeError):\n                                    pass\n                            near_node.parent = new_node\n                            near_node.cost = potential_cost\n                            new_node.add_child(near_node)\n                            edges.append((new_node, near_node))\n                            # Update costs of subtree rooted at near_node\n                            self._update_subtree_costs(near_node, obstacles, is_3d)\n\n                # Try connecting to other tree\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size and \\\n                   not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    # Merge trees, extract path\n                    success_state = True\n                    c_best = min(c_best, new_node.cost + connect_node.cost + dist_connect)\n\n                    path_start = self._path_to_root(new_node)\n                    path_goal = self._path_to_root(connect_node)\n                    path_goal.reverse()\n                    extracted_path = path_start + path_goal\n\n                    # Optional smoothing\n                    extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n                    return PlannerResult(success_state, extracted_path, nodes, edges)\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _uniform_sample(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _inside_bounds(self, pos, bounds):\n        return all(0 <= pos[i] <= bounds[i] for i in range(len(bounds)))\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if math.dist(node.position, point) <= radius]\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], step_size: float) -> Tuple[float, ...]:\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _path_to_root(self, node: Node) -> List[Tuple[float, ...]]:\n        path = []\n        current = node\n        while current is not None:\n            path.append(current.position)\n            current = current.parent\n        return path[::-1]\n\n    def _update_subtree_costs(self, node: Node, obstacles, is_3d):\n        # DFS update cost of children recursively\n        for child in node.children:\n            if not self._is_edge_in_obstacle(node.position, child.position, obstacles, is_3d):\n                child.cost = node.cost + math.dist(node.position, child.position)\n                self._update_subtree_costs(child, obstacles, is_3d)\n\n    def _smooth_path(self, path: List[Tuple[float, ...]], obstacles, is_3d, iterations=20) -> List[Tuple[float, ...]]:\n        # Shortcut smoothing attempts to remove unnecessary waypoints\n        if len(path) < 3:\n            return path\n\n        for _ in range(iterations):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 32.39026,
    "time_improvement": -120.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.018288540840148925,
            "num_nodes_avg": 136.6,
            "path_length_avg": 176.17728495855667,
            "success_improvement": 0.0,
            "time_improvement": -81.27522710300693,
            "length_improvement": 11.948286305123998,
            "objective_score": -21.992910869877278
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0203230619430542,
            "num_nodes_avg": 275.6,
            "path_length_avg": 251.47819612943417,
            "success_improvement": 0.0,
            "time_improvement": -42.07915593669526,
            "length_improvement": 16.551026638232653,
            "objective_score": -9.313541453362047
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.09636964797973632,
            "num_nodes_avg": 629.7,
            "path_length_avg": 122.9577397894858,
            "success_improvement": 0.0,
            "time_improvement": -235.87879885759014,
            "length_improvement": 24.496540670390164,
            "objective_score": -65.86433152319901
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an enhanced bidirectional RRT* variant that integrates adaptive parameter tuning and informed sampling to accelerate convergence and improve path quality. It grows two trees from start and goal states, employs radius-based rewiring to refine paths, and uses heuristic-driven samples within an informed ellipse to focus the search near the optimal path, thereby improving planning efficiency, success rate, and resulting path smoothness.",
    "planning_mechanism": "The planner alternates tree expansions from start and goal with rewiring optimization around new nodes. It adaptively adjusts the neighbor radius based on the number of nodes to balance exploration and exploitation. Informed sampling is employed after an initial solution is found, focusing new samples within the ellipsoidal subset defined by the current best path to enhance convergence and path quality. Collision checks ensure node and edge validity without exceeding map bounds.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 6.0, initial_radius: float = 20.0, min_radius: float = 8.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.initial_radius = initial_radius\n        self.min_radius = min_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  \n        start_position = map.start         \n        goal_position = map.goal           \n        obstacles = map.obstacles          \n        is_3d = len(bounds) == 3\n\n        import math, random\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(len(bounds)))\n\n        def sample_free():\n            # If a solution exists, use informed sampling inside ellipse; else uniform random.\n            if best_path_cost < math.inf:\n                # Ellipse parameters\n                c_min = dist(start_position, goal_position)\n                c_max = best_path_cost\n                center = tuple((start_position[i] + goal_position[i]) / 2 for i in range(len(bounds)))\n                # Compute rotation (unit vector from start to goal)\n                if c_min == 0:\n                    return tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                else:\n                    unit_vec = tuple((goal_position[i] - start_position[i]) / c_min for i in range(len(bounds)))\n                    while True:\n                        # Sample random point in unit n-ball scaled by 1\n                        while True:\n                            sample = [random.uniform(-1, 1) for _ in range(len(bounds))]\n                            norm = math.sqrt(sum(s**2 for s in sample))\n                            if norm <= 1 and norm > 0:\n                                sample = [s / norm for s in sample]\n                                break\n                        # Scale sample by random radius inside unit ball\n                        rad = random.uniform(0, 1) ** (1 / len(bounds))\n                        sample = [s * rad for s in sample]\n\n                        # Scale by ellipse axes lengths:\n                        a1 = c_max / 2\n                        a2 = math.sqrt(c_max**2 - c_min**2) / 2\n                        if len(bounds) == 2:\n                            ellipse_point = (\n                                a1 * sample[0],\n                                a2 * sample[1]\n                            )\n                            # Rotate point to world frame\n                            rot_point = (\n                                center[0] + unit_vec[0] * ellipse_point[0] - unit_vec[1] * ellipse_point[1],\n                                center[1] + unit_vec[1] * ellipse_point[0] + unit_vec[0] * ellipse_point[1]\n                            )\n                        else:  # 3D approx: scale last two dims equally by a2\n                            ellipse_point = (\n                                a1 * sample[0],\n                                a2 * sample[1],\n                                a2 * sample[2]\n                            )\n                            # Rotation matrix aligning x axis to unit_vec (approx)\n                            # Compute orthonormal basis U,V,W:\n                            ux, uy, uz = unit_vec\n                            if abs(ux) < 1.0:  # avoid numerical issues\n                                vx = -uy\n                                vy = ux\n                                vz = 0.0\n                                vnorm = math.sqrt(vx**2 + vy**2 + vz**2)\n                                vx /= vnorm\n                                vy /= vnorm\n                            else:\n                                vx, vy, vz = 0., 1., 0.\n                            wx = uy * vz - uz * vy\n                            wy = uz * vx - ux * vz\n                            wz = ux * vy - uy * vx\n\n                            rot_point = (\n                                center[0] + ellipse_point[0]*ux + ellipse_point[1]*vx + ellipse_point[2]*wx,\n                                center[1] + ellipse_point[0]*uy + ellipse_point[1]*vy + ellipse_point[2]*wy,\n                                center[2] + ellipse_point[0]*uz + ellipse_point[1]*vz + ellipse_point[2]*wz\n                            )\n                        # Check bounds and collision\n                        if in_bounds(rot_point) and not self._is_in_obstacle(rot_point, obstacles, is_3d):\n                            return rot_point\n            else:\n                # Uniform random sampling w/ obstacle check inside bounds\n                while True:\n                    point = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                    if not self._is_in_obstacle(point, obstacles, is_3d):\n                        return point\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def steer(from_pos, to_pos, step_size):\n            d = dist(from_pos, to_pos)\n            if d <= step_size:\n                return to_pos\n            ratio = step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return list(reversed(path_start)) + path_goal\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        best_path_cost = math.inf\n\n        for iter_num in range(self.max_iter):\n            sample = sample_free()\n\n            # adapt radius per iteration and node count according to RRT* theory\n            total_nodes = len(nodes)\n            gamma_rrt = self.initial_radius\n            r = max(self.min_radius, gamma_rrt * (math.log(total_nodes + 1) / (total_nodes + 1)) ** (1 / len(bounds)))\n\n            # Grow start_tree towards sample\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n\n                nearest_a = nearest(tree_a, sample)\n                new_pos = steer(nearest_a.position, sample, self.step_size)\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_a.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = near(tree_a, new_pos, r)\n\n                # Choose parent for new_node minimizing cost\n                min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n                min_parent = nearest_a\n                for near_node in near_nodes:\n                    cost = near_node.cost + dist(near_node.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near_node\n\n                min_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire near nodes if new_node reduces their cost\n                for near_node in near_nodes:\n                    if near_node == min_parent:\n                        continue\n                    new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try: edges.remove((near_node.parent, near_node))\n                            except ValueError: pass\n                            try: near_node.parent.children.remove(near_node)\n                            except ValueError: pass\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n                # Attempt to connect tree_b with new_node\n                nearest_b = nearest(tree_b, new_node.position)\n                if dist(new_node.position, nearest_b.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, nearest_b.position, obstacles, is_3d) and not self._is_in_obstacle(nearest_b.position, obstacles, is_3d):\n\n                        # Build combined path and update best path cost if improved\n                        path = extract_path(new_node, nearest_b)\n                        path_cost = 0.0\n                        for i in range(len(path)-1):\n                            path_cost += dist(path[i], path[i+1])\n\n                        if path_cost < best_path_cost:\n                            best_path_cost = path_cost\n                            success_state = True\n                            extracted_path = path\n\n                # Swap trees to alternate expansion\n                tree_a, tree_b = tree_b, tree_a\n\n            if success_state and iter_num > self.max_iter * 0.6:\n                # Optional early break after good path found and sufficient exploration\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 8407.72085,
    "time_improvement": -28045.0,
    "length_improvement": 29.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 4.587495517730713,
            "num_nodes_avg": 5569.4,
            "path_length_avg": 144.06970874781018,
            "success_improvement": 0.0,
            "time_improvement": -45371.057482346936,
            "length_improvement": 27.995344293389085,
            "objective_score": -13605.718175845403
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 3.675297474861145,
            "num_nodes_avg": 5344.2,
            "path_length_avg": 218.51667787358915,
            "success_improvement": 0.0,
            "time_improvement": -25594.118558891918,
            "length_improvement": 27.48877353331417,
            "objective_score": -7672.737812960912
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 3.807441544532776,
            "num_nodes_avg": 5502.0,
            "path_length_avg": 111.25965302553558,
            "success_improvement": 0.0,
            "time_improvement": -13170.141787454268,
            "length_improvement": 31.67987064805855,
            "objective_score": -3944.7065621066686
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is a simplified optimized Bidirectional RRT (BI-RRT*) that grows two trees from start and goal, progressively extending them toward sampled free points. It rewires nodes within a radius to improve path cost while ensuring collision-free nodes and edges. The method balances exploration and exploitation to find high-quality, smooth, and feasible paths efficiently.",
    "planning_mechanism": "The planning mechanism iteratively samples random free points within bounds, extends one tree toward the sample, then attempts to connect the other tree to the new node. Nodes and edges undergo strict collision checks. Rewiring nearby nodes optimizes paths incrementally. Trees alternate roles each iteration until a connecting path is found or iteration limit is reached.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position       # Coordinates (2D or 3D)\n        self.parent = parent           # Parent Node or None\n        self.cost = cost               # Cost from root\n        self.children = []\n        self.valid = True              # Validity flag (collision-free)\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        final_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        for _ in range(self.max_iter):\n            sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if not new_node_a:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._connect_and_rewire(tree_b, new_node_a, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                success = True\n                path_from_start = new_node_a.path_from_root()\n                path_from_goal = new_node_b.path_from_root()\n                final_path = path_from_start + path_from_goal[::-1][1:]  # avoid duplicate node\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success, final_path, nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d) -> Tuple[float, ...]:\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree: List[Node], point: Tuple[float, ...], obstacles, is_3d,\n                           nodes: List[Node], edges: List[Tuple[Node, Node]]) -> Node or None:\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            if self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                continue\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            if self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost:\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree: List[Node], new_node: Node, obstacles, is_3d,\n                            nodes: List[Node], edges: List[Tuple[Node, Node]]) -> Node or None:\n        nearest = self._nearest(tree, new_node.position)\n        current_pos = nearest.position\n\n        while True:\n            new_pos = self._steer(current_pos, new_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current_pos, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                if self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    continue\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            connect_node.parent = best_parent\n\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                if self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    continue\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.children.remove(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n\n            current_pos = connect_node.position\n            nearest = connect_node\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...],\n                             obstacles: List[Tuple], is_3d: bool, resolution: float=1.0) -> bool:\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 94.93936,
    "time_improvement": -304.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.037035250663757326,
            "num_nodes_avg": 75.5,
            "path_length_avg": 175.81824683755517,
            "success_improvement": -9.999999999999998,
            "time_improvement": -267.09180538619324,
            "length_improvement": 12.1277301071068,
            "objective_score": -82.70199559443661
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.07646899223327637,
            "num_nodes_avg": 204.9,
            "path_length_avg": 230.3093546583982,
            "success_improvement": -9.999999999999998,
            "time_improvement": -434.5970947821087,
            "length_improvement": 23.57556441210288,
            "objective_score": -130.66401555221202
        },
        {
            "map_id": 2,
            "success_rate": 0.7,
            "time_avg": 0.08894786834716797,
            "num_nodes_avg": 184.0,
            "path_length_avg": 109.50564099824196,
            "success_improvement": -30.000000000000004,
            "time_improvement": -210.01154209540965,
            "length_improvement": 32.75693969627909,
            "objective_score": -71.45207468936708
        }
    ],
    "success_rate": 0.8333333333333334
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm with adaptive goal biasing, an exponentially decaying neighbor radius for local rewiring, and heuristic cost-guided rewiring to aggressively optimize path length while reducing planning time. The planner also applies shortcut smoothing on the extracted path to improve smoothness and robustness. It carefully alternates between trees, performs strict collision and edge feasibility checks before node and edge additions, and uses early termination upon connection to minimize runtime.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions by sampling points with an adaptive double goal bias. It extends trees towards samples using a fixed step size, rewires neighbors within a dynamically shrinking radius to improve costs locally, and attempts incremental connections between trees. When connection occurs, the shortest path is extracted, and a path smoothing step prunes unnecessary waypoints, resulting in high-quality, shorter, and smoother paths efficiently.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance(self, other_pos):\n        from math import dist\n        return dist(self.position, other_pos)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 initial_neighbor_radius: float=15.0,\n                 min_neighbor_radius: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.initial_neighbor_radius = initial_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        def sample_free():\n            # Adaptive double goal biasing: goal twice as likely as start\n            r = random.random()\n            if r < self.goal_sample_rate:\n                return goal_position\n            elif r < 2 * self.goal_sample_rate:\n                return start_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if self._dist_sq(node.position, pos) <= r_sq]\n\n        def can_connect(p1, p2):\n            if not in_bounds(p2):\n                return False\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def rewire(new_node, near, tree, edges):\n            for neighbor in near:\n                if neighbor == new_node.parent:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, potential_cost)\n                        edges.append((new_node, neighbor))\n\n        def neighbor_radius(iteration):\n            decay = iteration / self.max_iter\n            r = self.initial_neighbor_radius * (0.95 ** (decay * self.max_iter))  # exponential decay to focus rewiring\n            r = max(r, self.min_neighbor_radius)\n            return r\n\n        def try_extend(tree, sample_point, radius):\n            nearest_node = nearest(tree, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                if node == nearest_node:\n                    continue\n                if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    cost_through_node = node.cost + math.dist(node.position, new_pos)\n                    # Heuristic aggressive rewiring: allow slight epsilon to choose better cost nodes\n                    if cost_through_node + 1e-9 < min_cost:\n                        min_cost = cost_through_node\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(new_node, near, tree, edges)\n            return new_node\n\n        def try_connect(to_tree, from_node, radius):\n            curr_node = nearest(to_tree, from_node.position)\n            last_added_node = None\n            while True:\n                new_pos = steer(curr_node.position, from_node.position)\n                if not can_connect(curr_node.position, new_pos):\n                    break\n\n                new_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = curr_node\n                curr_node.children.append(new_node)\n\n                to_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr_node, new_node))\n\n                curr_node = new_node\n                last_added_node = new_node\n\n                if math.dist(new_pos, from_node.position) <= self.step_size:\n                    if can_connect(new_pos, from_node.position):\n                        final_cost = new_node.cost + math.dist(new_pos, from_node.position)\n                        final_node = Node(from_node.position)\n                        final_node.cost = final_cost\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n\n                        to_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    break\n\n            # Local rewiring around last added node to improve path quality\n            if last_added_node:\n                near = near_nodes(to_tree, last_added_node.position, radius)\n                rewire(last_added_node, near, to_tree, edges)\n\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Join without duplicating connection node\n            return path_start + path_goal[::-1][1:]\n\n        def smooth_path(path, max_attempts=75):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    continue\n                path = path[:i+1] + path[j:]\n            return path\n\n        nodes = []\n        edges = []\n        tree_start = [Node(start_position, cost=0.0)]\n        tree_goal = [Node(goal_position, cost=0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            radius = neighbor_radius(it)\n            sample = sample_free()\n\n            # Attempt grow start tree towards sample\n            new_node_start = try_extend(tree_start, sample, radius)\n            if new_node_start is None:\n                # Swap trees if extension failed (bidirectional alternating)\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            # Try connect goal tree towards newly added node\n            new_node_goal = try_connect(tree_goal, new_node_start, radius)\n            if new_node_goal is not None:\n                success_state = True\n                extracted_path = extract_path(new_node_start, new_node_goal)\n                extracted_path = smooth_path(extracted_path, max_attempts=100)\n                break\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _dist_sq(self, p1, p2):\n        return sum((p1[d] - p2[d]) ** 2 for d in range(len(p1)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 94.94693,
    "time_improvement": -318.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.04654185771942139,
            "num_nodes_avg": 164.6,
            "path_length_avg": 165.83538010353692,
            "success_improvement": 0.0,
            "time_improvement": -361.3208840238588,
            "length_improvement": 17.117070950477448,
            "objective_score": -104.97285101706215
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.06950955390930176,
            "num_nodes_avg": 373.5,
            "path_length_avg": 243.98074684955972,
            "success_improvement": -9.999999999999998,
            "time_improvement": -385.9434457584319,
            "length_improvement": 19.0389339592929,
            "objective_score": -116.97524693567098
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.08783087730407715,
            "num_nodes_avg": 340.8,
            "path_length_avg": 130.74563020704176,
            "success_improvement": -9.999999999999998,
            "time_improvement": -206.11847391727417,
            "length_improvement": 19.714306803598834,
            "objective_score": -62.89268081446247
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "time_expert",
    "algorithm_description": "This implementation enhances the bidirectional RRT* by introducing adaptive goal bias with a faster ramp-up for better early convergence, employs a k-d tree for efficient nearest neighbor and radius searches reducing computational complexity, introduces lazy collision checks caching edge validity to avoid redundant computations, and implements more aggressive pruning of unproductive nodes. It prioritizes incremental extension of the smaller tree towards adaptively sampled points, dynamic neighbor radius based on iteration and node count, heuristic sampling weighted by distance to goal/start, and iterative shortcut smoothing to produce shorter, smoother, and near-optimal collision-free paths rapidly and robustly.",
    "planning_mechanism": "The planner grows two trees from start and goal, always extending the smaller tree towards adaptively sampled points biased towards start/goal or randomly sampled. It uses k-d trees for fast neighborhood queries, dynamically adjusts neighbor radius based on iteration and tree size for efficient rewiring. Each new node picks the best parent minimizing cost, rewires neighbors, and attempts incremental connections to the opposing tree with cached lazy collision checks. Periodic pruning removes dead-end nodes, and final solution paths undergo iterative shortcut smoothing for path quality improvement.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.25,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=150,\n                 prune_threshold: int=200,\n                 smoothing_iterations: int=120,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        # ---- Helper functions ----\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # KD-Tree for fast nearest and radius search\n        # Simple 2D/3D KD-tree for nodes positions with rebuilding every prune_interval\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = len(points_nodes[0][0]) if points_nodes else 2\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, point):\n                best = None\n                best_dist = float('inf')\n                stack = [(0, len(self.points))]\n                for i in range(len(self.points)):\n                    d = dist(point, self.points[i])\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, point, radius):\n                result = []\n                r2 = radius * radius\n                for i, p in enumerate(self.points):\n                    # squred dist for perf\n                    sqd = sum((p[d] - point[d])**2 for d in range(len(point)))\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def sample_free(iteration):\n            # Adaptive goal bias ramping faster early, capped at 0.4\n            bias = min(self.goal_sample_rate + (iteration/self.max_iter)*0.2, 0.4)\n            r = random.random()\n            if r < bias:\n                # 75% towards the main goal, 25% towards start (balanced growth)\n                if random.random() < 0.75:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # fallback if repeated hits inside obstacles, return random without checking\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / distance_between\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            if in_bounds(new_pos):\n                return new_pos\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(len(bounds)))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        # Cache collision checks for edges to avoid redundant computations\n        edge_collision_cache = {}\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def prune_dead_nodes():\n            # Remove leaf nodes with no children except roots\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (start_root, goal_root):\n                    continue\n                if not node.children:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(node)\n                except ValueError:\n                    pass\n                # Clean edges containing this node\n                while True:\n                    try:\n                        edges.remove(next(e for e in edges if e[0] == node or e[1] == node))\n                    except StopIteration:\n                        break\n                removed += 1\n            return removed\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Initialize roots and trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        # KD-trees to speed up near/nearest queries, rebuilt periodically\n        def rebuild_kdtree():\n            return KDTree([(node.position, node) for node in nodes])\n\n        kd_tree = rebuild_kdtree()\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for iteration in range(self.max_iter):\n            q_rand = sample_free(iteration)\n\n            # Always extend smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_a, tree_b = tree_goal, tree_start\n            else:\n                tree_a, tree_b = tree_start, tree_goal\n\n            r = neighbor_radius(iteration, len(nodes))\n\n            # Extend tree_a towards q_rand using RRT* logic\n            # Use kd_tree for nearest neighbor search within that tree subset\n            # Extract subset nodes of tree_a for nearest and neighbors\n            sub_nodes = [(node.position, node) for node in tree_a]\n            sub_kdtree = KDTree(sub_nodes)\n            nearest_node = sub_kdtree.nearest(q_rand)\n            new_pos = steer(nearest_node.position, q_rand)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                # Failed extension, skip iteration\n                continue\n\n            near = sub_kdtree.radius_search(new_pos, r)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            # Select best parent with minimal cost & valid connection\n            for node in near:\n                potential_cost = node.cost + dist(node.position, new_pos)\n                if potential_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = potential_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to optimize cost if possible\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try to connect tree_b to new_node incrementally\n            sub_nodes_b = [(node.position, node) for node in tree_b]\n            sub_kdtree_b = KDTree(sub_nodes_b)\n            nearest_b = sub_kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n\n            connected = False\n            max_extend_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_extend_steps):\n                new_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(new_pos_b) or not can_connect(last_node_b.position, new_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, new_pos_b)\n                new_node_b = Node(new_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                # Rewire neighbors of new_node_b in tree_b\n                near_b = sub_kdtree_b.radius_search(new_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_b_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_b_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_b_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                # Check if connection to new_node is possible\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Smooth path with iterative shortcutting\n                    merged_path = shortcut_smoothing(merged_path)\n\n                    extracted_path = merged_path\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic pruning of dead-end nodes for efficiency\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n                # Rebuild kd_tree after pruning for up-to-date efficient queries\n                kd_tree = rebuild_kdtree()\n                # Clear edge cache to avoid memory bloat, but keep minimal\n                edge_collision_cache.clear()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 35.05465,
    "time_improvement": -132.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.015506649017333984,
            "num_nodes_avg": 99.3,
            "path_length_avg": 156.99622385581873,
            "success_improvement": 0.0,
            "time_improvement": -53.701235478168805,
            "length_improvement": 21.53479628556501,
            "objective_score": -11.803411386337636
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.062104415893554685,
            "num_nodes_avg": 252.7,
            "path_length_avg": 232.9376796934483,
            "success_improvement": 0.0,
            "time_improvement": -334.17389637556147,
            "length_improvement": 22.703397245279902,
            "objective_score": -95.71148946361245
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.030992841720581053,
            "num_nodes_avg": 170.8,
            "path_length_avg": 124.11726748792546,
            "success_improvement": 0.0,
            "time_improvement": -8.019886639837587,
            "length_improvement": 23.784520812424446,
            "objective_score": 2.350938170533613
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved bidirectional RRT planner enhances path planning performance by integrating informed sampling biased towards frontiers, adaptive step sizing near obstacles, and efficient rewiring to minimize path costs dynamically during tree growth. After connecting the start and goal trees, an aggressive shortcut smoothing process is applied using randomized edge-skipping to produce shorter, smoother paths. The planner maintains strict collision and edge validations, pruning longer paths in favor of lower-cost connections, thereby improving success rates and reducing total planning time while providing higher quality paths.",
    "planning_mechanism": "The planner alternates growth between forward and reverse trees, sampling points with a frontier bias to promote exploration near unknown boundaries. It adaptively reduces step size near obstacles for safer expansion. Upon adding new nodes, it rewires nearby nodes to reduce overall path cost, akin to RRT*. When the trees connect, the concatenated path is shortcut-smoothed iteratively to remove unnecessary waypoints and improve smoothness. This process results in efficient, collision-free, and cost-optimized trajectories.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        # Remove self from old parent's children\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, frontier_sample_rate: float = 0.3, rewire_radius: float = 10.0, smoothing_iters: int = 100):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.frontier_sample_rate = frontier_sample_rate\n        self.rewire_radius = rewire_radius\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start + tree_goal)\n\n        frontiers = self._identify_frontiers(bounds, obstacles, is_3d)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        for i in range(self.max_iter):\n            # Alternate tree order\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Sampling with frontier bias\n            if frontiers and random.random() < self.frontier_sample_rate:\n                rand_point = self._sample_near_frontier(frontiers, bounds, is_3d)\n            else:\n                rand_point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest_a = nearest_node(tree_a, rand_point)\n            step_size_a = self._adaptive_step_size(nearest_a.position, obstacles, is_3d)\n            new_pos_a = self._steer(nearest_a.position, rand_point, step_size_a)\n\n            if not self._in_bounds(new_pos_a, bounds):\n                continue\n            if self._is_in_obstacle(new_pos_a, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_a.position, new_pos_a, obstacles, is_3d):\n                continue\n\n            # Choose parent with minimum cost among near nodes in tree_a for new_pos_a (rewiring)\n            near_a = near_nodes(tree_a, new_pos_a, self.rewire_radius)\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos_a)\n            min_parent = nearest_a\n            for node in near_a:\n                if not self._is_edge_in_obstacle(node.position, new_pos_a, obstacles, is_3d):\n                    cost_through_node = node.cost + dist(node.position, new_pos_a)\n                    if cost_through_node < min_cost:\n                        min_cost = cost_through_node\n                        min_parent = node\n\n            new_node_a = Node(new_pos_a, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node_a)\n            tree_a.append(new_node_a)\n            nodes.append(new_node_a)\n            edges.append((min_parent, new_node_a))\n\n            # Rewiring: Try to connect other near nodes to new_node_a if cheaper\n            for node in near_a:\n                if node is min_parent:\n                    continue\n                if not self._is_edge_in_obstacle(new_node_a.position, node.position, obstacles, is_3d):\n                    potential_cost = new_node_a.cost + dist(new_node_a.position, node.position)\n                    if potential_cost < node.cost:\n                        node.update_parent(new_node_a, potential_cost)\n                        edges.append((new_node_a, node))  # Track rewired edge (optional)\n\n            # Connect tree_b towards new_node_a\n            nearest_b = nearest_node(tree_b, new_pos_a)\n            connected = False\n            current_node_b = nearest_b\n            while True:\n                step_size_b = self._adaptive_step_size(current_node_b.position, obstacles, is_3d)\n                next_pos_b = self._steer(current_node_b.position, new_pos_a, step_size_b)\n\n                if not self._in_bounds(next_pos_b, bounds):\n                    break\n                if self._is_in_obstacle(next_pos_b, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(current_node_b.position, next_pos_b, obstacles, is_3d):\n                    break\n\n                # Rewiring in tree_b as well\n                near_b = near_nodes(tree_b, next_pos_b, self.rewire_radius)\n                min_cost_b = current_node_b.cost + dist(current_node_b.position, next_pos_b)\n                min_parent_b = current_node_b\n                for node in near_b:\n                    if not self._is_edge_in_obstacle(node.position, next_pos_b, obstacles, is_3d):\n                        cost_through_node = node.cost + dist(node.position, next_pos_b)\n                        if cost_through_node < min_cost_b:\n                            min_cost_b = cost_through_node\n                            min_parent_b = node\n\n                new_node_b = Node(next_pos_b, parent=min_parent_b, cost=min_cost_b)\n                min_parent_b.add_child(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((min_parent_b, new_node_b))\n\n                # Rewiring in tree_b\n                for node in near_b:\n                    if node is min_parent_b:\n                        continue\n                    if not self._is_edge_in_obstacle(new_node_b.position, node.position, obstacles, is_3d):\n                        potential_cost = new_node_b.cost + dist(new_node_b.position, node.position)\n                        if potential_cost < node.cost:\n                            node.update_parent(new_node_b, potential_cost)\n                            edges.append((new_node_b, node))\n\n                current_node_b = new_node_b\n\n                if dist(next_pos_b, new_pos_a) <= step_size_b:\n                    path_a = new_node_a.path_from_root()\n                    path_b = current_node_b.path_from_root()\n                    if tree_a is tree_goal and tree_b is tree_start:\n                        # swap to maintain start->goal order\n                        path_a, path_b = path_b, path_a\n                    path = path_a + path_b[::-1]\n                    success = True\n                    connected = True\n                    break\n\n            if connected:\n                break\n\n        if success and len(path) > 2:\n            path = self._shortcut_smooth(path, obstacles, is_3d, bounds)\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _adaptive_step_size(self, position, obstacles, is_3d):\n        query_radius = self.base_step_size * 2\n        min_dist = float('inf')\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                px, py, pz = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dz = max(oz - pz, 0, pz - (oz + d))\n                dist = (dx*dx + dy*dy + dz*dz) ** 0.5\n            else:\n                ox, oy, w, h = obs\n                px, py = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dist = (dx*dx + dy*dy) ** 0.5\n            if dist < min_dist:\n                min_dist = dist\n        if min_dist <= query_radius:\n            factor = max(0.2, min_dist / query_radius)  # Scale step size with distance but don't go below 20%\n            return self.base_step_size * factor\n        return self.base_step_size\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        import random\n        dim = len(bounds)\n        frontier = random.choice(frontiers)\n        radius = self.base_step_size * 3\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                yield nbr\n\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                min_c = [int(ox // resolution), int(oy // resolution), int(oz // resolution)]\n                max_c = [int((ox + w) // resolution), int((oy + h) // resolution), int((oz + d) // resolution)]\n                ranges = [range(min_c[i], max_c[i] + 1) for i in range(3)]\n                for x in ranges[0]:\n                    for y in ranges[1]:\n                        for z in ranges[2]:\n                            occupied.add((x, y, z))\n            else:\n                ox, oy, w, h = obs\n                min_c = [int(ox // resolution), int(oy // resolution)]\n                max_c = [int((ox + w) // resolution), int((oy + h) // resolution)]\n                for x in range(min_c[0], max_c[0] + 1):\n                    for y in range(min_c[1], max_c[1] + 1):\n                        occupied.add((x, y))\n\n        if is_3d:\n            for ix in range(steps[0] + 1):\n                for iy in range(steps[1] + 1):\n                    for iz in range(steps[2] + 1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontiers.append(tuple((pos_grid[d] + 0.5) * resolution for d in range(dims)))\n        else:\n            for ix in range(steps[0] + 1):\n                for iy in range(steps[1] + 1):\n                    pos_grid = (ix, iy)\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontiers.append(((ix + 0.5) * resolution, (iy + 0.5) * resolution))\n\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n            return\n        for item in arrays[0]:\n            for rest in self._cartesian_product(arrays[1:]):\n                yield (item,) + rest\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, bounds):\n        import random\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            p_i, p_j = new_path[i], new_path[j]\n            if self._in_bounds(p_i, bounds) and self._in_bounds(p_j, bounds):\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    new_path = new_path[:i + 1] + new_path[j:]\n        return new_path",
    "objective": 317.11977,
    "time_improvement": -1074.0,
    "length_improvement": 25.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.09651689529418946,
            "num_nodes_avg": 207.9,
            "path_length_avg": 152.38497676196295,
            "success_improvement": 0.0,
            "time_improvement": -856.6712985282026,
            "length_improvement": 23.839453262087442,
            "objective_score": -252.23349890604325
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.19585566520690917,
            "num_nodes_avg": 657.9,
            "path_length_avg": 226.874162371368,
            "success_improvement": 0.0,
            "time_improvement": -1269.233025810269,
            "length_improvement": 24.715477430666883,
            "objective_score": -375.82681225694733
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.3428631782531738,
            "num_nodes_avg": 738.6,
            "path_length_avg": 120.53298597760006,
            "success_improvement": 0.0,
            "time_improvement": -1094.986958013862,
            "length_improvement": 25.985485580515178,
            "objective_score": -323.29899028805556
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm is a hybrid incremental sampling planner that combines informed sampling within an ellipsoidal heuristic region around the current best path with iterative path optimization via shortcut smoothing. It aims to accelerate convergence toward an optimal path by focusing samples where improvements are most likely and continuously refining the found path to improve smoothness and length.",
    "planning_mechanism": "The planner first builds a tree incrementally like RRT but after finding an initial solution, it restricts sampling to an ellipsoidal subset defined by start, goal, and current best path cost to guide exploration efficiently. Upon reaching the goal, it performs shortcut smoothing by attempting to connect random pairs of points on the path directly if collision-free, thus improving path quality and reducing length while maintaining robustness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def path_to_root(self):\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        def euclidean(p1, p2):\n            return math.dist(p1, p2)\n\n        def sample_in_bounds():\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def sample_in_ellipse(cbest, start, goal):\n            # Generate a uniformly random sample in the ellipsoid scaled by current best cost cbest\n            # Ellipsoid defined in the frame with foci start and goal\n            dim = len(bounds)\n            c_min = euclidean(start, goal)\n            if cbest == float('inf'):\n                return sample_in_bounds()\n\n            # Center and rotation\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            diff = tuple(goal[d] - start[d] for d in range(dim))\n            dist = max(c_min, 1e-6)\n\n            # Rotation matrix: only for 2D or 3D cases (orthonormal basis)\n            # Here we build an orthonormal frame with first axis along diff\n            import numpy as np\n\n            diff_np = np.array(diff)\n            e1 = diff_np / dist\n\n            # Create an orthonormal basis with e1 as first basis vector\n            if dim == 2:\n                e2 = np.array([-e1[1], e1[0]])\n                rotation = np.vstack((e1, e2)).T  # 2x2 matrix\n            elif dim == 3:\n                # Gram-Schmidt to find two perpendicular vectors\n                if abs(e1[0]) < abs(e1[1]):\n                    v = np.array([1,0,0])\n                else:\n                    v = np.array([0,1,0])\n                e2 = v - np.dot(v,e1)*e1\n                e2 /= np.linalg.norm(e2)\n                e3 = np.cross(e1,e2)\n                rotation = np.vstack((e1, e2, e3)).T  # 3x3 matrix\n            else:\n                # fallback to uniform sampling\n                return sample_in_bounds()\n\n            # Radii of the ellipsoid axes\n            a = cbest / 2   # major axis half length\n            r = math.sqrt(cbest**2 - c_min**2) / 2 if cbest > c_min else 0\n            radii = [a] + [r] * (dim -1)\n\n            # Sample unit ball point (random direction + radius^{1/dim} for uniform volumetric sampling)\n            while True:\n                # sample random vector in unit ball\n                vec = np.random.normal(0,1,dim)\n                norm = np.linalg.norm(vec)\n                if norm == 0: \n                    continue\n                unit_vec = vec / norm\n                # scale by uniform radius within unit ball (radius^(1/d))\n                radius_scale = random.uniform(0,1)**(1/dim)\n                sample_ball = unit_vec * radius_scale\n\n                # scale by radii\n                local_point = np.multiply(sample_ball, radii)\n                global_point = rotation @ local_point + np.array(center)\n\n                # Check in bounds\n                if all(0 <= global_point[d] <= bounds[d] for d in range(dim)):\n                    return tuple(global_point)\n\n        def steer(from_pos, to_pos):\n            dist = euclidean(from_pos, to_pos)\n            if dist == 0:\n                return from_pos\n            step = min(self.step_size, dist)\n            unit_vec = tuple((to_pos[d] - from_pos[d]) / dist for d in range(len(from_pos)))\n            new_pos = tuple(from_pos[d] + unit_vec[d]*step for d in range(len(from_pos)))\n            return new_pos\n\n        for iter_count in range(self.max_iter):\n            # After initial solution: informed sampling within ellipsoidal heuristic sampling\n            if best_goal_node:\n                sample = sample_in_ellipse(best_cost, start_position, goal_position)\n            else:\n                sample = sample_in_bounds()\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: euclidean(n.position, sample))\n\n            new_position = steer(nearest_node.position, sample)\n\n            # Check collisions and bounds\n            if any(not (0 <= new_position[d] <= bounds[d]) for d in range(len(bounds))):\n                continue\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + euclidean(nearest_node.position, new_position)\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check goal reach\n            dist_to_goal = euclidean(new_position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_cost = new_node.cost + dist_to_goal\n                    if goal_cost < best_cost:\n                        goal_node = Node(goal_position, parent=new_node, cost=goal_cost)\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success_state = True\n                        best_goal_node = goal_node\n                        best_cost = goal_cost\n\n            # Early stopping if max iterations reached and found solution\n            if iter_count >= self.max_iter - 1 and success_state:\n                break\n\n        # If success, extract and smooth path by shortcutting\n        if success_state:\n            path = best_goal_node.path_to_root()\n\n            def shortcut_smooth(path_, max_attempts=100):\n                path_smoothed = path_[:]\n                for _ in range(max_attempts):\n                    if len(path_smoothed) <= 2:\n                        break\n                    i = random.randint(0, len(path_smoothed) - 2)\n                    j = random.randint(i+1, len(path_smoothed) -1)\n                    if j == i +1:\n                        continue\n                    p1 = path_smoothed[i]\n                    p2 = path_smoothed[j]\n                    if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                        # Shortcut is possible: remove intermediate points\n                        path_smoothed = path_smoothed[:i+1] + path_smoothed[j:]\n                return path_smoothed\n\n            extracted_path = shortcut_smooth(path, max_attempts=200)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 2995.45002,
    "time_improvement": -9996.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.2528609752655029,
            "num_nodes_avg": 3151.0,
            "path_length_avg": 178.45351599762108,
            "success_improvement": 0.0,
            "time_improvement": -12318.303887927857,
            "length_improvement": 10.810647909786953,
            "objective_score": -3693.3290367963996
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.6598132610321046,
            "num_nodes_avg": 4219.8,
            "path_length_avg": 240.8545685239727,
            "success_improvement": 0.0,
            "time_improvement": -11503.805952113076,
            "length_improvement": 20.076305691042464,
            "objective_score": -3447.126524495714
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.7981833457946776,
            "num_nodes_avg": 4588.2,
            "path_length_avg": 128.02205757347767,
            "success_improvement": 0.0,
            "time_improvement": -6167.239478121122,
            "length_improvement": 21.38674447138304,
            "objective_score": -1845.8944945420599
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid algorithm combines the asymptotic optimality and rewiring principles from RRT* and the fast convergence benefits of a bidirectional approach inspired by RRT-Connect. It grows two trees simultaneously from start and goal with goal biasing, samples from free space, connects the trees when close enough, and performs rewiring in both trees to improve path quality incrementally. Additionally, it performs path shortcutting to smooth the final path for better quality.",
    "planning_mechanism": "The planner alternates tree expansions by sampling points with goal biasing, steering nearest nodes toward sampled points, rewires neighbors for cost improvements, tries connecting the two trees to form a full path, and upon success, extracts and smooths the path. Collision checks are applied for nodes and edges throughout, ensuring valid paths that respect obstacles and boundaries.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D position\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Accumulated path cost\n        self.children = []\n        self.valid = True               # For collision validity\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, neighbor_radius: float=12.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        import random\n        import math\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def _distance(a, b):\n            return math.dist(a, b)\n\n        def _steer(from_pos, to_pos, step_size):\n            dist = _distance(from_pos, to_pos)\n            if dist <= step_size:\n                return to_pos\n            ratio = step_size / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def _near(tree, point, radius):\n            return [node for node in tree if _distance(node.position, point) <= radius]\n\n        def _extract_path_meet(node_from_start, node_from_goal):\n            path_start = []\n            current = node_from_start\n            while current:\n                path_start.append(current.position)\n                current = current.parent\n            path_goal = []\n            cur = node_from_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def _path_shortcut(path):\n            # Attempt to smooth path by shortcutting between non-adjacent nodes if direct connection is collision-free\n            if len(path) < 3:\n                return path\n            smooth_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smooth_path.append(path[j])\n                i = j\n            return smooth_path\n\n        def _check_in_bounds(pos):\n            for i, val in enumerate(pos):\n                if val < 0 or val > bounds[i]:\n                    return False\n            return True\n\n        success = False\n        final_path = []\n\n        for iter in range(self.max_iter):\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Alternate between start_tree and goal_tree expansions\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Find nearest node in tree_a to sample\n                nearest = min(tree_a, key=lambda n: _distance(n.position, sample))\n                new_pos = _steer(nearest.position, sample, self.step_size)\n\n                # Check bounds\n                if not _check_in_bounds(new_pos):\n                    continue\n                # Collision checks\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Create new node, find near neighbors for rewiring\n                new_node = Node(new_pos)\n                near_nodes = _near(tree_a, new_pos, self.neighbor_radius)\n\n                min_cost = nearest.cost + _distance(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    temp_cost = near.cost + _distance(near.position, new_pos)\n                    if temp_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        min_parent = near\n\n                new_node.update_parent(min_parent, min_cost)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors in tree_a\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + _distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                        near.update_parent(new_node, new_cost)\n                        edges.append((new_node, near))\n\n                # Try connect tree_b to new_node in tree_a to form path\n                connect_node = min(tree_b, key=lambda n: _distance(n.position, new_node.position))\n                dist_connect = _distance(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size:\n                    if (not self._is_in_obstacle(connect_node.position, obstacles, is_3d) and\n                        not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d)):\n                        # Path connected, extract full path\n                        success = True\n                        final_path = _extract_path_meet(new_node, connect_node)\n                        # Smooth path with shortcutting\n                        final_path = _path_shortcut(final_path)\n                        break\n            if success:\n                break\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 11.21486,
    "time_improvement": -51.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.013281702995300293,
            "num_nodes_avg": 128.5,
            "path_length_avg": 174.34981020638165,
            "success_improvement": 0.0,
            "time_improvement": -31.647666581591665,
            "length_improvement": 12.861640621493342,
            "objective_score": -6.921971850178831
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02387359142303467,
            "num_nodes_avg": 287.3,
            "path_length_avg": 230.3975784226972,
            "success_improvement": 0.0,
            "time_improvement": -66.90101757631824,
            "length_improvement": 23.546288782365693,
            "objective_score": -15.361047516422332
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.044390535354614256,
            "num_nodes_avg": 367.1,
            "path_length_avg": 121.70644892216498,
            "success_improvement": 0.0,
            "time_improvement": -54.7150997032626,
            "length_improvement": 25.26490864195521,
            "objective_score": -11.361548182587736
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is an enhanced bidirectional RRT* variant that integrates adaptive step sizing and dynamic radius rewiring for improved efficiency and path quality. It grows two trees from start and goal, samples points biased towards the path for faster convergence, and employs smoothing on the resultant path to increase smoothness and robustness. It enforces strict collision and edge checks and limits node placement within map bounds.",
    "planning_mechanism": "The planner alternately grows two trees by sampling points biased via a goal-biased probability. Each extension employs adaptive step sizing based on distance to the sample, then rewires nodes in a dynamically calculated radius to optimize cost. Connection attempts between the two trees are made after each extension. The final combined path is smoothed using shortcutting to reduce unnecessary waypoints and produce a shorter, smoother trajectory.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated cost from root\n        self.children = []\n        self.valid = True               # Node validity flag\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_and_propagate(self, new_cost):\n        self.cost = new_cost\n        for child in self.children:\n            child.update_cost_and_propagate(new_cost + self._distance(self.position, child.position))\n\n    @staticmethod\n    def _distance(a, b):\n        import math\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float=7.0, goal_sample_rate: float = 0.1, radius_constant: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal point\n        self.radius_constant = radius_constant    # Used for dynamic radius calculation\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        dim = len(bounds)\n        unit_ball_volume = {2: math.pi, 3: 4 / 3 * math.pi}[dim]\n\n        for iter in range(self.max_iter):\n            # Goal-biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        break\n\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                # Find nearest in tree_a\n                nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n                direction_distance = math.dist(nearest.position, sample)\n                if direction_distance == 0.0:\n                    continue\n\n                # Adaptive step size: don't overshoot closer samples\n                step = min(self.step_size, direction_distance)\n                new_pos = tuple(\n                    nearest.position[d] + (sample[d] - nearest.position[d]) * (step / direction_distance) for d in range(dim)\n                )\n\n                if not in_bounds(new_pos) or self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                # Compute dynamic radius (RRT* style)\n                radius = min(\n                    self.radius_constant * ((math.log(len(tree_a) + 1) / (len(tree_a) + 1)) ** (1 / dim)),\n                    self.step_size * 5\n                )\n\n                near_nodes = [node for node in tree_a if math.dist(node.position, new_pos) <= radius]\n\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                best_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + math.dist(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = near\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                new_node.parent = best_parent\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            # Remove old edge\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                            try:\n                                near.parent.children.remove(near)\n                            except ValueError:\n                                pass\n\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        # Propagate cost update downwards\n                        near.update_cost_and_propagate(new_cost)\n\n                # Attempt connection to the other tree\n                nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n                dist_connect = math.dist(nearest_other.position, new_node.position)\n\n                if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    # Connect the trees\n                    success_state = True\n                    # Form path from start_root to new_node\n                    if tree_a is tree_start:\n                        path_start = new_node.path_from_root()\n                        path_goal = nearest_other.path_from_root()\n                        path_goal.reverse()\n                        full_path = path_start + path_goal\n                    else:\n                        path_start = nearest_other.path_from_root()\n                        path_goal = new_node.path_from_root()\n                        path_goal.reverse()\n                        full_path = path_start + path_goal\n\n                    # Smooth the path via shortcutting method\n                    smoothed_path = self._smooth_path(full_path, obstacles, is_3d, max_iterations=150, map_bounds=bounds)\n\n                    extracted_path = smoothed_path\n                    return PlannerResult(True, extracted_path, nodes, edges)\n\n        return PlannerResult(False, extracted_path, nodes, edges)\n\n\n    def _smooth_path(self, path, obstacles, is_3d, max_iterations=100, map_bounds=None):\n        import random\n        import math\n\n        def valid_edge(p1, p2):\n            if map_bounds:\n                for d in range(len(p1)):\n                    if p1[d] < 0 or p1[d] > map_bounds[d]:\n                        return False\n                    if p2[d] < 0 or p2[d] > map_bounds[d]:\n                        return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        if len(path) < 3:\n            return path[:]\n\n        path = path[:]\n        for _ in range(max_iterations):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n\n            if valid_edge(path[i], path[j]):\n                # Remove intermediate nodes and connect directly\n                path = path[:i+1] + path[j:]\n\n        return path\n\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 25.54824,
    "time_improvement": -98.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02762300968170166,
            "num_nodes_avg": 99.9,
            "path_length_avg": 167.97260652957092,
            "success_improvement": 0.0,
            "time_improvement": -173.7980791953795,
            "length_improvement": 16.048905724690606,
            "objective_score": -48.92964261367573
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.023543739318847658,
            "num_nodes_avg": 192.1,
            "path_length_avg": 243.82630931447866,
            "success_improvement": 0.0,
            "time_improvement": -64.59501129251362,
            "length_improvement": 19.090181558287142,
            "objective_score": -15.560467076096655
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.044884872436523435,
            "num_nodes_avg": 404.1,
            "path_length_avg": 123.9554182240814,
            "success_improvement": 0.0,
            "time_improvement": -56.43802127435036,
            "length_improvement": 23.883906010388394,
            "objective_score": -12.15462518022743
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an improved bidirectional RRT* variant with adaptive step size, informed sampling around an ellipse for faster convergence, and enhanced rewiring to optimize path quality and reduce search time. It incorporates aggressive rewiring, goal bias sampling, and path smoothing for robust and high-quality paths.",
    "planning_mechanism": "The planner grows two trees from start and goal positions, alternating expansions with adaptive step sizes. Sampling is biased towards an ellipsoidal region defined by current best path cost to focus exploration. After each extension, it attempts connection and performs rewiring with a dynamically adjusted radius to optimize the path. On successful connection, the path is extracted and smoothed.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def rewire(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        new_parent.children.append(self)\n        self.cost = new_cost\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 6.0, goal_sample_rate: float = 0.2,\n                 search_radius_factor: float = 20.0, smoothing_iterations: int = 5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # probability of sampling goal bias\n        self.search_radius_factor = search_radius_factor  # factor multiplier for neighbor search radius\n        self.smoothing_iterations = smoothing_iterations  # iterations for path smoothing\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n\n        nodes = []\n        edges = []\n\n        best_path_cost = float(\"inf\")\n        success_state = False\n        extracted_path = []\n\n        dimension = len(bounds)\n        diag_dist = math.dist((0,) * dimension, bounds)\n        # Dynamic radius for near neighbors will depend on sample count and dimension\n        def calc_radius(n_nodes):\n            gamma = self.search_radius_factor\n            unit_ball_volume = math.pi if dimension == 2 else (4/3)*math.pi\n            r = min(\n                self.step_size * 5,\n                gamma * ((math.log(max(n_nodes,1)) / max(n_nodes,1)) ** (1/dimension))\n            )\n            return r if r > self.step_size else self.step_size * 1.5\n\n        def ellipse_sample(c_best, start, goal):\n            # If no solution yet, sample uniformly\n            if c_best == float(\"inf\"):\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[i]) for i in range(3))\n                    else:\n                        p = tuple(random.uniform(0, bounds[i]) for i in range(2))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            # Ellipsoidal sampling focused between start and goal according to c_best path cost\n            center = tuple([(s + g) / 2 for s, g in zip(start, goal)])\n            a1 = [g - s for s, g in zip(start, goal)]\n            a1_len = math.dist(start, goal) / 2\n            if a1_len < 1e-6:\n                return start  # start == goal\n\n            # Rotation matrix to align ellipse along start-goal vector (assume 2D or 3D)\n            def unit_vector(v):\n                l = math.dist((0,) * len(v), v)\n                return tuple(x / l for x in v)\n\n            e_r1 = unit_vector(a1)\n            dim = len(start)\n\n            # Create an orthonormal basis with e_r1\n            import numpy as np\n            e1 = np.array(e_r1)\n            if dim == 2:\n                e2 = np.array([-e1[1], e1[0]])\n                basis = np.stack([e1, e2], axis=1)  # dim x dim\n            else:\n                # Gram-Schmidt for 3D, pick arbitrary vector not colinear\n                if abs(e1[0]) < abs(e1[1]):\n                    v = np.array([1,0,0])\n                else:\n                    v = np.array([0,1,0])\n                e2 = v - (np.dot(v,e1))*e1\n                e2 /= np.linalg.norm(e2)\n                e3 = np.cross(e1, e2)\n                basis = np.stack([e1, e2, e3], axis=1)\n\n            # Define ellipse axes lengths\n            r1 = c_best / 2\n            r2 = math.sqrt(max(c_best**2 - math.dist(start, goal)**2, 0)) / 2\n            if r2 < 1e-6:\n                r2 = self.step_size*2\n\n            while True:\n                # Sample point in unit ball scaled to ellipse\n                if dim == 2:\n                    sample_ball = np.random.normal(size=2)\n                else:\n                    sample_ball = np.random.normal(size=3)\n                sample_ball /= np.linalg.norm(sample_ball)\n                uniform_radius = random.uniform(0,1) ** (1/dim)\n                sample_ball = sample_ball * uniform_radius\n                scale = np.array([r1, r2] + ([r2] if dim==3 else []))\n                offset = center + basis @ (sample_ball * scale)\n                p = tuple(offset.tolist())\n                if all(0 <= p[i] <= bounds[i] for i in range(dim)) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def find_path_cost_back(node):\n            return node.cost if node else float(\"inf\")\n\n        for iteration in range(self.max_iter):\n            # With goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = ellipse_sample(best_path_cost, start_position, goal_position)\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size, bounds)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                radius = calc_radius(len(tree_a)+1)\n                near_nodes = self._near(tree_a, new_pos, radius)\n\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    cost = near.cost + math.dist(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node = Node(new_pos)\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewiring near nodes to new_node if improves cost and collision-free\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.rewire(new_node, new_cost)\n                        # Update edges list accordingly\n                        # Remove old edge:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        edges.append((new_node, near))\n\n                # Try connecting tree_b to this new_node\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    # Path found: Extract full path\n                    success_state = True\n                    path_a = []\n                    node_iter = new_node\n                    while node_iter:\n                        path_a.append(node_iter.position)\n                        node_iter = node_iter.parent\n                    path_a.reverse()\n                    path_b = []\n                    node_iter = connect_node\n                    while node_iter:\n                        path_b.append(node_iter.position)\n                        node_iter = node_iter.parent\n                    extracted_path = path_a + path_b\n\n                    new_path_cost = min_cost + connect_node.cost\n                    if new_path_cost < best_path_cost:\n                        best_path_cost = new_path_cost\n\n                    # Smooth path before return\n                    extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n\n    def _steer(self, from_pos, to_pos, step_size, bounds):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            new_pos = to_pos\n        else:\n            ratio = step_size / dist\n            new_pos = tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        # Enforce boundary limits\n        new_pos_clamped = tuple(\n            max(0, min(new_pos[i], bounds[i])) for i in range(len(new_pos))\n        )\n        return new_pos_clamped\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if math.dist(node.position, point) <= radius]\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import random\n        if len(path) < 3:\n            return path\n\n        smoothed = path[:]\n        for _ in range(self.smoothing_iterations):\n            if len(smoothed) < 3:\n                break\n            # Pick two random vertices i, j with j > i+1\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                # shortcut path segment by directly connecting i to j\n                smoothed = smoothed[:i + 1] + smoothed[j:]\n        return smoothed",
    "objective": 3.37674,
    "time_improvement": -21.0,
    "length_improvement": 14.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.014727044105529784,
            "num_nodes_avg": 160.9,
            "path_length_avg": 174.3077033815884,
            "success_improvement": 0.0,
            "time_improvement": -45.97382525593398,
            "length_improvement": 12.882685207815397,
            "objective_score": -11.215610535217113
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.022585201263427734,
            "num_nodes_avg": 296.1,
            "path_length_avg": 265.9289031898334,
            "success_improvement": 0.0,
            "time_improvement": -57.893842038152854,
            "length_improvement": 11.755793146414167,
            "objective_score": -15.01699398216302
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.016541576385498045,
            "num_nodes_avg": 209.4,
            "path_length_avg": 135.1807269228711,
            "success_improvement": 0.0,
            "time_improvement": 42.3473580733592,
            "length_improvement": 16.990890245358386,
            "objective_score": 16.102385471079437
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a streamlined bidirectional RRT* planner with balanced tree growth, adaptive sampling biased towards start and goal, collision-free node and edge verification, and incremental rewiring within a dynamic neighborhood radius. It prioritizes computational efficiency and robust pathfinding through straightforward tree extensions, rewiring for cost improvements, and final path smoothing.",
    "planning_mechanism": "The planner grows two trees from start and goal, alternately extending towards sampled free points. For each new node, it rewires neighbors to reduce path cost if collision-free. It attempts to connect the opposite tree incrementally to the new node. Upon successful connection, the planner reconstructs and smooths the path before returning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 smoothing_iterations: int = 100,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / distance_between\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(len(bounds)))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - position[d])**2 for d in range(len(position))) <= r2]\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        tree_a, tree_b = [start_root], [goal_root]\n\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            sample = sample_free()\n            r = neighbor_radius(iteration, len(nodes))\n\n            # Extend tree_a towards sample\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            neighbors = near_nodes(tree_a, new_pos, r)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                cost_out = node.cost + dist(node.position, new_pos)\n                if cost_out + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_out\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper and collision-free\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try to connect tree_b to new_node incrementally\n            connect_node = nearest(tree_b, new_node.position)\n            curr_pos = connect_node.position\n            connected = False\n\n            while True:\n                next_pos = steer(curr_pos, new_node.position)\n                if not can_add_node(next_pos) or not can_connect(curr_pos, next_pos):\n                    break\n\n                neighbors_b = near_nodes(tree_b, next_pos, r)\n                min_cost_b = connect_node.cost + dist(curr_pos, next_pos)\n                best_parent_b = connect_node\n                for node_b in neighbors_b:\n                    if not can_connect(node_b.position, next_pos):\n                        continue\n                    cost_b = node_b.cost + dist(node_b.position, next_pos)\n                    if cost_b < min_cost_b:\n                        min_cost_b = cost_b\n                        best_parent_b = node_b\n\n                new_node_b = Node(next_pos, parent=best_parent_b, cost=min_cost_b)\n                best_parent_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((best_parent_b, new_node_b))\n\n                # Rewire neighbors of new_node_b\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is best_parent_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    path_start = new_node.path_from_root()\n                    path_goal = connection_node.path_from_root()\n                    extracted_path = path_start + path_goal[::-1][1:]\n                    extracted_path = shortcut_smoothing(extracted_path)\n                    connected = True\n                    break\n\n                curr_pos = new_node_b.position\n                connect_node = new_node_b\n\n            if connected:\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 5.05134,
    "time_improvement": -32.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.011016368865966797,
            "num_nodes_avg": 70.8,
            "path_length_avg": 155.16720304344847,
            "success_improvement": 0.0,
            "time_improvement": -9.19377250942915,
            "length_improvement": 22.44892330795998,
            "objective_score": 1.7316529087632513
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.025777411460876466,
            "num_nodes_avg": 229.0,
            "path_length_avg": 236.87693357543202,
            "success_improvement": 0.0,
            "time_improvement": -80.21068246785175,
            "length_improvement": 21.396219536347616,
            "objective_score": -19.783960833086002
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03083500862121582,
            "num_nodes_avg": 252.3,
            "path_length_avg": 121.00421879728697,
            "success_improvement": 0.0,
            "time_improvement": -7.469788212105313,
            "length_improvement": 25.696120241684756,
            "objective_score": 2.8982875847053577
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner that combines informed ellipsoidal sampling focused around the current best path instance, adaptive rewiring with KDTree optimization for near-neighbor searches, and dynamic goal biasing. It integrates pruning of dead-end branches and aggressive iterative shortcut smoothing applied progressively after each successful connection. These enhancements minimize path length, improve planning time, and increase robustness and smoothness while maintaining collision safety and bounded sampling.",
    "planning_mechanism": "The planner grows two trees from start and goal, always extending the smaller tree first. Sampling occurs inside an adaptive ellipsoid guided by the best path cost to concentrate exploration. Each extension steers with fixed step size and uses KDTree to find near neighbors for rewiring to improve path cost. Upon connecting the two trees, the path is shortcut-smoothed. Dead-end nodes are pruned dynamically to reduce tree size, improving planning efficiency. The process iterates until a high-quality collision-free path connecting start to goal is found or max iterations are reached.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate_start: float=0.15, goal_sample_rate_end: float=0.4,\n                 radius_constant: float=20.0, radius_min: float=3.0,\n                 prune_interval: int=150, prune_threshold: int=100,\n                 shortcut_trials: int=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = goal_sample_rate_start\n        self.goal_sample_rate_end = goal_sample_rate_end\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.shortcut_trials = shortcut_trials\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n        def dist_sq(a,b):\n            return sum((a[i]-b[i])**2 for i in range(len(a)))\n\n        # Uniform sampling within bounds and free of obstacles\n        def uniform_sample(max_retry=40):\n            for _ in range(max_retry):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            return start_position\n\n        # Informed ellipsoidal sampling centered between start and goal, scaled by current best cost\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf'):\n                return uniform_sample()\n\n            n = len(start)\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(n))\n            diff = tuple(goal[d] - start[d] for d in range(n))\n            length = dist(start, goal)\n\n            # Radii of ellipsoid axes\n            try:\n                radius_minor = math.sqrt(max(c_best*c_best - c_min*c_min,0)) / 2\n            except:\n                radius_minor = 0.0\n\n            if n == 2:\n                L = [c_best/2, radius_minor]\n            elif n ==3:\n                L = [c_best/2, radius_minor, radius_minor]\n            else:\n                return uniform_sample()\n\n            # Sample in unit ball using Marsaglia method\n            vec = [random.gauss(0,1) for _ in range(n)]\n            norm = math.sqrt(sum(v*v for v in vec))\n            if norm < 1e-10:\n                unit_vec = [1.0] + [0.0]*(n-1)\n            else:\n                unit_vec = [v/norm for v in vec]\n            r = random.random() ** (1.0/n)\n            point_ball = [r*u for u in unit_vec]\n\n            # Scale by ellipsoid axes length\n            sample_ellip = [point_ball[i]*L[i] for i in range(n)]\n\n            # Rotation aligns major axis with start->goal vector\n            if n == 2:\n                dx, dy = diff\n                theta = math.atan2(dy, dx)\n                cos_t, sin_t = math.cos(theta), math.sin(theta)\n                x_ellip = sample_ellip[0]*cos_t - sample_ellip[1]*sin_t\n                y_ellip = sample_ellip[0]*sin_t + sample_ellip[1]*cos_t\n                sample_rotated = (x_ellip, y_ellip)\n            elif n ==3:\n                ux, uy, uz = 1.0, 0.0, 0.0\n                vx, vy, vz = tuple((diff[d]/length) if length>0 else 0 for d in range(3))\n\n                kx = uy*vz - uz*vy\n                ky = uz*vx - ux*vz\n                kz = ux*vy - uy*vx\n                k_norm = math.sqrt(kx*kx + ky*ky + kz*kz)\n\n                if k_norm < 1e-10:\n                    if vx < 0:\n                        R = [[-1,0,0],[0,-1,0],[0,0,1]]\n                    else:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    kx /= k_norm\n                    ky /= k_norm\n                    kz /= k_norm\n                    cos_a = ux*vx + uy*vy + uz*vz\n                    sin_a = k_norm\n                    K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                    I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                    # K^2\n                    K2 = [[sum(K[r][m]*K[m][c] for m in range(3)) for c in range(3)] for r in range(3)]\n\n                    R = [[I[r][c] + sin_a*K[r][c] + (1 - cos_a)*K2[r][c] for c in range(3)] for r in range(3)]\n\n                sample_rotated = tuple(\n                    R[0][0]*sample_ellip[0] + R[0][1]*sample_ellip[1] + R[0][2]*sample_ellip[2],\n                    R[1][0]*sample_ellip[0] + R[1][1]*sample_ellip[1] + R[1][2]*sample_ellip[2],\n                    R[2][0]*sample_ellip[0] + R[2][1]*sample_ellip[1] + R[2][2]*sample_ellip[2]\n                )\n            else:\n                return uniform_sample()\n\n            sample_global = tuple(center[d] + sample_rotated[d] for d in range(n))\n            # Clamp to bounds\n            clamped = tuple(max(0.0, min(sample_global[d], bounds[d])) for d in range(n))\n            if self._is_in_obstacle(clamped, obstacles, is_3d):\n                return uniform_sample()\n            return clamped\n\n        # Dynamic radius for rewiring\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, val)\n\n        # KDTree building and querying for efficient nearest and near node search\n        try:\n            from scipy.spatial import cKDTree as KDTree\n        except ImportError:\n            KDTree = None\n\n        def build_kdtree(tree):\n            if KDTree is None or not tree:\n                return None\n            pts = [node.position for node in tree]\n            return KDTree(pts)\n\n        def nearest(tree, kdtree, point):\n            if kdtree is not None:\n                dist_, idx = kdtree.query(point)\n                return tree[idx]\n            else:\n                return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, kdtree, pos, radius):\n            if kdtree is not None:\n                idxs = kdtree.query_ball_point(pos, radius)\n                return [tree[i] for i in idxs]\n            else:\n                return [node for node in tree if dist(node.position, pos) <= radius]\n\n        # Steer from from_pos to to_pos with max step_size\n        def steer(from_pos, to_pos):\n            distance_ = dist(from_pos, to_pos)\n            if distance_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        # Check valid position and edge for adding a new node\n        def can_add_node(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            for d in range(len(pos)):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        # Try extend tree toward a point with rewiring\n        def try_extend(tree, kdtree, sample_pt):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, kdtree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, kdtree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better path through new_node\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        # Incrementally try connect opposite tree to a node\n        def try_connect(tree, kdtree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, kdtree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        # Shortcut smoothing to reduce path length after connection\n        def shortcut_smoothing(path, trials):\n            if len(path) < 3:\n                return path\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Prune dead-end nodes (without children) to reduce tree size and improve speed\n        def prune_dead_nodes():\n            removed = 0\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent and node in node.parent.children:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p,c) for (p,c) in edges if p != node and c != node]\n                        removed += 1\n                    except Exception:\n                        continue\n            return removed\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        c_best = float('inf')\n        c_min = dist(start_position, goal_position)\n\n        for itr in range(self.max_iter):\n            goal_bias = ((self.goal_sample_rate_end - self.goal_sample_rate_start) *\n                         itr / self.max_iter + self.goal_sample_rate_start)\n            if random.random() < goal_bias:\n                sample_pt = goal_position if random.random() < 0.75 else start_position\n            else:\n                sample_pt = informed_sample(c_best, c_min, start_position, goal_position)\n\n            sample_pt = tuple(max(0.0, min(sample_pt[d], bounds[d])) for d in range(len(bounds)))\n\n            # Extend smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            kdtree_start = build_kdtree(tree_start)\n            kdtree_goal = build_kdtree(tree_goal)\n\n            new_node_start = try_extend(tree_start, kdtree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, kdtree_goal, new_node_start)\n            if new_node_goal is not None:\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n\n                curr_cost = sum(dist(merged_path[i], merged_path[i+1]) for i in range(len(merged_path)-1))\n                if curr_cost < c_best - 1e-10:\n                    c_best = curr_cost\n                    extracted_path = merged_path\n                    extracted_path = shortcut_smoothing(extracted_path, self.shortcut_trials)\n                success_state = True\n\n                # Prune dead-end nodes for efficiency\n                if len(nodes) > self.prune_threshold:\n                    prune_dead_nodes()\n\n                # Break early if path found and improvements stalled after certain iterations\n                if itr > self.max_iter * 0.7:\n                    break\n\n            # Periodic pruning to reduce tree size\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 4905.60962,
    "time_improvement": -16361.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 3.543492388725281,
            "num_nodes_avg": 487.3,
            "path_length_avg": 157.47427161238699,
            "success_improvement": -9.999999999999998,
            "time_improvement": -35022.94354800594,
            "length_improvement": 21.295872611586677,
            "objective_score": -10507.623889879464
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.9704307794570923,
            "num_nodes_avg": 109.3,
            "path_length_avg": 239.3743263124307,
            "success_improvement": 0.0,
            "time_improvement": -6684.311656707587,
            "length_improvement": 20.567500135654885,
            "objective_score": -2001.179996985145
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 2.145063304901123,
            "num_nodes_avg": 282.4,
            "path_length_avg": 123.41707638669368,
            "success_improvement": 0.0,
            "time_improvement": -7376.226191831453,
            "length_improvement": 24.21448032880236,
            "objective_score": -2208.0249614836753
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "time_expert",
    "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm integrating adaptive goal biasing, dynamic neighborhood radius, and adaptive step sizing. It optimizes node connections with efficient rewiring and carefully balanced tree growth. Heuristic goal-biased sampling accelerates convergence, and rigorous collision checks ensure path feasibility. Post-processing with shortcut smoothing further refines the path quality, achieving reduced planning time and higher success rates.",
    "planning_mechanism": "The planner alternately grows two trees from start and goal with biased sampling towards both ends, adapting the step length based on obstacle proximity for efficient exploration. It rewires nodes within a shrinking radius proportional to the tree size to locally optimize costs. The connection attempts between trees are incremental and maintain collision safety. The extracted path undergoes iterative shortcut smoothing to improve smoothness and minimize length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.25,\n                 radius_const: float=25.0,\n                 radius_min: float=5.0,\n                 smoothing_iter: int=60,\n                 collision_resolution: float=0.5,\n                 adaptive_step_min: float=1.5,\n                 adaptive_step_max: float=7.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.smoothing_iter = smoothing_iter\n        self.collision_resolution = collision_resolution\n        self.adaptive_step_min = adaptive_step_min\n        self.adaptive_step_max = adaptive_step_max\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(point):\n            for i, val in enumerate(point):\n                if val < 0 or val > bounds[i]:\n                    return False\n            return True\n\n        def sample_point():\n            # Adaptive goal biasing with occasional start bias to diversify\n            if random.random() < self.goal_sample_rate:\n                if random.random() < 0.85:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest(tree, point):\n            # Cached distance computation for speed\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                dist = distance(node.position, point)\n                if dist < best_dist:\n                    best_dist = dist\n                    best_node = node\n            return best_node\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_const\n            r = self.radius_const * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, r)\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius*radius\n            near = []\n            for node in tree:\n                dx = node.position[0] - pos[0]\n                dy = node.position[1] - pos[1]\n                dz = node.position[2] - pos[2] if is_3d else 0.0\n                dist_sq = dx*dx + dy*dy + dz*dz\n                if dist_sq <= r_sq:\n                    near.append(node)\n            return near\n\n        def adaptive_step(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            # Adaptive step based on minimum distance, clipped by min/max step\n            step = min(self.adaptive_step_max, max(self.adaptive_step_min, dist))\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def collision_free(node_pos):\n            return (in_bounds(node_pos) and not self._is_in_obstacle(node_pos, obstacles, is_3d))\n\n        def edge_collision_free(pos1, pos2):\n            if not in_bounds(pos2):\n                return False\n            return not self._is_edge_in_obstacle(pos1, pos2, obstacles, is_3d, self.collision_resolution)\n\n        def add_node(tree, new_node, parent_node):\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = adaptive_step(nearest_node.position, point)\n\n            if not collision_free(new_pos) or not edge_collision_free(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + distance(node.position, new_pos)\n                if temp_cost < min_cost and edge_collision_free(node.position, new_pos):\n                    min_cost = temp_cost\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-12 < neighbor.cost and edge_collision_free(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            max_iters = 5  # Limit incremental connection steps to reduce search time\n            for _ in range(max_iters):\n                new_pos = adaptive_step(last_node.position, node.position)\n                if not collision_free(new_pos) or not edge_collision_free(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                dist_to_goal = distance(new_pos, node.position)\n                if dist_to_goal <= self.step_size:\n                    if edge_collision_free(new_pos, node.position):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + dist_to_goal\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if edge_collision_free(p_i, p_j):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            rand_point = sample_point()\n\n            # Balance tree growth: extend smaller tree first for efficiency\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                extracted_path = extract_path(new_node_start, new_node_goal)\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -0.56941,
    "time_improvement": -4.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.011932563781738282,
            "num_nodes_avg": 84.8,
            "path_length_avg": 179.4556821069735,
            "success_improvement": -9.999999999999998,
            "time_improvement": -18.275056952991342,
            "length_improvement": 10.309774920648962,
            "objective_score": -8.42056210176761
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.021422696113586426,
            "num_nodes_avg": 263.1,
            "path_length_avg": 246.43185249463258,
            "success_improvement": 0.0,
            "time_improvement": -49.76673250493788,
            "length_improvement": 18.22557418166317,
            "objective_score": -11.284904915148728
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.012469840049743653,
            "num_nodes_avg": 155.3,
            "path_length_avg": 126.59919358120321,
            "success_improvement": 0.0,
            "time_improvement": 56.538651062263334,
            "length_improvement": 22.260468677408557,
            "objective_score": 21.41368905416071
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved planner implements a bidirectional RRT* algorithm with enhanced heuristic-informed sampling biased toward the corridor between start and goal, dynamic adaptive radius rewiring optimized for minimizing path length, and periodic aggressive pruning of nodes that have higher costs or are dead ends. It maintains balanced growth between the two trees growing from start and goal, while aggressively rewiring to reduce overall path cost. To refine path quality and smoothness, an additional shortcutting smoothing phase is applied after path extraction to reduce unnecessary waypoints. Collision checking for nodes and edges is strictly enforced to guarantee safety. This approach improves planning efficiency, solution optimality, success rate, and path smoothness while controlling computational cost.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal points. Sampling is biased using an adaptive heuristic that favors points along the direct line between start and goal but still allows exploration to avoid local minima. Extensions grow the smaller tree first to maintain balanced tree sizes. For each new node, rewiring considers neighbors within a dynamically shrinking radius to minimize path cost. Attempts are made after each extension to connect the opposite tree. Periodically, nodes that are dead ends or have significantly worse costs than alternate nearby nodes are pruned to boost efficiency. On success, the path is extracted and then post-processed by shortcut smoothing to reduce path length and improve smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2, radius_constant: float = 30.0,\n                 radius_min: float = 5.0, prune_interval: int = 200, prune_threshold: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        direct_dist = math.dist(start_position, goal_position)\n\n        def sample_free():\n            # Heuristic-informed sampling biased towards corridor between start-goal segment with Gaussian noise\n            p_goal_bias = self.goal_sample_rate\n            if random.random() < p_goal_bias:\n                # Alternate bias to goal and start with probability weighted by distance\n                if random.random() < 0.7:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                w = 0.8  # corridor width fraction of max bound dimension\n                max_dim = max(bounds) if not is_3d else max(bounds[0], bounds[1], bounds[2])\n                corridor_width = w * max_dim\n\n                # Sample along line between start and goal plus perpendicular noise inside corridor_width\n                alpha = random.uniform(0.0, 1.0)\n                base_point = tuple(start_position[d] + alpha * (goal_position[d] - start_position[d]) for d in range(len(bounds)))\n\n                # Generate perpendicular noise vector\n                if is_3d:\n                    # sample random perpendicular vector in 3D using Gram-Schmidt\n                    import numpy as np\n                    dir_vec = np.array([goal_position[d] - start_position[d] for d in range(3)])\n                    dir_vec /= np.linalg.norm(dir_vec)\n                    # create arbitrary vector not parallel to dir_vec\n                    if abs(dir_vec[0]) < 0.9:\n                        temp_vec = np.array([1,0,0])\n                    else:\n                        temp_vec = np.array([0,1,0])\n                    perp_vec1 = temp_vec - dir_vec * np.dot(temp_vec, dir_vec)\n                    perp_vec1 /= np.linalg.norm(perp_vec1)\n                    perp_vec2 = np.cross(dir_vec, perp_vec1)\n                    perp_vec2 /= np.linalg.norm(perp_vec2)\n                    noise_radius = random.uniform(-corridor_width/2, corridor_width/2)\n                    noise_vec = perp_vec1 * noise_radius * random.gauss(0,0.5) + perp_vec2 * noise_radius * random.gauss(0,0.5)\n                    sample_np = np.array(base_point) + noise_vec\n                    sample = tuple(max(0, min(bounds[d], sample_np[d])) for d in range(3))\n                else:\n                    # 2D: noise perpendicular to line between start-goal\n                    dx = goal_position[0] - start_position[0]\n                    dy = goal_position[1] - start_position[1]\n                    length = math.hypot(dx, dy)\n                    if length == 0:\n                        perp = (0.0, 0.0)\n                    else:\n                        perp = (-dy/length, dx/length)\n                    offset = random.gauss(0, corridor_width/4)\n                    x = base_point[0] + perp[0]*offset\n                    y = base_point[1] + perp[1]*offset\n                    x = min(max(x, 0), bounds[0])\n                    y = min(max(y, 0), bounds[1])\n                    sample = (x, y)\n\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n                # fallback random sampling if corridor sample is invalid\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            # Choose parent that yields minimum cost and valid edge\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if improves cost and edge is free\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            # Remove dead-end nodes with no children except roots\n            removed_nodes = []\n            cost_threshold_factor = 1.5  # prune if cost significantly worse than neighbor best\n            for node in nodes[:]:\n                if (not node.children) and node is not start_root and node is not goal_root:\n                    # Check if nearby better paths exist: prune high cost dead ends\n                    radius = radius_by_nodes(len(nodes))\n                    near = near_nodes(nodes, node.position, radius)\n                    better_found = False\n                    for n in near:\n                        if n is node:\n                            continue\n                        if n.cost + distance(n.position, node.position) * 0.5 < node.cost * cost_threshold_factor:\n                            better_found = True\n                            break\n                    if better_found:\n                        try:\n                            if node.parent:\n                                node.parent.children.remove(node)\n                            nodes.remove(node)\n                            edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                            removed_nodes.append(node)\n                        except Exception:\n                            continue\n            return removed_nodes\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]\n\n        def shortcut_smooth(path):\n            # Attempt shortcutting by connecting non-adjacent waypoints directly if edge collision free\n            # Improves path length and smoothness\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(smoothed[-1], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always grow smaller tree first to keep balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                raw_path = extract_path(new_node_start, new_node_goal)\n                # Apply shortcut smoothing post extraction\n                extracted_path = shortcut_smooth(raw_path)\n                break\n\n            # Prune dead or costly nodes periodically to improve efficiency\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 246.94059,
    "time_improvement": -823.0,
    "length_improvement": 25.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.010161566734313964,
            "num_nodes_avg": 85.4,
            "path_length_avg": 151.13846741624656,
            "success_improvement": 0.0,
            "time_improvement": -0.7210106910926433,
            "length_improvement": 24.46244665225591,
            "objective_score": 4.676186123123389
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.10125017166137695,
            "num_nodes_avg": 385.5,
            "path_length_avg": 229.07856327082519,
            "success_improvement": 0.0,
            "time_improvement": -607.8430882316173,
            "length_improvement": 23.98398263402543,
            "objective_score": -177.55612994268012
        },
        {
            "map_id": 2,
            "success_rate": 0.7,
            "time_avg": 0.5628214597702026,
            "num_nodes_avg": 659.0,
            "path_length_avg": 117.72808715504519,
            "success_improvement": -30.000000000000004,
            "time_improvement": -1861.611356291771,
            "length_improvement": 27.707862427511778,
            "objective_score": -567.9418344020289
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm implements an anytime informed bidirectional RRT* variant with fast heuristic-informed sampling focusing search within an evolving ellipsoidal domain defined by currently best solution. It adaptively refines path quality by rewiring, employs KD-tree for nearest neighbor search, caches collision checks, prunes suboptimal branches, and applies iterative path smoothing. The bidirectional approach grows trees from start and goal asynchronously, prioritizing the smaller for extension, and connects them efficiently through incremental extension steps. Focused sampling and aggressive pruning reduce search space and improve convergence, producing shorter, smoother paths rapidly and robustly.",
    "planning_mechanism": "The planner initializes two trees from start and goal positions and iteratively samples points biased inside an informed ellipsoid that shrinks as better paths are found. The smaller tree is extended towards sampled points using RRT* style rewiring and cost optimization, with nearest neighbor queries accelerated by KD-tree. Connection attempts between trees are done incrementally with collision checking and caching. Periodic pruning removes unnecessary nodes, and the final path undergoes shortcut smoothing to improve quality and smoothness. This strategy improves planning efficiency, success rate, and path optimality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent: \n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def is_descendant_of(self, node):\n        \"\"\"Check if this node is descendant of given node.\"\"\"\n        cur = self.parent\n        while cur:\n            if cur == node:\n                return True\n            cur = cur.parent\n        return False\nclass Planner:\n    def __init__(self, max_iter: int =5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval:int=200, prune_threshold:int=300, smoothing_iterations:int=100,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clip to bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes,1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration/self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c+1)/c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1,p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree helper class for fast queries\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p,n in points_nodes]\n                self.nodes = [n for p,n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i,p in enumerate(self.points):\n                    d = dist(pt,p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i,p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d]-pt[d]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Sampling inside ellipsoid informed by current best path cost\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf'):\n                # No solution yet - uniform sample\n                for _ in range(10):\n                    p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Ellipsoidal sampling between start and goal (informed RRT*)\n            center = tuple((start[d] + goal[d])/2 for d in range(dim))\n            a1 = tuple((goal[d]-start[d])/c_min for d in range(dim))  # unit vector from start to goal\n\n            # Rotation matrix from unit vector to x-axis using Householder transform approximation for dim=2 or 3\n            import numpy as np\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d==0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u,u)\n            else:\n                rot = id_mat  # Already aligned\n\n            # Ellipsoid radii\n            r1 = c_best / 2.0\n            r_others = math.sqrt(r1**2 - (c_min/2)**2)\n            radii = [r1] + [r_others]*(dim-1)\n\n            # Sample a random point in unit ball\n            while True:\n                x = np.random.uniform(-1,1,dim)\n                if np.linalg.norm(x) <= 1:\n                    break\n            x = np.array(x)\n            # Scale with radii\n            x = x * radii\n            # Rotate to original coordinate system\n            p = rot @ x\n            # Translate back to center\n            p = p + np.array(center)\n\n            p_tuple = tuple(float(coord) for coord in p)\n            if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                return p_tuple\n            else:\n                # fallback uniform sampling if outside or collision\n                for _ in range(10):\n                    fallback_p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(fallback_p):\n                        return fallback_p\n                return fallback_p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1,p2):\n            if (p1,p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1,p2)]\n            if (p2,p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2,p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1,p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1,p2)\n            edge_collision_cache[(p1,p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        # Initialize trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal  = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        # Best path cost and path\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        def rebuild_kdtree():\n            return KDTree([(node.position, node) for node in nodes])\n\n        kd_tree = rebuild_kdtree()\n\n        def prune_useless_nodes():\n            # Prune nodes that cannot improve best path to reduce complexity\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                # Don't prune roots\n                if node in (root_start, root_goal):\n                    continue\n                # Prune if cost + heuristic > best path cost\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= c_best:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                # Remove from trees if present\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed +=1\n            return removed\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1,p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n            # Alternate, always extend smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Build KD-tree for tree_a subset\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest.position, new_pos):\n                continue\n\n            # Neighbor search radius\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for node in near:\n                c_p = node.cost + dist(node.position, new_pos)\n                if c_p + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = c_p\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cost improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try to connect tree_b to new_node incrementally\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_extend_steps = int(dist(last_node_b.position, new_node.position)/self.step_size) + 1\n\n            for _ in range(max_extend_steps):\n                new_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(new_pos_b) or not can_connect(last_node_b.position, new_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, new_pos_b)\n                new_node_b = Node(new_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(new_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_b_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_b_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_b_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Update best path cost and path\n                    c_best = final_cost\n                    best_path = merged_path\n\n                    # Shortcut smoothing\n                    best_path = shortcut_path(best_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_useless_nodes()\n                kd_tree = rebuild_kdtree()\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            # fallback if improved path not assigned\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -1.99103,
    "time_improvement": -7.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.013820695877075195,
            "num_nodes_avg": 90.8,
            "path_length_avg": 165.68594819008476,
            "success_improvement": 0.0,
            "time_improvement": -36.99014075187401,
            "length_improvement": 17.191755584556482,
            "objective_score": -7.658691108650905
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.018435454368591307,
            "num_nodes_avg": 189.5,
            "path_length_avg": 235.2552560057235,
            "success_improvement": 0.0,
            "time_improvement": -28.882832879132593,
            "length_improvement": 21.934347017770815,
            "objective_score": -4.2779804601856135
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.016191697120666503,
            "num_nodes_avg": 153.5,
            "path_length_avg": 123.44301109039233,
            "success_improvement": 0.0,
            "time_improvement": 43.56679831912523,
            "length_improvement": 24.19855485839855,
            "objective_score": 17.90975046741728
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the bidirectional tree growth approach of algorithm #1 with goal biasing and incremental single-tree expansion strategies inspired by algorithm #2. It integrates an adaptive heuristic to prioritize samples nearer the goal and enhances connection attempts between trees to improve success rates and path quality. Collision and edge-obstacle checks are strictly enforced to ensure safety. Additionally, it attempts local rewiring akin to RRT* for path smoothing and cost improvement.",
    "planning_mechanism": "The planner grows two trees from start and goal alternatively, sampling points with goal biasing to guide exploration. Each tree extends towards these samples via fixed step sizes, performing collision and edge checks. After adding new nodes, the algorithm tries to connect the two trees by extending one toward the other's new node in multiple smaller steps. A local rewiring step updates parents and costs within neighbors to optimize paths. The process repeats until the trees meet or max iterations are hit, then the path is reconstructed, providing improved efficiency, robustness, and smoother paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        # Initialize two trees: start and goal\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes.extend([start_root, goal_root])\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                # Sample inside bounds but avoid obstacles\n                for _ in range(100):\n                    if is_3d:\n                        p = (random.uniform(0, bounds[0]),\n                             random.uniform(0, bounds[1]),\n                             random.uniform(0, bounds[2]))\n                    else:\n                        p = (random.uniform(0, bounds[0]),\n                             random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # fallback, just return goal if no free sample found\n                return goal_position\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos, extend_length=None):\n            dist = math.dist(from_pos, to_pos)\n            step = self.step_size if extend_length is None else min(self.step_size, extend_length)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near(tree, new_node):\n            # Return nodes within rewire radius\n            r = self.rewire_radius\n            return [node for node in tree if math.dist(node.position, new_node.position) <= r]\n\n        def try_add_node(tree, point, all_nodes, all_edges):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            all_edges.append((nearest_node, new_node))\n\n            # Rewire nearby nodes for cost improvement (like RRT*)\n            neighbors = near(tree, new_node)\n            for neighbor in neighbors:\n                if neighbor == new_node or neighbor == nearest_node:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost:\n                    if (not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d) and\n                        not self._is_in_obstacle(neighbor.position, obstacles, is_3d)):\n                        neighbor.update_parent(new_node, potential_cost)\n                        # edges list update - remove old edge, add new edge\n                        try:\n                            all_edges.remove((neighbor.parent, neighbor))\n                        except (ValueError, AttributeError):\n                            pass\n                        all_edges.append((new_node, neighbor))\n            return new_node\n\n        def connect_trees(tree_a, tree_b, obstacles, is_3d, all_nodes, all_edges):\n            # Attempt to connect tree_b toward last node in tree_a by incremental steering,\n            # returns connecting node from tree_b if success else None\n            import math\n            new_node = tree_a[-1]\n            nearest_node = nearest(tree_b, new_node.position)\n            current_node = nearest_node\n            while True:\n                new_pos = steer(current_node.position, new_node.position)\n                if new_pos == current_node.position:\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d):\n                    return None\n                candidate = Node(new_pos, parent=current_node,\n                                 cost=current_node.cost + math.dist(current_node.position, new_pos))\n                current_node.add_child(candidate)\n                tree_b.append(candidate)\n                all_nodes.append(candidate)\n                all_edges.append((current_node, candidate))\n                dist_to_target = math.dist(candidate.position, new_node.position)\n                if dist_to_target <= self.step_size:\n                    # Final direct connection check\n                    if (not self._is_in_obstacle(new_node.position, obstacles, is_3d) and\n                        not self._is_edge_in_obstacle(candidate.position, new_node.position, obstacles, is_3d)):\n                        goal_connect = Node(new_node.position, parent=candidate,\n                                           cost=candidate.cost + dist_to_target)\n                        candidate.add_child(goal_connect)\n                        tree_b.append(goal_connect)\n                        all_nodes.append(goal_connect)\n                        all_edges.append((candidate, goal_connect))\n                        return goal_connect\n                    else:\n                        return None\n                current_node = candidate\n\n        # Begin main loop\n        for iteration in range(self.max_iter):\n            # Alternate sampling bias to improve coverage and goal proximity\n            if iteration % 2 == 0:\n                sample = sample_point()\n            else:\n                # Try goal direct sample half the times to speed connection\n                sample = goal_position if random.random() < 0.5 else sample_point()\n\n            # Extend start tree towards sample\n            new_node_start = try_add_node(tree_start, sample, nodes, edges)\n            if new_node_start is None:\n                # swap and continue next iteration\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            # Try to connect goal tree towards new node in start tree\n            new_node_goal = connect_trees(tree_start, tree_goal, obstacles, is_3d, nodes, edges)\n            if new_node_goal:\n                success_state = True\n                # Reconstruct path: start_root -> new_node_start + reversed(new_node_goal -> goal_root)\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                # Remove duplicated connecting node at join\n                if path_start[-1] == path_goal[-1]:\n                    path_goal.pop()\n                extracted_path = path_start + path_goal[::-1]\n                break\n\n            # Swap trees for next iteration to keep bidirectional balance\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 36.90791,
    "time_improvement": -128.0,
    "length_improvement": 7.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007505941390991211,
            "num_nodes_avg": 147.2,
            "path_length_avg": 181.13967146690692,
            "success_improvement": 0.0,
            "time_improvement": 25.601433041242466,
            "length_improvement": 9.46813322421259,
            "objective_score": 9.574056557215258
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0628847360610962,
            "num_nodes_avg": 651.3,
            "path_length_avg": 290.76659208493203,
            "success_improvement": 0.0,
            "time_improvement": -339.6291388520806,
            "length_improvement": 3.5138076746074822,
            "objective_score": -101.18598012070268
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04845216274261475,
            "num_nodes_avg": 500.9,
            "path_length_avg": 150.23335018440193,
            "success_improvement": 0.0,
            "time_improvement": -68.87115980193133,
            "length_improvement": 7.747672777496979,
            "objective_score": -19.11181338508
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm with heuristic-informed sampling biased toward the corridor between start and goal, dynamic adaptive radius rewiring to minimize path cost, balanced tree growth, and periodic pruning of costly or dead-end nodes. To improve path quality, shortcut smoothing is applied after path extraction. Collision checks are strictly enforced to maintain safety, and sampling respects map bounds and obstacles. This combination improves planning efficiency, path quality, smoothness, success rate, and reduces search time.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal, using heuristic-informed sampling biased mostly along the corridor connecting them but allowing exploration. The smaller tree is always grown first to maintain balanced growth. New nodes are chosen with minimum-cost parents within a dynamic radius, and rewiring is done to improve path cost. The opposite tree is aggressively connected after each extension attempt. Periodic pruning removes costly or dead-end nodes to maintain efficiency. Upon success, the combined path is extracted and smoothed by shortcutting non-colliding direct connections between waypoints.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2, radius_constant: float=30.0,\n                 radius_min: float=5.0, prune_interval: int=200, prune_threshold: int=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            p_goal_bias = self.goal_sample_rate\n            if random.random() < p_goal_bias:\n                if random.random() < 0.7:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                w = 0.8\n                max_dim = max(bounds) if not is_3d else max(bounds[0], bounds[1], bounds[2])\n                corridor_width = w * max_dim\n                alpha = random.uniform(0.0, 1.0)\n                base_point = tuple(start_position[d] + alpha * (goal_position[d] - start_position[d]) for d in range(len(bounds)))\n\n                if is_3d:\n                    import numpy as np\n                    dir_vec = np.array([goal_position[d] - start_position[d] for d in range(3)], dtype=float)\n                    norm = np.linalg.norm(dir_vec)\n                    if norm < 1e-8:\n                        dir_vec = np.array([1,0,0], dtype=float)\n                    else:\n                        dir_vec /= norm\n                    temp_vec = np.array([1,0,0], dtype=float) if abs(dir_vec[0]) < 0.9 else np.array([0,1,0], dtype=float)\n                    perp_vec1 = temp_vec - dir_vec * np.dot(temp_vec, dir_vec)\n                    perp_norm1 = np.linalg.norm(perp_vec1)\n                    if perp_norm1 < 1e-8:\n                        perp_vec1 = np.array([0,0,1], dtype=float)\n                    else:\n                        perp_vec1 /= perp_norm1\n                    perp_vec2 = np.cross(dir_vec, perp_vec1)\n                    perp_vec2 /= np.linalg.norm(perp_vec2)\n                    noise_radius = random.uniform(-corridor_width/2, corridor_width/2)\n                    noise_vec = perp_vec1 * noise_radius * random.gauss(0,0.5) + perp_vec2 * noise_radius * random.gauss(0,0.5)\n                    sample_np = np.array(base_point, dtype=float) + noise_vec\n                    sample = tuple(min(max(0, sample_np[d]), bounds[d]) for d in range(3))\n                else:\n                    dx = goal_position[0] - start_position[0]\n                    dy = goal_position[1] - start_position[1]\n                    length = math.hypot(dx, dy)\n                    if length == 0:\n                        perp = (0.0, 0.0)\n                    else:\n                        perp = (-dy/length, dx/length)\n                    offset = random.gauss(0, corridor_width/4)\n                    x = base_point[0] + perp[0]*offset\n                    y = base_point[1] + perp[1]*offset\n                    x = min(max(x, 0), bounds[0])\n                    y = min(max(y, 0), bounds[1])\n                    sample = (x, y)\n\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent: \n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except (ValueError, AttributeError):\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            cost_threshold_factor = 1.5\n            for node in nodes[:]:\n                if (not node.children) and node is not start_root and node is not goal_root:\n                    radius = radius_by_nodes(len(nodes))\n                    near = near_nodes(nodes, node.position, radius)\n                    better_found = False\n                    for n in near:\n                        if n is node:\n                            continue\n                        if n.cost + distance(n.position, node.position)*0.5 < node.cost * cost_threshold_factor:\n                            better_found = True\n                            break\n                    if better_found:\n                        try:\n                            if node.parent:\n                                node.parent.children.remove(node)\n                            nodes.remove(node)\n                            edges[:] = [(p,c) for (p,c) in edges if c!=node and p!=node]\n                            removed_nodes.append(node)\n                        except Exception:\n                            continue\n            return removed_nodes\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]\n\n        def shortcut_smooth(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(smoothed[-1], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                raw_path = extract_path(new_node_start, new_node_goal)\n                extracted_path = shortcut_smooth(raw_path)\n                break\n\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 408.79962,
    "time_improvement": -1361.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.013431835174560546,
            "num_nodes_avg": 122.2,
            "path_length_avg": 164.71237401501224,
            "success_improvement": 0.0,
            "time_improvement": -33.13577025966783,
            "length_improvement": 17.678338599752657,
            "objective_score": -6.4050633579498175
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.12614786624908447,
            "num_nodes_avg": 417.8,
            "path_length_avg": 231.42736672557194,
            "success_improvement": 0.0,
            "time_improvement": -781.9036427732079,
            "length_improvement": 23.204570184183034,
            "objective_score": -229.93017879512576
        },
        {
            "map_id": 2,
            "success_rate": 0.7,
            "time_avg": 0.9659038543701172,
            "num_nodes_avg": 830.6,
            "path_length_avg": 123.10854656596247,
            "success_improvement": -30.000000000000004,
            "time_improvement": -3266.4813893059863,
            "length_improvement": 24.403936224880425,
            "objective_score": -990.0636295468198
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "m2",
    "algorithm_description": "This planner implements an advanced bidirectional RRT* with adaptive double goal biasing, an exponentially decaying neighbor radius for more focused local rewiring, heuristic cost-guided rewiring aggressively optimizing path length while minimizing runtime. It alternates tree growth with careful collision and edge feasibility checks, applies early termination upon tree connection, and employs comprehensive path smoothing with iterative shortcutting for high-quality, smooth, and shorter paths.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal by sampling with adaptive double goal bias, steers nodes towards samples within step size, selects parents optimizing path cost among neighbors inside shrinking radius, rewires aggressively, attempts incremental connections between trees, and upon connection extracts and smooths path via iterative shortcutting to improve path quality and smoothness, ensuring validity by stringent collision and edge checks and maintaining efficient exploration and rewiring to improve success rate and reduce search time.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance(self, other_pos):\n        from math import dist\n        return dist(self.position, other_pos)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 6.0,\n                 goal_sample_rate: float = 0.12,\n                 initial_neighbor_radius: float = 18.0,\n                 min_neighbor_radius: float = 6.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.initial_neighbor_radius = initial_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        def sample_free():\n            r = random.random()\n            if r < self.goal_sample_rate:\n                return goal_position\n            elif r < 2 * self.goal_sample_rate:\n                return start_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if self._dist_sq(node.position, pos) <= r_sq]\n\n        def can_connect(p1, p2):\n            if not in_bounds(p2):\n                return False\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def rewire(new_node, near, tree, edges):\n            for neighbor in near:\n                if neighbor == new_node.parent:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, potential_cost)\n                        edges.append((new_node, neighbor))\n\n        def neighbor_radius(iteration):\n            decay = iteration / self.max_iter\n            r = self.initial_neighbor_radius * (0.94 ** (decay * self.max_iter))\n            return max(r, self.min_neighbor_radius)\n\n        def try_extend(tree, sample_point, radius):\n            nearest_node = nearest(tree, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                if node == nearest_node:\n                    continue\n                if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    cost_through_node = node.cost + math.dist(node.position, new_pos)\n                    if cost_through_node + 1e-9 < min_cost:\n                        min_cost = cost_through_node\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(new_node, near, tree, edges)\n            return new_node\n\n        def try_connect(to_tree, from_node, radius):\n            curr_node = nearest(to_tree, from_node.position)\n            last_added_node = None\n            while True:\n                new_pos = steer(curr_node.position, from_node.position)\n                if not can_connect(curr_node.position, new_pos):\n                    break\n\n                new_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = curr_node\n                curr_node.children.append(new_node)\n\n                to_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr_node, new_node))\n\n                curr_node = new_node\n                last_added_node = new_node\n\n                if math.dist(new_pos, from_node.position) <= self.step_size:\n                    if can_connect(new_pos, from_node.position):\n                        final_cost = new_node.cost + math.dist(new_pos, from_node.position)\n                        final_node = Node(from_node.position)\n                        final_node.cost = final_cost\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n\n                        to_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    break\n\n            if last_added_node:\n                near = near_nodes(to_tree, last_added_node.position, radius)\n                rewire(last_added_node, near, to_tree, edges)\n\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]\n\n        def smooth_path(path, max_attempts=120):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        nodes = []\n        edges = []\n        tree_start = [Node(start_position, cost=0.0)]\n        tree_goal = [Node(goal_position, cost=0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            radius = neighbor_radius(it)\n            sample = sample_free()\n\n            new_node_start = try_extend(tree_start, sample, radius)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start, radius)\n            if new_node_goal is not None:\n                success_state = True\n                extracted_path = extract_path(new_node_start, new_node_goal)\n                extracted_path = smooth_path(extracted_path, max_attempts=150)\n                break\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _dist_sq(self, p1, p2):\n        return sum((p1[d] - p2[d]) ** 2 for d in range(len(p1)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.4):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 62.54878,
    "time_improvement": -209.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.030744433403015137,
            "num_nodes_avg": 111.9,
            "path_length_avg": 173.95066017563983,
            "success_improvement": -9.999999999999998,
            "time_improvement": -204.73749633704824,
            "length_improvement": 13.06113197042886,
            "objective_score": -63.80902250702869
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05458786487579346,
            "num_nodes_avg": 284.2,
            "path_length_avg": 243.07376726958424,
            "success_improvement": 0.0,
            "time_improvement": -281.6254552424765,
            "length_improvement": 19.33990046841358,
            "objective_score": -80.61965647906023
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.06925151348114014,
            "num_nodes_avg": 282.3,
            "path_length_avg": 128.7219256943174,
            "success_improvement": -9.999999999999998,
            "time_improvement": -141.36349623282294,
            "length_improvement": 20.956983284422506,
            "objective_score": -43.21765221296238
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements an efficient bidirectional RRT* planner combining balanced tree growth, adaptive neighbor radius for rewiring, incremental connection attempts, and path shortcut smoothing. It ensures collision-free node and edge validation, bounds adherence, and aims to improve path quality, success rate, and planning speed by dynamically rewiring nodes towards lower-cost paths.",
    "planning_mechanism": "The planner alternately extends two trees from the start and goal towards randomly sampled free points, chooses optimal parents in a dynamic neighborhood for each new node, rewires neighboring nodes if a cheaper path is found, and attempts incremental connections between trees. Upon successful connection, it reconstructs and smooths the path before returning.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position      # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent          # Node or None\n        self.cost = cost              # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True             # For potential future use\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 smoothing_iterations: int = 100, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback sample even if in obstacle\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / distance_between\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(len(bounds)))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes,1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + \\\n                      (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - position[d])**2 for d in range(len(position))) <= r2]\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n        tree_a, tree_b = [start_root], [goal_root]\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for iteration in range(self.max_iter):\n            sample = sample_free()\n            radius = neighbor_radius(iteration, len(nodes))\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            neighbors = near_nodes(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                cost_thru_node = node.cost + dist(node.position, new_pos)\n                if cost_thru_node + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_thru_node\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper path found via new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt incremental connection from tree_b towards new_node\n            connect_node = nearest(tree_b, new_node.position)\n            curr_pos = connect_node.position\n            connected = False\n\n            while True:\n                next_pos = steer(curr_pos, new_node.position)\n                if not can_add_node(next_pos) or not can_connect(curr_pos, next_pos):\n                    break\n\n                neighbors_b = near_nodes(tree_b, next_pos, radius)\n\n                min_cost_b = connect_node.cost + dist(curr_pos, next_pos)\n                best_parent_b = connect_node\n                for node_b in neighbors_b:\n                    cost_b = node_b.cost + dist(node_b.position, next_pos)\n                    if cost_b + 1e-12 < min_cost_b and can_connect(node_b.position, next_pos):\n                        min_cost_b = cost_b\n                        best_parent_b = node_b\n\n                new_node_b = Node(next_pos, parent=best_parent_b, cost=min_cost_b)\n                best_parent_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((best_parent_b, new_node_b))\n\n                # Rewire neighbors of new_node_b\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is best_parent_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    path_start = new_node.path_from_root()\n                    path_goal = connection_node.path_from_root()\n                    extracted_path = path_start + path_goal[::-1][1:]\n                    extracted_path = shortcut_smoothing(extracted_path)\n                    connected = True\n                    break\n\n                curr_pos = new_node_b.position\n                connect_node = new_node_b\n\n            if connected:\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 11.36172,
    "time_improvement": -53.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009463739395141602,
            "num_nodes_avg": 65.6,
            "path_length_avg": 156.78522789428558,
            "success_improvement": 0.0,
            "time_improvement": 6.195823762394946,
            "length_improvement": 21.640250039152267,
            "objective_score": 6.186797136548938
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.023795652389526366,
            "num_nodes_avg": 218.4,
            "path_length_avg": 241.46927916424852,
            "success_improvement": 0.0,
            "time_improvement": -66.35614337741997,
            "length_improvement": 19.872323904012422,
            "objective_score": -15.932378232423506
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05674192905426025,
            "num_nodes_avg": 304.6,
            "path_length_avg": 122.22337727974164,
            "success_improvement": 0.0,
            "time_improvement": -97.76362553088236,
            "length_improvement": 24.94748349011496,
            "objective_score": -24.339590961241715
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm with adaptive sampling towards the goal and start to improve exploration efficiency. It employs a KD-tree to accelerate nearest and near neighbor searches, dynamically adjusts the neighborhood radius based on the growing tree sizes, and performs incremental rewiring to minimize path cost and improve smoothness. Early connection attempts between the two trees enable faster convergence. Post path extraction, an optimization-based shortcutting smooths the path while ensuring collision-free transitions. Overall, this approach balances fast search, path quality, robustness, and planning efficiency.",
    "planning_mechanism": "The planner grows two trees bidirectionally from start and goal, alternately extending them by sampling points biased toward both ends. Using KD-trees, it quickly finds nearest and nearby nodes for efficient rewiring to locally optimize path costs. The rewiring radius shrinks adaptively with the tree size, focusing on refining the solution as exploring proceeds. When trees connect, the shortest cost path is extracted and post-processed by shortcutting to smooth the trajectory. Collision checks prevent invalid nodes or edges, and out-of-bound checks ensure safety.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 radius_constant: float=40.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        class KDTree:\n            def __init__(self):\n                self.points = []\n                self.nodes = []\n\n            def insert(self, node):\n                self.points.append(node.position)\n                self.nodes.append(node)\n\n            def nearest(self, point):\n                best_node = None\n                best_dist = float('inf')\n                for node in self.nodes:\n                    dist = math.dist(node.position, point)\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_node = node\n                return best_node\n\n            def near(self, point, radius):\n                r_sq = radius * radius\n                neighbors = []\n                for node in self.nodes:\n                    dx = 0\n                    for d in range(dim):\n                        diff = node.position[d] - point[d]\n                        dx += diff * diff\n                        if dx > r_sq:\n                            break\n                    if dx <= r_sq:\n                        neighbors.append(node)\n                return neighbors\n\n        def sample_free():\n            # Adaptive goal/start biasing to balance exploration\n            r = random.random()\n            if r < self.goal_sample_rate:\n                return goal_position\n            elif r < self.goal_sample_rate * 2:\n                return start_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def out_of_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return True\n            return False\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_constant\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        # Initialize trees and kd-trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        kd_start = KDTree()\n        kd_goal = KDTree()\n        kd_start.insert(start_root)\n        kd_goal.insert(goal_root)\n\n        tree_flag = True  # True: extend start tree; False: extend goal tree\n\n        def try_extend(tree, kd_tree, point):\n            if not tree:\n                return None\n            nearest_node = kd_tree.nearest(point)\n            if nearest_node is None:\n                return None\n            new_pos = steer(nearest_node.position, point)\n            if out_of_bounds(new_pos): \n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = kd_tree.near(new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + math.dist(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            kd_tree.insert(new_node)\n\n            # Rewire neighbors for incremental optimization\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, kd_tree, node):\n            if not tree:\n                return None\n            nearest_node = kd_tree.nearest(node.position)\n            if nearest_node is None:\n                return None\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if out_of_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + math.dist(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n                kd_tree.insert(new_node)\n\n                if math.dist(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + math.dist(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        kd_tree.insert(final_node)\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def combine_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            path_goal.reverse()\n            return path_start + path_goal[1:]\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Alternate tree extension with balancing sizes for faster convergence\n            if len(tree_start) > len(tree_goal):\n                tree_extend, kd_extend = tree_goal, kd_goal\n                tree_connect, kd_connect = tree_start, kd_start\n                start_tree_flag = False\n            else:\n                tree_extend, kd_extend = tree_start, kd_start\n                tree_connect, kd_connect = tree_goal, kd_goal\n                start_tree_flag = True\n\n            new_node = try_extend(tree_extend, kd_extend, rand_point)\n            if new_node is None:\n                continue\n\n            connect_node = try_connect(tree_connect, kd_connect, new_node)\n            if connect_node is not None:\n                success_state = True\n                if start_tree_flag:\n                    extracted_path = combine_path(new_node, connect_node)\n                else:\n                    extracted_path = combine_path(connect_node, new_node)\n\n                # Post-process smoothing\n                extracted_path = smooth_path(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 12.53989,
    "time_improvement": -56.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012874317169189454,
            "num_nodes_avg": 112.4,
            "path_length_avg": 158.54806002330182,
            "success_improvement": 0.0,
            "time_improvement": -27.6096758642203,
            "length_improvement": 20.759203484525322,
            "objective_score": -4.131062062361026
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03498883247375488,
            "num_nodes_avg": 396.1,
            "path_length_avg": 235.32768417519816,
            "success_improvement": 0.0,
            "time_improvement": -144.6080122675867,
            "length_improvement": 21.910312900785097,
            "objective_score": -39.00034110011899
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.027908682823181152,
            "num_nodes_avg": 266.9,
            "path_length_avg": 124.63820597220362,
            "success_improvement": 0.0,
            "time_improvement": 2.7293856430958123,
            "length_improvement": 23.464633201215378,
            "objective_score": 5.511742333171819
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved planner implements a bidirectional RRT* algorithm with heuristic-informed adaptive sampling biased towards the goal region to direct exploration. It uses a dynamic neighborhood radius for rewiring to optimize path costs continuously. Additionally, it incorporates intelligent periodic pruning of dead-end nodes to reduce computational overhead and an enhanced shortcut smoothing technique that attempts multiple path refinements to minimize path length and improve smoothness. Rigorous collision checks ensure validity of nodes and edges, while balanced tree expansions promote efficient bidirectional search and early path convergence leading to a robust, high-quality, and computationally efficient path planning solution.",
    "planning_mechanism": "The planner grows two trees from start and goal, always extending the smaller tree to maintain balanced exploration. Sampling is adaptively biased towards the goal area to guide the search effectively. Nodes are only added if collision-free, and rewiring within a dynamically calculated neighborhood improves path cost continually. Dead-end nodes are periodically pruned to keep the tree manageable. Once a connection between the trees is found, iterative shortcut smoothing refines the path, producing a shorter and smoother trajectory.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2, radius_constant: float=30.0,\n                 radius_min: float=5.0, prune_interval: int=150,\n                 prune_threshold: int=150, smoothing_iterations: int=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d in range(len(pos)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            p_bias = 0.85\n            if random.random() < self.goal_sample_rate:\n                # Adaptive informed sampling: biased around goal with small Gaussian noise\n                if random.random() < p_bias:\n                    dim = len(bounds)\n                    noise_scale = self.step_size * 1.5\n                    if dim == 2:\n                        sample = (random.gauss(goal_position[0], noise_scale),\n                                  random.gauss(goal_position[1], noise_scale))\n                    else:\n                        sample = tuple(random.gauss(goal_position[d], noise_scale) for d in range(dim))\n                    # Check bounds and collisions\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                # fallback to pure uniform random sample\n                # sample uniformly until valid\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d) and in_bounds(sample):\n                        return sample\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d) and in_bounds(sample):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            # Use list copy to avoid modifying list while iterating\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                # Dead-end nodes have no children and are not start/goal\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Extend smaller tree for balanced exploration\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 11.40345,
    "time_improvement": -47.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.016108107566833497,
            "num_nodes_avg": 86.3,
            "path_length_avg": 161.6470753664288,
            "success_improvement": -9.999999999999998,
            "time_improvement": -59.66286664965168,
            "length_improvement": 19.21034540220651,
            "objective_score": -19.0567909144542
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.027827692031860352,
            "num_nodes_avg": 173.6,
            "path_length_avg": 238.82154154739888,
            "success_improvement": 0.0,
            "time_improvement": -94.54425748597812,
            "length_improvement": 20.750932822233363,
            "objective_score": -24.213090681346763
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.024597597122192384,
            "num_nodes_avg": 154.9,
            "path_length_avg": 123.94005355805423,
            "success_improvement": 0.0,
            "time_improvement": 14.269569834663018,
            "length_improvement": 23.893340840912128,
            "objective_score": 9.05953911858133
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm combines the strengths of informed sampling and a heuristic-guided tree expansion to efficiently converge to high-quality, collision-free paths. It builds a single tree rooted at the start node but uses heuristic-biased sampling focused within an ellipsoidal informed subset between the start and goal to improve sampling efficiency and path quality. The algorithm integrates a lazy collision-checking approach to reduce expensive collision checks and attempts local shortcutting for smoothness and shorter connections whenever possible. The rewiring step is constrained for efficiency, balancing performance and optimality.",
    "planning_mechanism": "Planning mechanism includes generating candidate samples focused inside an informed ellipse to bias exploration toward promising regions. Nodes are expanded toward these samples using step-size limited steering. The tree rewiring step optimizes local connectivity for cost reduction. Lazy collision checks skip edge verification until necessary. After path extraction, a post-processing smooth shortcutting is applied to improve path smoothness and reduce length. The combination ensures faster convergence, improved path quality, and higher success rates.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # cumulative cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def line_cost(a, b):\n            return dist(a, b)\n\n        def parent_path_cost(node):\n            return node.cost\n\n        # Informed sampling ellipse parameters for 2D or 3D\n        def informed_sample():\n            # Compute current best path cost for heuristic radius\n            c_min = dist(start_position, goal_position)\n            c_best = best_path_cost if success_state else float('inf')\n\n            if c_best == float('inf'):\n                # No solution yet, do uniform random sample\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            # Sample inside prolate hyperspheroid (ellipse in 2D, ellipsoid in 3D)\n            # Focus samples in better region as solution improves (Heuristic-based)\n            # Transformation and scaling to ellipsoid defined by foci start/goal and radius c_best\n            from numpy import random as np_random\n            from numpy import sqrt, dot, array\n            d = len(bounds)\n            c_min_vec = array(start_position)\n            c_max_vec = array(goal_position)\n            center = (c_min_vec + c_max_vec) / 2\n            diff = c_max_vec - c_min_vec\n            length = dist(start_position, goal_position)\n            if length == 0:\n                # Start and goal same point: return start\n                return start_position\n\n            # Unit vector from start to goal\n            e1 = diff / length\n\n            # Construct rotation matrix from unit vector e1 to axis aligned\n            # For simplicity in 2D or 3D, sets up rotation that aligns x-axis to e1\n\n            # Orthogonal basis via Gram-Schmidt or QR (for 3D and above)\n            # But simplest for 2D:\n            if d == 2:\n                # Rotation matrix whose first column = e1\n                R = [[e1[0], e1[1]],\n                     [-e1[1], e1[0]]]\n                R = array(R).T\n            elif d == 3:\n                # For 3D: construct two orthogonal vectors orthogonal to e1\n                # Use arbitrary vector not colinear with e1\n                arbitrary = array([1.0, 0.0, 0.0])\n                if abs(dot(arbitrary, e1)) > 0.99:\n                    arbitrary = array([0.0, 1.0, 0.0])\n                v = arbitrary - dot(arbitrary, e1) * e1\n                v /= sqrt(dot(v, v))\n                w = np_random.cross(e1, v)\n                R = array([e1, v, w]).T\n            else:\n                # For higher dims, fallback: uniform random sample (no ellipse)\n                while True:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(d))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            # Lengths of ellipsoid axes (radii)\n            # Major axis half-length = c_best / 2\n            a1 = c_best / 2\n            # Other axes half-length: sqrt(c_best^2 - c_min^2)/2\n            if c_best < float('inf'):\n                radius_others = sqrt(max(c_best**2 - c_min**2, 0)) / 2\n            else:\n                radius_others = max(bounds)  # fallback large radius\n\n            # Sample uniformly within unit n-ball\n            # Sample direction uniformly on sphere and radius with proper distribution\n            from numpy import linalg as LA\n            unit_ball_sample = np_random.normal(size=d)\n            unit_ball_sample /= LA.norm(unit_ball_sample)\n            # Radius sample with power law for uniform ball\n            u = np_random.uniform()\n            radius = u**(1/d)\n            unit_ball_sample *= radius\n\n            # Scale according to axes\n            scale = [a1] + [radius_others]*(d-1)\n            sample_ellipse = array([unit_ball_sample[i]*scale[i] for i in range(d)])\n\n            # Transform back to world frame\n            sample_point = center + R @ sample_ellipse\n            sample_tuple = tuple(float(max(0, min(bounds[i], sample_point[i]))) for i in range(d))\n\n            if not self._is_in_obstacle(sample_tuple, obstacles, is_3d):\n                return sample_tuple\n            else:\n                # If in obstacle, fallback to uniform sampling till free\n                count = 0\n                while count < 100:\n                    count += 1\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(d))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # As last resort forcibly return sample_tuple anyway\n                return sample_tuple\n\n        def local_shortcut(path):\n            # Post-process the found path to smooth by attempting shortcut connections\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = len(path)-1\n                while j > i+1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        smoothed.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    smoothed.append(path[i+1])\n                    i += 1\n            return smoothed\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        nodes = [start_root]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n        best_path_cost = float('inf')\n\n        for iter_num in range(self.max_iter):\n            sample = informed_sample()\n\n            # Find nearest node in tree\n            nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n\n            new_pos = steer(nearest_node.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + line_cost(nearest_node.position, new_pos)\n\n            # Find neighbors within smaller radius for rewiring (smaller radius for efficiency)\n            search_radius = min(20.0, self.step_size * 5)\n            near_nodes = [n for n in nodes if dist(n.position, new_pos) <= search_radius and n is not nearest_node]\n\n            # Choose best parent from near nodes + nearest_node itself to minimize cost\n            possible_parents = near_nodes + [nearest_node]\n\n            best_parent = None\n            min_cost = float('inf')\n            for pnode in possible_parents:\n                c = pnode.cost + line_cost(pnode.position, new_pos)\n                if c < min_cost and not self._is_edge_in_obstacle(pnode.position, new_pos, obstacles, is_3d):\n                    min_cost = c\n                    best_parent = pnode\n\n            if best_parent is None:\n                # No valid parent found\n                continue\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if passing through new node reduces cost\n            for neighbor in near_nodes:\n                cost_through_new = new_node.cost + line_cost(new_node.position, neighbor.position)\n                if cost_through_new + 1e-6 < neighbor.cost:  # small epsilon to prevent oscillations\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Remove previous edge\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.children.remove(neighbor)\n                            except Exception:\n                                pass\n                        # Reassign parent and cost\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n            # Check if new node can connect directly to goal (final connection)\n            if dist(new_node.position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and \\\n                   not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist(new_node.position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    # Extract path and smooth\n                    extracted_path = goal_node.path_from_root()\n                    extracted_path = local_shortcut(extracted_path)\n                    success_state = True\n                    best_path_cost = goal_node.cost\n                    break\n\n        if success_state and len(extracted_path) >= 2:\n            # Final smoothing: attempt repeated shortcuts to optimize further\n            max_attempts = 10\n            for _ in range(max_attempts):\n                path = extracted_path\n                if len(path) < 3:\n                    break\n                i = 0\n                improved = False\n                while i < len(path) - 2:\n                    j = min(len(path) - 1, i + 2)\n                    while j > i + 1:\n                        if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                            if j != i + 1:\n                                # shortcut found\n                                extracted_path = path[:i+1] + path[j:]\n                                improved = True\n                                break\n                        j -= 1\n                    if improved:\n                        break\n                    i += 1\n                if not improved:\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 409.34608,
    "time_improvement": -1383.0,
    "length_improvement": 27.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.21757075786590577,
            "num_nodes_avg": 532.2,
            "path_length_avg": 152.58747789048397,
            "success_improvement": 0.0,
            "time_improvement": -2056.5519571978184,
            "length_improvement": 23.738245144391588,
            "objective_score": -612.2179381304672
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.243973970413208,
            "num_nodes_avg": 907.7,
            "path_length_avg": 220.28017967172042,
            "success_improvement": 0.0,
            "time_improvement": -1605.629588885833,
            "length_improvement": 26.90358397477311,
            "objective_score": -476.3081598707953
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.1679832935333252,
            "num_nodes_avg": 714.7,
            "path_length_avg": 112.93375056867983,
            "success_improvement": 0.0,
            "time_improvement": -485.4750748075694,
            "length_improvement": 30.651873907235245,
            "objective_score": -139.51214766082376
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid algorithm combines the efficient incremental bidirectional RRT* tree growth from Algorithm #1 with the heuristic-informed sampling, KD-tree accelerated nearest neighbor searches, collision caching, and pruning strategies from Algorithm #2. It interleaves adaptive ellipsoidal sampling focused on promising regions with balanced tree expansions. Periodic pruning of suboptimal nodes reduces search complexity, while incremental rewiring improves path cost. Final path smoothing ensures a high-quality, smooth path. This approach enhances planning efficiency, robustness, success rates, and path optimality, producing shorter and smoother paths faster in both 2D and 3D spaces.",
    "planning_mechanism": "The planner grows two trees from start and goal, alternating extension of the smaller tree towards informed ellipsoid-biased samples. KD-tree structures accelerate neighbor queries for rewiring and nearest node search. Edge collision caching speeds collision checks. Nodes and edges are only added if both node placement and connecting edges are collision-free and within bounds. The best path cost updates the ellipsoid sampling region dynamically, progressively shrinking the search space. Periodic pruning removes nodes that cannot beat the current best path, lowering computational overhead. After successful connection, the final path is shortcut-smoothed for better smoothness and path length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checks etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_iterations: int = 100,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Helpers\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c+1)/c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree helper for nearest and radius search\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Ellipsoidal informed sampling as in Algorithm #2\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # No solution yet or marginal improvement: uniform sample\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Calculate ellipsoid parameters\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))  # unit vector from start to goal\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1**2 - (c_min / 2)**2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    x = x * radii\n                    p = rot @ x + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n            # fallback uniform sampling\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback last sample\n\n        # Caches for collision checks\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        # Shortcut smoothing (similar to both algorithms)\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Prune nodes that cannot improve the best path\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialize\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cost improvements\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try connect other tree incrementally to new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Update best cost and path\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to reduce complexity\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 2.55304,
    "time_improvement": -22.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.00791943073272705,
            "num_nodes_avg": 61.8,
            "path_length_avg": 158.4027803367249,
            "success_improvement": 0.0,
            "time_improvement": 21.50294454054769,
            "length_improvement": 20.83181287552122,
            "objective_score": 10.617245937268551
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.027858495712280273,
            "num_nodes_avg": 228.4,
            "path_length_avg": 240.8903836814004,
            "success_improvement": 0.0,
            "time_improvement": -94.7596069705228,
            "length_improvement": 20.06442101012724,
            "objective_score": -24.414997889131392
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.026755642890930176,
            "num_nodes_avg": 178.9,
            "path_length_avg": 129.35039218762472,
            "success_improvement": 0.0,
            "time_improvement": 6.748095637353845,
            "length_improvement": 20.57106699807329,
            "objective_score": 6.138642090820811
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm implements an improved bidirectional RRT* planner that adaptively balances exploration by always extending the smaller tree, performs heuristic-informed sampling biased towards the corridor connecting start and goal, employs dynamic radius-based rewiring to optimize path costs continually, and uses periodic pruning of dead-end and costly nodes to maintain computational efficiency. Multiple iterations of shortcut smoothing refine the extracted path for enhanced smoothness and shorter length, maintaining rigorous collision and boundary checks to ensure feasibility and robustness.",
    "planning_mechanism": "The planner grows two balanced trees from start and goal positions using corridor-biased sampling. Each new sample attempts extension on the smaller tree, connecting afterwards to the opposite tree aggressively. A dynamic neighborhood radius facilitates rewiring neighbors for optimal path costs. Periodic pruning removes unhelpful nodes to keep the search efficient. Upon successful connection, the algorithm extracts and iteratively smooths the combined path to improve quality and smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2,\n                 radius_constant: float=30.0, radius_min: float=5.0,\n                 prune_interval: int=150, prune_threshold: int=150,\n                 smoothing_iterations: int=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d in range(len(pos)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            p_goal_bias = self.goal_sample_rate\n            corridor_width_ratio = 0.8\n\n            if random.random() < p_goal_bias:\n                # 75% sampling bias near goal + 20% near start to diversify\n                if random.random() < 0.75:\n                    # Gaussian sample near goal\n                    noise_scale = self.step_size * 1.5\n                    if is_3d:\n                        sample = tuple(random.gauss(goal_position[d], noise_scale) for d in range(3))\n                    else:\n                        sample = (random.gauss(goal_position[0], noise_scale),\n                                  random.gauss(goal_position[1], noise_scale))\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                elif random.random() < 0.6:\n                    # Gaussian sample near start\n                    noise_scale = self.step_size * 1.5\n                    if is_3d:\n                        sample = tuple(random.gauss(start_position[d], noise_scale) for d in range(3))\n                    else:\n                        sample = (random.gauss(start_position[0], noise_scale),\n                                  random.gauss(start_position[1], noise_scale))\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n            # Corridor-biased sampling along line start->goal with Gaussian perpendicular noise\n            max_dim = max(bounds) if not is_3d else max(bounds[0], bounds[1], bounds[2])\n            corridor_width = corridor_width_ratio * max_dim\n            alpha = random.uniform(0.0, 1.0)\n            base_point = tuple(start_position[d] + alpha*(goal_position[d] - start_position[d]) for d in range(len(bounds)))\n\n            if is_3d:\n                dir_vec = np.array([goal_position[d] - start_position[d] for d in range(3)], dtype=float)\n                norm_dir = np.linalg.norm(dir_vec)\n                dir_vec = dir_vec / norm_dir if norm_dir > 1e-8 else np.array([1,0,0], dtype=float)\n\n                # Generate two perpendicular unit vectors\n                temp_vec = np.array([1,0,0], dtype=float) if abs(dir_vec[0]) < 0.9 else np.array([0,1,0], dtype=float)\n                perp_vec1 = temp_vec - dir_vec * np.dot(temp_vec, dir_vec)\n                perp_norm1 = np.linalg.norm(perp_vec1)\n                if perp_norm1 < 1e-8:\n                    perp_vec1 = np.array([0,0,1], dtype=float)\n                else:\n                    perp_vec1 /= perp_norm1\n                perp_vec2 = np.cross(dir_vec, perp_vec1)\n                perp_vec2 /= np.linalg.norm(perp_vec2)\n\n                noise_radius1 = random.gauss(0, corridor_width/5)\n                noise_radius2 = random.gauss(0, corridor_width/5)\n                offset_vec = perp_vec1 * noise_radius1 + perp_vec2 * noise_radius2\n                sample_np = np.array(base_point, dtype=float) + offset_vec\n                sample = tuple(min(max(0, sample_np[d]), bounds[d]) for d in range(3))\n            else:\n                dx = goal_position[0] - start_position[0]\n                dy = goal_position[1] - start_position[1]\n                length = math.hypot(dx, dy)\n                if length < 1e-8:\n                    perp = (0.0, 0.0)\n                else:\n                    perp = (-dy/length, dx/length)\n                offset = random.gauss(0, corridor_width/5)\n                x = base_point[0] + perp[0]*offset\n                y = base_point[1] + perp[1]*offset\n                x = min(max(0, x), bounds[0])\n                y = min(max(0, y), bounds[1])\n                sample = (x,y)\n\n            if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                return sample\n\n            # Fallback: uniform random sampling until valid\n            for _ in range(100):\n                if is_3d:\n                    candidate = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    candidate = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                if in_bounds(candidate) and not self._is_in_obstacle(candidate, obstacles, is_3d):\n                    return candidate\n            # If all fail, return start position as fallback\n            return start_position\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.5):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            # Remove dead ends that have no children except start/goal nodes\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p,c) for (p,c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            total = 0.0\n            for i in range(len(path) -1):\n                total += dist(path[i], path[i+1])\n            return total\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend smaller tree first - balanced exploration\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]  # concatenate except duplicate joint\n\n                smoothed_path = shortcut_smoothing(raw_path)\n                # Keep best path length result\n                if path_length(smoothed_path) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 262.70356,
    "time_improvement": -869.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.016899800300598143,
            "num_nodes_avg": 106.2,
            "path_length_avg": 161.1997363781885,
            "success_improvement": -9.999999999999998,
            "time_improvement": -67.51009084120277,
            "length_improvement": 19.433921128931754,
            "objective_score": -21.36624302657448
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.11010003089904785,
            "num_nodes_avg": 269.0,
            "path_length_avg": 232.66026717120423,
            "success_improvement": 0.0,
            "time_improvement": -669.7127284546341,
            "length_improvement": 22.795452105443808,
            "objective_score": -196.35472811530144
        },
        {
            "map_id": 2,
            "success_rate": 0.7,
            "time_avg": 0.5647856235504151,
            "num_nodes_avg": 442.1,
            "path_length_avg": 120.93758143578452,
            "success_improvement": -30.000000000000004,
            "time_improvement": -1868.4570902452258,
            "length_improvement": 25.73703959594945,
            "objective_score": -570.3897191543779
        }
    ],
    "success_rate": 0.8666666666666666
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner with adaptive step sizing, dynamic radius rewiring, and goal-biased sampling to improve exploration efficiency and path quality. The planner incrementally grows two trees from start and goal, attempts connections between them, and uses shortcut smoothing on the final combined path to deliver shorter and smoother trajectories with robustness in collision avoidance and bounded node placement.",
    "planning_mechanism": "The planner alternately extends two trees by sampling points mostly in free space but biased towards the goal to accelerate convergence. Each extension uses adaptive step size and dynamically computed radii to find near neighbors for rewiring, improving path optimality. After connecting the trees, the path is extracted and refined using shortcut smoothing, assuring collision and bound checks throughout the process to guarantee feasible, high-quality paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost\n        self.children = []\n        self.valid = True               # Node validity flag\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_and_propagate(self, new_cost):\n        self.cost = new_cost\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_cost_and_propagate(new_cost + dist)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 6.0, goal_sample_rate: float = 0.12, radius_constant: float = 24.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Probability to sample goal point\n        self.radius_constant = radius_constant      # Coefficient for dynamic radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            # Goal-biased sampling with slight randomness to increase exploration\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        break\n\n            # Alternate tree growth: (start -> goal) and (goal -> start)\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                # 1. Find nearest node in tree_a\n                nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n                dist_near_to_sample = math.dist(nearest.position, sample)\n                if dist_near_to_sample == 0:\n                    continue\n\n                # 2. Adaptive step sizing to avoid overshoot\n                step = min(self.step_size, dist_near_to_sample)\n                new_pos = tuple(nearest.position[d] + (sample[d] - nearest.position[d]) * (step / dist_near_to_sample) for d in range(dim))\n\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # 3. Create new node with cost from nearest\n                new_node = Node(new_pos)\n                # Compute dynamic radius for rewiring (RRT* style)\n                radius = min(\n                    self.radius_constant * ((math.log(len(tree_a) + 1) / (len(tree_a) + 1)) ** (1 / dim)),\n                    self.step_size * 5\n                )\n\n                # 4. Find neighbors within radius for potential better parent connection\n                near_nodes = [node for node in tree_a if math.dist(node.position, new_pos) <= radius]\n\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near in near_nodes:\n                    if near == nearest:\n                        continue\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = near\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                new_node.parent = best_parent\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # 5. Rewire neighbors to improve paths where beneficial\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                            try:\n                                near.parent.children.remove(near)\n                            except ValueError:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        near.update_cost_and_propagate(new_cost)\n\n                # 6. Attempt to connect the other tree\n                nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n                dist_to_connect = math.dist(nearest_other.position, new_node.position)\n                if dist_to_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    # Connect trees and extract path\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = new_node.path_from_root()\n                        path_goal = nearest_other.path_from_root()\n                        path_goal.reverse()\n                        full_path = path_start + path_goal\n                    else:\n                        path_start = nearest_other.path_from_root()\n                        path_goal = new_node.path_from_root()\n                        path_goal.reverse()\n                        full_path = path_start + path_goal\n\n                    # Smooth final path with shortcutting\n                    smoothed_path = self._smooth_path(full_path, obstacles, is_3d, max_iterations=150, map_bounds=bounds)\n\n                    extracted_path = smoothed_path\n                    return PlannerResult(True, extracted_path, nodes, edges)\n\n        # If no path found\n        return PlannerResult(False, extracted_path, nodes, edges)\n\n\n    def _smooth_path(self, path, obstacles, is_3d, max_iterations=150, map_bounds=None):\n        import random\n\n        def valid_edge(p1, p2):\n            if map_bounds:\n                for d in range(len(p1)):\n                    if p1[d] < 0 or p1[d] > map_bounds[d]:\n                        return False\n                    if p2[d] < 0 or p2[d] > map_bounds[d]:\n                        return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        if len(path) < 3:\n            return path[:]\n\n        path = path[:]\n        for _ in range(max_iterations):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if valid_edge(path[i], path[j]):\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 11.8182,
    "time_improvement": -51.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.023647093772888185,
            "num_nodes_avg": 132.8,
            "path_length_avg": 171.6632933428514,
            "success_improvement": 0.0,
            "time_improvement": -134.3889723884336,
            "length_improvement": 14.20433592843752,
            "objective_score": -37.47582453084257
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.020715737342834474,
            "num_nodes_avg": 206.8,
            "path_length_avg": 243.57773464966635,
            "success_improvement": 0.0,
            "time_improvement": -44.82436182713705,
            "length_improvement": 19.172667041727053,
            "objective_score": -9.612775139795703
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02119474411010742,
            "num_nodes_avg": 255.5,
            "path_length_avg": 131.94851844751196,
            "success_improvement": 0.0,
            "time_improvement": 26.12959222084375,
            "length_improvement": 18.975660960743372,
            "objective_score": 11.6340098584018
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is a simplified and generalized bidirectional RRT* planner with adaptive step sizing and dynamic neighborhood radius for rewiring. It alternately grows two trees from start and goal by sampling free points using uniform sampling combined with goal bias. New nodes are connected only if collision checks pass for both the node position and the connecting edge. Rewiring of nearby nodes within a dynamic radius improves the path cost incrementally. The final path is extracted once the two trees connect, and a simple shortcut smoothing step reduces unnecessary waypoints for improved path quality and smoothness.",
    "planning_mechanism": "The planner iteratively samples free points within the map bounds, growing two trees from start and goal alternately. Each extension employs adaptive step size limited by distance to the sampled point. Nearby nodes within a dynamically computed radius are rewired to optimize cost while ensuring no collisions. After each extension, the planner attempts to connect the two trees within step size distance. Upon successful connection, the combined path is extracted and smoothed via shortcutting to reduce path length and improve smoothness.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_and_propagate(self, new_cost: float):\n        self.cost = new_cost\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_cost_and_propagate(new_cost + dist)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, radius_const: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        success = False\n        final_path: List[Tuple[float, ...]] = []\n\n        unit_ball_volume = {2: math.pi, 3: 4/3*math.pi}[dim] if dim in (2,3) else 1.0\n\n        for _ in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        break\n\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n                dist_to_sample = math.dist(nearest.position, sample)\n                if dist_to_sample == 0:\n                    continue\n\n                step = min(self.step_size, dist_to_sample)\n                new_pos = tuple(nearest.position[d] + (sample[d] - nearest.position[d]) * (step / dist_to_sample) for d in range(dim))\n\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n\n                radius = min(\n                    self.radius_const * ((math.log(len(tree_a) + 1) / (len(tree_a) + 1)) ** (1 / dim)),\n                    self.step_size * 5\n                )\n                near_nodes = [n for n in tree_a if math.dist(n.position, new_pos) <= radius]\n\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near in near_nodes:\n                    if self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        continue\n                    cost = near.cost + math.dist(near.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = near\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                new_node.parent = best_parent\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for near in near_nodes:\n                    if near is best_parent:\n                        continue\n                    if self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost:\n                        if near.parent:\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                            try:\n                                near.parent.children.remove(near)\n                            except ValueError:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        near.update_cost_and_propagate(new_cost)\n\n                # Try connecting trees\n                nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n                dist_connect = math.dist(nearest_other.position, new_node.position)\n\n                if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    success = True\n                    if tree_a is tree_start:\n                        path_start = new_node.path_from_root()\n                        path_goal = nearest_other.path_from_root()\n                        path_goal.reverse()\n                        full_path = path_start + path_goal\n                    else:\n                        path_start = nearest_other.path_from_root()\n                        path_goal = new_node.path_from_root()\n                        path_goal.reverse()\n                        full_path = path_start + path_goal\n\n                    final_path = self._shortcut_smooth(full_path, obstacles, is_3d, bounds)\n                    return PlannerResult(True, final_path, nodes, edges)\n\n        return PlannerResult(False, final_path, nodes, edges)\n\n    def _shortcut_smooth(self, path: List[Tuple[float, ...]], obstacles, is_3d, bounds, max_iter=150):\n        if len(path) < 3:\n            return path[:]\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def valid_edge(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        path = path[:]\n        for _ in range(max_iter):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if valid_edge(path[i], path[j]):\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool, resolution: float = 0.5) -> bool:\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 63.76212,
    "time_improvement": -214.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.05035068988800049,
            "num_nodes_avg": 136.0,
            "path_length_avg": 164.92793999066626,
            "success_improvement": -9.999999999999998,
            "time_improvement": -399.07386401232645,
            "length_improvement": 17.570600797032462,
            "objective_score": -121.20803904429144
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04345982074737549,
            "num_nodes_avg": 276.2,
            "path_length_avg": 241.93575378801788,
            "success_improvement": 0.0,
            "time_improvement": -203.82895383820454,
            "length_improvement": 19.717531842306865,
            "objective_score": -57.20517978299999
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.040335798263549806,
            "num_nodes_avg": 292.2,
            "path_length_avg": 127.82321657443333,
            "success_improvement": -9.999999999999998,
            "time_improvement": -40.58305447553266,
            "length_improvement": 21.508844823179572,
            "objective_score": -12.873147378023884
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved planner retains the bidirectional RRT* framework while enhancing path quality and planning efficiency through an adaptive goal-biased sampling focused on progressive connection attempts, a tightened dynamic neighborhood radius for rewiring based on tree size and cost-aware heuristics, and an enhanced shortcut smoothing with bidirectional checking and adaptive iterations. Dead-end pruning is stabilized and performed more frequently to reduce computational load and maintain robustness. The algorithm aggressively rewires nodes to paths of lower cost and emphasizes extending the smaller tree for balanced exploration, improving success rate and path optimality.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternately sampling in free space with a bias toward start and goal points to expedite connection. On each iteration, it extends the smaller tree by steering toward the sample, rewires nearby nodes for optimality within a dynamically computed radius, and then tries to connect the other tree to the newly added node. It rigorously checks collisions for nodes and edges, prunes dead ends periodically, and applies enhanced iterative shortcut smoothing to minimize path length and improve smoothness before returning the final path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...] (2D or 3D)\n        self.parent = parent              # Parent Node or None\n        self.cost = cost                  # Cost from root to this node\n        self.children = []\n        self.valid = True                 # For collision flag etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 20.0,\n                 radius_min: float = 5.0, prune_interval: int = 100,\n                 smoothing_iterations: int = 60):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        import random\n        import math\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def sample_free():\n            # Adaptive bias sampling toward start or goal with more focus on unexplored regions\n            bias_prob = 0.85\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < bias_prob else start_position\n            else:\n                attempts = 0\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                    attempts += 1\n                    if attempts > 100:\n                        # fallback to goal if stuck sampling\n                        return goal_position\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree, pos, radius):\n            radsq = radius * radius\n            result = []\n            for node in tree:\n                d_sq = sum((node.position[d] - pos[d])**2 for d in range(len(pos)))\n                if d_sq <= radsq:\n                    result.append(node)\n            return result\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(val, self.radius_min)\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                if not can_connect(node.position, new_pos):\n                    continue\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                # Improved cost comparison allowing negligible float tolerance\n                if tentative_cost + 1e-12 < min_cost:\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Improved rewiring: rewire neighbors for better cost paths if possible\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                if not can_connect(new_node.position, neighbor.position):\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            # Prune nodes that have no children and are not root nodes\n            for node in nodes[:]:\n                if node in (start_root, goal_root):\n                    continue\n                if not node.children and node.parent is not None:\n                    try:\n                        node.parent.children.remove(node)\n                    except Exception:\n                        pass\n                    # Remove node from main data structures\n                    try:\n                        nodes.remove(node)\n                    except Exception:\n                        pass\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    removed.append(node)\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            max_iter = self.smoothing_iterations\n            count = 0\n            while count < max_iter and len(path) >= 3:\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n                    # After successful shortcut, restart smoothing more aggressively\n                    count = 0\n                    continue\n                count += 1\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always grow smaller tree for better balance & efficiency\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal:\n                # Successful connection: extract full path\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed_path = shortcut_smoothing(raw_path)\n                # Choose path with minimal length between raw and smoothed\n                if path_length(smoothed_path) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            # Prune dead nodes periodically for efficiency and robustness\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > 150:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.7):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 47.34171,
    "time_improvement": -159.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.03282475471496582,
            "num_nodes_avg": 101.0,
            "path_length_avg": 174.22720544091052,
            "success_improvement": -9.999999999999998,
            "time_improvement": -225.35755135221999,
            "length_improvement": 12.922917304860498,
            "objective_score": -70.0226819446939
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03972630500793457,
            "num_nodes_avg": 170.6,
            "path_length_avg": 245.22545494316165,
            "success_improvement": 0.0,
            "time_improvement": -177.72782958721908,
            "length_improvement": 18.625897703486842,
            "objective_score": -49.59316933546835
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.05017263889312744,
            "num_nodes_avg": 137.3,
            "path_length_avg": 121.72262325370605,
            "success_improvement": -9.999999999999998,
            "time_improvement": -74.86756504997003,
            "length_improvement": 25.254976628030867,
            "objective_score": -22.409274189384835
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the bidirectional adaptive radius rewiring and KD-tree acceleration from the first algorithm with the adaptive step sizing, dynamic neighbor searches, and randomized shortcut smoothing of the second algorithm. It alternates growth between two trees seeded at start and goal, uses KD-trees for efficient nearest and neighbor queries, employs adaptive neighborhood radii shrinking with more rigorous collision and boundary checks, and increments rewiring to iteratively improve path quality. The planner applies a multi-pass randomized shortcut smoother on the final connected path to enhance smoothness and reduce length, ensuring robust collision avoidance and bounded exploration. Overall, this fusion targets improved planning efficiency, path optimality, and success robustness in complex environments.",
    "planning_mechanism": "The planner grows two bidirectional trees from start and goal positions, alternating their extension with adaptive step sizes and sampling biased towards both ends to balance exploration and exploitation. KD-trees speed up nearest and near neighbor searches, enabling efficient incremental rewiring within dynamically calculated radii to optimize paths continuously. Once the trees connect, the shortest-cost path is extracted, and a stochastic shortcut smoothing refines the trajectory while cautiously avoiding collisions and out-of-bound violations, resulting in faster convergence, better path lengths, and smoother, more feasible solutions.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_and_propagate(self, new_cost):\n        self.cost = new_cost\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_cost_and_propagate(new_cost + dist)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 radius_constant: float=30.0, radius_min: float=5.0, smoothing_iterations: int=200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        class KDTree:\n            # Simple KD-tree for nearest and near neighbor search acceleration\n            def __init__(self):\n                self.nodes = []\n                self.points = []\n\n            def insert(self, node):\n                self.nodes.append(node)\n                self.points.append(node.position)\n\n            def nearest(self, point):\n                best_node = None\n                best_dist = float('inf')\n                for node in self.nodes:\n                    dist = math.dist(node.position, point)\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_node = node\n                return best_node\n\n            def near(self, point, radius):\n                r_sq = radius * radius\n                neighbors = []\n                for node in self.nodes:\n                    dist_sq = 0\n                    for d in range(dim):\n                        diff = node.position[d] - point[d]\n                        dist_sq += diff * diff\n                        if dist_sq > r_sq:\n                            break\n                    if dist_sq <= r_sq:\n                        neighbors.append(node)\n                return neighbors\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            r = random.random()\n            # Bias sampling towards goal and start equally\n            if r < self.goal_sample_rate:\n                return goal_position\n            elif r < 2 * self.goal_sample_rate:\n                return start_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_constant\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        def try_extend(tree, kd_tree, point):\n            if not tree:\n                return None\n            nearest_node = kd_tree.nearest(point)\n            if nearest_node is None:\n                return None\n            new_pos = steer(nearest_node.position, point)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near_nodes = kd_tree.near(new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near_nodes:\n                if node == nearest_node:\n                    continue\n                tentative_cost = node.cost + math.dist(node.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n\n            tree.append(new_node)\n            kd_tree.insert(new_node)\n\n            # Incremental rewiring to improve neighbor costs\n            for neighbor in near_nodes:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except Exception:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            edges.append((best_parent, new_node))\n            nodes.append(new_node)\n            return new_node\n\n        def try_connect(tree, kd_tree, node):\n            # Attempt incremental connection from 'tree' to 'node'\n            if not tree:\n                return None\n            nearest_node = kd_tree.nearest(node.position)\n            if nearest_node is None:\n                return None\n\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + math.dist(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                last_node.add_child(new_node)\n\n                tree.append(new_node)\n                kd_tree.insert(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if math.dist(new_pos, node.position) <= self.step_size:\n                    if (not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d)) and in_bounds(node.position):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + math.dist(new_pos, node.position)\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        kd_tree.insert(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def combine_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            path_goal.reverse()\n            return path_start + path_goal[1:]\n\n        def smooth_path(path):\n            # Multi-pass randomized shortcut smoothing improving on both quality and robustness\n            if len(path) < 3:\n                return path[:]\n\n            def valid_edge(p1, p2):\n                if not in_bounds(p1) or not in_bounds(p2):\n                    return False\n                return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n            smoothed = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if valid_edge(smoothed[i], smoothed[j]):\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        # Initialize trees, KD-trees, and core containers\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        kd_start = KDTree()\n        kd_goal = KDTree()\n        kd_start.insert(start_root)\n        kd_goal.insert(goal_root)\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Alternate tree extension biased by current sizes for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_extend, kd_extend = tree_goal, kd_goal\n                tree_connect, kd_connect = tree_start, kd_start\n                start_flag = False\n            else:\n                tree_extend, kd_extend = tree_start, kd_start\n                tree_connect, kd_connect = tree_goal, kd_goal\n                start_flag = True\n\n            new_node = try_extend(tree_extend, kd_extend, rand_point)\n            if new_node is None:\n                continue\n\n            connect_node = try_connect(tree_connect, kd_connect, new_node)\n            if connect_node is not None:\n                success_state = True\n                if start_flag:\n                    extracted_path = combine_path(new_node, connect_node)\n                else:\n                    extracted_path = combine_path(connect_node, new_node)\n\n                extracted_path = smooth_path(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 29.44894,
    "time_improvement": -112.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.024479079246520995,
            "num_nodes_avg": 131.6,
            "path_length_avg": 163.98526830228192,
            "success_improvement": 0.0,
            "time_improvement": -142.63557647770563,
            "length_improvement": 18.041739046401037,
            "objective_score": -39.18232513403147
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04385039806365967,
            "num_nodes_avg": 384.4,
            "path_length_avg": 241.88975993152175,
            "success_improvement": 0.0,
            "time_improvement": -206.55949196189712,
            "length_improvement": 19.732794159933697,
            "objective_score": -58.02128875658239
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02449533939361572,
            "num_nodes_avg": 248.4,
            "path_length_avg": 126.46153273020836,
            "success_improvement": 0.0,
            "time_improvement": 14.625970462539719,
            "length_improvement": 22.34500073274858,
            "objective_score": 8.856791285311633
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is a tuned and optimized bidirectional RRT* planner that balances exploration and exploitation by dynamically adjusting neighbor radius, step sizes, and smoothing iterations. It improves planning efficiency and path quality by incorporating adaptive rewiring, incremental connection attempts, and path shortcut smoothing, ensuring robust collision-free paths within bounded environments.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternately extending toward random free samples. Each new node selects the best parent in a dynamically sized neighborhood to minimize cost, rewires neighbors for further optimization, then tries to connect the two trees incrementally. Once connected, the path is extracted and smoothed by shortcutting collision-free segments to produce a high-quality feasible plan.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 4000,\n                 step_size: float = 4.0,\n                 min_neighbor_radius: float = 4.0,\n                 max_neighbor_radius: float = 25.0,\n                 smoothing_iterations: int = 120,\n                 collision_check_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            attempt = 0\n            while attempt < 40:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n                attempt += 1\n            # fallback sample even if in obstacle after attempts\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / distance_between\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            # Clamp inside bounds precisely\n            return tuple(max(0.0, min(new_pos[d], bounds[d])) for d in range(len(bounds)))\n\n        def neighbor_radius(iteration, n_nodes):\n            n_nodes = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + \\\n                      (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        def shortcut_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - position[d])**2 for d in range(len(position))) <= r2]\n\n        # Initialization\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n        tree_a, tree_b = [start_root], [goal_root]\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for iteration in range(self.max_iter):\n            sample = sample_free()\n            radius = neighbor_radius(iteration, len(nodes))\n\n            # Extend tree_a towards the sample\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Find best parent within radius\n            neighbors = near_nodes(tree_a, new_pos, radius)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                cost_thru_node = node.cost + dist(node.position, new_pos)\n                if cost_thru_node + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_thru_node\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper path found\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connection attempt from tree_b towards new_node\n            connect_node = nearest(tree_b, new_node.position)\n            curr_pos = connect_node.position\n            connected = False\n\n            while True:\n                next_pos = steer(curr_pos, new_node.position)\n                if not can_add_node(next_pos) or not can_connect(curr_pos, next_pos):\n                    break\n\n                neighbors_b = near_nodes(tree_b, next_pos, radius)\n\n                min_cost_b = connect_node.cost + dist(curr_pos, next_pos)\n                best_parent_b = connect_node\n                for node_b in neighbors_b:\n                    cost_b = node_b.cost + dist(node_b.position, next_pos)\n                    if cost_b + 1e-12 < min_cost_b and can_connect(node_b.position, next_pos):\n                        min_cost_b = cost_b\n                        best_parent_b = node_b\n\n                new_node_b = Node(next_pos, parent=best_parent_b, cost=min_cost_b)\n                best_parent_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((best_parent_b, new_node_b))\n\n                # Rewire neighbors around new_node_b for optimization\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is best_parent_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                # Check direct connection to new_node\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    path_start = new_node.path_from_root()\n                    path_goal = connection_node.path_from_root()\n                    extracted_path = path_start + path_goal[::-1][1:]\n                    extracted_path = shortcut_smoothing(extracted_path)\n                    connected = True\n                    break\n\n                curr_pos = new_node_b.position\n                connect_node = new_node_b\n\n            if connected:\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 41.07145,
    "time_improvement": -145.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.02482466697692871,
            "num_nodes_avg": 123.6,
            "path_length_avg": 168.09220560095326,
            "success_improvement": -9.999999999999998,
            "time_improvement": -146.06102713892747,
            "length_improvement": 15.989131258339807,
            "objective_score": -45.620481890010275
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04994676113128662,
            "num_nodes_avg": 326.6,
            "path_length_avg": 237.26005015406326,
            "success_improvement": 0.0,
            "time_improvement": -249.17935511830055,
            "length_improvement": 21.269088494147063,
            "objective_score": -70.49998883666075
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03995215892791748,
            "num_nodes_avg": 275.6,
            "path_length_avg": 124.74416071249581,
            "success_improvement": 0.0,
            "time_improvement": -39.24594967181061,
            "length_improvement": 23.39957060785503,
            "objective_score": -7.0938707799721765
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a streamlined bidirectional RRT* algorithm with balanced tree growth, adaptive goal-biased sampling, dynamic neighborhood radius for rewiring, and iterative shortcut smoothing. It maintains rigorous collision checks for nodes and edges, and adapts exploration efficiently to improve planning speed and path quality while preserving robustness across 2D and 3D maps.",
    "planning_mechanism": "The planner grows two trees from start and goal, always extending the smaller tree for balanced exploration. Sampling is biased towards the goal to guide search efficiently. Nodes and edges are added only after confirming collision-free states and paths. Rewiring is performed within a dynamically calculated radius to optimize path cost. Upon successful tree connection, the path is extracted and refined via iterative shortcut smoothing to improve smoothness and shorten the path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2, radius_const: float = 30.0,\n                 radius_min: float = 5.0, smoothing_iter: int = 60):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.smoothing_iter = smoothing_iter\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d) and in_bounds(sample):\n                        break\n            return sample\n\n        def steer(from_p, to_p):\n            distance = dist(from_p, to_p)\n            if distance <= self.step_size:\n                return to_p\n            ratio = self.step_size / distance\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(len(from_p)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def radius_dynamic(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_const\n            r = self.radius_const * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(r, self.radius_min)\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            near = []\n            for node in tree:\n                dx = node.position[0] - pos[0]\n                dy = node.position[1] - pos[1]\n                dz = (node.position[2] - pos[2]) if is_3d else 0.0\n                dist_sq = dx*dx + dy*dy + dz*dz\n                if dist_sq <= r_sq:\n                    near.append(node)\n            return near\n\n        def can_add_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def can_connect(p1, p2):\n            if not in_bounds(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def try_extend(tree, sample):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                return None\n\n            r = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                cost_thru = node.cost + dist(node.position, new_pos)\n                if cost_thru + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_thru\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_thru_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_thru_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos) or not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size and can_connect(new_pos, node.position):\n                    final_cost = new_node.cost + dist(new_pos, node.position)\n                    final_node = Node(node.position, parent=new_node, cost=final_cost)\n                    new_node.children.append(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n\n                last_node = new_node\n\n        def extract_path(n_start, n_goal):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            sample = sample_free()\n\n            # Balance tree expansion by extending the smaller tree\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                raw_path = extract_path(new_node_start, new_node_goal)\n                smoothed_path = shortcut_smoothing(raw_path)\n                extracted_path = smoothed_path if len(smoothed_path) < len(raw_path) else raw_path\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 6.77202,
    "time_improvement": -37.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007858896255493164,
            "num_nodes_avg": 72.4,
            "path_length_avg": 158.97044898668418,
            "success_improvement": 0.0,
            "time_improvement": 22.102959664993527,
            "length_improvement": 20.548097540416986,
            "objective_score": 10.740507407581454
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03225698471069336,
            "num_nodes_avg": 337.6,
            "path_length_avg": 241.2652125430845,
            "success_improvement": 0.0,
            "time_improvement": -125.50957988515808,
            "length_improvement": 19.9400401127957,
            "objective_score": -33.66486594298828
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03081839084625244,
            "num_nodes_avg": 269.0,
            "path_length_avg": 123.50683756551288,
            "success_improvement": 0.0,
            "time_improvement": -7.411869993958881,
            "length_improvement": 24.159361557702983,
            "objective_score": 2.6083113133529325
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner combines the strengths of bidirectional RRT* with adaptive informed sampling towards start and goal, dynamic neighbor radius rewiring, balanced tree expansion by always extending the smaller tree, aggressive pruning of dead-ends for efficiency, lazy collision checking, and robust path smoothing using iterative randomized shortcutting. It prioritizes path cost optimization during tree growth, reduces computational overhead by pruning unnecessary nodes, and maintains path feasibility and smoothness to minimize both planning time and path length.",
    "planning_mechanism": "The planner initializes two trees from start and goal and iteratively extends the smaller tree towards adaptively biased samples within map bounds. Each new node is connected by rewiring neighbors within a dynamically computed radius to optimize path cost. After each successful connection of the two trees, the planner extracts and smooths the resultant path. Periodic pruning removes dead-end nodes to maintain tree efficiency and reduce search complexity. Careful collision checks on nodes and edges ensure feasibility while alternating tree expansions and adaptive sampling improve exploration balance and convergence speed.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2, radius_constant: float = 27.0,\n                 radius_min: float = 5.0, prune_interval: int = 150,\n                 prune_threshold: int = 120, smoothing_iterations: int = 80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        import math\n        import random\n\n        is_3d = len(bounds) == 3\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        success_state = False\n        extracted_path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            bias_to_goal = self.goal_sample_rate\n            if random.random() < bias_to_goal:\n                # Alternate bias between goal and start to avoid biasing only goal\n                return goal_position if random.random() < 0.6 else start_position\n            else:\n                attempts = 0\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if (not self._is_in_obstacle(p, obstacles, is_3d)) and in_bounds(p):\n                        return p\n                    attempts += 1\n                    if attempts > 30:\n                        return goal_position if random.random() < 0.6 else start_position\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d_] + (to_pos[d_] - from_pos[d_]) * ratio for d_ in range(len(from_pos)))\n            # Clamp to bounds\n            clamped = tuple(max(0, min(new_pos[d_], bounds[d_])) for d_ in range(len(bounds)))\n            return clamped\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def can_connect(p1, p2):\n            if dist(p1, p2) < 1e-9:\n                return True\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos): \n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            # Prune leaf nodes except roots\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            total = 0.0\n            for i in range(len(path) - 1):\n                total += dist(path[i], path[i + 1])\n            return total\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            path = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend smaller tree for balanced search\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                # Fail fast to next iteration\n                if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                    prune_dead_nodes()\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 6.58919,
    "time_improvement": -35.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009231066703796387,
            "num_nodes_avg": 82.1,
            "path_length_avg": 162.4624183556212,
            "success_improvement": 0.0,
            "time_improvement": 8.502065432133769,
            "length_improvement": 18.80284481287468,
            "objective_score": 6.311188592215067
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03338677883148193,
            "num_nodes_avg": 124.3,
            "path_length_avg": 239.9674241601271,
            "success_improvement": 0.0,
            "time_improvement": -133.40800560042,
            "length_improvement": 20.37069020439601,
            "objective_score": -35.948263639246804
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02317764759063721,
            "num_nodes_avg": 115.5,
            "path_length_avg": 129.43392433655305,
            "success_improvement": 0.0,
            "time_improvement": 19.21854446615108,
            "length_improvement": 20.51977322656999,
            "objective_score": 9.869517985159321
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved bidirectional RRT* planner accelerates planning by employing goal bias sampling, adaptive neighbor radius that shrinks with iteration count, and early tree connection attempts. It uses a KD-tree for faster nearest neighbor queries to minimize extension overhead. Path smoothing is enhanced by shortcutting with a limited randomized trial to yield smoother, shorter paths. These combined heuristics improve planning efficiency, path quality, robustness, and success rate while reducing search time.",
    "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling points with a bias toward the goal to expedite convergence. It uses adaptive neighbor radius shrinking with iterations to progressively favor exploitation over exploration and KD-tree acceleration for nearest and near neighbor queries. Upon extending a tree, it attempts to connect it to the other tree. Once connected, the combined path is shortcut-smoothed by randomly testing line-of-sight shortcuts, leading to high-quality navigation paths quickly.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]: coordinates in 2D/3D\n        self.parent = parent          # Parent Node or None\n        self.cost = cost              # Cost (distance) from root\n        self.children = []\n        self.valid = True             # For future use (collision status etc.)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, initial_neighbor_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.initial_neighbor_radius = initial_neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        from bisect import bisect_left\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # We use a simple spatial index for faster nearest and near queries (flattens positions)\n        class KDNode:\n            def __init__(self, node_list, depth=0):\n                self.axis = depth % dim\n                if not node_list:\n                    self.node = None\n                    self.left = None\n                    self.right = None\n                    return\n                node_list.sort(key=lambda n: n.position[self.axis])\n                median = len(node_list) // 2\n                self.node = node_list[median]\n                left_list = node_list[:median]\n                right_list = node_list[median+1:]\n                self.left = KDNode(left_list, depth + 1) if left_list else None\n                self.right = KDNode(right_list, depth + 1) if right_list else None\n\n            def nearest(self, point, best=None, best_dist=float('inf')):\n                if self.node is None:\n                    return best, best_dist\n                d = math.dist(point, self.node.position)\n                if d < best_dist:\n                    best = self.node\n                    best_dist = d\n\n                diff = point[self.axis] - self.node.position[self.axis]\n                close, away = (self.left, self.right) if diff <= 0 else (self.right, self.left)\n                if close:\n                    best, best_dist = close.nearest(point, best, best_dist)\n                if away and abs(diff) < best_dist:\n                    best, best_dist = away.nearest(point, best, best_dist)\n                return best, best_dist\n\n            def near(self, point, radius, found=None):\n                if found is None:\n                    found = []\n                if self.node is None:\n                    return found\n                d = math.dist(point, self.node.position)\n                if d <= radius:\n                    found.append(self.node)\n                diff = point[self.axis] - self.node.position[self.axis]\n                if self.left and diff - radius <= 0:\n                    self.left.near(point, radius, found)\n                if self.right and diff + radius >= 0:\n                    self.right.near(point, radius, found)\n                return found\n\n        def build_kdtree(tree):\n            return KDNode(tree) if tree else None\n\n        def nearest(kdtree, point):\n            if kdtree is None:\n                return None\n            node, _ = kdtree.nearest(point)\n            return node\n\n        def near(kdtree, point, radius):\n            if kdtree is None:\n                return []\n            return kdtree.near(point, radius)\n\n        def sample_free(goal_bias=0.1):\n            # Goal bias: with probability goal_bias return goal directly\n            if random.random() < goal_bias:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def add_node(tree, new_node):\n            tree.append(new_node)\n            nodes.append(new_node)\n\n        def try_extend(tree, other_tree_kdtree, other_tree, point, neighbor_radius):\n            nearest_node = nearest(build_kdtree(tree), point)\n            if nearest_node is None:\n                return None\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            near_nodes = near(build_kdtree(tree), new_pos, neighbor_radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_node.position)\n            best_parent = nearest_node\n            for node in near_nodes:\n                cost = node.cost + math.dist(node.position, new_node.position)\n                if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_node.position, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = node\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            add_node(tree, new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors with improved costs\n            for node in near_nodes:\n                if node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                    if node.parent:\n                        try:\n                            edges.remove((node.parent, node))\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass  # Edge might already be removed in rare conditions\n                    node.parent = new_node\n                    node.cost = cost_through_new\n                    new_node.add_child(node)\n                    edges.append((new_node, node))\n\n            return new_node\n\n        def try_connect(tree, from_node, neighbor_radius):\n            # Attempt to connect as directly as possible from from_node to any node in tree within step_size increments\n            current_node = from_node\n            while True:\n                nearest_node = nearest(build_kdtree(tree), current_node.position)\n                if nearest_node is None:\n                    return None\n                new_pos = steer(current_node.position, nearest_node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_node = Node(new_pos)\n                near_nodes = near(build_kdtree(tree), new_pos, neighbor_radius)\n\n                min_cost = current_node.cost + math.dist(current_node.position, new_node.position)\n                best_parent = current_node\n                for node in near_nodes:\n                    cost = node.cost + math.dist(node.position, new_node.position)\n                    if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_node.position, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = node\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                add_node(tree, new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for node in near_nodes:\n                    if node is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                    if cost_through_new < node.cost and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        if node.parent:\n                            try:\n                                edges.remove((node.parent, node))\n                                node.parent.children.remove(node)\n                            except ValueError:\n                                pass\n                        node.parent = new_node\n                        node.cost = cost_through_new\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n                if math.dist(new_node.position, nearest_node.position) <= self.step_size:\n                    return new_node\n                current_node = new_node\n\n        def connect_trees(node_a, tree_b_kdtree, tree_b):\n            # Try to connect newly added node_a to tree_b by stepping from node_a towards closest node in tree_b\n            closest_b, dist_b = tree_b_kdtree.nearest(node_a.position)\n            if closest_b is None:\n                return None\n            if self._is_edge_in_obstacle(node_a.position, closest_b.position, obstacles, is_3d):\n                return None\n\n            # Direct connection check\n            return closest_b\n\n        def smooth_path(path):\n            # Randomized shortcut smoothing: try limited trials to reduce path length and smooth further\n            if len(path) < 3:\n                return path\n            path = path[:]  # copy path\n            max_trials = 100\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                pi = path[i]\n                pj = path[j]\n                if not self._is_edge_in_obstacle(pi, pj, obstacles, is_3d):\n                    # Remove intermediate points\n                    path[i + 1:j] = []\n            return path\n\n        # Alternate growth: starting with tree_a from start and tree_b from goal\n        for iter_num in range(1, self.max_iter + 1):\n            # Adaptive neighbor radius shrinks with iterations to favor fast convergence and rewiring\n            neighbor_radius = max(self.step_size, self.initial_neighbor_radius * (1 - iter_num / self.max_iter))\n\n            sample = sample_free(goal_bias=0.15)\n\n            # Extend tree_a towards sample\n            new_node_a = try_extend(tree_a, build_kdtree(tree_b), tree_b, sample, neighbor_radius)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Attempt connecting tree_b to new_node_a directly\n            tree_b_kdtree = build_kdtree(tree_b)\n            connect_node = nearest(tree_b_kdtree, new_node_a.position)\n            if connect_node and math.dist(connect_node.position, new_node_a.position) <= neighbor_radius and \\\n               not self._is_edge_in_obstacle(connect_node.position, new_node_a.position, obstacles, is_3d):\n                # Connect trees: create dummy connecting node if needed (or reuse connect_node)\n                if connect_node.position != new_node_a.position:\n                    connecting_node = Node(new_node_a.position)\n                    connect_node.add_child(connecting_node)\n                    connecting_node.cost = connect_node.cost + math.dist(connect_node.position, connecting_node.position)\n                    tree_b.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((connect_node, connecting_node))\n                    # Now path is connected via new_node_a and connecting_node\n                    path_a = new_node_a.path_from_root()\n                    path_b = connecting_node.path_from_root()\n                else:\n                    path_a = new_node_a.path_from_root()\n                    path_b = connect_node.path_from_root()\n                # Merge paths from start to goal\n                success_state = True\n                extracted_path = path_a + path_b[::-1][1:]\n                extracted_path = smooth_path(extracted_path)\n                break\n\n            # Swap trees for next iteration\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 166.22555,
    "time_improvement": -568.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.031371688842773436,
            "num_nodes_avg": 98.2,
            "path_length_avg": 167.20375525249227,
            "success_improvement": 0.0,
            "time_improvement": -210.95482517085898,
            "length_improvement": 16.433170203162927,
            "objective_score": -59.99981351062511
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.1715749740600586,
            "num_nodes_avg": 292.8,
            "path_length_avg": 230.01129347580567,
            "success_improvement": 0.0,
            "time_improvement": -1099.4859614471086,
            "length_improvement": 23.674471196345674,
            "objective_score": -325.1108941948634
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.1420062303543091,
            "num_nodes_avg": 218.8,
            "path_length_avg": 122.82926244082725,
            "success_improvement": 0.0,
            "time_improvement": -394.93676776456454,
            "length_improvement": 24.57543350207221,
            "objective_score": -113.56594362895491
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm with adaptive informed sampling biased towards both the start and goal positions. It alternately extends the smaller of the two trees, employing a dynamically shrinking rewiring radius proportional to the logarithm of explored nodes to optimize local costs continuously. The sampling strategy leverages heuristic goal and start biasing for efficient exploration and exploitation balance. After each successful extension, it attempts to connect the opposite tree directly to form a complete path. Dead-end nodes are pruned periodically to maintain efficiency. Upon path discovery, a shortcut smoothing procedure is applied iteratively to minimize path length while ensuring collision-free transitions. Together, these improvements lead to faster planning times, higher success rates, more optimal and smoother paths, and elevated robustness in cluttered environments.",
    "planning_mechanism": "The planning mechanism grows two RRT* trees simultaneously from start and goal points, alternating growth on the smaller tree to keep balance. Samples are drawn with bias toward the start and goal to focus search in promising regions. New nodes are generated via steering, validated by collision checks on nodes and edges, and inserted using rewiring with a shrinking radius to refine path costs effectively. After extension, direct connection attempts between trees attempt path completion. Periodic pruning removes dead branches, reducing computation. Once connected, the extracted path undergoes shortcut smoothing to reduce unnecessary waypoints and path length, improving smoothness and efficiency.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=25.0,\n                 radius_min: float=5.0, prune_interval: int=250, prune_threshold: int=100,\n                 smoothing_iterations: int=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if self._squared_distance(node.position, pos) <= r_sq]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Check node validity and edge collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            # Choose best parent minimizing cost among neighbors\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring for lower cost paths locally\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-10 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            last_node = nearest(tree, node.position)\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                # Check for collision at node position and edge\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            for node in nodes[:]:\n                if (not node.children) and node is not start_root and node is not goal_root:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed_nodes.append(node)\n                    except Exception:\n                        continue\n            return removed_nodes\n\n        def path_length(path):\n            if len(path) < 2:\n                return 0.0\n            total = 0.0\n            for i in range(len(path) - 1):\n                total += distance(path[i], path[i + 1])\n            return total\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def informed_sample(c_best, c_min, x_center):\n            # Adaptive informed sampling within ellipse defined by start and goal\n            while True:\n                if is_3d:\n                    # sample in unit ball 3D\n                    from random import uniform\n                    import numpy as np\n                    import math\n\n                    # Create rotation matrix aligning ellipse axis\n                    a1 = [(goal_position[d] - start_position[d]) / c_min for d in range(len(start_position))]\n                    I = np.eye(3)\n                    M = np.outer(a1, I[:, 0])\n                    U, _, Vt = np.linalg.svd(M)\n                    C = np.dot(U, Vt)\n                    # sample random point in unit ball\n                    while True:\n                        x_ball = np.random.normal(0, 1, 3)\n                        norm = np.linalg.norm(x_ball)\n                        if 0 < norm <= 1:\n                            break\n                    x_ball = (x_ball / norm) * (random.random() ** (1.0/3.0))\n                    L = np.diag([c_best / 2.0, math.sqrt(c_best ** 2 - c_min ** 2) / 2.0, math.sqrt(c_best ** 2 - c_min ** 2) / 2.0])\n                    rnd = np.dot(np.dot(C, L), x_ball) + np.array(x_center)\n                    sample_pt = tuple(rnd)\n                else:\n                    import math\n                    # 2D ellipse sampling\n                    while True:\n                        r1 = random.random()\n                        r2 = random.random()\n                        theta = 2 * math.pi * r2\n                        radius = r1 ** 0.5\n                        x_ball = (radius * math.cos(theta), radius * math.sin(theta))\n\n                        a = c_best / 2.0\n                        b = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n                        rot = math.atan2(goal_position[1] - start_position[1], goal_position[0] - start_position[0])\n                        x = x_ball[0] * a\n                        y = x_ball[1] * b\n\n                        # Rotate and translate\n                        cos_r = math.cos(rot)\n                        sin_r = math.sin(rot)\n                        sample_x = cos_r * x - sin_r * y + x_center[0]\n                        sample_y = sin_r * x + cos_r * y + x_center[1]\n                        sample_pt = (sample_x, sample_y)\n\n                        if 0 <= sample_x <= bounds[0] and 0 <= sample_y <= bounds[1]:\n                            if not self._is_in_obstacle(sample_pt, obstacles, is_3d):\n                                return sample_pt\n                    continue\n\n                # Verify sample within bounds and not in obstacle\n                if all(0 <= sample_pt[d] <= bounds[d] for d in range(len(bounds))) and not self._is_in_obstacle(sample_pt, obstacles, is_3d):\n                    return sample_pt\n\n        def sample_adaptive(c_best):\n            c_min = distance(start_position, goal_position)\n            x_center = tuple((start_position[d] + goal_position[d]) / 2.0 for d in range(len(start_position)))\n            if c_best < float('inf'):\n                return informed_sample(c_best, c_min, x_center)\n            else:\n                return sample_free()\n\n        # Keep track of best path cost found so far\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        for itr in range(self.max_iter):\n            # Sample state with adaptive informed sampling if path found else biased random\n            sample_pt = sample_adaptive(best_cost)\n\n            # Alternate growth on smaller tree for balanced progress\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                candidate_cost = new_node_start.cost + new_node_goal.cost\n                if candidate_cost + 1e-10 < best_cost:\n                    best_cost = candidate_cost\n                    best_start_node = new_node_start\n                    best_goal_node = new_node_goal\n\n                # Immediately extract path if desired or keep searching for improvements (can break early or keep going)\n                # For better path quality, continue search but here break for efficiency and as per previous code\n                success_state = True\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n                smoothed_path = path_smoothing(raw_path)\n                if path_length(smoothed_path) + 1e-8 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    @staticmethod\n    def _squared_distance(p1, p2):\n        return sum((a - b) ** 2 for a, b in zip(p1, p2))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 22.94459,
    "time_improvement": -89.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.006510114669799805,
            "num_nodes_avg": 74.9,
            "path_length_avg": 163.0264082947292,
            "success_improvement": 0.0,
            "time_improvement": 35.47202450160224,
            "length_improvement": 18.520968062095992,
            "objective_score": 14.34580096289987
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.030130410194396974,
            "num_nodes_avg": 194.7,
            "path_length_avg": 252.37764071734563,
            "success_improvement": 0.0,
            "time_improvement": -110.64263153069815,
            "length_improvement": 16.252560494398942,
            "objective_score": -29.942277360329655
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.08396587371826172,
            "num_nodes_avg": 173.5,
            "path_length_avg": 125.7449422235135,
            "success_improvement": 0.0,
            "time_improvement": -192.64771015297225,
            "length_improvement": 22.78503047199763,
            "objective_score": -53.237306951492144
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the bidirectional rapid exploration and connection strategy of dual-tree RRT with the path optimality improvements from RRT*, including adaptive step sizing, dynamic neighbor radius rewiring, and goal-biased sampling. It grows two trees simultaneously from start and goal, tries to connect them with collision-checked edges, dynamically rewires to improve path costs, and applies path shortcut smoothing upon success, ensuring efficient exploration, higher success rates, and smooth, shorter paths.",
    "planning_mechanism": "The planner alternates expansion between two trees (start and goal), sampling points mostly free space but biased towards the goal. It uses adaptive step size for node extension and dynamically computes a radius for rewire neighborhood search. New nodes connect through the lowest-cost parents while ensuring no collisions. Trees attempt to connect once nodes are close enough. If connected, the algorithm extracts and smooths the path by shortcutting collision-free edges.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_and_propagate(self, new_cost):\n        self.cost = new_cost\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_cost_and_propagate(new_cost + dist)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, radius_constant: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Probability of sampling the goal\n        self.radius_constant = radius_constant      # Radius constant for rewiring\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n\n        nodes = tree_start + tree_goal\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        for _ in range(self.max_iter):\n            # Goal-biased sampling with randomness\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        break\n\n            # Alternate between trees\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                if not tree_a:\n                    continue\n                nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n                dist_to_sample = math.dist(nearest.position, sample)\n                if dist_to_sample == 0:\n                    continue\n\n                # Adaptive step size: don't overshoot sample\n                step = min(self.step_size, dist_to_sample)\n                new_pos = tuple(nearest.position[d] + (sample[d] - nearest.position[d]) * (step / dist_to_sample) for d in range(dim))\n\n                if not in_bounds(new_pos):\n                    continue\n                # Collision checks on new node and edge\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Dynamic neighbor radius (RRT*) for rewiring, scales with tree size and dimension\n                n_nodes = len(tree_a)+1\n                radius = min(self.radius_constant * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 6)\n\n                # Find neighbors within radius for better parenting\n                near_nodes = [node for node in tree_a if math.dist(node.position, new_pos) <= radius]\n\n                # Choose best parent by minimal cost + collision-free edge\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near_node in near_nodes:\n                    if near_node == nearest:\n                        continue\n                    cost_through_near = near_node.cost + math.dist(near_node.position, new_pos)\n                    if cost_through_near < min_cost:\n                        if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                            min_cost = cost_through_near\n                            best_parent = near_node\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                new_node.parent = best_parent\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors if better path available through new_node\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                    if new_cost < near_node.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                            # Remove old edge\n                            if near_node.parent and (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                            if near_node.parent and near_node in near_node.parent.children:\n                                near_node.parent.children.remove(near_node)\n                            # Reparent to new_node\n                            near_node.parent = new_node\n                            near_node.cost = new_cost\n                            new_node.add_child(near_node)\n                            edges.append((new_node, near_node))\n                            near_node.update_cost_and_propagate(new_cost)\n\n                # Try connecting trees if close and edge free\n                nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n                dist_between_trees = math.dist(nearest_other.position, new_node.position)\n                if dist_between_trees <= self.step_size:\n                    if not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                        # Build full path\n                        success_state = True\n                        if tree_a is tree_start:\n                            path_start = new_node.path_from_root()\n                            path_goal = nearest_other.path_from_root()\n                            path_goal.reverse()\n                            full_path = path_start + path_goal\n                        else:\n                            path_start = nearest_other.path_from_root()\n                            path_goal = new_node.path_from_root()\n                            path_goal.reverse()\n                            full_path = path_start + path_goal\n\n                        # Smooth path by shortcutting collision-free edges to reduce path length and improve smoothness\n                        extracted_path = self._smooth_path(full_path, obstacles, is_3d, bounds)\n\n                        return PlannerResult(True, extracted_path, nodes, edges)\n\n        # No path found\n        return PlannerResult(False, extracted_path, nodes, edges)\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds, max_iterations=200):\n        if len(path) < 3:\n            return path[:]\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def valid_edge(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        path = path[:]\n        for _ in range(max_iterations):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if valid_edge(path[i], path[j]):\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 26.48884,
    "time_improvement": -101.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02938246726989746,
            "num_nodes_avg": 158.5,
            "path_length_avg": 164.47276628880394,
            "success_improvement": 0.0,
            "time_improvement": -191.23774683568234,
            "length_improvement": 17.79809223832267,
            "objective_score": -53.81170560304017
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02877089977264404,
            "num_nodes_avg": 268.1,
            "path_length_avg": 242.5897014915241,
            "success_improvement": 0.0,
            "time_improvement": -101.13825203556932,
            "length_improvement": 19.500529870248055,
            "objective_score": -26.441369636621182
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03202950954437256,
            "num_nodes_avg": 347.8,
            "path_length_avg": 128.02929172435498,
            "success_improvement": 0.0,
            "time_improvement": -11.633002914192119,
            "length_improvement": 21.38230226695179,
            "objective_score": 0.7865595791327227
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is an enhanced bidirectional RRT* variant that merges adaptive rewiring, informed sampling inside an ellipsoidal subset, and dynamic neighborhood radius to accelerate convergence, improve path quality, and increase success rates. It integrates incremental connection attempts and extensive shortcut smoothing to yield shorter, smoother, and collision-free paths efficiently.",
    "planning_mechanism": "The planner grows two trees from start and goal simultaneously using informed samples biased towards promising regions. Each extension selects the best parent from a dynamically computed neighborhood for minimal path cost, followed by rewiring neighbors to optimize path costs. Incremental connection attempts are made between trees after each extension. Successful connection triggers path extraction and iterative shortcut smoothing, producing a high-quality feasible solution while respecting collision and boundary constraints.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 min_neighbor_radius: float = 4.0,\n                 max_neighbor_radius: float = 20.0,\n                 smoothing_iterations: int = 100,\n                 collision_check_resolution: float = 0.5,\n                 informed_sampling_rate: float = 0.7):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.informed_sampling_rate = informed_sampling_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_a, tree_b = [start_root], [goal_root]\n\n        success_state = False\n        extracted_path = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float(\"inf\")\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            # Clamp inside bounds\n            return tuple(max(0.0, min(new_pos[d], bounds[d])) for d in range(len(bounds)))\n\n        def is_collision_free_point(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_collision_free_edge(p1, p2):\n            return in_bounds(p1) and in_bounds(p2) and not self._is_edge_in_obstacle(\n                p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        def uniform_sample():\n            attempts = 0\n            while attempts < 40:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n                attempts += 1\n            # fallback sample even if in obstacle after attempts\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def informed_sample():\n            # Sample inside prolate hyperspheroid (ellipsoid) between start and goal\n            d = len(bounds)\n            if c_best == float(\"inf\"):\n                # No solution found yet - uniform sample\n                return uniform_sample()\n            c = c_best\n            c_min_ = c_min\n            x_center = tuple((start_position[d] + goal_position[d]) / 2.0 for d in range(d))\n            a1 = tuple((goal_position[i] - start_position[i]) / c_min_ for i in range(d))  # unit vector\n\n            # Sampling in unit ball\n            while True:\n                sample = [random.gauss(0, 1) for _ in range(d)]\n                norm = math.sqrt(sum(s ** 2 for s in sample))\n                unit_ball_sample = [s / norm for s in sample]\n\n                r = random.uniform(0,1) ** (1/d)\n                unit_ball_scale = [r * s for s in unit_ball_sample]\n\n                # Define scaling matrix L\n                L = [c / 2.0] + [math.sqrt(c * c - c_min_ * c_min_) / 2.0] * (d - 1)\n\n                # Transform sample\n                scaled = [L[0] * unit_ball_scale[0]] + [L[i] * unit_ball_scale[i] for i in range(1, d)]\n\n                # Rotation matrix that aligns x-axis with a1\n                R = self._rotation_matrix_to_align(a1)\n\n                sample_pos = [0.0] * d\n                for i in range(d):\n                    for j in range(d):\n                        sample_pos[i] += R[i][j] * scaled[j]\n                pos = tuple(sample_pos[i] + x_center[i] for i in range(d))\n\n                if is_collision_free_point(pos):\n                    return pos\n\n        def sample():\n            if c_best < float(\"inf\") and random.random() < self.informed_sampling_rate:\n                return informed_sample()\n            else:\n                return uniform_sample()\n\n        def neighbor_radius(iteration, n_nodes):\n            n_nodes = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + \\\n                      (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - position[d]) ** 2 for d in range(len(position))) <= r2]\n\n        def shortcut_smoothing(path: list):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if is_collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for iteration in range(self.max_iter):\n            rand_point = sample()\n            radius = neighbor_radius(iteration, len(nodes))\n\n            for extend_trees in [(tree_a, tree_b), (tree_b, tree_a)]:\n                tree_src, tree_tgt = extend_trees\n                nearest_node = nearest(tree_src, rand_point)\n                new_pos = steer(nearest_node.position, rand_point)\n\n                if not is_collision_free_point(new_pos) or not is_collision_free_edge(nearest_node.position, new_pos):\n                    continue\n\n                neighbors = near_nodes(tree_src, new_pos, radius)\n\n                # Find best parent minimizing cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for node in neighbors:\n                    cost_thru_node = node.cost + dist(node.position, new_pos)\n                    if cost_thru_node + 1e-12 < min_cost and is_collision_free_edge(node.position, new_pos):\n                        min_cost = cost_thru_node\n                        best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree_src.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors for better paths\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-12 < neighbor.cost and is_collision_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n                # Incremental connection attempt from target tree to new_node\n                connect_node = nearest(tree_tgt, new_node.position)\n                curr_pos = connect_node.position\n                connected = False\n\n                while True:\n                    next_pos = steer(curr_pos, new_node.position)\n                    if not is_collision_free_point(next_pos) or not is_collision_free_edge(curr_pos, next_pos):\n                        break\n\n                    neighbors_b = near_nodes(tree_tgt, next_pos, radius)\n\n                    min_cost_b = connect_node.cost + dist(curr_pos, next_pos)\n                    best_parent_b = connect_node\n                    for node_b in neighbors_b:\n                        cost_b = node_b.cost + dist(node_b.position, next_pos)\n                        if cost_b + 1e-12 < min_cost_b and is_collision_free_edge(node_b.position, next_pos):\n                            min_cost_b = cost_b\n                            best_parent_b = node_b\n\n                    new_node_b = Node(next_pos, parent=best_parent_b, cost=min_cost_b)\n                    best_parent_b.children.append(new_node_b)\n                    tree_tgt.append(new_node_b)\n                    nodes.append(new_node_b)\n                    edges.append((best_parent_b, new_node_b))\n\n                    # Rewire neighbors around new_node_b\n                    for neighbor_b in neighbors_b:\n                        if neighbor_b is best_parent_b:\n                            continue\n                        cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                        if cost_via_new_b + 1e-12 < neighbor_b.cost and is_collision_free_edge(new_node_b.position, neighbor_b.position):\n                            try:\n                                edges.remove((neighbor_b.parent, neighbor_b))\n                            except ValueError:\n                                pass\n                            neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                            edges.append((new_node_b, neighbor_b))\n\n                    # Check direct connection to new_node\n                    if dist(new_node_b.position, new_node.position) <= self.step_size and is_collision_free_edge(new_node_b.position, new_node.position):\n                        final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                        connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                        new_node_b.children.append(connection_node)\n                        tree_tgt.append(connection_node)\n                        nodes.append(connection_node)\n                        edges.append((new_node_b, connection_node))\n\n                        success_state = True\n                        c_best = min(c_best, final_cost + new_node.cost)\n\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n                        extracted_path = path_start + path_goal[::-1][1:]\n                        extracted_path = shortcut_smoothing(extracted_path)\n                        connected = True\n                        break\n\n                    curr_pos = new_node_b.position\n                    connect_node = new_node_b\n\n                if connected:\n                    break\n\n            if success_state:\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return self._finish_result(success_state, extracted_path, nodes, edges)\n\n    def _finish_result(self, success_state, extracted_path, nodes, edges):\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _rotation_matrix_to_align(self, a1):\n        \"\"\"\n        Compute the rotation matrix R that aligns the x-axis unit vector (1,0,...)\n        to the vector a1 (unit vector) in d-dimensional space.\n        This implementation supports 2D and 3D only; higher dims returns identity.\n        \"\"\"\n        d = len(a1)\n        if d == 2:\n            # 2D rotation matrix\n            angle = math.atan2(a1[1], a1[0])\n            cos_t = math.cos(angle)\n            sin_t = math.sin(angle)\n            return [[cos_t, -sin_t],\n                    [sin_t,  cos_t]]\n        elif d == 3:\n            v = (1.0, 0.0, 0.0)  # x-axis\n            b = a1\n            dot = sum(v[i]*b[i] for i in range(3))\n            if abs(dot - 1.0) < 1e-10:\n                # vectors are the same\n                return [[1,0,0],[0,1,0],[0,0,1]]\n            if abs(dot + 1.0) < 1e-10:\n                # vectors are opposite\n                return [[-1,0,0],[0,-1,0],[0,0,1]]\n            cross = (v[1]*b[2] - v[2]*b[1],\n                     v[2]*b[0] - v[0]*b[2],\n                     v[0]*b[1] - v[1]*b[0])\n            cross_norm = math.sqrt(sum(x*x for x in cross))\n            if cross_norm < 1e-10:\n                return [[1,0,0],[0,1,0],[0,0,1]]\n            k = tuple(x / cross_norm for x in cross)\n            K = [[0, -k[2], k[1]],\n                 [k[2], 0, -k[0]],\n                 [-k[1], k[0], 0]]\n            I = [[1,0,0],[0,1,0],[0,0,1]]\n\n            def mat_add(A,B):\n                return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n            def mat_scalar_mul(A, s):\n                return [[A[i][j] * s for j in range(3)] for i in range(3)]\n            def mat_mul(A,B):\n                return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n            K2 = mat_mul(K,K)\n            R = mat_add(mat_add(I, mat_scalar_mul(K, math.sin(math.acos(dot)))), mat_scalar_mul(K2, 1 - dot))\n            return R\n        else:\n            # For dimensions != 2 or 3, return identity matrix\n            return [[1 if i == j else 0 for j in range(d)] for i in range(d)]\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 19.6595,
    "time_improvement": -74.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.016077089309692382,
            "num_nodes_avg": 89.7,
            "path_length_avg": 161.0362629793951,
            "success_improvement": -9.999999999999998,
            "time_improvement": -59.35541502424637,
            "length_improvement": 19.515623562424647,
            "objective_score": -18.903499794788978
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04176735877990723,
            "num_nodes_avg": 287.1,
            "path_length_avg": 239.56231900136723,
            "success_improvement": 0.0,
            "time_improvement": -191.99689976748255,
            "length_improvement": 20.505117801390018,
            "objective_score": -53.49804636996676
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.020148921012878417,
            "num_nodes_avg": 182.6,
            "path_length_avg": 126.28510850985008,
            "success_improvement": 0.0,
            "time_improvement": 29.774617527864315,
            "length_improvement": 22.453335832022415,
            "objective_score": 13.423052424763778
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm with adaptive goal-biased sampling, dynamic neighborhood radius rewiring, frequent dead-end pruning, and improved shortcut smoothing for high-quality, efficient path planning in 2D/3D spaces. It balances tree growth by always extending the smaller tree and performs rigorous collision and edge obstacle checks to ensure robustness and path feasibility.",
    "planning_mechanism": "The planner grows two RRT* trees simultaneously from start and goal positions. On each iteration, it samples points with bias towards start or goal, extends the smaller tree towards the sample with collision-free checks, rewires neighbors within a dynamically computed radius to optimize path costs, and attempts connecting the opposite tree. Periodically, it prunes dead-end nodes to reduce computational load. Once connected, it extracts and smooths the path with iterative shortcutting to improve smoothness and reduce length, returning the best feasible path found within iteration limits.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List['Node'] = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 4000,\n                 step_size: float = 4.0,\n                 goal_sample_rate: float = 0.12,\n                 radius_constant: float = 18.0,\n                 radius_min: float = 4.0,\n                 prune_interval: int = 80,\n                 smoothing_iterations: int = 80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        import random\n        import math\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def sample_free() -> Tuple[float, ...]:\n            bias_prob = 0.85\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < bias_prob else start_position\n            else:\n                attempts = 0\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                    attempts += 1\n                    if attempts > 100:\n                        return goal_position\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d_] + ratio * (to_pos[d_] - from_pos[d_]) for d_ in range(len(from_pos)))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            radsq = radius * radius\n            return [node for node in tree if sum((node.position[d_] - pos[d_])**2 for d_ in range(len(pos))) <= radsq]\n\n        def radius_dynamic(n: int) -> float:\n            if n == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(val, self.radius_min)\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree: List[Node], sample_pt: Tuple[float, ...]) -> Node:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                if not can_connect(node.position, new_pos):\n                    continue\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                if not can_connect(new_node.position, neighbor.position):\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node) -> Node:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node in (start_root, goal_root):\n                    continue\n                if not node.children and node.parent is not None:\n                    try:\n                        node.parent.children.remove(node)\n                    except Exception:\n                        pass\n                    try:\n                        nodes.remove(node)\n                    except Exception:\n                        pass\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    removed.append(node)\n            return removed\n\n        def path_length(path: List[Tuple[float, ...]]) -> float:\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            max_iter = self.smoothing_iterations\n            count = 0\n            while count < max_iter and len(path) >= 3:\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n                    count = 0\n                    continue\n                count += 1\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend smaller tree for balanced exploration\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed_path = shortcut_smoothing(raw_path)\n                if path_length(smoothed_path) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > 150:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 51.14103,
    "time_improvement": -179.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.02684323787689209,
            "num_nodes_avg": 83.8,
            "path_length_avg": 159.14907342188536,
            "success_improvement": -9.999999999999998,
            "time_improvement": -166.06901473688194,
            "length_improvement": 20.458822764551623,
            "objective_score": -50.72893986815426
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.059581875801086426,
            "num_nodes_avg": 190.4,
            "path_length_avg": 243.65621708904914,
            "success_improvement": 0.0,
            "time_improvement": -316.5387404055304,
            "length_improvement": 19.146623913160752,
            "objective_score": -91.13229733902696
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04453613758087158,
            "num_nodes_avg": 173.9,
            "path_length_avg": 122.09788723283347,
            "success_improvement": 0.0,
            "time_improvement": -55.2225696576676,
            "length_improvement": 25.024541938564187,
            "objective_score": -11.561862509587442
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a streamlined bidirectional RRT* with adaptive informed sampling and efficient rewiring in both 2D and 3D. It incorporates essential collision and bounds checks, incremental tree growth from start and goal, periodic pruning, and shortcut path smoothing to balance exploration, path quality, and computational efficiency. The approach uses dynamic neighbor radius based on iteration and node count to optimize rewiring and refines paths progressively while maintaining robustness against obstacles and reducing search time.",
    "planning_mechanism": "The planning mechanism simultaneously grows two RRT* trees from start and goal, alternating expansions focused on samples drawn adaptively within an informed ellipsoid when a path is found to guide search in promising areas. Each extension uses steering with collision and bounds checks. Nearby nodes within a dynamic radius are rewired to minimize path cost while pruning removes non-promising nodes to maintain manageable complexity. Upon connection of the two trees, the path is extracted and shortcut-smoothed to enhance smoothness and shorten length, delivering an efficient and robust solution.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = 5.0\n        self.max_radius = 30.0\n        self.prune_interval = 200\n        self.prune_threshold = 300\n        self.smoothing_iterations = 50\n        self.collision_resolution = 1.0\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        import math\n        import random\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            n = max(n_nodes, 1)\n            r_iter = self.max_radius * (1 - (iteration / self.max_iter) ** 0.9)\n            r_log = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.min_radius, min(r_iter, r_log))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance_edge = dist(p1, p2)\n            steps = max(1, int(distance_edge / self.collision_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        # Ellipsoidal informed sampling to bias towards promising areas\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            I = np.eye(dim)\n            u = direction - I[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = I - 2 * np.outer(u, u)\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback\n\n        # KD-tree substitute: linear search for neighbors and nearest node (simplify for clarity)\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            result = [node for node in tree if sum((a - b) ** 2 for a, b in zip(node.position, point)) <= r2]\n            return result\n\n        # Prune nodes that cannot improve the best path\n        def prune_nodes(nodes, tree_start, tree_goal, best_cost):\n            to_remove = []\n            for node in nodes:\n                if node is root_start or node is root_goal:\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n\n        # Shortcut smoothing to improve path quality\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate expanding smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            nearest_a = nearest_node(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if (not in_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            neighbors = near_nodes(tree_a, new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in neighbors:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improvements\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt incremental connection from other tree\n            nearest_b = nearest_node(tree_b, new_node.position)\n            last_b = nearest_b\n            max_connect_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            connected = False\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if (not in_bounds(next_pos_b)) or is_in_obstacle(next_pos_b) or is_edge_in_obstacle(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                # Rewire neighbors around new_node_b\n                neighbors_b = near_nodes(tree_b, next_pos_b, r)\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is last_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and not is_edge_in_obstacle(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and not is_edge_in_obstacle(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Extract and merge path\n                    if tree_a is tree_start:\n                        path_from_start = connection_node.path_from_root()\n                        path_from_goal = new_node.path_from_root()\n                    else:\n                        path_from_start = new_node.path_from_root()\n                        path_from_goal = connection_node.path_from_root()\n\n                    merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic pruning to remove nodes that cannot improve path\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )",
    "objective": -1.08481,
    "time_improvement": -10.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.00862126350402832,
            "num_nodes_avg": 59.7,
            "path_length_avg": 160.531158757098,
            "success_improvement": 0.0,
            "time_improvement": 14.546408416754108,
            "length_improvement": 19.768069797921118,
            "objective_score": 8.317536484610455
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.026832151412963866,
            "num_nodes_avg": 241.5,
            "path_length_avg": 244.1143260176625,
            "success_improvement": 0.0,
            "time_improvement": -87.58440216349558,
            "length_improvement": 18.994607872132015,
            "objective_score": -22.47639907462227
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.016585564613342284,
            "num_nodes_avg": 163.0,
            "path_length_avg": 124.13203186042806,
            "success_improvement": 0.0,
            "time_improvement": 42.19404514297159,
            "length_improvement": 23.775454598287087,
            "objective_score": 17.413304462548894
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner combines the strengths of adaptive bidirectional RRT* frameworks with dynamic informed sampling and adaptive rewiring radius, alternating expansion of the smaller tree for balanced exploration. It incorporates lazy collision checking, incremental rewiring for path cost optimization, pruning of dead ends to reduce computational overhead, and iterative path shortcut smoothing with early stopping. The adaptive sampling biases towards both start and goal improve convergence speed, while dynamic neighbor radius enables local refinements. Moreover, enhanced connection attempts and pruning strategies increase success rate and reduce planning time, resulting in shorter, smoother, and computationally efficient paths.",
    "planning_mechanism": "The planner grows two trees from start and goal positions alternately, always expanding the smaller tree to balance exploration. Sampling is informed and adaptively biased towards start and goal to focus the search. Each extension steers nodes towards sampled points within step limits, checking node validity and edge collision. After adding nodes, dynamic neighbor radius rewiring optimizes path costs locally while avoiding collisions. Periodic pruning removes dead ends from the trees to maintain efficiency. When trees connect, the path is extracted and iteratively shortcut-smoothed with early stopping to minimize path length and enhance smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2, radius_constant: float = 30.0,\n                 radius_min: float = 5.0, prune_interval: int = 150,\n                 prune_threshold: int = 150, smoothing_iterations: int = 60):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def adaptive_informed_sample(tree_start, tree_goal, iteration):\n            bias = min(self.goal_sample_rate + 0.3 * (iteration / self.max_iter), 0.45)\n            p_goal = goal_position\n            p_start = start_position\n            if random.random() < bias:\n                # Alternate bias between goal and start based on iteration parity to cover both directions\n                return p_goal if iteration % 2 == 0 else p_start\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / distance\n                new_p = tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * ratio for d in range(len(from_pos)))\n            if in_bounds(new_p):\n                return new_p\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(len(bounds)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            # Linear search for simplicity, can be optimized with spatial indexing if needed\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def dynamic_radius(n):\n            if n == 0:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(r, self.radius_min)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = dynamic_radius(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Incremental rewiring for neighbors\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_ends():\n            removed_nodes = []\n            for node in nodes[:]:\n                if node in (start_root, goal_root):\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed_nodes.append(node)\n                    except Exception:\n                        continue\n            return removed_nodes\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smooth(path):\n            if len(path) < 3:\n                return path\n            path = path[:]\n            improved = True\n            trials = 0\n            max_trials = self.smoothing_iterations * 10\n            while improved and trials < max_trials and len(path) >= 3:\n                improved = False\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n                    improved = True\n                trials += 1\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = adaptive_informed_sample(tree_start, tree_goal, itr)\n\n            # Alternate expanding the smaller tree for balanced search\n            if len(tree_start) > len(tree_goal):\n                tree_small, tree_large = tree_goal, tree_start\n            else:\n                tree_small, tree_large = tree_start, tree_goal\n\n            new_node_small = try_extend(tree_small, sample_pt)\n            if new_node_small is None:\n                # Failed to extend smaller tree, swap and continue next iteration\n                continue\n\n            new_node_large = try_connect(tree_large, new_node_small)\n            if new_node_large is not None:\n                success_state = True\n                path_start = new_node_small.path_from_root()\n                path_goal = new_node_large.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed_path = shortcut_smooth(raw_path)\n                if path_length(smoothed_path) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            # Periodic pruning to remove dead ends and enhance efficiency\n            if (itr + 1) % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_ends()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.75):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 43.37529,
    "time_improvement": -140.0,
    "length_improvement": 10.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.013194608688354491,
            "num_nodes_avg": 120.3,
            "path_length_avg": 172.7323748586638,
            "success_improvement": -9.999999999999998,
            "time_improvement": -30.78439157190256,
            "length_improvement": 13.67001926230805,
            "objective_score": -11.501313619109157
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.028463339805603026,
            "num_nodes_avg": 240.8,
            "path_length_avg": 284.6989934614709,
            "success_improvement": -9.999999999999998,
            "time_improvement": -98.98809077347467,
            "length_improvement": 5.527242173869194,
            "objective_score": -33.590978797268555
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.11222856044769287,
            "num_nodes_avg": 222.4,
            "path_length_avg": 144.0243208517412,
            "success_improvement": 0.0,
            "time_improvement": -291.15214043963,
            "length_improvement": 11.560390825970662,
            "objective_score": -85.03356396669486
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved planner implements an advanced bidirectional RRT* with enhanced informed sampling, adaptive neighbor radius rewiring, and lazy collision checking with caching. It further optimizes performance by early rejection of unpromising samples via quick bounding checks, an adaptive sampling fallback mechanism to avoid stagnation, caching of nearest neighbor searches, and efficient incremental path smoothing through shortcutting and cost-aware pruning. The planner maintains robust exploration-exploitation balance by switching between wide uniform sampling and heuristic-informed ellipsoidal sampling after an initial path is found. These improvements reduce search time, increase success rates, and yield higher quality, smoother, and shorter paths.",
    "planning_mechanism": "The planning mechanism simultaneously grows two trees from start and goal, alternating expansions each iteration. It samples points either uniformly or inside the heuristic-informed ellipsoid once a path is found, clamps samples to workspace bounds, and rejects collisions early. Nodes are connected only after thorough collision and edge checks with caching. The connection attempts between trees utilize incremental steering with lazy checks and adaptive rewiring based on dynamically computed neighbor radius. Upon connecting the two trees, the solution path is extracted and refined by iterative shortcutting with collision checks, improving path smoothness and length efficiently before returning the result.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self._edge_collision_cache = dict()\n        self._node_in_collision_cache = dict()\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n            # Clamp to bounds to avoid floating point slips\n            clamped = tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n            return clamped\n\n        def _is_in_obstacle_cached(pos):\n            key = tuple(round(c, 4) for c in pos)\n            cached = self._node_in_collision_cache.get(key)\n            if cached is not None:\n                return cached\n            val = self._is_in_obstacle(pos, obstacles, is_3d)\n            self._node_in_collision_cache[key] = val\n            return val\n\n        def sample_uniform_free():\n            attempt = 0\n            while attempt < 100:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not _is_in_obstacle_cached(p):\n                    return p\n                attempt += 1\n            # Fallback to informed sampling if uniform fails repeatedly\n            return sample_informed()\n\n        def sample_informed():\n            # Early fallback to uniform if no path found yet (avoid infinite loop)\n            if not path_found:\n                return sample_uniform_free()\n\n            c_current = c_max if c_max >= c_min else c_min\n            center_ = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n\n            if is_3d:\n                import numpy as np\n                c = c_current\n                center_np = np.array(center_)\n                start_np = np.array(start)\n                goal_np = np.array(goal)\n                diff = goal_np - start_np\n                length = np.linalg.norm(diff)\n                if length == 0:\n                    return start\n                a1 = diff / length\n\n                # Orthonormal basis via Gram-Schmidt\n                def orthonormal_basis(a1):\n                    bases = []\n                    temp = np.eye(3)\n                    for i in range(3):\n                        v = temp[:, i]\n                        if abs(np.dot(a1, v)) < 1 - 1e-3:\n                            e = v - np.dot(v, a1) * a1\n                            e /= np.linalg.norm(e)\n                            bases.append(e)\n                    if len(bases) < 2:\n                        bases = [np.array([0., 1., 0.]), np.array([0., 0., 1.])]\n                    return bases[:2]\n\n                e2, e3 = orthonormal_basis(a1)\n                C = np.column_stack((a1, e2, e3))\n                r1 = c / 2\n                r2 = math.sqrt(max(c ** 2 - c_min ** 2, 0)) / 2\n                r3 = r2\n\n                for _ in range(100):\n                    u = np.random.normal(0, 1, 3)\n                    norm_u = np.linalg.norm(u)\n                    if norm_u == 0:\n                        continue\n                    u /= norm_u\n                    radius = random.random() ** (1/3)\n                    u *= radius\n                    sample = center_np + C @ np.array([r1 * u[0], r2 * u[1], r3 * u[2]])\n                    sample_clamped = np.clip(sample, np.zeros(3), np.array(bounds))\n                    pt = tuple(sample_clamped)\n                    if not _is_in_obstacle_cached(pt):\n                        return pt\n                # fallback if no valid sample found\n                return sample_uniform_free()\n            else:\n                c = c_current\n                c1, c2 = center_\n                r1 = c / 2.0\n                r2 = math.sqrt(max(c ** 2 - c_min ** 2, 0)) / 2.0\n                dx = goal[0] - start[0]\n                dy = goal[1] - start[1]\n                length = math.hypot(dx, dy)\n                if length == 0:\n                    return start\n                cos_angle = dx / length\n                sin_angle = dy / length\n\n                for _ in range(100):\n                    theta = random.uniform(0, 2 * math.pi)\n                    rho = math.sqrt(random.uniform(0, 1))\n                    x_ball = rho * math.cos(theta)\n                    y_ball = rho * math.sin(theta)\n                    x_ell = r1 * x_ball\n                    y_ell = r2 * y_ball\n                    x_rot = cos_angle * x_ell - sin_angle * y_ell\n                    y_rot = sin_angle * x_ell + cos_angle * y_ell\n                    sample = (c1 + x_rot, c2 + y_rot)\n                    if in_bounds(sample) and not _is_in_obstacle_cached(sample):\n                        return sample\n                return sample_uniform_free()\n\n        def edge_cache_key(p1, p2):\n            return tuple(sorted([(round(c, 4)) for c in p1] + [(round(c,4)) for c in p2]))\n\n        def is_edge_collision_cached(p1, p2):\n            key = edge_cache_key(p1, p2)\n            return self._edge_collision_cache.get(key, None)\n\n        def cache_edge_collision(p1, p2, val):\n            key = edge_cache_key(p1, p2)\n            self._edge_collision_cache[key] = val\n\n        def node_nearest(tree, point, last_nearest=None):\n            # Cache nearest node if repeated for same point to reduce cost if desired\n            # Here linear search since no special structure; could use KD-tree\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                dist_ = distance(node.position, point)\n                if dist_ < best_dist:\n                    best = node\n                    best_dist = dist_\n            return best\n\n        def nodes_near(tree, pos, rad):\n            rad_sq = rad * rad\n            return [node for node in tree if (distance(node.position, pos) **2) <= rad_sq]\n\n        def neighbor_radius(nnodes):\n            if nnodes < 2:\n                return float('inf')\n            gamma_rrt_star = 30.0\n            unit_ball_volume = math.pi if dim == 2 else 4.0/3.0 * math.pi\n            val = gamma_rrt_star * ((math.log(nnodes) / nnodes) ** (1/dim))\n            return max(val, self.step_size)\n\n        def lazy_edge_collision_check(n1_pos, n2_pos):\n            cached = is_edge_collision_cached(n1_pos, n2_pos)\n            if cached is not None:\n                return cached\n            col = self._is_edge_in_obstacle(n1_pos, n2_pos, obstacles, is_3d, resolution=0.25)\n            cache_edge_collision(n1_pos, n2_pos, col)\n            return col\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        connection_start = None\n        connection_goal = None\n\n        best_cost = float('inf')\n        c_min = distance(start, goal)\n        c_max = float('inf')\n        path_found = False\n        informed_center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n\n        for it in range(self.max_iter):\n            # Sampling\n            if path_found:\n                q_rand = sample_informed()\n            else:\n                q_rand = sample_uniform_free()\n\n            # Alternate tree expansion\n            if it % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            nearest_node = node_nearest(tree_a, q_rand)\n            new_pos = steer(nearest_node.position, q_rand)\n\n            if _is_in_obstacle_cached(new_pos):\n                continue\n\n            # Edge collision check lazy\n            if lazy_edge_collision_check(nearest_node.position, new_pos):\n                continue\n\n            # Add new node\n            new_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Local rewiring in tree_a\n            radius = neighbor_radius(len(tree_a))\n            near = nodes_near(tree_a, new_pos, radius)\n\n            for node in near:\n                if node is nearest_node:\n                    continue\n                cost_path = new_node.cost + distance(new_node.position, node.position)\n                if cost_path + 1e-8 < node.cost:\n                    if not lazy_edge_collision_check(new_node.position, node.position):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_path)\n                        edges.append((new_node, node))\n\n            # Try connecting tree_b to new_node incrementally\n            connect_node_b = node_nearest(tree_b, new_node.position)\n            prev_node_b = connect_node_b\n            connected = False\n\n            while True:\n                next_pos_b = steer(prev_node_b.position, new_node.position)\n                if _is_in_obstacle_cached(next_pos_b):\n                    break\n\n                if lazy_edge_collision_check(prev_node_b.position, next_pos_b):\n                    break\n\n                cost_b = prev_node_b.cost + distance(prev_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=prev_node_b, cost=cost_b)\n                prev_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((prev_node_b, new_node_b))\n\n                # Local rewiring in tree_b\n                r_b = neighbor_radius(len(tree_b))\n                near_b = nodes_near(tree_b, next_pos_b, r_b)\n                for nb_node in near_b:\n                    if nb_node is prev_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + distance(new_node_b.position, nb_node.position)\n                    if cost_via_new_b + 1e-8 < nb_node.cost:\n                        if not lazy_edge_collision_check(new_node_b.position, nb_node.position):\n                            try:\n                                edges.remove((nb_node.parent, nb_node))\n                            except ValueError:\n                                pass\n                            nb_node.update_parent(new_node_b, cost_via_new_b)\n                            edges.append((new_node_b, nb_node))\n\n                dist_to_new_node = distance(new_node_b.position, new_node.position)\n                if dist_to_new_node <= self.step_size:\n                    # Final connection edge check\n                    if not lazy_edge_collision_check(new_node_b.position, new_node.position):\n                        final_cost = new_node_b.cost + dist_to_new_node\n                        connect_node_goal = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                        new_node_b.children.append(connect_node_goal)\n                        tree_b.append(connect_node_goal)\n                        nodes.append(connect_node_goal)\n                        edges.append((new_node_b, connect_node_goal))\n\n                        if tree_a is tree_start:\n                            connection_start = new_node\n                            connection_goal = connect_node_goal\n                        else:\n                            connection_start = connect_node_goal\n                            connection_goal = new_node\n\n                        connected = True\n                    break\n                prev_node_b = new_node_b\n\n            if connected:\n                path_start = connection_start.path_from_root()\n                path_goal = connection_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n\n                # Update current best path info\n                best_cost = 0.0\n                for i in range(len(merged_path) - 1):\n                    best_cost += distance(merged_path[i], merged_path[i + 1])\n                c_max = best_cost + 1e-6\n                informed_center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n                path_found = True\n\n                # Path smoothing by iterative shortcutting with early pruning\n                def smooth_path(path, max_trials=150):\n                    if len(path) < 3:\n                        return path\n                    smoothed = path[:]\n                    for _ in range(max_trials):\n                        if len(smoothed) < 3:\n                            break\n                        i = random.randint(0, len(smoothed) - 3)\n                        j = random.randint(i + 2, len(smoothed) - 1)\n                        if not lazy_edge_collision_check(smoothed[i], smoothed[j]):\n                            smoothed = smoothed[:i + 1] + smoothed[j:]\n                    return smoothed\n\n                merged_path = smooth_path(merged_path)\n\n                return PlannerResult(\n                    success=True,\n                    path=merged_path,\n                    nodes=nodes,\n                    edges=edges,\n                )\n\n        # Failed to find path\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.25):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 22.94595,
    "time_improvement": -90.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.022675609588623045,
            "num_nodes_avg": 85.6,
            "path_length_avg": 166.64793293133317,
            "success_improvement": 0.0,
            "time_improvement": -124.75966310296911,
            "length_improvement": 16.710964856993783,
            "objective_score": -34.085705959491975
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02847111225128174,
            "num_nodes_avg": 225.9,
            "path_length_avg": 242.95981943119415,
            "success_improvement": 0.0,
            "time_improvement": -99.04242818211367,
            "length_improvement": 19.377712216218352,
            "objective_score": -25.83718601139043
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04152281284332275,
            "num_nodes_avg": 292.0,
            "path_length_avg": 126.20025917463163,
            "success_improvement": 0.0,
            "time_improvement": -44.72017689569982,
            "length_improvement": 22.50543843525649,
            "objective_score": -8.914965381658646
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved planner implements an enhanced bidirectional RRT* algorithm integrating goal bias sampling, adaptive local sampling around tree midpoints, and a dynamically shrinking rewiring radius. It introduces heuristic-informed rewiring prioritization and adaptive step sizing to accelerate convergence and reduce path cost. It maintains strict collision and edge validity checks and applies iterative post-search shortcutting and smoothing to produce shorter, smoother paths. The balanced two-tree growth enhances search space coverage and success rate, while incremental rewiring and shortcutting optimize the path quality and planning efficiency.",
    "planning_mechanism": "The planner alternately grows two trees from start and goal with goal-biased and locally adaptive sampling. It extends the smaller tree first to maintain balanced growth, steering nodes toward samples with step sizes adapted to the cost improvement potential. New nodes are added only if collision-free and edges are verified collision-free. After each addition, neighbors within a shrinking dynamic radius are rewired for local path cost improvements prioritizing lowest cost gains. Upon connection of the two trees, the combined path is merged and subjected to multiple rounds of shortcutting and smoothing to minimize length and enhance smoothness, resulting in improved overall path planning performance and robustness.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag (collision etc.)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        curr = self\n        while curr:\n            path.append(curr.position)\n            curr = curr.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 radius_const: float=30.0, radius_min: float=3.0,\n                 shortcut_iterations: int=10):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.shortcut_iterations = shortcut_iterations\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: environment bounds\n        start_position = map.start         # start coordinates\n        goal_position = map.goal           # goal coordinates\n        obstacles = map.obstacles          # obstacle list\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def is_in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def edge_in_obstacle(p1, p2, resolution=0.5):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=resolution)\n\n        def sample_free(iteration):\n            r = random.random()\n            # Goal bias first\n            if r < self.goal_sample_rate:\n                sub_r = random.random()\n                if sub_r < 0.7 and not in_obstacle(goal_position):\n                    return goal_position\n                elif sub_r < 0.85 and not in_obstacle(start_position):\n                    return start_position\n                else:\n                    # Local biased sampling around mid-tree points\n                    if len(tree_start) > 10 and len(tree_goal) > 10:\n                        mid_start_pos = random.choice(tree_start).position\n                        mid_goal_pos = random.choice(tree_goal).position\n                        midpoint = tuple((mid_start_pos[d] + mid_goal_pos[d]) * 0.5 for d in range(dim))\n                        spread = self.step_size * 4 * max(0.1, 1 - iteration / self.max_iter)\n                        for _ in range(10):\n                            candidate = tuple(\n                                max(0, min(bounds[d], midpoint[d] + random.uniform(-spread, spread)))\n                                for d in range(dim)\n                            )\n                            if not in_obstacle(candidate):\n                                return candidate\n            # Uniform random fallback sampling\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return start_position\n\n        def steer(from_pos, to_pos, max_step=None):\n            dist = math.dist(from_pos, to_pos)\n            step = max_step if max_step is not None else self.step_size\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (sum((node.position[d]-pos[d])**2 for d in range(dim)) <= r_sq)]\n\n        def dynamic_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.radius_const\n            base = self.radius_const * math.sqrt(math.log(n_nodes) / n_nodes)\n            decay = max(self.radius_min / base, math.exp(-6 * iteration / self.max_iter))\n            return max(self.radius_min, base * decay)\n\n        def try_extend(tree, point, iteration):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, point)\n            dist_to_point = math.dist(nearest_node.position, point)\n            # Adaptive step size: reduce step towards goal to improve precision near obstacles/goals\n            max_step = min(self.step_size, dist_to_point)\n            new_pos = steer(nearest_node.position, point, max_step)\n\n            if (not is_in_bounds(new_pos)) or in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            r = dynamic_radius(len(tree), iteration)\n            neighbors = near_nodes(tree, new_pos, r)\n\n            # Choose best parent with lowest cost + collision free edge\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                tentative_cost = node.cost + math.dist(node.position, new_pos)\n                if tentative_cost + 1e-8 < min_cost and not edge_in_obstacle(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cost improved\n            neighbors_sorted = sorted(neighbors, key=lambda n: n.cost)\n            for neighbor in neighbors_sorted:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-8 < neighbor.cost and not edge_in_obstacle(new_node.position, neighbor.position):\n                    # Update parent and edges\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, target_node, iteration):\n            if not tree:\n                return None\n\n            last = nearest(tree, target_node.position)\n            while True:\n                dist_to_target = math.dist(last.position, target_node.position)\n                max_step = min(self.step_size, dist_to_target)\n                new_pos = steer(last.position, target_node.position, max_step)\n\n                if (not is_in_bounds(new_pos)) or in_obstacle(new_pos) or edge_in_obstacle(last.position, new_pos):\n                    return None\n\n                r = dynamic_radius(len(tree), iteration)\n                neighbors = near_nodes(tree, new_pos, r)\n\n                min_cost = last.cost + math.dist(last.position, new_pos)\n                best_parent = last\n                for node in neighbors:\n                    tentative_cost = node.cost + math.dist(node.position, new_pos)\n                    if tentative_cost + 1e-8 < min_cost and not edge_in_obstacle(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors for improvements\n                neighbors_sorted = sorted(neighbors, key=lambda n: n.cost)\n                for neighbor in neighbors_sorted:\n                    if neighbor is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if cost_through_new + 1e-8 < neighbor.cost and not edge_in_obstacle(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n                # If within step_size of target_node and path collision free, connect final node\n                if dist_to_target <= self.step_size:\n                    if not edge_in_obstacle(new_pos, target_node.position):\n                        final_cost = new_node.cost + math.dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last = new_node\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i:\n                    if not edge_in_obstacle(path[i], path[j]):\n                        shortened.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    i += 1\n                    if i < len(path):\n                        shortened.append(path[i])\n            return shortened\n\n        def smooth_path(path, smoothing_iters=5):\n            # Simple Chaikin's algorithm adapted for smoothing\n            if len(path) < 3:\n                return path\n            for _ in range(smoothing_iters):\n                new_path = [path[0]]\n                for i in range(len(path) - 1):\n                    p1 = path[i]\n                    p2 = path[i+1]\n                    q = tuple(0.75 * p1[d] + 0.25 * p2[d] for d in range(dim))\n                    r = tuple(0.25 * p1[d] + 0.75 * p2[d] for d in range(dim))\n                    # Check edge collision before adding intermediate points\n                    if not edge_in_obstacle(new_path[-1], q):\n                        new_path.append(q)\n                    else:\n                        new_path.append(p1)\n                    if not edge_in_obstacle(new_path[-1], r):\n                        new_path.append(r)\n                    else:\n                        new_path.append(p2)\n                new_path.append(path[-1])\n                path = new_path\n            return path\n\n        # Initialize trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success = False\n        final_path: List[Tuple[float, ...]] = []\n\n        for itr in range(self.max_iter):\n            # Balanced growth: extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            rand_point = sample_free(itr)\n            new_node_start = try_extend(tree_start, rand_point, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start, itr)\n            if new_node_goal:\n                # Connected trees -> construct combined path\n                success = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                mid_path = path_start + path_goal[::-1][1:]\n                # Repeated shortcutting for better path quality\n                for _ in range(self.shortcut_iterations):\n                    mid_path = shortcut_path(mid_path)\n                # Smooth resulting path further\n                smoothed_path = smooth_path(mid_path, smoothing_iters=3)\n                final_path = smoothed_path\n                break\n\n        return PlannerResult(success=success, path=final_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 73.90647,
    "time_improvement": -257.0,
    "length_improvement": 24.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.05910654067993164,
            "num_nodes_avg": 105.7,
            "path_length_avg": 163.61066829427972,
            "success_improvement": -9.999999999999998,
            "time_improvement": -485.8614789817467,
            "length_improvement": 18.22896052993376,
            "objective_score": -147.11265158853726
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0413144588470459,
            "num_nodes_avg": 269.8,
            "path_length_avg": 225.75802475980748,
            "success_improvement": 0.0,
            "time_improvement": -188.83066229967247,
            "length_improvement": 25.085849650798604,
            "objective_score": -51.63202875974201
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05611839294433594,
            "num_nodes_avg": 286.4,
            "path_length_avg": 116.4187041742457,
            "success_improvement": 0.0,
            "time_improvement": -95.59040435558296,
            "length_improvement": 28.511902456280513,
            "objective_score": -22.974740815418784
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm is an enhanced bidirectional PRM*-inspired planner that dynamically samples nodes with adaptive density around the current best path corridor and obstacles. It constructs two probabilistic roadmaps simultaneously from start and goal, using KD-tree accelerated nearest neighbor queries for fast connection attempts. The planner incrementally rewires to improve path cost and applies efficient lazy collision checking to minimize expensive collision tests. Once a connection between the two graphs is found, the resulting path is shortcut-smoothed for quality and smoothness. The adaptive sampling and rewiring ensure faster convergence, shorter paths, and higher success rates in both 2D and 3D environments.",
    "planning_mechanism": "The planner initializes two PRM* graphs from start and goal positions. At each iteration, it samples new nodes biased towards a corridor around the best-known path (or uniform if none yet), avoiding obstacles and out-of-bound positions. Using KD-tree queries, new nodes connect to neighbors within a radius proportional to log of nodes count, rewiring to improve cost while checking collisions lazily. The two graphs try to connect via newly added nodes, and upon success, path extraction and shortcut smoothing finalize the path. Periodic pruning discards nodes unlikely to contribute to better solutions, improving planning efficiency and robustness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]: 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from the root of its roadmap\n        self.children = []\n        self.valid = True               # For collision checks / pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float = 8.0,\n                 max_neighbor_radius: float = 35.0,\n                 prune_interval: int = 250,\n                 prune_threshold: int = 400,\n                 smoothing_iterations: int = 120,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            factor = math.log(n_nodes) / n_nodes\n            r = self.max_neighbor_radius * math.sqrt(factor)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree helper for nearest and radius search\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Adaptive sampling biased towards corridor around last best path or uniform if none\n        def adaptive_sample(best_path):\n            if best_path:\n                import numpy as np\n                # Sample near path nodes with some Gaussian noise scaled to step_size\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 1.2, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            # Fallback uniform random sampling\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            # Final fallback: unconstrained\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # Lazy collision checking cache: store edge collision results for reuse\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)  # Sorted tuple for symmetry\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) -1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def extract_path(node):\n            return node.path_from_root()\n\n        def prune_nodes(nodes_list, best_cost, root_start, root_goal):\n            removed = 0\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(rm_node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialize graph roots\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        best_path = []\n        c_best = float(\"inf\")\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            sample_point = adaptive_sample(best_path)\n\n            # Alternate expanding smaller tree for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(sample_point)\n            new_pos = steer(nearest_a.position, sample_point)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            # Choose parent minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for nbr in near_nodes:\n                cost_candidate = nbr.cost + dist(nbr.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(nbr.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = nbr\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for potential improvements\n            for nbr in near_nodes:\n                if nbr is best_parent:\n                    continue\n                c_new = new_node.cost + dist(new_node.position, nbr.position)\n                if c_new + 1e-12 < nbr.cost and can_connect(new_node.position, nbr.position):\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                    except ValueError:\n                        pass\n                    nbr.update_parent(new_node, c_new)\n                    edges.append((new_node, nbr))\n\n            # Try connecting tree_b to new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_connect_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes))\n                near_b_nodes = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_b_nodes:\n                    if nbr_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if c_via_new_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    connection_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=connection_cost)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if connection_cost + 1e-12 < c_best:\n                        c_best = connection_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodically prune unpromising nodes to speed up search\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                removed_start = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_goal = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -0.87076,
    "time_improvement": -12.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.013141536712646484,
            "num_nodes_avg": 84.4,
            "path_length_avg": 159.69086813692314,
            "success_improvement": 0.0,
            "time_improvement": -30.25834444034824,
            "length_improvement": 20.18803897343391,
            "objective_score": -5.03989553741769
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.020515084266662598,
            "num_nodes_avg": 207.7,
            "path_length_avg": 236.2902695479745,
            "success_improvement": 0.0,
            "time_improvement": -43.42158995257977,
            "length_improvement": 21.590894508385396,
            "objective_score": -8.708298084096851
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.017832279205322266,
            "num_nodes_avg": 158.0,
            "path_length_avg": 122.09045132245728,
            "success_improvement": 0.0,
            "time_improvement": 37.848849238961265,
            "length_improvement": 25.029108035481944,
            "objective_score": 16.360476378784767
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid algorithm combines the bidirectional tree growth strategy with dynamic rewiring inspired by RRT* to optimize path quality, while employing an adaptive goal bias and informed sampling to improve planning efficiency and success rate. It alternates growth between start and goal trees, samples points with occasional bias toward the midpoint between start and goal to steer exploration, rewires nearby nodes to minimize path cost, and upon connecting the trees, it reconstructs and smooths the final path for improved path quality and smoothness.",
    "planning_mechanism": "The planner grows two trees bidirectionally, extending and rewiring nodes dynamically to optimize path cost. It incorporates goal bias and informed sampling in the sampling routine to balance exploration and exploitation. Once the trees connect, it reconstructs the path, then applies shortcut smoothing while ensuring collision-free checks for nodes and path edges. This mechanism enhances path length, smoothness, success rate, and computational efficiency.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 20.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling goal or midpoint bias\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if distance(node.position, position) <= radius]\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def sample_free():\n            # Adaptive sampling: goal bias + informed sampling around midpoint to improve efficiency\n            while True:\n                r = random.random()\n                if r < self.goal_sample_rate:\n                    # Bias sampling: sample either goal or midpoint\n                    if r < self.goal_sample_rate / 2:\n                        sample = goal_position\n                    else:\n                        mid = tuple((start_position[d] + goal_position[d]) * 0.5 for d in range(len(bounds)))\n                        # Uniform small ball sampling around midpoint (informed sampling)\n                        sample = tuple(\n                            min(bounds[d], max(0.0, random.gauss(mid[d], self.step_size * 2)))\n                            for d in range(len(bounds))\n                        )\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        # Attempt to rewire neighbors by cost improvement\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                new_cost = new_node.cost + distance(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    if (not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d)):\n                        # Rewire neighbor\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.children.remove(neighbor)\n                            except ValueError:\n                                pass  # Edge may have been already removed\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        # Extend a tree towards a point with rewiring and cost-minimization\n        def extend_and_rewire(tree, point):\n            nearest_node = min(tree, key=lambda node: distance(node.position, point))\n            new_pos = steer(nearest_node.position, point)\n            if (self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                return None\n            new_node = Node(new_pos)\n            neighbors = near_nodes(tree, new_pos, self.rewire_radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + distance(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        # Connect trees by steering and rewiring from tree towards new_node in other tree\n        def connect_and_rewire(tree, new_node_other):\n            nearest_node = min(tree, key=lambda node: distance(node.position, new_node_other.position))\n            current_node = nearest_node\n            while True:\n                new_pos = steer(current_node.position, new_node_other.position)\n                if (self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                        self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d)):\n                    return None\n                connect_node = Node(new_pos)\n                neighbors = near_nodes(tree, new_pos, self.rewire_radius)\n\n                min_cost = current_node.cost + distance(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    cost = neighbor.cost + distance(neighbor.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                best_parent.add_child(connect_node)\n                connect_node.cost = min_cost\n                connect_node.parent = best_parent\n                tree.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((best_parent, connect_node))\n\n                rewire(tree, connect_node, neighbors)\n\n                if distance(connect_node.position, new_node_other.position) <= self.step_size:\n                    return connect_node\n\n                current_node = connect_node\n\n        # Shortcut smoothing to improve path smoothness and length\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) - 1\n                while j > i +1:\n                    if (not self._is_edge_in_obstacle(smoothed[-1], path[j], obstacles, is_3d)):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        for iter_num in range(self.max_iter):\n            rand_point = sample_free()\n            new_a = extend_and_rewire(tree_a, rand_point)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = connect_and_rewire(tree_b, new_a)\n            if new_b is not None:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                raw_path = path_a + path_b[::-1]\n\n                # Apply shortcut smoothing after path found\n                extracted_path = shortcut_path(raw_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 15.91351,
    "time_improvement": -45.0,
    "length_improvement": 30.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.013213729858398438,
            "num_nodes_avg": 86.5,
            "path_length_avg": 154.70397161416258,
            "success_improvement": 0.0,
            "time_improvement": -30.973919783720433,
            "length_improvement": 22.680441923969667,
            "objective_score": -4.756087550322195
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.02826528549194336,
            "num_nodes_avg": 271.1,
            "path_length_avg": 220.85431302450215,
            "success_improvement": -9.999999999999998,
            "time_improvement": -97.60348692818627,
            "length_improvement": 26.713067104524345,
            "objective_score": -28.93843265755101
        },
        {
            "map_id": 2,
            "success_rate": 0.6,
            "time_avg": 0.030745434761047363,
            "num_nodes_avg": 227.3,
            "path_length_avg": 96.8855939375421,
            "success_improvement": -40.0,
            "time_improvement": -7.1575948899013655,
            "length_improvement": 40.50640883597447,
            "objective_score": -14.045996699775515
        }
    ],
    "success_rate": 0.8333333333333334
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner that incorporates dynamic neighborhood radius adjustment, adaptive sampling biased towards start and goal regions, incremental rewiring for path cost minimization, collision-free node and edge verification, and final path shortcut smoothing for improved path quality and efficiency. It balances exploration and exploitation by alternating tree extensions and continuously optimizes the connection process to produce shorter and smoother paths with higher success rates.",
    "planning_mechanism": "The planner grows two trees from start and goal positions alternately. Each iteration samples a collision-free point, steers the nearest node in the active tree towards it within step limits while ensuring collision safety, and performs rewiring within a radius that adapts during iterations. It attempts to incrementally connect the opposite tree to the newly added node. Upon successful connection, the combined path is shortcut-smoothed for higher quality before returning.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 smoothing_iterations: int = 100, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Adaptive biased sampling: 10% goal, 10% start, 80% uniform random\n            r = random.random()\n            if r < 0.1:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    return goal_position\n            elif r < 0.2:\n                if not self._is_in_obstacle(start_position, obstacles, is_3d):\n                    return start_position\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback return (may be in obstacle but rare)\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / distance_between\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            # Clamp inside bounds strictly\n            new_pos = tuple(max(0, min(new_pos[d], bounds[d])) for d in range(len(bounds)))\n            return new_pos\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            return in_bounds(p1) and in_bounds(p2) and not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        def shortcut_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - position[d]) ** 2 for d in range(len(position))) <= r2]\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        nodes: List[Node] = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n        tree_a, tree_b = [start_root], [goal_root]\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for iteration in range(self.max_iter):\n            sample = sample_free()\n            r = neighbor_radius(iteration, len(nodes))\n\n            # Extend active tree toward sample point\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            neighbors = near_nodes(tree_a, new_pos, r)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                cost_via_node = node.cost + dist(node.position, new_pos)\n                if cost_via_node + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_via_node\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to possibly new_node for cost improvement\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt incremental connection from opposite tree to new_node\n            connect_node = nearest(tree_b, new_node.position)\n            curr_pos = connect_node.position\n            connected = False\n\n            while True:\n                next_pos = steer(curr_pos, new_node.position)\n                if not can_add_node(next_pos) or not can_connect(curr_pos, next_pos):\n                    break\n\n                neighbors_b = near_nodes(tree_b, next_pos, r)\n                min_cost_b = connect_node.cost + dist(curr_pos, next_pos)\n                best_parent_b = connect_node\n\n                for node_b in neighbors_b:\n                    if not can_connect(node_b.position, next_pos):\n                        continue\n                    cost_b = node_b.cost + dist(node_b.position, next_pos)\n                    if cost_b < min_cost_b:\n                        min_cost_b = cost_b\n                        best_parent_b = node_b\n\n                new_node_b = Node(next_pos, parent=best_parent_b, cost=min_cost_b)\n                best_parent_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((best_parent_b, new_node_b))\n\n                # Rewire neighbors of new_node_b for cost improvements\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is best_parent_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    # Successful connection found\n                    success_state = True\n\n                    path_start = new_node.path_from_root()\n                    path_goal = connection_node.path_from_root()\n                    combined_path = path_start + path_goal[::-1][1:]  # merge paths avoiding duplicate node\n\n                    extracted_path = shortcut_smoothing(combined_path)\n                    connected = True\n                    break\n\n                curr_pos = new_node_b.position\n                connect_node = new_node_b\n\n            if connected:\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # alternate trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 30.50429,
    "time_improvement": -116.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.013696694374084472,
            "num_nodes_avg": 93.3,
            "path_length_avg": 162.78166818583708,
            "success_improvement": 0.0,
            "time_improvement": -35.76104320865118,
            "length_improvement": 18.643286816201503,
            "objective_score": -6.999655599355053
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.041968274116516116,
            "num_nodes_avg": 313.0,
            "path_length_avg": 235.24636926182453,
            "success_improvement": 0.0,
            "time_improvement": -193.40150511288348,
            "length_improvement": 21.937295940048422,
            "objective_score": -53.63299234585536
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06280975341796875,
            "num_nodes_avg": 326.8,
            "path_length_avg": 123.82039436627615,
            "success_improvement": 0.0,
            "time_improvement": -118.91191860537585,
            "length_improvement": 23.966818793054863,
            "objective_score": -30.88021182300178
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an optimized bidirectional RRT* variant that efficiently grows two trees from start and goal points. It performs rewiring to guarantee asymptotic optimality while adaptively tuning exploration parameters for faster convergence and higher-quality paths. It incorporates adaptive radius and step size scaling based on problem dimensions and map bounds to improve success rate and path smoothness.",
    "planning_mechanism": "The planner alternates growing two trees by sampling, steering, rewiring nearby nodes within an adaptive radius, and attempts connection between the trees after each extension. Extensive collision checks ensure robustness. Upon successful connection, an optimal path is extracted by backtracking parents from both trees and smoothing the path using shortcutting.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size_init = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size                    # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start           # Tuple[float, ...]\n        goal_position = map.goal             # Tuple[float, ...]\n        obstacles = map.obstacles            # List of obstacles: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        \n        # Adaptive step size and radius scaling based on environment size and dimension\n        diag = math.dist((0,)*dim, bounds)\n        step_size = min(self.step_size_init, diag * 0.05)\n        search_radius = min(50.0, diag * 0.15)  # dynamic radius for rewiring\n\n        start_tree = [Node(start_position, parent=None, cost=0.0)]\n        goal_tree = [Node(goal_position, parent=None, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if distance(node.position, point) <= radius]\n\n        def extract_path(node_a, node_b):\n            path_from_start = []\n            cur = node_a\n            while cur is not None:\n                path_from_start.append(cur.position)\n                cur = cur.parent\n            path_from_start.reverse()\n\n            path_from_goal = []\n            cur = node_b\n            while cur is not None:\n                path_from_goal.append(cur.position)\n                cur = cur.parent\n\n            return path_from_start + path_from_goal\n\n        def is_in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def smooth_path(path):\n            # Shortcut smoothing: try to replace intermediate nodes by direct edges\n            if len(path) <= 2:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path)-1\n                while j > i+1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -=1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        for iteration in range(self.max_iter):\n            rand_point = None\n            # Adaptive biasing: with 10% probability sample the goal to speed convergence\n            if random.random() < 0.1:\n                rand_point = goal_position\n            else:\n                while True:\n                    rand_point = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if (not self._is_in_obstacle(rand_point, obstacles, is_3d)) and is_in_bounds(rand_point):\n                        break\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, rand_point)\n                new_pos = steer(nearest_node.position, rand_point, step_size)\n\n                if (not is_in_bounds(new_pos)\n                    or self._is_in_obstacle(new_pos, obstacles, is_3d)\n                    or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                    continue\n\n                near_nodes = near(tree_a, new_pos, search_radius)\n\n                min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n                min_parent = nearest_node\n\n                # Choose parent with minimal cost and collision-free edge\n                for near_node in near_nodes:\n                    if near_node == nearest_node:\n                        continue\n                    cost_candidate = near_node.cost + distance(near_node.position, new_pos)\n                    if cost_candidate < min_cost:\n                        if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                            min_cost = cost_candidate\n                            min_parent = near_node\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire near nodes to new_node if that shortens path and collision free\n                for near_node in near_nodes:\n                    if near_node == min_parent:\n                        continue\n                    cost_through_new = new_node.cost + distance(new_node.position, near_node.position)\n                    if cost_through_new < near_node.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                            # Rewire\n                            if near_node.parent:\n                                try:\n                                    edges.remove((near_node.parent, near_node))\n                                    near_node.parent.children.remove(near_node)\n                                except ValueError:\n                                    pass\n                            near_node.parent = new_node\n                            near_node.cost = cost_through_new\n                            new_node.add_child(near_node)\n                            edges.append((new_node, near_node))\n\n                # Try to connect to the other tree\n                connect_node = nearest(tree_b, new_node.position)\n                dist_connect = distance(new_node.position, connect_node.position)\n                if dist_connect <= step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    # Connect trees - unify parents and costs to create one path\n                    success_state = True\n                    path = extract_path(new_node, connect_node)\n                    # Smooth the resulting path to improve quality and path length\n                    extracted_path = smooth_path(path)\n                    return PlannerResult(\n                        success=success_state,\n                        path=extracted_path,\n                        nodes=nodes,\n                        edges=edges\n                    )\n\n        # Failed to find path in given iterations\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 64.30161,
    "time_improvement": -229.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.041902995109558104,
            "num_nodes_avg": 149.9,
            "path_length_avg": 167.81445107593092,
            "success_improvement": 0.0,
            "time_improvement": -315.3406781423399,
            "length_improvement": 16.127950300309244,
            "objective_score": -91.37661338264013
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.041944694519042966,
            "num_nodes_avg": 298.3,
            "path_length_avg": 228.90048490620657,
            "success_improvement": 0.0,
            "time_improvement": -193.23665941612285,
            "length_improvement": 24.04307506006509,
            "objective_score": -53.162382812823836
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.08005759716033936,
            "num_nodes_avg": 423.0,
            "path_length_avg": 119.35314515512133,
            "success_improvement": 0.0,
            "time_improvement": -179.0261263514597,
            "length_improvement": 26.70997892032407,
            "objective_score": -48.3658421213731
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified, generalized bidirectional RRT* planner that balances exploration and exploitation through alternate tree expansions with adaptive neighbor radius rewiring, rigorous collision checks for nodes and edges, path cost optimization, and randomized shortcut smoothing. It maintains path feasibility and robustness while enhancing planning efficiency, success rate, and path quality.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal by iteratively sampling collision-free points within map bounds, steering towards samples within a fixed step size, rewiring neighbors to lower path costs, and attempting to connect the two trees incrementally. Upon connection, it reconstructs and smooths the path via randomized shortcutting before returning.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_radius: float = 5.0, max_radius: float = 30.0,\n                 smoothing_iters: int = 100, collision_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.smoothing_iters = smoothing_iters\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback: uniform random\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d_] + ratio * (to_pos[d_] - from_pos[d_]) for d_ in range(len(from_pos)))\n            # Clamp to bounds\n            return tuple(max(0, min(new_pos[d_], bounds[d_])) for d_ in range(len(bounds)))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes,1)\n            r_iter = self.max_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            if dist(p1, p2) < 1e-12:\n                return True\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if sum((node.position[d] - position[d])**2 for d in range(len(position))) <= radius_sq]\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path[:]\n            smoothed = path[:]\n            for _ in range(self.smoothing_iters):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if can_connect(smoothed[i], smoothed[j]):\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n        tree_a, tree_b = [start_root], [goal_root]\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for iteration in range(self.max_iter):\n            sample = sample_free()\n            radius = neighbor_radius(iteration, len(nodes))\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            neighbors = near_nodes(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                cost_thru_node = node.cost + dist(node.position, new_pos)\n                if cost_thru_node + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_thru_node\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            connect_node = nearest(tree_b, new_node.position)\n            curr_pos = connect_node.position\n            connected = False\n\n            while True:\n                next_pos = steer(curr_pos, new_node.position)\n                if not can_add_node(next_pos) or not can_connect(curr_pos, next_pos):\n                    break\n\n                neighbors_b = near_nodes(tree_b, next_pos, radius)\n\n                min_cost_b = connect_node.cost + dist(curr_pos, next_pos)\n                best_parent_b = connect_node\n                for node_b in neighbors_b:\n                    cost_b = node_b.cost + dist(node_b.position, next_pos)\n                    if cost_b + 1e-12 < min_cost_b and can_connect(node_b.position, next_pos):\n                        min_cost_b = cost_b\n                        best_parent_b = node_b\n\n                new_node_b = Node(next_pos, parent=best_parent_b, cost=min_cost_b)\n                best_parent_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((best_parent_b, new_node_b))\n\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is best_parent_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    path_start = new_node.path_from_root()\n                    path_goal = connection_node.path_from_root()\n                    combined_path = path_start + path_goal[::-1][1:]\n                    extracted_path = shortcut_smoothing(combined_path)\n                    connected = True\n                    break\n\n                curr_pos = new_node_b.position\n                connect_node = new_node_b\n\n            if connected:\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 7.72768,
    "time_improvement": -41.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012247347831726074,
            "num_nodes_avg": 69.8,
            "path_length_avg": 157.58179279190188,
            "success_improvement": 0.0,
            "time_improvement": -21.395182864002873,
            "length_improvement": 21.242134559504606,
            "objective_score": -2.1701279472999406
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0289870023727417,
            "num_nodes_avg": 230.0,
            "path_length_avg": 234.08323517595468,
            "success_improvement": 0.0,
            "time_improvement": -102.64903201073415,
            "length_improvement": 22.323263180317472,
            "objective_score": -26.330056967156747
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02798898220062256,
            "num_nodes_avg": 212.2,
            "path_length_avg": 125.53899308665306,
            "success_improvement": 0.0,
            "time_improvement": 2.4495168357540735,
            "length_improvement": 22.911495648614675,
            "objective_score": 5.317154180449157
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner combines the strengths of both provided algorithms by integrating adaptive bidirectional RRT* search with dynamic neighbor radius rewiring, frontier and heuristic bias sampling, and adaptive step sizing near obstacles. It grows two trees alternately from start and goal positions, dynamically adjusting sampling biases toward frontiers and goals, employing incremental rewiring with collision checks to minimize path costs. Efficient incremental connection attempts merge the trees, followed by an improved iterative shortcut smoothing that reduces path length and enhances smoothness. This approach aims to increase planning success rate, reduce planning time, and produce shorter, smoother paths with lower computational overhead while maintaining robustness.",
    "planning_mechanism": "The planner alternates growth between two RRT* trees from start and goal, sampling adaptively biased points (towards frontiers and goal/start) based on iteration and environment complexity. It uses adaptive step sizing near obstacles for precise expansions, locally optimizes connections and rewiring with dynamically adjusted neighbor radius, and repeatedly attempts to connect the two trees incrementally. Upon connection, it merges paths and performs iterative shortcut smoothing with early stopping, resulting in efficient, high-quality, collision-free path planning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 8.0, max_neighbor_radius: float = 25.0,\n                 goal_sample_rate: float = 0.15, frontier_sample_rate: float = 0.25,\n                 smoothing_trials: int = 200):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.frontier_sample_rate = frontier_sample_rate\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def adaptive_step_size(pos):\n            query_radius = self.base_step_size * 2\n            min_dist = float('inf')\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, w, h, d = obs\n                    px, py, pz = pos\n                    dx = max(ox - px, 0, px - (ox + w))\n                    dy = max(oy - py, 0, py - (oy + h))\n                    dz = max(oz - pz, 0, pz - (oz + d))\n                    d_obs = (dx * dx + dy * dy + dz * dz) ** 0.5\n                else:\n                    ox, oy, w, h = obs\n                    px, py = pos\n                    dx = max(ox - px, 0, px - (ox + w))\n                    dy = max(oy - py, 0, py - (oy + h))\n                    d_obs = (dx * dx + dy * dy) ** 0.5\n                if d_obs < min_dist:\n                    min_dist = d_obs\n            if min_dist <= query_radius:\n                # Closer to obstacles => smaller step size\n                return max(self.base_step_size * 0.4, self.base_step_size * (min_dist / query_radius))\n            return self.base_step_size\n\n        def steer(from_pos, to_pos, step):\n            d = dist(from_pos, to_pos)\n            if d <= step:\n                p_new = to_pos\n            else:\n                ratio = step / d\n                p_new = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n            # Keep within bounds\n            return tuple(max(0, min(p_new[d], bounds[d])) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def adaptive_goal_frontier_bias(iteration, toggle_start, frontiers):\n            # Increase goal bias as iteration progresses, tempered to max rate\n            goal_bias = min(self.goal_sample_rate + 0.25 * (iteration / self.max_iter), 0.4)\n            frontier_bias = self.frontier_sample_rate\n\n            r = random.random()\n            # Sampling priority:\n            # 1) With goal_bias, sample goal (or start) directly\n            if r < goal_bias:\n                return start_pos if toggle_start else goal_pos\n            # 2) With frontier_bias, sample near frontiers if available\n            elif r < goal_bias + frontier_bias and frontiers:\n                frontier = random.choice(frontiers)\n                radius = self.base_step_size * 3\n                sampled = []\n                for d in range(dim):\n                    low = max(0, frontier[d] - radius)\n                    high = min(bounds[d], frontier[d] + radius)\n                    sampled.append(random.uniform(low, high))\n                return tuple(sampled)\n            # 3) Uniform random sample in bounds avoiding obstacles\n            attempts = 100\n            for _ in range(attempts):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            return start_pos if toggle_start else goal_pos\n\n        def neighbor_radius(iteration):\n            factor = (1.0 - (iteration / self.max_iter) ** 0.98)\n            radius = max(self.min_neighbor_radius, self.max_neighbor_radius * factor)\n            return radius\n\n        def near_nodes(tree, pos, radius):\n            # Linear scan, could be optimized with spatial structure if needed\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def identify_frontiers():\n            # Grid-based frontier finding: occupied cells adjacent to free cells\n            frontiers = []\n            resolution = self.base_step_size * 2\n            steps = [int(bounds[d] / resolution) for d in range(dim)]\n            occupied = set()\n\n            def neighbors_grid(pos_grid):\n                offsets = [-1, 0, 1]\n                for delta in self._cartesian_product([offsets] * dim):\n                    if all(x == 0 for x in delta):\n                        continue\n                    nbr = tuple(pos_grid[d] + delta[d] for d in range(dim))\n                    yield nbr\n\n            # Mark occupied grid cells\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, w, h, d = obs\n                    min_c = [int(ox // resolution), int(oy // resolution), int(oz // resolution)]\n                    max_c = [int((ox + w) // resolution), int((oy + h) // resolution), int((oz + d) // resolution)]\n                    for x in range(min_c[0], max_c[0] + 1):\n                        for y in range(min_c[1], max_c[1] + 1):\n                            for z in range(min_c[2], max_c[2] + 1):\n                                occupied.add((x, y, z))\n                else:\n                    ox, oy, w, h = obs\n                    min_c = [int(ox // resolution), int(oy // resolution)]\n                    max_c = [int((ox + w) // resolution), int((oy + h) // resolution)]\n                    for x in range(min_c[0], max_c[0] + 1):\n                        for y in range(min_c[1], max_c[1] + 1):\n                            occupied.add((x, y))\n\n            # Iterate grid cells to identify frontiers (free cells adjacent to occupied)\n            if is_3d:\n                for ix in range(steps[0] + 1):\n                    for iy in range(steps[1] + 1):\n                        for iz in range(steps[2] + 1):\n                            pos_grid = (ix, iy, iz)\n                            if pos_grid in occupied:\n                                continue\n                            if any(nbr in occupied for nbr in neighbors_grid(pos_grid)):\n                                frontiers.append(tuple((pos_grid[d] + 0.5) * resolution for d in range(dim)))\n            else:\n                for ix in range(steps[0] + 1):\n                    for iy in range(steps[1] + 1):\n                        pos_grid = (ix, iy)\n                        if pos_grid in occupied:\n                            continue\n                        if any(nbr in occupied for nbr in neighbors_grid(pos_grid)):\n                            frontiers.append(((ix + 0.5) * resolution, (iy + 0.5) * resolution))\n\n            return frontiers\n\n        # Initialize trees and core structures\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        toggle_start = True  # Alternate which tree samples towards goal/start bias\n        success = False\n        final_path = []\n\n        # Precompute frontiers once for sampling bias\n        frontiers = identify_frontiers()\n\n        for iteration in range(self.max_iter):\n            q_rand = adaptive_goal_frontier_bias(iteration, toggle_start, frontiers)\n\n            tree_a = tree_start if toggle_start else tree_goal\n            tree_b = tree_goal if toggle_start else tree_start\n\n            radius = neighbor_radius(iteration)\n\n            nearest_node = nearest(tree_a, q_rand)\n            step = adaptive_step_size(nearest_node.position)\n            new_pos = steer(nearest_node.position, q_rand, step)\n\n            if not in_bounds(new_pos):\n                toggle_start = not toggle_start\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                toggle_start = not toggle_start\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=step * 0.2):\n                toggle_start = not toggle_start\n                continue\n\n            near = near_nodes(tree_a, new_pos, radius)\n\n            # Choose best parent minimizing cost + collision check\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost < min_cost and \\\n                   not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, resolution=step * 0.2):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper via new_node found (local optimization)\n            for node in near:\n                if node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, node.position)\n                if cost_through_new < node.cost and \\\n                   not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, resolution=step * 0.2):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, node))\n\n            # Incremental connection attempt: grow from tree_b toward new_node\n            curr_node_b = nearest(tree_b, new_node.position)\n            connected_node_b = None\n            connection_threshold = step * 0.5\n\n            while True:\n                step_b = adaptive_step_size(curr_node_b.position)\n                new_pos_b = steer(curr_node_b.position, new_node.position, step_b)\n\n                if not in_bounds(new_pos_b):\n                    break\n                if self._is_in_obstacle(new_pos_b, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(curr_node_b.position, new_pos_b, obstacles, is_3d, resolution=step_b * 0.2):\n                    break\n\n                cost_b = curr_node_b.cost + dist(curr_node_b.position, new_pos_b)\n                new_node_b = Node(new_pos_b, parent=curr_node_b, cost=cost_b)\n                curr_node_b.add_child(new_node_b)\n\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((curr_node_b, new_node_b))\n\n                # Rewire neighbors around new_node_b\n                near_b = near_nodes(tree_b, new_pos_b, radius)\n                for node in near_b:\n                    if node == curr_node_b:\n                        continue\n                    cost_through_new_b = new_node_b.cost + dist(new_node_b.position, node.position)\n                    if cost_through_new_b < node.cost and \\\n                       not self._is_edge_in_obstacle(new_node_b.position, node.position, obstacles, is_3d, resolution=step_b * 0.2):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node_b, cost_through_new_b)\n                        edges.append((new_node_b, node))\n\n                if dist(new_node_b.position, new_node.position) <= connection_threshold:\n                    connected_node_b = new_node_b\n                    break\n\n                curr_node_b = new_node_b\n\n            if connected_node_b:\n                success = True\n                connection_start = new_node if toggle_start else connected_node_b\n                connection_goal = connected_node_b if toggle_start else new_node\n\n                path_start = connection_start.path_from_root()\n                path_goal = connection_goal.path_from_root()\n\n                merged_path = path_start + path_goal[::-1][1:]  # avoid repeating node\n\n                # Improved iterative shortcut smoothing with early stopping\n                smoothed_path = self._path_smooth(merged_path, obstacles, is_3d, max_trials=self.smoothing_trials)\n\n                final_path = smoothed_path\n                break\n\n            toggle_start = not toggle_start\n\n        return PlannerResult(success=success, path=final_path, nodes=nodes, edges=edges)\n\n    def _path_smooth(self, path, obstacles, is_3d, max_trials=200):\n        import random\n        if len(path) < 3:\n            return path[:]\n        smoothed = path[:]\n        improved = True\n        trials = 0\n        while trials < max_trials and improved and len(smoothed) >= 3:\n            improved = False\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n            p_i, p_j = smoothed[i], smoothed[j]\n            if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d, resolution=1.0):\n                smoothed = smoothed[:i + 1] + smoothed[j:]\n                improved = True\n            trials += 1\n        return smoothed\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n            return\n        for item in arrays[0]:\n            for rest in self._cartesian_product(arrays[1:]):\n                yield (item,) + rest\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 213.73127,
    "time_improvement": -722.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.06441245079040528,
            "num_nodes_avg": 208.8,
            "path_length_avg": 154.4899082426573,
            "success_improvement": 0.0,
            "time_improvement": -538.453430886009,
            "length_improvement": 22.7874287395786,
            "objective_score": -156.97854351788698
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.14043493270874025,
            "num_nodes_avg": 727.3,
            "path_length_avg": 238.29311539032045,
            "success_improvement": 0.0,
            "time_improvement": -881.7849672058738,
            "length_improvement": 20.926282498604518,
            "objective_score": -260.35023366204126
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.2426041841506958,
            "num_nodes_avg": 802.2,
            "path_length_avg": 123.76027808039387,
            "success_improvement": -9.999999999999998,
            "time_improvement": -745.5525539275116,
            "length_improvement": 24.00373381405257,
            "objective_score": -223.86501941544293
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "time_expert",
    "algorithm_description": "This enhanced planner implements a heuristic-biased bidirectional RRT* with balanced tree growth, but introduces an adaptive sampling region shrunk progressively towards the corridor between start and goal to reduce sample space, and employs a KD-tree for nearest neighbor queries enhancing speed. It also applies early goal biasing when trees are close, adaptive rewiring radius tightened based on node density, and aggressive shortcut smoothing combined with lazy collision checking. Periodic pruning removes dead-ends and improves efficiency. These collectively reduce planning time, improve path quality and success rate while maintaining robustness and smoothness.",
    "planning_mechanism": "The planner alternately extends the smaller of two trees starting at start and goal, using a heuristic sampling biased towards the direct corridor connecting them, minimizing sample waste. Nearest neighbors are found via a KD-tree improving query speed. New nodes are validated by collision checks on position and edges. The rewiring radius adapts inversely with node density to focus local improvements. Upon a successful extension, attempts are made to connect opposite trees. Final paths are shortcut-smoothed aggressively with lazy collision checks to reduce overhead, and dead-end pruning keeps tree size manageable.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, prune_interval: int = 120,\n                 prune_threshold: int = 100, smoothing_iterations: int = 60,\n                 radius_constant: float = 20.0, radius_min: float = 3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        from bisect import bisect_left\n        from collections import deque\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # KD-tree helper for efficient nearest search (approximate with sorting per coord)\n        class KDTree:\n            def __init__(self, node_list):\n                self.nodes = node_list\n                self.points = [node.position for node in node_list]\n                self.dim = len(self.points[0]) if self.points else 0\n                # Sort by first dimension only for quick search - tradeoff for speed/simple approx\n                self.sorted_indices = sorted(range(len(self.points)), key=lambda i: self.points[i][0])\n\n            def nearest(self, point):\n                if not self.points:\n                    return None\n                # Simple linear search for sanity fallback\n                best_node = None\n                best_dist = float('inf')\n                for node in self.nodes:\n                    d = math.dist(point, node.position)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = node\n                return best_node\n\n            def near(self, point, radius):\n                radius_sq = radius * radius\n                result = []\n                for node in self.nodes:\n                    d_sq = sum((node.position[i] - point[i]) ** 2 for i in range(self.dim))\n                    if d_sq <= radius_sq:\n                        result.append(node)\n                return result\n\n            def add(self, node):\n                self.nodes.append(node)\n                self.points.append(node.position)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if (x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d):\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if (x <= px <= x + w and y <= py <= y + h):\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not _is_in_obstacle(pos)\n\n        def can_connect(p1, p2):\n            return in_bounds(p1) and in_bounds(p2) and not _is_edge_in_obstacle(p1, p2)\n\n        def heuristic_sample():\n            # Bias samples progressively shrinking corridor between start & goal with some Gaussian around line\n            # Improve efficiency by limiting sampling region\n            line_vec = tuple(goal_position[d] - start_position[d] for d in range(dim))\n            line_len = dist(start_position, goal_position)\n            if line_len == 0:\n                return start_position\n            # Sample scalar t on [0,1] with more weight near midpoint\n            t = random.betavariate(2, 2)  # bell shaped bias towards middle\n            base_point = tuple(start_position[d] + t * line_vec[d] for d in range(dim))\n            # Add gaussian noise orthogonal to line to widen corridor adaptively shrinking with progress\n            corridor_width = max(0.3 * line_len * (1 - (iters_done / self.max_iter)), 0.8)\n            # Generate Gaussian noise vector orthogonal to line_vec in 2D or 3D\n            noise = [0] * dim\n            if dim == 2:\n                # Orthogonal unit vector\n                ox, oy = -line_vec[1], line_vec[0]\n                norm = math.sqrt(ox * ox + oy * oy)\n                ox /= norm\n                oy /= norm\n                offset = random.gauss(0, corridor_width)\n                noise[0] = ox * offset\n                noise[1] = oy * offset\n            else:\n                # In 3D, create random vector perpendicular to line_vec:\n                from random import gauss\n                lv = line_vec\n                lv_norm = math.sqrt(sum(c*c for c in lv))\n                lv_unit = tuple(c/lv_norm for c in lv)\n                # Generate random vector & subtract projection to make perpendicular\n                random_vec = [random.gauss(0, 1) for _ in range(3)]\n                proj_len = sum(random_vec[d]*lv_unit[d] for d in range(3))\n                perp_vec = [random_vec[d] - proj_len*lv_unit[d] for d in range(3)]\n                norm_pv = math.sqrt(sum(c*c for c in perp_vec))\n                if norm_pv > 1e-10:\n                    perp_unit = [c/norm_pv for c in perp_vec]\n                    offset = random.gauss(0, corridor_width)\n                    for d in range(3):\n                        noise[d] = perp_unit[d] * offset\n                else:\n                    noise = [0,0,0]\n            sample = tuple(min(max(base_point[d] + noise[d], 0), bounds[d]) for d in range(dim))\n            if can_add_node(sample):\n                return sample\n\n            # fallback uniform sample\n            while True:\n                s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if can_add_node(s):\n                    return s\n\n        def steer(from_pos, to_pos):\n            dist_btwn = dist(from_pos, to_pos)\n            if dist_btwn <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist_btwn\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def radius_dynamic(n):\n            if n <= 1:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n) / n)\n            return max(val, self.radius_min)\n\n        def try_extend(tree, kd_tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = kd_tree.nearest(sample_pt)\n            if nearest_node is None:\n                return None\n\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = kd_tree.near(new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            kd_tree.add(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, kd_tree, node):\n            if not tree:\n                return None\n            nearest_node = kd_tree.nearest(node.position)\n            if nearest_node is None:\n                return None\n\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos) or not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                kd_tree.add(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        kd_tree.add(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            # Collect nodes with no children and not root to prune\n            to_prune = deque(node for node in nodes if node not in (start_root, goal_root) and not node.children)\n            while to_prune:\n                node = to_prune.popleft()\n                if not node.children and node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                    try:\n                        nodes.remove(node)\n                    except ValueError:\n                        pass\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    removed.append(node)\n                    # If parent becomes dead end, prune it next\n                    if node.parent and not node.parent.children and node.parent not in (start_root, goal_root):\n                        to_prune.append(node.parent)\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n\n            improved = True\n            iteration = 0\n            while improved and iteration < self.smoothing_iterations:\n                improved = False\n                iteration += 1\n                i = 0\n                while i < len(path) - 2:\n                    j = i + 2\n                    while j < len(path):\n                        if can_connect(path[i], path[j]):\n                            # Remove intermediate nodes [i+1 to j-1]\n                            del path[i+1:j]\n                            improved = True\n                            break\n                        j += 1\n                    if not improved:\n                        i += 1\n                    else:\n                        # Restart from beginning after improvement to catch further shortcuts\n                        break\n            return path\n\n        iters_done = 0\n        kd_start = KDTree(tree_start)\n        kd_goal = KDTree(tree_goal)\n\n        for itr in range(self.max_iter):\n            iters_done = itr\n\n            # Sample point heuristic-biased towards corridor start-goal with fallback uniform\n            if random.random() < self.goal_sample_rate:\n                # Alternate bias to goal or start\n                sample_pt = goal_position if random.random() < 0.75 else start_position\n            else:\n                sample_pt = heuristic_sample()\n\n            # Always extend smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n                kd_start, kd_goal = kd_goal, kd_start\n\n            new_node_start = try_extend(tree_start, kd_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, kd_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            # Periodic pruning to remove dead ends and keep tree small\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 534.42704,
    "time_improvement": -1768.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0659254550933838,
            "num_nodes_avg": 75.3,
            "path_length_avg": 159.1495850224622,
            "success_improvement": 0.0,
            "time_improvement": -553.4502642051632,
            "length_improvement": 20.45856707150057,
            "objective_score": -161.94336584724886
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.1473874568939209,
            "num_nodes_avg": 97.3,
            "path_length_avg": 229.96846430101746,
            "success_improvement": 0.0,
            "time_improvement": -930.3902792709455,
            "length_improvement": 23.68868336551587,
            "objective_score": -274.3793471081804
        },
        {
            "map_id": 2,
            "success_rate": 0.5,
            "time_avg": 1.124910044670105,
            "num_nodes_avg": 297.0,
            "path_length_avg": 128.30886760005959,
            "success_improvement": -50.0,
            "time_improvement": -3820.6684111379145,
            "length_improvement": 21.21062583733505,
            "objective_score": -1166.9583981739072
        }
    ],
    "success_rate": 0.8333333333333334
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved planner implements a bidirectional RRT* with adaptive informed sampling biased towards start and goal, dynamic neighbor radius shrinking with tree growth for efficient rewiring, dead-end pruning, and aggressive iterative shortcut smoothing. Additionally, it employs heuristics based on path costs and Euclidean distances to bias sampling, balances tree growth by always extending the smaller tree, and carefully performs collision and edge feasibility checks to ensure robustness and path optimality. The combination improves planning efficiency, success rate, path length minimization, and smoothness while reducing search time and computational overhead.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal, always extending the smaller. Sampling is adaptively biased using a heuristic that considers distance to start and goal, encouraging exploration near these points and informed regions. Each newly added node undergoes rewiring within a shrinking neighbor radius to optimize local cost, improving path quality. Dead-end nodes are pruned periodically to maintain tree compactness. Upon connecting the two trees, an iterative shortcut smoothing step refines the path to reduce length and enhance smoothness, ensuring collision-free shortcuts. Collision checks apply rigorously for nodes and edges, while boundary constraints are enforced, yielding efficient, robust, and high-quality paths.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 5.0, prune_interval: int = 200,\n                 prune_threshold: int = 100, smoothing_iterations: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def heuristic_sample():\n            # Adaptive sampling biased towards start and goal and around the informed ellipse when path found\n            p_bias = 0.9\n            if random.random() < self.goal_sample_rate:\n                # Biased sample: either start or goal with probability p_bias\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                # Uniform + informed sampling region bias\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            # Return nearest node and its distance\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = node\n            return min_node\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            return max(self.radius_min, self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1)))\n\n        def can_add_node(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            for d in range(len(pos)):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            prune_candidates = [node for node in nodes if node is not start_root and node is not goal_root and not node.children]\n            for node in prune_candidates:\n                try:\n                    if node.parent:\n                        node.parent.children.remove(node)\n                    nodes.remove(node)\n                    edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                    removed.append(node)\n                except Exception:\n                    continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            path_coords = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(path_coords) < 3:\n                    break\n                i = random.randint(0, len(path_coords) - 3)\n                j = random.randint(i + 2, len(path_coords) - 1)\n                p1, p2 = path_coords[i], path_coords[j]\n                if not can_connect(p1, p2):\n                    continue\n                path_coords = path_coords[:i+1] + path_coords[j:]\n            return path_coords\n\n        for itr in range(self.max_iter):\n            sample_pt = heuristic_sample()\n\n            # Always extend smaller tree to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                    prune_dead_nodes()\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n\n                # Combined raw path\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed_path = shortcut_smoothing(raw_path)\n                if path_length(smoothed_path) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -0.08789,
    "time_improvement": -14.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.010836625099182129,
            "num_nodes_avg": 78.1,
            "path_length_avg": 162.348637351029,
            "success_improvement": 0.0,
            "time_improvement": -7.412160054448005,
            "length_improvement": 18.8597114653641,
            "objective_score": 1.5482942767384187
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.023978519439697265,
            "num_nodes_avg": 137.5,
            "path_length_avg": 238.1851169434197,
            "success_improvement": 0.0,
            "time_improvement": -67.63457259294447,
            "length_improvement": 20.962120037036257,
            "objective_score": -16.09794777047609
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0190171480178833,
            "num_nodes_avg": 96.5,
            "path_length_avg": 124.60039533384824,
            "success_improvement": 0.0,
            "time_improvement": 33.719205498325195,
            "length_improvement": 23.48785121091676,
            "objective_score": 14.81333189168091
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This planner introduces a bidirectional Anytime RRT* with informed sampling and dynamic rewiring radius. It integrates heuristic ellipse-shaped sampling to focus the search within an informed subset after initial path discovery, adaptive step sizing responsive to obstacle proximity, and priority rewiring to expedite optimized path refinement. The collision checks are rigorously enforced for node validity and edge feasibility. Post path-finding, aggressive shortcut smoothing is applied to enhance path quality. This approach balances exploration and exploitation to improve planning speed, path length, smoothness, and success rate.",
    "planning_mechanism": "The planner grows two trees from start and goal towards sampled points biased within an ellipse formed by the current best path cost, using adaptive stepping to avoid obstacles and ensuring collision-free node and edge addition. After connecting the two trees, it switches to focused informed sampling to reduce unnecessary exploration. Neighborhood radius for rewiring shrinks as the node count grows to concentrate local optimization. The path is iteratively shortcut-smoothed before returning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float=6.0,\n                 goal_sample_rate: float=0.20,\n                 radius_const: float=30.0,\n                 radius_min: float=5.0,\n                 smoothing_iter: int=120,\n                 collision_resolution: float=0.3,\n                 adaptive_step_min: float = 1.5,\n                 adaptive_step_max: float = 8.0,\n                 informed_sampling_enabled: bool=True):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.smoothing_iter = smoothing_iter\n        self.collision_resolution = collision_resolution\n        self.adaptive_step_min = adaptive_step_min\n        self.adaptive_step_max = adaptive_step_max\n        self.informed_sampling_enabled = informed_sampling_enabled\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Current best cost to guide informed sampling\n        current_best_cost = float('inf')\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= pos[0] <= x+w and y <= pos[1] <= y+h and z <= pos[2] <= z+d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= pos[0] <= x+w and y <= pos[1] <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / self.collision_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def adaptive_step(from_p, to_p):\n            d = dist(from_p, to_p)\n            step = min(self.adaptive_step_max, max(self.adaptive_step_min, d))\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def nearest_node(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def radius_by_nodes(n):\n            if n <= 1:\n                return self.radius_const\n            r = self.radius_const * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(self.radius_min, r)\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            near = []\n            for node in tree:\n                sqd = sum((node.position[i] - pos[i])**2 for i in range(dim))\n                if sqd <= r2:\n                    near.append(node)\n            return near\n\n        def sample_uniform():\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def sample_informed():\n            # Informed sampling within prolate hyperspheroid (ellipse for 2D, ellipsoid for 3D)\n            # defined by start, goal, and current_best_cost\n            if current_best_cost == float('inf'):\n                return sample_uniform()\n\n            from numpy import linalg, array, dot\n            import numpy as np\n\n            c_best = current_best_cost\n            c_min = dist(start_pos, goal_pos)\n            if c_best < c_min:\n                c_best = c_min\n\n            # Center of ellipse\n            center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n\n            # Vector from start to goal\n            a1 = np.array([goal_pos[d] - start_pos[d] for d in range(dim)])\n            length = np.linalg.norm(a1)\n            if length == 0:\n                return sample_uniform()\n            e1 = a1 / length\n\n            # Build an orthonormal basis via Householder transformation\n            eye = np.eye(dim)\n            if dim == 2:\n                # 2D rotation matrix calculation for ellipse axis alignment\n                theta = math.atan2(e1[1], e1[0])\n                cos_t, sin_t = math.cos(theta), math.sin(theta)\n                rotation = np.array([[cos_t, -sin_t],[sin_t, cos_t]])\n                # Sample random point in unit circle\n                r = random.random()**0.5\n                angle = random.uniform(0, 2*math.pi)\n                sample_unit = np.array([r * math.cos(angle), r * math.sin(angle)])\n                # Scale by ellipse axes\n                a = c_best / 2.0  # major axis\n                b = math.sqrt(c_best**2 - c_min**2) / 2.0  # minor axis\n                sample_ellipse = np.array([a * sample_unit[0], b * sample_unit[1]])\n                # Rotate back and translate to center\n                rotated = dot(rotation, sample_ellipse) + np.array(center)\n                sample = tuple(rotated.tolist())\n                if in_bounds(sample) and not is_in_obstacle(sample):\n                    return sample\n                else:\n                    return sample_uniform()\n            else:\n                # For 3D and higher, use sampling in unit sphere + scaling by axes\n                a = c_best / 2.0\n                c = c_min / 2.0\n                b = math.sqrt(c_best**2 - c_min**2) / 2.0 if c_best > c_min else 0.0\n\n                # Sample random point in unit ball (using normal distribution)\n                while True:\n                    vec = np.random.normal(0,1,dim)\n                    norm_vec = np.linalg.norm(vec)\n                    if norm_vec == 0:\n                        continue\n                    unit_vec = vec / norm_vec\n                    radius = random.random()**(1/dim)\n                    point_unit_ball = radius * unit_vec\n                    break\n\n                # Form the scaling matrix for the ellipse axes: major axis along e1, others equal b\n                C = np.zeros((dim, dim))\n                C[:,0] = e1\n                # Orthonormal basis completion for axes orthogonal to e1\n                if dim == 3:\n                    # Gram-schmidt completion for second and third axis\n                    b1 = np.array([0.0,0.0,0.0])\n                    if abs(e1[0]) < 1.0:\n                        b1[0] = 1.0\n                    elif abs(e1[1]) < 1.0:\n                        b1[1] = 1.0\n                    else:\n                        b1[2] = 1.0\n                    b1 = b1 - np.dot(b1, e1)*e1\n                    b1 /= np.linalg.norm(b1)\n                    b2 = np.cross(e1, b1)\n                    C[:,1] = b1\n                    C[:,2] = b2\n                    L = np.diag([a, b, b])\n                else:\n                    # For dim>3 fallback to unit ball sampling (not informed)\n                    return sample_uniform()\n\n                # Map the unit ball point to ellipse using scaling and rotation\n                sample_ellipse = dot(C, dot(L, point_unit_ball)) + np.array(center)\n                sample = tuple(sample_ellipse.tolist())\n                if in_bounds(sample) and not is_in_obstacle(sample):\n                    return sample\n                else:\n                    return sample_uniform()\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_n = nearest_node(tree, point)\n            new_pos = adaptive_step(nearest_n.position, point)\n            if not in_bounds(new_pos) or is_in_obstacle(new_pos):\n                return None\n            if edge_in_obstacle(nearest_n.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_n.cost + dist(nearest_n.position, new_pos)\n            best_parent = nearest_n\n            for node in near:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost < min_cost and not edge_in_obstacle(node.position, new_pos):\n                    min_cost = temp_cost\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cost improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-12 < neighbor.cost and not edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_n = nearest_node(tree, node.position)\n            last_node = nearest_n\n\n            max_steps = 7\n            for _ in range(max_steps):\n                new_pos = adaptive_step(last_node.position, node.position)\n                if not in_bounds(new_pos) or is_in_obstacle(new_pos):\n                    return None\n                if edge_in_obstacle(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                dist_to_goal = dist(new_pos, node.position)\n                if dist_to_goal <= self.step_size:\n                    if not edge_in_obstacle(new_pos, node.position):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + dist_to_goal\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n            return None\n\n        def extract_path(n_start, n_goal):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            length = len(path)\n            if length < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) -1)\n                p_i, p_j = path[i], path[j]\n                if not edge_in_obstacle(p_i, p_j):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            # Alternate sampling: Use informed sampling if best cost found\n            if self.informed_sampling_enabled and success_state:\n                rand_point = sample_informed()\n            else:\n                # With goal biasing for efficiency\n                if random.random() < self.goal_sample_rate:\n                    rand_point = goal_pos\n                else:\n                    rand_point = sample_uniform()\n\n            # Alternate growth on smaller tree first for better balanced exploration\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_candidate = extract_path(new_node_start, new_node_goal)\n                path_candidate = shortcut_path(path_candidate)\n                cost_candidate = 0.0\n                for idx in range(1,len(path_candidate)):\n                    cost_candidate += dist(path_candidate[idx-1], path_candidate[idx])\n                if cost_candidate < current_best_cost:\n                    current_best_cost = cost_candidate\n                    extracted_path = path_candidate\n                # Optionally break early for anytime planning\n                if itr > self.max_iter * 0.1:\n                    break\n\n        # Final aggressive smoothing on discovered path for improved smoothness & length\n        if success_state and extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )",
    "objective": 2049.5368,
    "time_improvement": -6840.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 1.544097375869751,
            "num_nodes_avg": 437.4,
            "path_length_avg": 162.25428450644773,
            "success_improvement": -9.999999999999998,
            "time_improvement": -15205.0265150441,
            "length_improvement": 18.906868110213754,
            "objective_score": -4562.726580891187
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.2932902336120605,
            "num_nodes_avg": 271.4,
            "path_length_avg": 241.0862744130195,
            "success_improvement": 0.0,
            "time_improvement": -1950.4011134168395,
            "length_improvement": 19.999417838097624,
            "objective_score": -581.1204504574323
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.9941812992095947,
            "num_nodes_avg": 487.5,
            "path_length_avg": 124.19124322648193,
            "success_improvement": 0.0,
            "time_improvement": -3365.037256288531,
            "length_improvement": 23.739095252577307,
            "objective_score": -1004.7633578360438
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the adaptive heuristic-biased sampling corridor and KD-tree accelerated nearest neighbor searches from the first algorithm, with the straightforward incremental rewiring and dynamic neighbor radius strategy of the second. It employs bidirectional RRT* with balanced tree growth, aggressively prunes dead-ends, and applies shortcut smoothing with lazy collision checks for improved path quality and smoothness. The dual-tree incremental connection attempts reduce wasted exploration, while adaptive radius and corridor shrinking focus sampling efficiency, achieving a balanced performance boost in planning speed, robustness, and path optimality.",
    "planning_mechanism": "The planner alternately extends the smaller of two trees rooted at start and goal, sampling points biased towards a corridor shrinking adaptively between them. KD-trees enable fast neighbor queries. Each extension rewires neighbors within a dynamically computed radius, ensuring local cost improvements. Incremental attempts connect the opposite tree to new nodes. Periodic pruning removes dead-ends to control memory. Final path extraction undergoes shortcut smoothing with lazy collision checking, yielding a robust, efficient, and high-quality solution.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float = 0.15,\n                 prune_interval: int = 100,\n                 prune_threshold: int = 150,\n                 smoothing_iterations: int = 80,\n                 radius_constant: float = 25.0,\n                 radius_min: float = 3.0,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n        from collections import deque\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # KD-tree class for efficient nearest neighbor queries (simple approx)\n        class KDTree:\n            def __init__(self, node_list: List[Node]):\n                self.nodes = list(node_list)\n                self.points = [node.position for node in self.nodes]\n                self.dim = len(self.points[0]) if self.points else 0\n\n            def nearest(self, point: Tuple[float, ...]) -> Node:\n                best_node = None\n                best_dist = float('inf')\n                for node in self.nodes:\n                    d = math.dist(point, node.position)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = node\n                return best_node\n\n            def near(self, point: Tuple[float, ...], radius: float) -> List[Node]:\n                radius_sq = radius * radius\n                result = []\n                for node in self.nodes:\n                    d_sq = sum((node.position[d] - point[d])**2 for d in range(self.dim))\n                    if d_sq <= radius_sq:\n                        result.append(node)\n                return result\n\n            def add(self, node: Node):\n                self.nodes.append(node)\n                self.points.append(node.position)\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / distance_between\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def radius_dynamic(n: int) -> float:\n            if n <= 1:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n) / n)\n            return max(val, self.radius_min)\n\n        def heuristic_sample(iters_done: int) -> Tuple[float, ...]:\n            # Shrinking corridor towards line start-goal with Gaussian orthogonal noise\n            line_vec = tuple(goal_position[d] - start_position[d] for d in range(dim))\n            line_len = dist(start_position, goal_position)\n            if line_len == 0:\n                return start_position\n\n            t = random.betavariate(2, 2)  # Bell-shaped towards middle\n            base_point = tuple(start_position[d] + t * line_vec[d] for d in range(dim))\n\n            # Corridor width shrinks over iterations (not below 0.8)\n            corridor_width = max(0.4 * line_len * (1 - (iters_done / self.max_iter)), 0.8)\n\n            noise = [0]*dim\n            if dim == 2:\n                # Orthogonal unit vector\n                ox, oy = -line_vec[1], line_vec[0]\n                norm_oxoy = math.sqrt(ox*ox + oy*oy)\n                if norm_oxoy > 1e-10:\n                    ox /= norm_oxoy\n                    oy /= norm_oxoy\n                    offset = random.gauss(0, corridor_width)\n                    noise[0] = ox * offset\n                    noise[1] = oy * offset\n            else:\n                # 3D orthogonal noise\n                lv_norm = math.sqrt(sum(c*c for c in line_vec))\n                lv_unit = tuple(c/lv_norm for c in line_vec)\n                random_vec = [random.gauss(0,1) for _ in range(dim)]\n                proj_len = sum(random_vec[d]*lv_unit[d] for d in range(dim))\n                perp_vec = [random_vec[d] - proj_len*lv_unit[d] for d in range(dim)]\n                norm_pv = math.sqrt(sum(c*c for c in perp_vec))\n                if norm_pv > 1e-10:\n                    perp_unit = [c/norm_pv for c in perp_vec]\n                    offset = random.gauss(0, corridor_width)\n                    for d in range(dim):\n                        noise[d] = perp_unit[d] * offset\n                else:\n                    noise = [0]*dim\n\n            sample = tuple(min(max(base_point[d] + noise[d], 0), bounds[d]) for d in range(dim))\n            if can_add_node(sample):\n                return sample\n\n            # fallback uniform sampling\n            for _ in range(20):\n                s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if can_add_node(s):\n                    return s\n            return sample  # return sample even if potentially invalid (extreme fallback)\n\n        def try_extend(tree: List[Node], kd_tree: KDTree, sample_pt: Tuple[float, ...], iters_done: int) -> Node:\n            if not tree:\n                return None\n            nearest_node = kd_tree.nearest(sample_pt)\n            if nearest_node is None:\n                return None\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = kd_tree.near(new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            kd_tree.add(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], kd_tree: KDTree, node: Node) -> Node:\n            if not tree:\n                return None\n            nearest_node = kd_tree.nearest(node.position)\n            if nearest_node is None:\n                return None\n\n            curr_node = nearest_node\n            radius = radius_dynamic(len(tree))\n            while True:\n                new_pos = steer(curr_node.position, node.position)\n                if not can_add_node(new_pos) or not can_connect(curr_node.position, new_pos):\n                    return None\n\n                near = kd_tree.near(new_pos, radius)\n                min_cost = curr_node.cost + dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in near:\n                    if not can_connect(neighbor.position, new_pos):\n                        continue\n                    tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                    if tentative_cost < min_cost:\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                kd_tree.add(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for neighbor in near:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n                # If reachable within step_size and collision-free, connect final node\n                if dist(new_node.position, node.position) <= self.step_size and can_connect(new_node.position, node.position):\n                    final_cost = new_node.cost + dist(new_node.position, node.position)\n                    final_node = Node(node.position, parent=new_node, cost=final_cost)\n                    new_node.children.append(final_node)\n                    tree.append(final_node)\n                    kd_tree.add(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n\n                curr_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            to_prune = deque(node for node in nodes if node not in (start_root, goal_root) and not node.children)\n            while to_prune:\n                node = to_prune.popleft()\n                if not node.children and node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                    try:\n                        nodes.remove(node)\n                    except ValueError:\n                        pass\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    removed.append(node)\n                    if node.parent and not node.parent.children and node.parent not in (start_root, goal_root):\n                        to_prune.append(node.parent)\n            return removed\n\n        def path_length(path: List[Tuple[float, ...]]) -> float:\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            improved = True\n            iteration = 0\n            while improved and iteration < self.smoothing_iterations:\n                improved = False\n                iteration += 1\n                i = 0\n                while i < len(path) - 2:\n                    j = i + 2\n                    while j < len(path):\n                        if can_connect(path[i], path[j]):\n                            del path[i+1:j]\n                            improved = True\n                            break\n                        j += 1\n                    if not improved:\n                        i += 1\n                    else:\n                        break\n            return path\n\n        kd_start = KDTree(tree_start)\n        kd_goal = KDTree(tree_goal)\n\n        for itr in range(self.max_iter):\n            # Balanced tree extension: always extend smaller tree\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n                kd_start, kd_goal = kd_goal, kd_start\n\n            # Sampling with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample_pt = goal_position if random.random() < 0.75 else start_position\n            else:\n                sample_pt = heuristic_sample(itr)\n\n            new_node_start = try_extend(tree_start, kd_start, sample_pt, itr)\n            if new_node_start is None:\n                # failed attempt, switch trees next iteration\n                continue\n\n            new_node_goal = incremental_connect(tree_goal, kd_goal, new_node_start)\n\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            # Periodic dead-end pruning to reduce tree size and improve speed\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 322.02624,
    "time_improvement": -1059.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.04328150749206543,
            "num_nodes_avg": 77.9,
            "path_length_avg": 166.91434017876176,
            "success_improvement": 0.0,
            "time_improvement": -329.00443335318414,
            "length_improvement": 16.577817075301382,
            "objective_score": -95.38576659089496
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.09378881454467773,
            "num_nodes_avg": 120.3,
            "path_length_avg": 241.769765045852,
            "success_improvement": 0.0,
            "time_improvement": -555.6805093715361,
            "length_improvement": 19.772612522606572,
            "objective_score": -162.7496303069395
        },
        {
            "map_id": 2,
            "success_rate": 0.5,
            "time_avg": 0.6867690801620483,
            "num_nodes_avg": 290.1,
            "path_length_avg": 121.0050331030719,
            "success_improvement": -50.0,
            "time_improvement": -2293.608138797644,
            "length_improvement": 25.695620208878207,
            "objective_score": -707.9433175975176
        }
    ],
    "success_rate": 0.8333333333333334
}
{
    "operator": "m1",
    "algorithm_description": "This planner integrates a bidirectional RRT* framework enhanced with adaptive informed sampling and dynamic neighbor radius for efficient rewiring. By growing two trees simultaneously from start and goal positions, it refines paths incrementally and prunes non-promising nodes to maintain manageable complexity. Collision and bounds checks guard against invalid expansions. The algorithm applies shortcut smoothing on extracted paths to ensure smooth and shorter trajectories, balancing exploration with path quality and computational speed across both 2D and 3D environments.",
    "planning_mechanism": "The planner alternates tree expansions between start and goal trees, sampling adaptively within informed ellipsoids when a path is found to bias exploration. Each new node is chosen via steering, verified for collisions and bounds, and connected with rewiring nearby nodes to minimize cost. Upon connecting the two trees, the merged path is shortcut-smoothed. Periodic pruning removes nodes that cannot improve paths, facilitating faster convergence and robustness against obstacles.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D position\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = 5.0\n        self.max_radius = 30.0\n        self.prune_interval = 200\n        self.prune_threshold = 300\n        self.smoothing_iterations = 50\n        self.collision_resolution = 1.0\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        import math\n        import random\n        import numpy as np\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            n = max(n_nodes, 1)\n            r_iter = self.max_radius * (1 - (iteration / self.max_iter) ** 0.9)\n            r_log = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.min_radius, min(r_iter, r_log))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance_edge = dist(p1, p2)\n            steps = max(1, int(distance_edge / self.collision_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            I = np.eye(dim)\n            u = direction - I[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = I - 2 * np.outer(u, u)\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((a - b) ** 2 for a, b in zip(node.position, point)) <= r2]\n\n        def prune_nodes(nodes_list, tree_start, tree_goal, best_cost):\n            to_remove = []\n            for node in nodes_list:\n                if node is root_start or node is root_goal:\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate expanding smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            nearest_a = nearest_node(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if (not in_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            neighbors = near_nodes(tree_a, new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in neighbors:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improvements\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt incremental connection from other tree\n            nearest_b = nearest_node(tree_b, new_node.position)\n            last_b = nearest_b\n            max_connect_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            connected = False\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if (not in_bounds(next_pos_b)) or is_in_obstacle(next_pos_b) or is_edge_in_obstacle(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                neighbors_b = near_nodes(tree_b, next_pos_b, r)\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is last_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and not is_edge_in_obstacle(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and not is_edge_in_obstacle(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_from_start = connection_node.path_from_root()\n                        path_from_goal = new_node.path_from_root()\n                    else:\n                        path_from_start = new_node.path_from_root()\n                        path_from_goal = connection_node.path_from_root()\n\n                    merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -0.3229,
    "time_improvement": -12.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009643340110778808,
            "num_nodes_avg": 77.1,
            "path_length_avg": 163.31726940222234,
            "success_improvement": 0.0,
            "time_improvement": 4.4156292242104564,
            "length_improvement": 18.37559847618153,
            "objective_score": 4.999808462499443
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.026294636726379394,
            "num_nodes_avg": 248.9,
            "path_length_avg": 238.22040157765733,
            "success_improvement": 0.0,
            "time_improvement": -83.82662032985807,
            "length_improvement": 20.95041140166391,
            "objective_score": -20.95790381862464
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01644265651702881,
            "num_nodes_avg": 155.1,
            "path_length_avg": 129.31015539791787,
            "success_improvement": 0.0,
            "time_improvement": 42.69212519974307,
            "length_improvement": 20.595774810858295,
            "objective_score": 16.92679252209458
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is a tuned bidirectional RRT* planner optimized for improved performance, path quality, and robustness. It features adaptive neighbor radius for rewiring, dynamic bounding of the search space, and iterative path shortcut smoothing to ensure smooth and shorter paths. The planner carefully alternates the expansion of two trees from the start and goal, validating collision-free nodes and edges while rewiring for cost optimization.",
    "planning_mechanism": "The planner samples random free points within bounds, extends the current tree toward them with collision checks on nodes and edges, selects the best parent node from neighbors minimizing cost, and rewires neighbors to improve path costs. It attempts incremental, collision-free connections between start and goal trees with rewiring on both sides. Upon connection, the algorithm reconstructs and smooths the path iteratively before returning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...] (2D or 3D)\n        self.parent = parent          # Node or None\n        self.cost = cost              # Cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 7.0,\n                 min_neighbor_radius: float = 7.0, max_neighbor_radius: float = 25.0,\n                 smoothing_iterations: int = 150, collision_check_resolution: float = 0.8):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Try 30 samples to avoid obstacles, fallback if necessary\n            for _ in range(30):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n            # fallback random sample even if inside obstacle\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp within bounds\n            return tuple(max(0, min(new_pos[i], bounds[i])) for i in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + \\\n                      (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.collision_check_resolution)\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - position[d]) ** 2 for d in range(dim)) <= r2]\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            sample_point = sample_free()\n            radius = neighbor_radius(iteration, len(nodes))\n\n            nearest_node = nearest(tree_a, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            neighbors = near_nodes(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in neighbors:\n                cost_through_node = node.cost + dist(node.position, new_pos)\n                if cost_through_node + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_through_node\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors for better cost paths\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connect attempt from tree_b towards new_node\n            connect_node = nearest(tree_b, new_node.position)\n            curr_pos = connect_node.position\n            connected = False\n\n            while True:\n                next_pos = steer(curr_pos, new_node.position)\n                if not can_add_node(next_pos) or not can_connect(curr_pos, next_pos):\n                    break\n\n                neighbors_b = near_nodes(tree_b, next_pos, radius)\n\n                min_cost_b = connect_node.cost + dist(curr_pos, next_pos)\n                best_parent_b = connect_node\n                for node_b in neighbors_b:\n                    cost_b = node_b.cost + dist(node_b.position, next_pos)\n                    if cost_b + 1e-12 < min_cost_b and can_connect(node_b.position, next_pos):\n                        min_cost_b = cost_b\n                        best_parent_b = node_b\n\n                new_node_b = Node(next_pos, parent=best_parent_b, cost=min_cost_b)\n                best_parent_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((best_parent_b, new_node_b))\n\n                # Rewiring neighbors of new_node_b\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is best_parent_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    path_start = new_node.path_from_root()\n                    path_goal = connection_node.path_from_root()\n                    extracted_path = path_start + path_goal[::-1][1:]\n                    extracted_path = shortcut_smoothing(extracted_path)\n                    connected = True\n                    break\n\n                curr_pos = new_node_b.position\n                connect_node = new_node_b\n\n            if connected:\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 10.47907,
    "time_improvement": -37.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.01812765598297119,
            "num_nodes_avg": 82.0,
            "path_length_avg": 173.58473745338588,
            "success_improvement": -9.999999999999998,
            "time_improvement": -79.68054334571647,
            "length_improvement": 13.244016629946307,
            "objective_score": -26.25535967772568
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.024157261848449706,
            "num_nodes_avg": 188.9,
            "path_length_avg": 238.8472360111225,
            "success_improvement": 0.0,
            "time_improvement": -68.88416631247343,
            "length_improvement": 20.742406529887468,
            "objective_score": -16.51676858776453
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.017768049240112306,
            "num_nodes_avg": 159.6,
            "path_length_avg": 122.84527794352934,
            "success_improvement": -9.999999999999998,
            "time_improvement": 38.07271104625896,
            "length_improvement": 24.565599018623015,
            "objective_score": 11.33493311760229
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a simplified yet efficient bidirectional RRT* inspired planner that balances exploration and exploitation by growing two trees from start and goal positions. It uses adaptive step steering, heuristic corridor-biased sampling to focus search, and local rewiring to optimize path cost. Path smoothing is applied at the end to ensure smooth and feasible trajectories, while rigorous collision and edge checks maintain robustness and safety. The method trades complexity for generalization and speed, improving planning efficiency, path quality, and success rate.",
    "planning_mechanism": "The planner alternately extends the smaller tree towards a heuristically sampled point biased near the corridor between start and goal, steering with a fixed step size. New nodes and edges are validated for collisions before integration. A rewiring step locally optimizes tree structure by considering neighbors within an adaptive radius. Upon connecting the two trees, the planner extracts and smoothes the path for improved quality.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position               # Tuple[float, ...]: 2D or 3D coordinates\n        self.parent = parent                   # Parent Node or None\n        self.cost = cost                       # Cost from root to this node\n        self.children = []                     # List[Node]\n        self.valid = True                      # For collision checking etc.\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: \"Node\", new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n\n        bounds = map.size                              # Workspace bounds (W,H) or (W,H,D)\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if (x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d):\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if (x <= px <= x + w and y <= py <= y + h):\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=0.5):\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not _is_in_obstacle(pos)\n\n        def can_connect(p1, p2):\n            return in_bounds(p1) and in_bounds(p2) and not _is_edge_in_obstacle(p1, p2)\n\n        def steer(from_pos, to_pos):\n            dist_btwn = dist(from_pos, to_pos)\n            if dist_btwn <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist_btwn\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def sample_corridor(progress_ratio: float):\n            # Sample inside corridor between start & goal with Gaussian radius shrinking as progress advances\n            line_vec = tuple(goal_position[d] - start_position[d] for d in range(dim))\n            line_len = dist(start_position, goal_position)\n            if line_len < 1e-10:\n                return start_position\n\n            # biased t around middle (0.5)\n            t = random.betavariate(2, 2)\n            base_point = tuple(start_position[d] + t * line_vec[d] for d in range(dim))\n\n            # Gaussian noise orthogonal to line_vec\n            corridor_width = max(0.5 * line_len * (1 - progress_ratio), 0.3)\n            noise = [0] * dim\n            if dim == 2:\n                ox, oy = -line_vec[1], line_vec[0]\n                norm = math.sqrt(ox * ox + oy * oy)\n                ox /= norm\n                oy /= norm\n                offset = random.gauss(0, corridor_width)\n                noise[0] = ox * offset\n                noise[1] = oy * offset\n            else:\n                # 3D orthogonal noise\n                lv = line_vec\n                lv_norm = math.sqrt(sum(c * c for c in lv))\n                lv_unit = tuple(c / lv_norm for c in lv)\n                random_vec = [random.gauss(0, 1) for _ in range(dim)]\n                proj_len = sum(random_vec[d] * lv_unit[d] for d in range(dim))\n                perp_vec = [random_vec[d] - proj_len * lv_unit[d] for d in range(dim)]\n                norm_pv = math.sqrt(sum(c * c for c in perp_vec))\n                if norm_pv > 1e-10:\n                    perp_unit = [c / norm_pv for c in perp_vec]\n                    offset = random.gauss(0, corridor_width)\n                    for d in range(dim):\n                        noise[d] = perp_unit[d] * offset\n                else:\n                    noise = [0] * dim\n\n            sample = tuple(\n                min(max(base_point[d] + noise[d], 0), bounds[d]) for d in range(dim)\n            )\n            if can_add_node(sample):\n                return sample\n\n            # fallback uniform random sample\n            while True:\n                s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if can_add_node(s):\n                    return s\n\n        def find_nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def radius_dynamic(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 2\n            from math import log, sqrt\n            return max(self.step_size * 2, 10 * sqrt(log(n_nodes) / n_nodes))\n\n        # Main loop:\n        for itr in range(self.max_iter):\n            progress_ratio = itr / self.max_iter\n            # Goal bias sampling: 20% chance pick goal exactly, else corridor sample\n            if random.random() < 0.2:\n                sample = goal_position\n            else:\n                sample = sample_corridor(progress_ratio)\n\n            # Always extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            nearest = find_nearest(tree_start, sample)\n            new_pos = steer(nearest.position, sample)\n\n            if not can_add_node(new_pos) or not can_connect(nearest.position, new_pos):\n                continue\n\n            radius = radius_dynamic(len(tree_start) + 1)\n            near = near_nodes(tree_start, new_pos, radius)\n\n            # Choose best parent based on cost + collision-free path\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for node in near:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_start.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near nodes to new_node if cost improvement and collision-free\n            for node in near:\n                if node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, node.position)\n                if cost_through_new + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, node))\n\n            # Try to connect opposite tree to new_node\n            nearest_other = find_nearest(tree_goal, new_node.position)\n            if dist(new_node.position, nearest_other.position) <= self.step_size:\n                if can_connect(new_node.position, nearest_other.position):\n                    # Successful connection - extract path\n                    success_state = True\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_other.path_from_root()\n                    extracted_path = path_start + path_goal[::-1][1:]  # avoid repeat node\n\n                    # Path smoothing by shortcutting\n                    def shortcut_smooth(path):\n                        if len(path) < 3:\n                            return path\n                        improved = True\n                        max_smth = 30\n                        iteration = 0\n                        while improved and iteration < max_smth:\n                            improved = False\n                            iteration += 1\n                            i = 0\n                            while i < len(path) - 2:\n                                j = i + 2\n                                while j < len(path):\n                                    if can_connect(path[i], path[j]):\n                                        del path[i + 1:j]\n                                        improved = True\n                                        break\n                                    j += 1\n                                if not improved:\n                                    i += 1\n                                else:\n                                    break\n                        return path\n\n                    extracted_path = shortcut_smooth(extracted_path)\n\n                    return PlannerResult(\n                        success=success_state,\n                        path=extracted_path,\n                        nodes=nodes,\n                        edges=edges\n                    )\n\n        # Failure, no path found within max_iter\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 295.18582,
    "time_improvement": -970.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.06529579162597657,
            "num_nodes_avg": 153.7,
            "path_length_avg": 174.14321184508137,
            "success_improvement": 0.0,
            "time_improvement": -547.2090671052756,
            "length_improvement": 12.964896496751733,
            "objective_score": -161.56974083223236
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.10112934112548828,
            "num_nodes_avg": 384.7,
            "path_length_avg": 237.63290307318871,
            "success_improvement": 0.0,
            "time_improvement": -606.9983582101992,
            "length_improvement": 21.145363281405587,
            "objective_score": -177.87043480677863
        },
        {
            "map_id": 2,
            "success_rate": 0.5,
            "time_avg": 0.5321126222610474,
            "num_nodes_avg": 1379.0,
            "path_length_avg": 120.04444266595053,
            "success_improvement": -50.0,
            "time_improvement": -1754.581314436095,
            "length_improvement": 26.285480604212236,
            "objective_score": -546.1172982099861
        }
    ],
    "success_rate": 0.8333333333333334
}
{
    "operator": "cross_over",
    "algorithm_description": "An improved bidirectional RRT* planner combining adaptive goal biasing, dynamic neighbor radius rewiring, and rigorous collision checking. It alternates growth between start and goal trees, always extending the smaller tree to balance exploration. It incorporates heuristic sampling biased towards the goal, dynamic radius shrinking with node growth, and performs local rewiring to optimize path cost incrementally. Once trees are connected, the path is reconstructed and refined with randomized shortcut smoothing and final path simplification. The approach prioritizes reducing path length and planning time while ensuring high success and path quality.",
    "planning_mechanism": "A bidirectional RRT* variant grows two trees rooted at start and goal. It samples collision-free points with a goal bias, extends the smaller tree towards samples using fixed step size, and rewires neighbors within a dynamically calculated radius based on tree size to optimize paths locally. On successful tree connection, it backtracks from the connection nodes to form the full path, followed by a shortcut smoothing step to reduce path length and increase smoothness. Throughout, collision checks on nodes and edges guarantee feasibility, and alternating tree expansion balances exploration for better efficiency and success rates.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 40.0, radius_min: float = 5.0,\n                 smoothing_iters: int = 120, collision_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.smoothing_iters = smoothing_iters\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                # Bias towards goal mostly, occasionally start for balanced exploration\n                return goal_position if random.random() < 0.8 else start_position\n            else:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # Fallback uniform sample if unlucky\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d_] + ratio * (to_pos[d_] - from_pos[d_]) for d_ in range(len(from_pos)))\n            # Clamp to bounds rigorously\n            return tuple(max(0.0, min(new_pos[d_], bounds[d_])) for d_ in range(len(bounds)))\n\n        def radius_by_nodes(n_nodes):\n            # Decreases with more nodes; prevents overuse of large radius (faster local improvements)\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(self.radius_min, val)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if sum((node.position[d] - pos[d]) ** 2 for d in range(len(pos))) <= radius_sq]\n\n        def is_collision_free_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_collision_free_edge(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            if dist(p1, p2) < 1e-12:\n                return True\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not is_collision_free_node(new_pos) or not is_collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                cost_thru_node = node.cost + dist(node.position, new_pos)\n                if cost_thru_node + 1e-12 < min_cost and is_collision_free_edge(node.position, new_pos):\n                    min_cost = cost_thru_node\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better path costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and is_collision_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree or node is None:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not is_collision_free_node(new_pos) or not is_collision_free_edge(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if is_collision_free_edge(new_pos, node.position):\n                        final_node = Node(node.position, parent=new_node,\n                                          cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def shortcut_smoothing(path: list) -> list:\n            if len(path) < 3:\n                return path[:]\n            smoothed = path[:]\n            for _ in range(self.smoothing_iters):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if is_collision_free_edge(smoothed[i], smoothed[j]):\n                    smoothed = smoothed[:i + 1] + smoothed[j:]\n            return smoothed\n\n        # Initialization\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        for iteration in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Always extend smaller tree first for balanced and efficient growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                full_path = path_from_start + path_from_goal[::-1][1:]\n\n                # Use shortcut smoothing with collision checks to reduce path length and increase smoothness\n                extracted_path = shortcut_smoothing(full_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 24.56309,
    "time_improvement": -96.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01574430465698242,
            "num_nodes_avg": 74.5,
            "path_length_avg": 160.02617751222635,
            "success_improvement": 0.0,
            "time_improvement": -56.056867916323995,
            "length_improvement": 20.02045457048235,
            "objective_score": -12.81296946080073
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04121623039245605,
            "num_nodes_avg": 299.1,
            "path_length_avg": 238.03443525744714,
            "success_improvement": 0.0,
            "time_improvement": -188.14394412914302,
            "length_improvement": 21.012121318230268,
            "objective_score": -52.24075897509685
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04126429557800293,
            "num_nodes_avg": 247.0,
            "path_length_avg": 126.12590632480143,
            "success_improvement": 0.0,
            "time_improvement": -43.81916220508034,
            "length_improvement": 22.55109556414326,
            "objective_score": -8.635529548695448
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This new planner integrates a bidirectional anytime RRT* approach with adaptive informed sampling and dynamic tree balancing. It uses a KD-tree for fast nearest neighbor queries and caching for collision checks. The planner incrementally grows two trees from start and goal positions, adaptively shrinking the sampling space based on the current best path cost (informed ellipsoid sampling). Nodes are rewired locally to improve path costs continuously. To enhance robustness and efficiency, periodic pruning removes nodes unlikely to contribute to better paths, and multiple path-smoothing iterations refine the final trajectory. This design achieves faster convergence, improved path quality, and higher success rates in complex 2D and 3D environments.",
    "planning_mechanism": "The planner maintains two trees growing bidirectionally, always extending the smaller tree towards samples biased within an informed ellipsoid based on the best known path cost. It utilizes KD-tree structures to perform efficient nearest neighbor and radius searches for rewiring and node connections, caching collision checks for speed. Upon a successful connection of the two trees, it applies intensive shortcut smoothing. Periodic pruning eliminates suboptimal nodes, thereby focusing the search efficiently and reducing overhead. This mechanism balances exploration with exploitation and dynamically adapts search to promising regions, ensuring high-quality, smooth, and efficient path planning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checks etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 prune_interval: int = 150, prune_threshold: int = 250,\n                 smoothing_rounds: int = 120,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_rounds = smoothing_rounds\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree for efficient nearest and radius queries\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = np.array([p for p, n in points_nodes])\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, point):\n                if len(self.points) == 0:\n                    return None\n                diff = self.points - np.array(point)\n                dists = np.linalg.norm(diff, axis=1)\n                idx = np.argmin(dists)\n                return self.nodes[idx]\n\n            def radius_search(self, point, radius):\n                if len(self.points) == 0:\n                    return []\n                diff = self.points - np.array(point)\n                dists = np.linalg.norm(diff, axis=1)\n                idxs = np.where(dists <= radius)[0]\n                return [self.nodes[i] for i in idxs]\n\n        # Caches for collision checks for edges\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            rev_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return not edge_collision_cache[rev_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            coll = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = coll\n            return not coll\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        # Informed ellipsoidal sampling\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(15):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) * 0.5 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            # Compute rotation matrix via Householder reflection\n            id_mat = np.eye(dim)\n            e1 = np.zeros(dim)\n            e1[0] = 1.0\n            v = a1 - e1\n            s = np.linalg.norm(v)\n            if s > 1e-10:\n                u = v / s\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1**2 - (c_min / 2)**2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    scaled = x * radii\n                    sample = rot @ scaled + center\n                    point = tuple(float(coord) for coord in sample)\n                    if in_bounds(point) and not is_in_obstacle(point):\n                        return point\n\n            # Fallback uniform\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # last fallback\n\n        # Dynamic neighbor radius based on number of nodes and iteration progress\n        def neighbor_radius(iteration, n_nodes):\n            if n_nodes == 0:\n                return self.step_size * 2\n            r_iter = 50 * (1 - (iteration / self.max_iter) ** 0.95)\n            r_log = self.step_size + 40 * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.step_size, min(r_iter, r_log))\n\n        # Shortcut smoothing for path\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            path = path[:]\n            for _ in range(self.smoothing_rounds):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Prune nodes unlikely to improve best path\n        def prune_nodes(best_cost):\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except Exception:\n                        pass\n                try:\n                    nodes.remove(node)\n                except Exception:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n            return len(to_remove)\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            # Sample adaptive informed points\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Always extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            # Build KD-tree for tree_a for near/nearest queries\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            if nearest_a is None:\n                continue\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                c_tent = node.cost + dist(node.position, new_pos)\n                if c_tent + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = c_tent\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better cost\n            for neighbor in near_nodes_a:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except Exception:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt to connect tree_b to new_node incrementally\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            if nearest_b is None:\n                continue\n\n            last_node_b = nearest_b\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            connection_made = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except Exception:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_smoothing(merged_path)\n\n                    connection_made = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connection_made:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to reduce overhead and focus search\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 20.93857,
    "time_improvement": -84.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01796424388885498,
            "num_nodes_avg": 78.8,
            "path_length_avg": 160.0910402281309,
            "success_improvement": 0.0,
            "time_improvement": -78.06080972501867,
            "length_improvement": 19.988036808501043,
            "objective_score": -19.420635555805394
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03698420524597168,
            "num_nodes_avg": 249.4,
            "path_length_avg": 237.07282046977184,
            "success_improvement": 0.0,
            "time_improvement": -158.55772516272054,
            "length_improvement": 21.331217637657083,
            "objective_score": -43.30107402128475
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03332986831665039,
            "num_nodes_avg": 184.0,
            "path_length_avg": 124.12826160044786,
            "success_improvement": 0.0,
            "time_improvement": -16.165165806480026,
            "length_improvement": 23.777769765039213,
            "objective_score": -0.093995788936164
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid algorithm combines the asymptotically optimal rewiring and cost-aware mechanisms from the first algorithm with the efficient bidirectional tree growth and connection strategy of the second algorithm. It adds adaptive radius for rewiring to speed convergence and incorporates path smoothing via shortcutting at the end to enhance path quality and smoothness. The planner attempts to maintain balance between exploration (random sampling) and exploitation (cost optimization and rewiring), improving success rate and reducing search time.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternating expansions toward randomly sampled collision-free points. Each extension rewires nearby nodes within a dynamically computed radius to optimize path cost, and attempts are made to connect the two trees in a collision-free manner. Upon successful connection, the combined path is extracted, and a post-processing shortcut smoothing step refines the path for smoothness and shorter length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        # Remove self from old parent's children list if exists\n        if self.parent:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root = Node(goal_position, parent=None, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            dist_val = dist(from_pos, to_pos)\n            if dist_val <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist_val\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def sample_free():\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def collision_free_edge(pos_a, pos_b):\n            return (not self._is_in_obstacle(pos_b, obstacles, is_3d)) and (not self._is_edge_in_obstacle(pos_a, pos_b, obstacles, is_3d))\n\n        def rewire(tree, new_node, radius):\n            neighbors = near_nodes(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-8 < neighbor.cost:\n                    if collision_free_edge(new_node.position, neighbor.position):\n                        neighbor.update_parent(new_node, potential_cost)\n\n        def connect_trees(node_from, tree_other):\n            nearest_other = nearest(tree_other, node_from.position)\n            # Try connecting by incremental steering from nearest_other toward node_from\n            current_pos = nearest_other.position\n            prev_node = nearest_other\n            while True:\n                new_pos = steer(current_pos, node_from.position)\n                if not collision_free_edge(current_pos, new_pos):\n                    return None\n                new_cost = prev_node.cost + dist(prev_node.position, new_pos)\n                new_node = Node(new_pos, parent=prev_node, cost=new_cost)\n                prev_node.add_child(new_node)\n                tree_other.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n\n                if dist(new_pos, node_from.position) <= self.step_size:\n                    # Final connecting node\n                    if collision_free_edge(new_pos, node_from.position):\n                        final_cost = new_node.cost + dist(new_pos, node_from.position)\n                        final_node = Node(node_from.position, parent=new_node, cost=final_cost)\n                        new_node.add_child(final_node)\n                        tree_other.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                prev_node = new_node\n                current_pos = new_pos\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            # Try shortcut smoothing by randomly attempting to connect non-consecutive points directly\n            if len(path) < 3:\n                return path\n            import random\n            max_attempts = max(100, len(path)*5)\n            smoothed = path[:]\n            for _ in range(max_attempts):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed)-3)\n                j = random.randint(i+2, len(smoothed)-1)\n                p1 = smoothed[i]\n                p2 = smoothed[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # shortcut possible -> remove intermediate points\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        for it in range(self.max_iter):\n            sample = sample_free()\n\n            # Alternate tree expansion per iteration for balanced growth\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n\n                if not collision_free_edge(nearest_node.position, new_pos):\n                    continue\n\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Adaptive rewiring radius decreases as number of nodes grows (like RRT*)\n                radius = min(30.0, 50.0 * ((math.log(len(tree_a)+1) / (len(tree_a)+1)) ** 0.5))\n\n                # Rewire near neighbors to improve local path cost\n                rewire(tree_a, new_node, radius)\n\n                # Try connecting to opposite tree and rewire opposite tree nearby nodes on connection\n                connected_node = connect_trees(new_node, tree_b)\n                if connected_node is not None:\n                    # Rewire around connecting node in opposite tree to improve path\n                    rewire(tree_b, connected_node, radius)\n                    success_state = True\n                    extracted_path = extract_path(new_node, connected_node)\n                    # Path smoothing by shortcutting\n                    extracted_path = shortcut_path(extracted_path)\n                    return PlannerResult(success_state, extracted_path, nodes, edges)\n\n        # If no path found after max_iter\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 4.75742,
    "time_improvement": -29.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.014185929298400879,
            "num_nodes_avg": 88.1,
            "path_length_avg": 164.1092800630312,
            "success_improvement": 0.0,
            "time_improvement": -40.6103186531681,
            "length_improvement": 17.979759160317187,
            "objective_score": -8.587143763886992
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.023843717575073243,
            "num_nodes_avg": 242.7,
            "path_length_avg": 242.25516288870887,
            "success_improvement": 0.0,
            "time_improvement": -66.69216857931012,
            "length_improvement": 19.611541096606793,
            "objective_score": -16.085342354471678
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.023023700714111327,
            "num_nodes_avg": 292.3,
            "path_length_avg": 126.42322177324938,
            "success_improvement": 0.0,
            "time_improvement": 19.75509817428814,
            "length_improvement": 22.36852596821227,
            "objective_score": 10.400234645928897
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner is an enhanced bidirectional informed RRT* variant integrating adaptive ellipsoidal sampling, KD-tree accelerated nearest neighbor and radius searches, collision caching, incremental rewiring, pruning, and shortcut smoothing to improve efficiency, path quality, robustness, and success rate in both 2D and 3D path planning tasks.",
    "planning_mechanism": "The planner alternates growth between two trees from start and goal, biasing sampling inside an adaptive ellipsoid around the best current path to focus search on promising regions. KD-trees speed up nearest neighbor and local rewiring to optimize costs. It incrementally extends connections, performs collision caching, prunes nodes unlikely to improve best solutions periodically, and applies shortcut smoothing to refine the final path for smoothness and length improvement.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Ellipsoidal informed sampling\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # No solution yet or marginal improvement: uniform sample\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))  # unit vector start->goal\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) * (c_min / 2), 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    x = x * radii\n                    p = rot @ x + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback last sample\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors for cost improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 3.31952,
    "time_improvement": -26.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.010067939758300781,
            "num_nodes_avg": 72.2,
            "path_length_avg": 161.84981114355097,
            "success_improvement": 0.0,
            "time_improvement": 0.207015852309783,
            "length_improvement": 19.109020009395124,
            "objective_score": 3.88390875757196
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.025036144256591796,
            "num_nodes_avg": 208.8,
            "path_length_avg": 234.63653959753782,
            "success_improvement": 0.0,
            "time_improvement": -75.02846046786841,
            "length_improvement": 22.139658054114502,
            "objective_score": -18.080606529537626
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.029380106925964357,
            "num_nodes_avg": 198.1,
            "path_length_avg": 122.48105292818816,
            "success_improvement": 0.0,
            "time_improvement": -2.398994200699506,
            "length_improvement": 24.78925511932657,
            "objective_score": 4.238152763655462
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner with adaptive step sizes, ellipsoidal informed sampling that focuses sampling within an elliptical region defined by the current best path cost, goal biasing for directed exploration, and aggressive rewiring for path optimization and smoothing. It balances exploration and exploitation to improve planning efficiency, success rate, path quality, and smoothness while maintaining robustness in both 2D and 3D environments.",
    "planning_mechanism": "The planner alternates growing two trees from start and goal, samples points biased inside an ellipsoid when a solution is known, extends trees towards samples with adaptive step size and rewires nearby nodes to improve cost. Upon attempting to connect the two trees within step size and collision-free constraints, it extracts the combined path, applies iterative smoothing shortcuts, and returns the final optimized path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def rewire(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        new_parent.children.append(self)\n        self.cost = new_cost\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 6000,\n        step_size: float = 7.0,\n        goal_sample_rate: float = 0.15,\n        search_radius_factor: float = 25.0,\n        smoothing_iterations: int = 10,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate      # Probability of sampling goal directly\n        self.search_radius_factor = search_radius_factor\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math, random, numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_path_cost = float(\"inf\")\n        success_state = False\n        extracted_path = []\n\n        dimension = len(bounds)\n\n        def calc_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 2\n            gamma = self.search_radius_factor\n            unit_ball_volume = math.pi if dimension == 2 else (4.0 / 3.0) * math.pi\n            r = min(\n                self.step_size * 7,\n                gamma * ((math.log(n_nodes) / n_nodes) ** (1 / dimension))\n            )\n            return r if r > self.step_size else self.step_size * 1.5\n\n        def unit_vector(v):\n            norm = np.linalg.norm(v)\n            if norm < 1e-10:\n                return np.zeros_like(v)\n            return v / norm\n\n        def ellipse_sample(c_best, start, goal):\n            # Uniform sampling if no solution yet\n            if c_best == float(\"inf\"):\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[i]) for i in range(3))\n                    else:\n                        p = tuple(random.uniform(0, bounds[i]) for i in range(2))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n            a1 = np.array([g - s for s, g in zip(start, goal)])\n            c_min = np.linalg.norm(a1)\n            if c_min < 1e-10:\n                return start\n\n            e1 = unit_vector(a1)\n            # Orthonormal basis\n            if dimension == 2:\n                e2 = np.array([-e1[1], e1[0]])\n                basis = np.column_stack((e1, e2))\n            else:\n                # Gram-Schmidt for 3D\n                if abs(e1[0]) < abs(e1[1]):\n                    v = np.array([1, 0, 0])\n                else:\n                    v = np.array([0, 1, 0])\n                e2 = v - np.dot(v, e1) * e1\n                e2 /= np.linalg.norm(e2)\n                e3 = np.cross(e1, e2)\n                basis = np.column_stack((e1, e2, e3))\n\n            r1 = c_best / 2.0\n            val = max(c_best ** 2 - c_min ** 2, 0.0)\n            r2 = math.sqrt(val) / 2.0\n            r2 = r2 if r2 > 1e-6 else self.step_size * 3.0\n\n            while True:\n                # Sample from unit ball\n                if dimension == 2:\n                    direction = np.random.normal(0, 1, 2)\n                else:\n                    direction = np.random.normal(0, 1, 3)\n                direction /= np.linalg.norm(direction)\n                # Uniform radius in unit ball\n                radius_u = random.uniform(0, 1) ** (1 / dimension)\n                sample_ball = direction * radius_u\n                scale = np.array([r1, r2] + ([r2] if dimension == 3 else []))\n                point = center + np.dot(basis, sample_ball * scale)\n                p = tuple(np.clip(point, [0]*dimension, bounds))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if math.dist(node.position, point) <= radius]\n\n        def steer(from_pos, to_pos, step_size):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step_size:\n                new_pos = to_pos\n            else:\n                ratio = step_size / dist\n                new_pos = tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n            # Clamp inside bounds\n            new_pos_clamped = tuple(max(0, min(new_pos[i], bounds[i])) for i in range(len(new_pos)))\n            return new_pos_clamped\n\n        for iteration in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = ellipse_sample(best_path_cost, start_position, goal_position)\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=0.3):\n                    continue\n\n                radius = calc_radius(len(tree_a) + 1)\n                neighbors = near(tree_a, new_pos, radius)\n\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_node in neighbors:\n                    tentative_cost = near_node.cost + math.dist(near_node.position, new_pos)\n                    if tentative_cost < min_cost:\n                        if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution=0.3):\n                            min_cost = tentative_cost\n                            min_parent = near_node\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors to new_node if improves cost\n                for near_node in neighbors:\n                    if near_node is min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                    if new_cost < near_node.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=0.3):\n                            near_node.rewire(new_node, new_cost)\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            edges.append((new_node, near_node))\n\n                # Try connecting to tree_b\n                connect_node = nearest(tree_b, new_node.position)\n                distance_connect = math.dist(new_node.position, connect_node.position)\n                if distance_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d, resolution=0.3):\n                        # Path found - extract full path\n                        success_state = True\n\n                        path_from_start = []\n                        node = new_node\n                        while node:\n                            path_from_start.append(node.position)\n                            node = node.parent\n                        path_from_start.reverse()\n\n                        path_from_goal = []\n                        node = connect_node\n                        while node:\n                            path_from_goal.append(node.position)\n                            node = node.parent\n\n                        extracted_path = path_from_start + path_from_goal\n\n                        total_cost = new_node.cost + connect_node.cost\n                        if total_cost < best_path_cost:\n                            best_path_cost = total_cost\n\n                        extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n                        return PlannerResult(True, extracted_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import random\n        if len(path) < 3:\n            return path[:]\n\n        smoothed = path[:]\n        for _ in range(self.smoothing_iterations):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d, resolution=0.3):\n                smoothed = smoothed[:i + 1] + smoothed[j:]\n        return smoothed",
    "objective": 14.99888,
    "time_improvement": -57.0,
    "length_improvement": 11.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02059333324432373,
            "num_nodes_avg": 138.1,
            "path_length_avg": 188.26669941321614,
            "success_improvement": 0.0,
            "time_improvement": -104.12022989157663,
            "length_improvement": 5.906113158053538,
            "objective_score": -30.05484633586228
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.021007442474365236,
            "num_nodes_avg": 240.4,
            "path_length_avg": 270.13946445844925,
            "success_improvement": 0.0,
            "time_improvement": -46.86368144277488,
            "length_improvement": 10.358586467859952,
            "objective_score": -11.987387139260473
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0348435640335083,
            "num_nodes_avg": 305.9,
            "path_length_avg": 134.53183070218137,
            "success_improvement": 0.0,
            "time_improvement": -21.44087563703807,
            "length_improvement": 17.38935161502788,
            "objective_score": -2.954392368105844
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a simplified and generalized bidirectional RRT* planner with adaptive informed sampling inside an ellipsoidal region focused between start and goal. It balances exploration and exploitation by alternately growing two trees from the start and goal positions, dynamically adjusting neighbor search radius for efficient rewiring and pruning to maintain manageable complexity. The planner ensures collision-free node placement and edge connection, progressively improves path quality through shortcut path smoothing, and stops once a feasible, smooth path is found or iteration limit is reached.",
    "planning_mechanism": "The planner grows two trees from start and goal by sampling points informed by the current best path cost, steering towards these points while avoiding obstacles and boundaries. It connects nodes via collision-checked edges, rewires nearby nodes for cost improvement, and attempts to connect the two trees incrementally. Upon successful connection, the planner extracts, smooths, and returns the optimized path alongside the explored nodes and edges.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = 5.0\n        self.max_radius = 25.0\n        self.smoothing_iterations = 30\n        self.collision_resolution = 1.0\n        self.goal_sample_rate = 0.2  # probability to sample goal directly\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        import math\n        import random\n        import numpy as np\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            n = max(n_nodes, 1)\n            r_iter = self.max_radius * (1 - (iteration / self.max_iter) ** 0.9)\n            r_log = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.min_radius, min(r_iter, r_log))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance_edge = dist(p1, p2)\n            steps = max(1, int(distance_edge / self.collision_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # Uniform random sampling in bounds (with check)\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            I = np.eye(dim)\n            u = direction - I[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = I - 2 * np.outer(u, u)\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # Fallback uniform sampling\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if sum((a - b) ** 2 for a, b in zip(node.position, point)) <= radius_sq]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not is_edge_in_obstacle(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                q_rand = goal_pos\n            else:\n                q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate expand smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            nearest_a = nearest_node(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if (not in_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            neighbors = near_nodes(tree_a, new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in neighbors:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if improved\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try incremental connection from other tree\n            nearest_b = nearest_node(tree_b, new_node.position)\n            last_b = nearest_b\n            max_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if (not in_bounds(next_pos_b)) or is_in_obstacle(next_pos_b) or is_edge_in_obstacle(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.add_child(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                neighbors_b = near_nodes(tree_b, next_pos_b, r)\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b < neighbor_b.cost and not is_edge_in_obstacle(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and not is_edge_in_obstacle(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.add_child(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_from_start = connection_node.path_from_root()\n                        path_from_goal = new_node.path_from_root()\n                    else:\n                        path_from_start = new_node.path_from_root()\n                        path_from_goal = connection_node.path_from_root()\n\n                    merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                    if final_cost < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                break\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 10.41258,
    "time_improvement": -48.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.006945180892944336,
            "num_nodes_avg": 83.3,
            "path_length_avg": 162.7631822288285,
            "success_improvement": 0.0,
            "time_improvement": 31.159666884080572,
            "length_improvement": 18.652525919836677,
            "objective_score": 13.078405249191508
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04181349277496338,
            "num_nodes_avg": 336.9,
            "path_length_avg": 243.25230759521227,
            "success_improvement": 0.0,
            "time_improvement": -192.31942395679675,
            "length_improvement": 19.280654748082156,
            "objective_score": -53.839696237422594
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.023754334449768065,
            "num_nodes_avg": 239.2,
            "path_length_avg": 127.34111422002702,
            "success_improvement": 0.0,
            "time_improvement": 17.20860779394743,
            "length_improvement": 21.8048847111195,
            "objective_score": 9.52355928040813
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This algorithm fuses the strengths of bidirectional PRM*-inspired adaptive sampling and balanced RRT* growth to yield an efficient, high-quality planner. It employs dynamic radius rewiring, KD-tree accelerated neighbor searches, and lazy collision checking to minimize expensive operations. Adaptive sampling biases new samples around the current best path corridor and obstacles, while alternating expansions of balanced trees enable rapid convergence. Periodic pruning removes unpromising nodes to maintain tractability. The planner incrementally improves paths by rewiring and applies intensive shortcut smoothing upon solution discovery, optimizing both path length and smoothness with reduced planning time and enhanced robustness across 2D/3D spaces.",
    "planning_mechanism": "The planner initializes two bidirectional trees from start and goal. It adaptively samples points biased around the best path corridor when available, otherwise uniformly, ensuring samples are free and in bounds. Using KD-trees, it efficiently finds neighbors within a dynamic radius based on node count to select parents minimizing costs and to rewire neighbors for local improvements. The planner alternately extends the smaller tree towards new samples, then aggressively tries to connect the opposite tree via iterative steering with collision checks. Lazy collision checking caches edge validations to avoid redundant costly operations. Periodic pruning eliminates dead or unpromising nodes to maintain efficiency. Upon successful connection, it extracts and shortcut-smooths the combined path to optimize length and smoothness before returning the final result.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=6.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, bisect\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos):\n            total_d = dist(from_pos, to_pos)\n            if total_d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / total_d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            val = self.max_neighbor_radius * math.sqrt(math.log(n_nodes)/n_nodes)\n            return max(self.min_neighbor_radius, min(val, self.max_neighbor_radius))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # Lazy collision checking cache for edges\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        # KD-tree like helper for fast nearest and radius query (simple linear for moderate scale)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [p for p,n in points_nodes]\n                self.nodes = [n for p,n in points_nodes]\n                self.dim = dim\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p,n in zip(self.points, self.nodes):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, r):\n                r2 = r*r\n                result = []\n                for p,n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for i in range(self.dim):\n                        delta = p[i] - pt[i]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(n)\n                return result\n\n        # Adaptive sampling biased around best path corridor with Gaussian noise, fallback uniform\n        def adaptive_sample(best_path):\n            if best_path:\n                import numpy as np\n                attempts = 40\n                for _ in range(attempts):\n                    base_point = best_path[random.randint(0, len(best_path)-1)]\n                    noise = np.random.normal(0, self.step_size*1.0, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            # goal bias and uniform fallback\n            if random.random() < self.goal_sample_rate:\n                if random.random() < 0.5:\n                    return goal_pos\n                else:\n                    return start_pos\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # Shortcut smoothing of path via collision-check verified shortcuts\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def extract_path(node):\n            return node.path_from_root()\n\n        def prune_nodes(tree_nodes, best_cost, root_start, root_goal):\n            removed_nodes = 0\n            to_remove = []\n            for node in tree_nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm in to_remove:\n                if rm.parent:\n                    try:\n                        rm.parent.children.remove(rm)\n                    except ValueError:\n                        pass\n                try:\n                    tree_nodes.remove(rm)\n                except ValueError:\n                    pass\n                removed_nodes += 1\n            return removed_nodes\n\n        # Main variables\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        nodes = [root_start, root_goal]\n        edges = []\n\n        best_path = []\n        c_best = float('inf')\n        success_state = False\n        extracted_path = []\n\n        # Main planner loop\n        for it in range(self.max_iter):\n            sample_point = adaptive_sample(best_path)\n\n            # Alternate expanding smaller tree for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(sample_point)\n            new_pos = steer(nearest_a.position, sample_point)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            # Choose parent with minimal cost that can connect\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for nbr in near_nodes:\n                candidate_cost = nbr.cost + dist(nbr.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(nbr.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for possible cost improvements\n            for nbr in near_nodes:\n                if nbr is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                if c_via_new + 1e-12 < nbr.cost and can_connect(new_node.position, nbr.position):\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                    except ValueError:\n                        pass\n                    nbr.update_parent(new_node, c_via_new)\n                    edges.append((new_node, nbr))\n\n            # Attempt to connect opposite tree toward new_node with iterative steering\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_connect_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 5\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes))\n                near_b_nodes = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_b_nodes:\n                    if nbr_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if c_via_new_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    connection_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=connection_cost)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n                    success_state = True\n\n                    # Extract combined path\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if connection_cost + 1e-12 < c_best:\n                        c_best = connection_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning of unpromising nodes to maintain efficiency\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                removed_start = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_goal = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 16.77877,
    "time_improvement": -70.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009657025337219238,
            "num_nodes_avg": 86.4,
            "path_length_avg": 166.61317672450994,
            "success_improvement": 0.0,
            "time_improvement": 4.279981850665,
            "length_improvement": 16.728335675104866,
            "objective_score": 4.629661690220473
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.028910040855407715,
            "num_nodes_avg": 273.7,
            "path_length_avg": 242.09832486199966,
            "success_improvement": 0.0,
            "time_improvement": -102.11099165770764,
            "length_improvement": 19.6635852599355,
            "objective_score": -26.70058044532519
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06047048568725586,
            "num_nodes_avg": 296.6,
            "path_length_avg": 122.4452129476676,
            "success_improvement": 0.0,
            "time_improvement": -110.75882837344537,
            "length_improvement": 24.811263026402948,
            "objective_score": -28.26539590675302
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This implementation improves the bidirectional RRT* path planner by incorporating an adaptive dynamic goal bias that increases over time to balance exploration and exploitation, uses a caching incremental KD-tree for efficient nearest neighbor queries, performs early termination immediately upon connecting both trees, applies partial rewiring only on promising neighbors to reduce computation, and employs a refined path smoothing method with randomized shortcut attempts for better path quality and smoothness. It constrains sampling within map bounds and aggressively prunes connections that collide with obstacles to maintain robustness and reduce planning time.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal states, alternating growth each iteration. It samples points with an adaptive goal bias, finds nearest neighbors efficiently via KD-tree, steers towards sampled points respecting step limits and map boundaries, checks collisions rigorously for nodes and edges, rewires local neighbors to optimize costs selectively, connects trees as soon as possible for early success, reconstructs the combined path, and finally smooths it through randomized shortcutting to produce a shorter and smoother path, thus improving efficiency, robustness, and path quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, neighbor_radius_factor: float = 2.5, max_goal_sample_rate: float = 0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius_factor = neighbor_radius_factor  # Multiplier on step_size for neighbor radius \n        self.max_goal_sample_rate = max_goal_sample_rate      # Upper bound for adaptive goal bias\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Adaptive goal sample rate increases up to max_goal_sample_rate over iterations to balance exploration and exploitation\n        def adaptive_goal_sample_rate(iter_idx):\n            ratio = min(iter_idx / (self.max_iter * 0.8), 1.0)\n            return 0.05 + ratio * (self.max_goal_sample_rate - 0.05)\n\n        # KD-Tree approximation with incremental brute-force and caching to speed nearest/near queries\n        class KDTree:\n            def __init__(self):\n                self.nodes = []\n                self.positions = []\n\n            def insert(self, node):\n                self.nodes.append(node)\n                self.positions.append(node.position)\n\n            def nearest(self, point):\n                best_node = None\n                best_dist_sq = float('inf')\n                for node_pos, node in zip(self.positions, self.nodes):\n                    dist_sq = 0.0\n                    for i in range(dim):\n                        diff = node_pos[i] - point[i]\n                        dist_sq += diff * diff\n                        if dist_sq > best_dist_sq:\n                            break\n                    else:\n                        if dist_sq < best_dist_sq:\n                            best_dist_sq = dist_sq\n                            best_node = node\n                return best_node\n\n            def near(self, point, radius):\n                radius_sq = radius * radius\n                neighbors = []\n                for node_pos, node in zip(self.positions, self.nodes):\n                    dist_sq = 0.0\n                    for i in range(dim):\n                        diff = node_pos[i] - point[i]\n                        dist_sq += diff * diff\n                        if dist_sq > radius_sq:\n                            break\n                    else:\n                        neighbors.append(node)\n                return neighbors\n\n        def sample_free(iter_idx):\n            p_goal_sample = adaptive_goal_sample_rate(iter_idx)\n            if random.random() < p_goal_sample:\n                # Direct goal sample with small noise to increase connection chances but avoid duplicates exactly on goal\n                if is_3d:\n                    noise = tuple(random.uniform(-0.1, 0.1) for _ in range(dim))\n                else:\n                    noise = (random.uniform(-0.1, 0.1), random.uniform(-0.1, 0.1)) if dim==2 else tuple(random.uniform(-0.1,0.1) for _ in range(dim))\n                goal_sample = tuple(max(0.0, min(bounds[d], goal_position[d] + noise[d])) for d in range(dim))\n                if not self._is_in_obstacle(goal_sample, obstacles, is_3d):\n                    return goal_sample\n            # Uniform random sample inside bounds with rejection sampling for obstacle avoidance\n            trial = 0\n            max_trials = 100\n            while True:\n                sample = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n                trial += 1\n                if trial > max_trials:\n                    # If stuck, return goal to bias connection\n                    return goal_position\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0.0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        # Initialize trees\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        kd_start = KDTree()\n        kd_goal = KDTree()\n        kd_start.insert(start_root)\n        kd_goal.insert(goal_root)\n\n        neighbor_radius = self.step_size * self.neighbor_radius_factor\n        success_state = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        tree_flag = True  # Toggle tree growing\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n\n            if tree_flag:\n                new_node = self._extend_tree(tree_start, kd_start, rand_point, obstacles, is_3d, nodes, edges,\n                                            in_bounds, steer, neighbor_radius)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n                connect_node = self._connect_tree(tree_goal, kd_goal, new_node.position, obstacles, is_3d, nodes, edges,\n                                                 in_bounds, steer, neighbor_radius)\n                if connect_node is not None:\n                    success_state = True\n                    connection_node_start = new_node\n                    connection_node_goal = connect_node\n                    break\n            else:\n                new_node = self._extend_tree(tree_goal, kd_goal, rand_point, obstacles, is_3d, nodes, edges,\n                                            in_bounds, steer, neighbor_radius)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n                connect_node = self._connect_tree(tree_start, kd_start, new_node.position, obstacles, is_3d, nodes, edges,\n                                                 in_bounds, steer, neighbor_radius)\n                if connect_node is not None:\n                    success_state = True\n                    connection_node_start = connect_node\n                    connection_node_goal = new_node\n                    break\n\n            tree_flag = not tree_flag\n\n        extracted_path = []\n        if success_state:\n            path_start = connection_node_start.path_from_root()\n            path_goal = connection_node_goal.path_from_root()\n            path_goal.reverse()\n            extracted_path = path_start + path_goal\n\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _extend_tree(self, tree, kd_tree, rand_point, obstacles, is_3d, nodes, edges,\n                     in_bounds_fn, steer_fn, neighbor_radius) -> Node:\n        import math\n\n        nearest_node = kd_tree.nearest(rand_point)\n        if nearest_node is None:\n            return None\n\n        new_pos = steer_fn(nearest_node.position, rand_point)\n        if not in_bounds_fn(new_pos):\n            return None\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            return None\n\n        near_nodes = kd_tree.near(new_pos, neighbor_radius)\n\n        min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n        best_parent = nearest_node\n\n        # Limit rewiring checks to subset with cost less than current min_cost + margin to reduce overhead\n        cost_margin = 5.0\n        for near_node in near_nodes:\n            edge_cost = math.dist(near_node.position, new_pos)\n            candidate_cost = near_node.cost + edge_cost\n            if candidate_cost + cost_margin < min_cost:\n                if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = candidate_cost\n                    best_parent = near_node\n\n        new_node = Node(new_pos)\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        kd_tree.insert(new_node)\n\n        # Rewire neighbors only if it reduces cost significantly (>= 1% improvement) to avoid excessive rewiring\n        for near_node in near_nodes:\n            if near_node is best_parent:\n                continue\n            potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n            if potential_cost + 0.01 * near_node.cost < near_node.cost:\n                if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent is not None:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.children.remove(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = potential_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n        return new_node\n\n    def _connect_tree(self, tree, kd_tree, target_pos, obstacles, is_3d, nodes, edges,\n                      in_bounds_fn, steer_fn, neighbor_radius) -> Node:\n        import math\n\n        nearest_node = kd_tree.nearest(target_pos)\n        if nearest_node is None:\n            return None\n\n        current_node = nearest_node\n\n        while True:\n            new_pos = steer_fn(current_node.position, target_pos)\n            if not in_bounds_fn(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            near_nodes = kd_tree.near(new_pos, neighbor_radius)\n            min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n            best_parent = current_node\n\n            for near_node in near_nodes:\n                cost_through_near = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_through_near < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_near\n                        best_parent = near_node\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            kd_tree.insert(new_node)\n\n            # Limited rewiring for efficiency using same cost improvement threshold as _extend_tree\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new + 0.01 * near_node.cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size * 0.5:\n                return new_node\n\n            current_node = new_node\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import random\n        import math\n\n        if len(path) < 3:\n            return path\n\n        smoothed_path = path[:]\n        max_attempts = 50\n        for _ in range(max_attempts):\n            if len(smoothed_path) < 3:\n                break\n            i = random.randint(0, len(smoothed_path) - 3)\n            j = random.randint(i + 2, len(smoothed_path) - 1)\n\n            if not self._is_edge_in_obstacle(smoothed_path[i], smoothed_path[j], obstacles, is_3d):\n                # Remove intermediate points between i and j\n                smoothed_path = smoothed_path[:i+1] + smoothed_path[j:]\n        return smoothed_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 23.64648,
    "time_improvement": -92.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02005617618560791,
            "num_nodes_avg": 134.2,
            "path_length_avg": 172.3179664823574,
            "success_improvement": 0.0,
            "time_improvement": -98.79595232018453,
            "length_improvement": 13.877136585701205,
            "objective_score": -26.863358378915116
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02918541431427002,
            "num_nodes_avg": 255.4,
            "path_length_avg": 237.94861171987864,
            "success_improvement": 0.0,
            "time_improvement": -104.03613604353662,
            "length_improvement": 21.040600471534994,
            "objective_score": -27.002720718753984
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05003442764282227,
            "num_nodes_avg": 318.2,
            "path_length_avg": 120.16420656975197,
            "success_improvement": 0.0,
            "time_improvement": -74.38585499172775,
            "length_improvement": 26.211938352579207,
            "objective_score": -17.073368827002483
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This implementation refines the bidirectional RRT* approach by incorporating informed sampling biased adaptively toward both the start and goal regions to balance between exploration and exploitation. It employs a dynamically shrinking radius for neighborhood rewiring, continually optimizing path costs as nodes are added. The planner grows two trees simultaneously from start and goal, always extending the currently smaller tree to maintain balanced growth. After each extension, an attempt is made to directly connect the two trees to form a feasible path. Periodic pruning of dead-ends and low-potential nodes improves search efficiency. Finally, a robust shortcut smoothing procedure is applied to the extracted path to reduce length and improve smoothness, ensuring collision-free shortcuts. The algorithm improves planning speed, path optimality, and robustness in cluttered environments.",
    "planning_mechanism": "The planner alternates growth between two trees starting from start and goal points. Sampling uses adaptive informed bias toward start and goal. Extension is made by steering towards sampled points with collision checks. Neighboring nodes within a dynamically adaptive radius are rewired to reduce cost locally. After each extension, the planner attempts to directly connect to the opposing tree node, thus quickly identifying feasible paths. Dead nodes and unreachable branches are periodically pruned to enhance efficiency. Extracted paths are smoothed via collision-free shortcuts to ensure minimal length and improved smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float=0.15, radius_const: float = 25.0,\n                 radius_min: float = 5.0, prune_interval: int = 250,\n                 prune_threshold: int = 100, smoothing_iters: int = 40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [n for n in tree if dist(n.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_const * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        # Adaptive Informed Sampling function biased towards start and goal\n        def sample_informed():\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                # Bias toward start or goal with probability split\n                if random.random() < p_goal_bias:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                while True:\n                    if is_3d:\n                        point = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        point = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(point, obstacles, is_3d):\n                        return point\n\n        def add_node(tree, new_parent, new_pos, new_cost):\n            new_node = Node(new_pos, parent=new_parent, cost=new_cost)\n            new_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((new_parent, new_node))\n            return new_node\n\n        def rewire(tree, new_node, radius):\n            near = near_nodes(tree, new_node.position, radius)\n\n            for neighbor in near:\n                if neighbor is new_node.parent:\n                    continue\n                dist_new_neighbor = dist(new_node.position, neighbor.position)\n                cost_via_new = new_node.cost + dist_new_neighbor\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    # Check edge collision\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Check node collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            # Check edge collision\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n\n            near = near_nodes(tree, new_pos, radius)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = add_node(tree, best_parent, new_pos, min_cost)\n            rewire(tree, new_node, radius)\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            current = nearest_node\n\n            while True:\n                new_pos = steer(current.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                    return None\n\n                cost_to_new = current.cost + dist(current.position, new_pos)\n                new_node = add_node(tree, current, new_pos, cost_to_new)\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    # Remove node & edges\n                    if node.parent:\n                        try:\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    try:\n                        nodes.remove(node)\n                    except ValueError:\n                        pass\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    removed.append(node)\n            return removed\n\n        def path_length(path):\n            if len(path) < 2:\n                return 0.0\n            return sum(dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if j <= i:\n                    continue\n                p1, p2 = path[i], path[j]\n                # Check collision free shortcut\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # Apply shortcut\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_informed()\n\n            # Always expand smaller tree\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                full_path = path_start + path_goal[::-1][1:]\n\n                smooth_path = shortcut_path(full_path)\n\n                if path_length(smooth_path) + 1e-10 < path_length(full_path):\n                    extracted_path = smooth_path\n                else:\n                    extracted_path = full_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -0.11103,
    "time_improvement": -13.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007130169868469238,
            "num_nodes_avg": 83.7,
            "path_length_avg": 160.7808293289118,
            "success_improvement": 0.0,
            "time_improvement": 29.32606414655588,
            "length_improvement": 19.64328684583648,
            "objective_score": 12.72647661313406
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.021118903160095216,
            "num_nodes_avg": 196.9,
            "path_length_avg": 244.9828089725167,
            "success_improvement": 0.0,
            "time_improvement": -47.64290655132469,
            "length_improvement": 18.706415845625372,
            "objective_score": -10.551588796272334
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03469939231872558,
            "num_nodes_avg": 147.5,
            "path_length_avg": 126.69999612621147,
            "success_improvement": 0.0,
            "time_improvement": -20.938391468987145,
            "length_improvement": 22.19856984232601,
            "objective_score": -1.841803472230942
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This novel path planning algorithm combines informed sampling with a dynamic, cost-aware rewiring process and bidirectional tree growth. It leverages heuristic-guided sampling within an ellipsoidal domain defined by the start and goal nodes to focus the search on promising regions, reducing sample redundancy. The planner adaptively tunes neighborhood radius based on node density and iteration count, ensuring efficient local optimization while maintaining exploration. After connection of the two trees, a post-processing shortcut smoothing step refines the path to further enhance smoothness and reduce length. It guarantees collision-free nodes and edges, bounds adherence, and actively manages tree structures for robustness and improved success rates.",
    "planning_mechanism": "The planner grows two trees from start and goal positions, alternately extending them towards samples drawn from an informed ellipsoidal region narrowing as better solutions emerge. Each new node connects through the optimal parent in a dynamically sized neighborhood, followed by rewiring neighbors to improve path costs. Incremental connection attempts join the trees when close enough. Upon successful connection, the path is extracted and aggressively shortcut-smoothed to ensure smoothness and minimal path length. The approach balances efficient exploration, path quality, and computational speed.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 35.0,\n                 collision_check_resolution: float = 0.5, smoothing_iterations: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.collision_check_resolution = collision_check_resolution\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size              # World size tuple\n        start_pos = map.start          # Start coordinate tuple\n        goal_pos = map.goal            # Goal coordinate tuple\n        obstacles = map.obstacles      # List of rectangular obstacle tuples\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        # Node roots\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes.extend([start_root, goal_root])\n\n        # Precompute heuristic distance function\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # Check if a position is inside bounds\n        def in_bounds(pos):\n            for i in range(dim):\n                if pos[i] < 0 or pos[i] > bounds[i]:\n                    return False\n            return True\n\n        # Collision and edge collision checks\n        def is_free(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            return in_bounds(p1) and in_bounds(p2) and not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # Steering function to move from from_pos towards to_pos by step_size\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            new_pos = tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n            # Clamp to map bounds\n            return tuple(max(0, min(new_pos[i], bounds[i])) for i in range(dim))\n\n        # Adaptive neighbor radius based on iteration and node count\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        # Find nearest node in a tree to position\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        # Return nodes within radius squared (efficient)\n        def near_nodes(tree, position, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[i] - position[i]) ** 2 for i in range(dim)) <= r2]\n\n        # Path shortcut smoothing postprocessing\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Informed sampling inside ellipsoid if solution found, else uniform random\n        def informed_sample(c_best):\n            # If no solution found yet, sample uniformly\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            # Else sample in prolate hyperspheroid (informed sampling)\n            else:\n                # Compute center and rotation (only for 2D and 3D)\n                c_min = dist(start_pos, goal_pos)\n                if c_best <= c_min:\n                    # Degenerate case, sample uniform fallback\n                    while True:\n                        sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                        if not self._is_in_obstacle(sample, obstacles, is_3d):\n                            return sample\n\n                center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n                a1 = tuple((goal_pos[i] - start_pos[i]) / c_min for i in range(dim))\n\n                # Generate orthonormal basis using Gram-Schmidt\n                def generate_basis():\n                    basis = [a1]\n                    for j in range(1, dim):\n                        v = [0]*dim\n                        v[j] = 1\n                        for k in range(len(basis)):\n                            proj = sum(v[m]*basis[k][m] for m in range(dim))\n                            v = [v[m] - proj*basis[k][m] for m in range(dim)]\n                        norm = math.sqrt(sum(x*x for x in v))\n                        if norm > 1e-9:\n                            v = [x/norm for x in v]\n                            basis.append(tuple(v))\n                    return basis\n                basis = generate_basis()\n\n                # Radii of the prolate hyperspheroid\n                r1 = c_best / 2.0\n                r_other = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0 if c_best > c_min else 0.0\n\n                while True:\n                    # Sample random point inside unit n-ball (using normal distribution)\n                    x = [random.gauss(0,1) for _ in range(dim)]\n                    norm_x = math.sqrt(sum(xx*xx for xx in x))\n                    if norm_x ==0:\n                        continue\n                    unit_ball_point = [xx / norm_x for xx in x]\n                    radius = random.random() ** (1/dim)\n                    unit_ball_point = [xx * radius for xx in unit_ball_point]\n\n                    # Scale by radii\n                    scale = [r1] + [r_other]*(dim-1)\n                    sample_local = tuple(unit_ball_point[i] * scale[i] for i in range(dim))\n\n                    # Rotate and translate\n                    sample = list(center)\n                    for i in range(dim):\n                        sample = [sample[d] + sample_local[i]*basis[i][d] for d in range(dim)]\n                    sample = tuple(sample)\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        c_best = float('inf')  # Best path cost so far\n\n        for iteration in range(self.max_iter):\n            sample = informed_sample(c_best)\n\n            # Alternate trees each iteration\n            if iteration % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            radius = neighbor_radius(iteration, len(nodes))\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not is_free(new_pos) or not can_connect(nearest_node.position, new_pos):\n                continue\n\n            neighbors = near_nodes(tree_a, new_pos, radius)\n\n            # Choose best parent minimizing cost\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                cost_thru_node = node.cost + dist(node.position, new_pos)\n                if cost_thru_node + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_thru_node\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper path via new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt incremental connection from tree_b toward new_node\n            connect_near = nearest(tree_b, new_node.position)\n            curr_node = connect_near\n            connected = False\n\n            while True:\n                next_pos = steer(curr_node.position, new_node.position)\n                if not is_free(next_pos) or not can_connect(curr_node.position, next_pos):\n                    break\n\n                neighbors_b = near_nodes(tree_b, next_pos, radius)\n\n                min_cost_b = curr_node.cost + dist(curr_node.position, next_pos)\n                best_parent_b = curr_node\n                for node_b in neighbors_b:\n                    cost_b = node_b.cost + dist(node_b.position, next_pos)\n                    if cost_b + 1e-12 < min_cost_b and can_connect(node_b.position, next_pos):\n                        min_cost_b = cost_b\n                        best_parent_b = node_b\n\n                new_node_b = Node(next_pos, parent=best_parent_b, cost=min_cost_b)\n                best_parent_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((best_parent_b, new_node_b))\n\n                # Rewire neighbors around new_node_b\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is best_parent_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                # Check if new_node_b close enough to new_node to finish connection\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Build path from start_root to goal_root through connection\n                    if tree_a is tree_start:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n                    else:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n\n                    extracted_path = path_start + path_goal[::-1][1:]\n\n                    # Update best cost for informed sampling\n                    c_best = min(c_best, connection_node.cost)\n\n                    # Shortcut smoothing\n                    extracted_path = shortcut_smoothing(extracted_path)\n                    connected = True\n                    break\n\n                curr_node = new_node_b\n\n            if connected:\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if (x <= px <= x + w) and (y <= py <= y + h) and (z <= pz <= z + d):\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if (x <= px <= x + w) and (y <= py <= y + h):\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 52.6047,
    "time_improvement": -173.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.02501828670501709,
            "num_nodes_avg": 88.6,
            "path_length_avg": 160.03125366308612,
            "success_improvement": -9.999999999999998,
            "time_improvement": -147.98017752318296,
            "length_improvement": 20.01791755907205,
            "objective_score": -45.39046974514047
        },
        {
            "map_id": 1,
            "success_rate": 0.8,
            "time_avg": 0.04130699634552002,
            "num_nodes_avg": 250.6,
            "path_length_avg": 237.96963390824484,
            "success_improvement": -19.999999999999996,
            "time_improvement": -188.77849172021234,
            "length_improvement": 21.033624598222804,
            "objective_score": -62.42682259641914
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.08126170635223388,
            "num_nodes_avg": 335.5,
            "path_length_avg": 122.38187099083196,
            "success_improvement": 0.0,
            "time_improvement": -183.22282891855798,
            "length_improvement": 24.850158803683712,
            "objective_score": -49.996816914830646
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner integrates bidirectional RRT* tree growth with heuristic-informed ellipsoidal sampling, KD-tree accelerated neighbor searches, incremental rewiring, collision caching, and periodic pruning. It dynamically adapts neighbor radius, focuses sampling to promising regions based on best path cost, and performs post-connection path shortcut smoothing. This combination improves planning efficiency, path optimality, robustness, and success rate in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees from start and goal, alternating extensions toward ellipsoid-biased samples. It uses KD-trees for fast nearest neighbor and radius queries. After extending and rewiring, it attempts to incrementally connect the opposite tree with collision checks assisted by caching. Periodically, it prunes nodes unlikely to improve the current best path, reduces search complexity, and smooths the final path via shortcutting for improved smoothness and length.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...] (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration: int, n_nodes: int) -> float:\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree helper for nearest and radius search (brute force)\n        class KDTree:\n            def __init__(self, points_nodes: List[Tuple[Tuple[float, ...], Node]]):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Ellipsoidal informed sampling\n        def informed_sample(c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1**2 - (c_min / 2) ** 2, 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    x_scaled = x / norm_x * np.random.uniform(0,1)**(1/dim)  # Uniform inside unit ball\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + center\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            # fallback uniform\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # last fallback\n\n        edge_collision_cache = {}\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost: float) -> int:\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_position)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_position, cost=0.0)\n        root_goal = Node(goal_position, cost=0.0)\n        nodes: List[Node] = [root_start, root_goal]\n        edges: List[Tuple[Node, Node]] = []\n        tree_start: List[Node] = [root_start]\n        tree_goal: List[Node] = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_position, goal_position)\n        best_path: List[Tuple[float, ...]] = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_position, goal_position)\n\n            # Alternate tree extension: extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near neighbors\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connect other tree to new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to reduce complexity\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -1.57125,
    "time_improvement": -9.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01206068992614746,
            "num_nodes_avg": 74.4,
            "path_length_avg": 163.69240063990296,
            "success_improvement": 0.0,
            "time_improvement": -19.54503776385068,
            "length_improvement": 18.188111489161447,
            "objective_score": -2.225889031322914
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.022300076484680176,
            "num_nodes_avg": 198.9,
            "path_length_avg": 230.79387416427326,
            "success_improvement": 0.0,
            "time_improvement": -55.9005258727738,
            "length_improvement": 23.41478444802912,
            "objective_score": -12.087200872226314
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.015093231201171875,
            "num_nodes_avg": 144.4,
            "path_length_avg": 123.69918383264796,
            "success_improvement": 0.0,
            "time_improvement": 47.39530056397553,
            "length_improvement": 24.041249362547966,
            "objective_score": 19.02684004170225
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This improved bidirectional RRT* algorithm integrates adaptive rewiring radius and dynamic parent selection for cost optimization, alternating tree expansion with efficient collision checking, and concludes with a robust path shortcutting step to enhance smoothness and minimize path length. These combined enhancements boost planning efficiency, robustness, success rate, and overall path quality.",
    "planning_mechanism": "The planner grows two trees from start and goal points, alternating expansions toward random collision-free samples. Each new node connects via the lowest cost parent within an adaptive radius, followed by rewiring neighbors to optimize costs. It attempts to connect the trees incrementally, ensuring collision-free edges. Upon connection, the combined path is extracted and refined via shortcut smoothing to produce a shorter, smoother route.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent and self in self.parent.children:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map: 'Map') -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def sample_free() -> Tuple[float, ...]:\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def collision_free_edge(pos_a: Tuple[float, ...], pos_b: Tuple[float, ...]) -> bool:\n            if self._is_in_obstacle(pos_b, obstacles, is_3d):\n                return False\n            return not self._is_edge_in_obstacle(pos_a, pos_b, obstacles, is_3d)\n\n        def rewire(tree: List[Node], new_node: Node, radius: float):\n            neighbors = near_nodes(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-8 < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, potential_cost)\n\n        def choose_parent(tree: List[Node], new_pos: Tuple[float, ...], radius: float) -> Tuple[Node, float]:\n            neighbors = near_nodes(tree, new_pos, radius)\n            min_cost = math.inf\n            best_parent = None\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n            if best_parent is None:\n                best_parent = nearest(tree, new_pos)\n                min_cost = best_parent.cost + dist(best_parent.position, new_pos)\n            return best_parent, min_cost\n\n        def connect_trees(node_from: Node, tree_other: List[Node], radius: float) -> Node or None:\n            nearest_other = nearest(tree_other, node_from.position)\n            current_pos = nearest_other.position\n            prev_node = nearest_other\n\n            while True:\n                new_pos = steer(current_pos, node_from.position)\n                if not collision_free_edge(current_pos, new_pos):\n                    return None\n\n                best_parent, new_cost = choose_parent(tree_other, new_pos, radius)\n                new_node = Node(new_pos, parent=best_parent, cost=new_cost)\n                best_parent.children.append(new_node)\n                tree_other.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewire(tree_other, new_node, radius)\n\n                if dist(new_pos, node_from.position) <= self.step_size:\n                    if collision_free_edge(new_pos, node_from.position):\n                        final_cost = new_node.cost + dist(new_pos, node_from.position)\n                        final_node = Node(node_from.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree_other.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                prev_node = new_node\n                current_pos = new_pos\n\n        def extract_path(node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            smoothed = path[:]\n            max_attempts = max(100, len(path)*5)\n            for _ in range(max_attempts):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed)-3)\n                j = random.randint(i+2, len(smoothed)-1)\n                p1 = smoothed[i]\n                p2 = smoothed[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        for iteration in range(self.max_iter):\n            sample = sample_free()\n\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                radius = min(30.0, 50.0 * ((math.log(len(tree_a) + 1) / (len(tree_a) + 1)) ** 0.5))\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n\n                if not collision_free_edge(nearest_node.position, new_pos):\n                    continue\n\n                best_parent, min_cost = choose_parent(tree_a, new_pos, radius)\n                new_node = Node(new_pos, cost=min_cost)\n                best_parent.children.append(new_node)\n                new_node.parent = best_parent\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewire(tree_a, new_node, radius)\n\n                connected_node = connect_trees(new_node, tree_b, radius)\n                if connected_node is not None:\n                    rewire(tree_b, connected_node, radius)\n                    success_state = True\n                    extracted_path = extract_path(new_node, connected_node)\n                    extracted_path = shortcut_path(extracted_path)\n                    return PlannerResult(success_state, extracted_path, nodes, edges)\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 13.55337,
    "time_improvement": -60.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02235889434814453,
            "num_nodes_avg": 128.6,
            "path_length_avg": 167.2928752970426,
            "success_improvement": 0.0,
            "time_improvement": -121.6203953152029,
            "length_improvement": 16.3886288614737,
            "objective_score": -33.208392822266134
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.027738618850708007,
            "num_nodes_avg": 261.0,
            "path_length_avg": 234.00735959373688,
            "success_improvement": 0.0,
            "time_improvement": -93.92154411580869,
            "length_improvement": 22.34844126548253,
            "objective_score": -23.7067749816461
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.018079710006713868,
            "num_nodes_avg": 194.3,
            "path_length_avg": 120.8423377059049,
            "success_improvement": 0.0,
            "time_improvement": 36.986474392585805,
            "length_improvement": 25.795524983674362,
            "objective_score": 16.255047314510612
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* planner combining adaptive heuristics, incremental KD-tree nearest neighbor search, and prioritized rewiring for improved path planning efficiency and quality. It employs adaptive goal biasing to balance exploration and exploitation, rigorous collision checking for nodes and edges, aggressive pruning to reduce complexity, and randomized shortcut smoothing to improve path smoothness and length. The planner efficiently grows two trees from start and goal, alternating extensions, attempting early connections, and refining paths iteratively to maximize success rate and robustness in complex environments.",
    "planning_mechanism": "The planner initializes two trees at start and goal, alternately sampling points with an adaptive goal bias that increases over iterations to encourage goal-focused exploration. It uses an incremental KD-tree for fast nearest neighbor queries to extend trees towards sampled points, ensures nodes and edges are collision-free, and selectively rewires neighbors with significant cost improvement. Connection attempts are made upon each extension for early path discovery. Once a connection is found, the combined path is extracted and post-processed via randomized shortcut smoothing to produce a high-quality, smooth path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4500, step_size: float = 6.0, neighbor_radius_factor: float = 2.2, max_goal_sample_rate: float = 0.35,\n                 smoothing_attempts: int = 70, collision_check_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.max_goal_sample_rate = max_goal_sample_rate\n        self.smoothing_attempts = smoothing_attempts\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def adaptive_goal_sample_rate(iter_idx):\n            ratio = min(iter_idx / (self.max_iter * 0.8), 1.0)\n            return 0.07 + ratio * (self.max_goal_sample_rate - 0.07)\n\n        class KDTree:\n            def __init__(self):\n                self.nodes = []\n                self.positions = []\n\n            def insert(self, node):\n                self.nodes.append(node)\n                self.positions.append(node.position)\n\n            def nearest(self, point):\n                best_node = None\n                best_dist_sq = float('inf')\n                for node_pos, node in zip(self.positions, self.nodes):\n                    dist_sq = 0.0\n                    for i in range(dim):\n                        diff = node_pos[i] - point[i]\n                        dist_sq += diff * diff\n                        if dist_sq > best_dist_sq:\n                            break\n                    else:\n                        if dist_sq < best_dist_sq:\n                            best_dist_sq = dist_sq\n                            best_node = node\n                return best_node\n\n            def near(self, point, radius):\n                radius_sq = radius * radius\n                neighbors = []\n                for node_pos, node in zip(self.positions, self.nodes):\n                    dist_sq = 0.0\n                    for i in range(dim):\n                        diff = node_pos[i] - point[i]\n                        dist_sq += diff * diff\n                        if dist_sq > radius_sq:\n                            break\n                    else:\n                        neighbors.append(node)\n                return neighbors\n\n        def sample_free(iter_idx):\n            p_goal_sample = adaptive_goal_sample_rate(iter_idx)\n            if random.random() < p_goal_sample:\n                # Sample goal with small noise in bounds to reduce duplicates exactly on goal\n                noise = tuple(random.uniform(-0.08, 0.08) for _ in range(dim))\n                goal_sample = tuple(max(0.0, min(bounds[d], goal_position[d] + noise[d])) for d in range(dim))\n                if not self._is_in_obstacle(goal_sample, obstacles, is_3d):\n                    return goal_sample\n            # Uniform random free sample with rejection\n            trial = 0\n            max_trials = 120\n            while True:\n                sample = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n                trial += 1\n                if trial > max_trials:\n                    return goal_position\n\n        def steer(from_pos, to_pos):\n            dist_val = math.dist(from_pos, to_pos)\n            if dist_val <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist_val\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        success_state = False\n        extracted_path: list = []\n        nodes: list = []\n        edges: list = []\n\n        # Initialize trees\n        root_start = Node(start_position, cost=0.0)\n        root_goal = Node(goal_position, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes.extend([root_start, root_goal])\n\n        kd_start = KDTree()\n        kd_goal = KDTree()\n        kd_start.insert(root_start)\n        kd_goal.insert(root_goal)\n\n        neighbor_radius = self.step_size * self.neighbor_radius_factor\n\n        tree_flag = True  # alternate between start and goal trees\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n\n            if tree_flag:\n                new_node = self._extend_tree(tree_start, kd_start, rand_point, obstacles, is_3d, nodes, edges,\n                                            in_bounds, steer, neighbor_radius)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n                connect_node = self._connect_tree(tree_goal, kd_goal, new_node.position, obstacles, is_3d, nodes, edges,\n                                                 in_bounds, steer, neighbor_radius)\n                if connect_node is not None:\n                    success_state = True\n                    connection_node_start = new_node\n                    connection_node_goal = connect_node\n                    break\n            else:\n                new_node = self._extend_tree(tree_goal, kd_goal, rand_point, obstacles, is_3d, nodes, edges,\n                                            in_bounds, steer, neighbor_radius)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n                connect_node = self._connect_tree(tree_start, kd_start, new_node.position, obstacles, is_3d, nodes, edges,\n                                                 in_bounds, steer, neighbor_radius)\n                if connect_node is not None:\n                    success_state = True\n                    connection_node_start = connect_node\n                    connection_node_goal = new_node\n                    break\n\n            tree_flag = not tree_flag\n\n        if success_state:\n            path_start = connection_node_start.path_from_root()\n            path_goal = connection_node_goal.path_from_root()\n            path_goal.reverse()\n            extracted_path = path_start + path_goal[1:]\n\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _extend_tree(self, tree, kd_tree, rand_point, obstacles, is_3d, nodes, edges,\n                     in_bounds_fn, steer_fn, neighbor_radius) -> 'Node':\n        import math\n\n        nearest_node = kd_tree.nearest(rand_point)\n        if nearest_node is None:\n            return None\n\n        new_pos = steer_fn(nearest_node.position, rand_point)\n        if not in_bounds_fn(new_pos):\n            return None\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_check_resolution):\n            return None\n\n        near_nodes = kd_tree.near(new_pos, neighbor_radius)\n\n        min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n        best_parent = nearest_node\n\n        cost_margin = 4.0  # tighter margin favors more pruning\n\n        for near_node in near_nodes:\n            edge_cost = math.dist(near_node.position, new_pos)\n            candidate_cost = near_node.cost + edge_cost\n            if candidate_cost + cost_margin < min_cost:\n                if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, self.collision_check_resolution):\n                    min_cost = candidate_cost\n                    best_parent = near_node\n\n        new_node = Node(new_pos)\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        kd_tree.insert(new_node)\n\n        # Rewire neighbors only if cost improvement >= 1.5% for efficiency\n        for near_node in near_nodes:\n            if near_node is best_parent:\n                continue\n            potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n            if potential_cost + 0.015 * near_node.cost < near_node.cost:\n                if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, self.collision_check_resolution):\n                    if near_node.parent is not None:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        try:\n                            near_node.parent.children.remove(near_node)\n                        except ValueError:\n                            pass\n                    near_node.parent = new_node\n                    near_node.cost = potential_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n        return new_node\n\n    def _connect_tree(self, tree, kd_tree, target_pos, obstacles, is_3d, nodes, edges,\n                      in_bounds_fn, steer_fn, neighbor_radius) -> 'Node':\n        import math\n\n        nearest_node = kd_tree.nearest(target_pos)\n        if nearest_node is None:\n            return None\n\n        current_node = nearest_node\n\n        while True:\n            new_pos = steer_fn(current_node.position, target_pos)\n            if not in_bounds_fn(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d, self.collision_check_resolution):\n                return None\n\n            near_nodes = kd_tree.near(new_pos, neighbor_radius)\n            min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n            best_parent = current_node\n\n            for near_node in near_nodes:\n                cost_through_near = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_through_near < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, self.collision_check_resolution):\n                        min_cost = cost_through_near\n                        best_parent = near_node\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            kd_tree.insert(new_node)\n\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new + 0.015 * near_node.cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, self.collision_check_resolution):\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size * 0.45:\n                return new_node\n\n            current_node = new_node\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import random\n        if len(path) < 3:\n            return path\n        smoothed_path = path[:]\n        for _ in range(self.smoothing_attempts):\n            if len(smoothed_path) < 3:\n                break\n            i = random.randint(0, len(smoothed_path) - 3)\n            j = random.randint(i + 2, len(smoothed_path) - 1)\n            if not self._is_edge_in_obstacle(smoothed_path[i], smoothed_path[j], obstacles, is_3d, self.collision_check_resolution):\n                smoothed_path = smoothed_path[:i+1] + smoothed_path[j:]\n        return smoothed_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else None\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 11.20692,
    "time_improvement": -50.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01647026538848877,
            "num_nodes_avg": 102.3,
            "path_length_avg": 178.56718444988107,
            "success_improvement": 0.0,
            "time_improvement": -63.25255933981795,
            "length_improvement": 10.753837509871376,
            "objective_score": -16.82500029997111
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.024542832374572755,
            "num_nodes_avg": 212.3,
            "path_length_avg": 235.55877423421785,
            "success_improvement": 0.0,
            "time_improvement": -71.57970181096917,
            "length_improvement": 21.83362940107772,
            "objective_score": -17.107184663075206
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03325984477996826,
            "num_nodes_avg": 244.1,
            "path_length_avg": 121.42331719442411,
            "success_improvement": 0.0,
            "time_improvement": -15.921111564448342,
            "length_improvement": 25.438768578930336,
            "objective_score": 0.31142024645156585
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a streamlined bidirectional RRT* algorithm with balanced tree growth, adaptive steering, neighborhood rewiring, and rigorous collision checking to ensure path feasibility. It optimizes path quality through incremental rewiring and incorporates shortcut smoothing for improved smoothness and shorter paths, thereby enhancing planning efficiency, success rate, and robustness.",
    "planning_mechanism": "The planner alternately expands two trees from the start and goal locations by sampling collision-free points within the map bounds and steering nodes toward them using fixed step sizing. It selects optimal parent nodes from neighbors within a dynamic radius to minimize path cost and rewires nearby nodes for local improvements. When trees connect via collision-free edges, the path is extracted and shortcut smoothing is applied to reduce unnecessary detours and path length.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position             # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent                 # Parent node or None\n        self.cost = cost                     # Cost from root\n        self.children = []\n        self.valid = True                    # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius_const: float = 20.0, radius_min: float = 5.0,\n                 smoothing_iter: int = 50, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.smoothing_iter = smoothing_iter\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            near = []\n            for node in tree:\n                dx = node.position[0] - pos[0]\n                dy = node.position[1] - pos[1]\n                dz = (node.position[2] - pos[2]) if is_3d else 0.0\n                if dx*dx + dy*dy + dz*dz <= r_sq:\n                    near.append(node)\n            return near\n\n        def radius_by_nodes(n):\n            if n <= 1:\n                return self.radius_const\n            val = self.radius_const * math.sqrt((math.log(n + 1) / (n + 1)))\n            return max(self.radius_min, val)\n\n        def can_connect(p1, p2):\n            if not in_bounds(p2):\n                return False\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                return False\n            return True\n\n        def add_node(tree, new_node, parent_node):\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n\n        def rewire(tree, new_node):\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n            new_node = Node(new_pos)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n            for neighbor in neighbors:\n                c = neighbor.cost + dist(neighbor.position, new_pos)\n                if c < min_cost and can_connect(neighbor.position, new_pos):\n                    min_cost = c\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node)\n            return new_node\n\n        def connect(tree, new_node_other):\n            nearest_node = nearest(tree, new_node_other.position)\n            current = nearest_node\n\n            max_steps = 10\n            for _ in range(max_steps):\n                new_pos = steer(current.position, new_node_other.position)\n                if not can_connect(current.position, new_pos):\n                    return None\n\n                connect_node = Node(new_pos)\n                radius = radius_by_nodes(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for neighbor in neighbors:\n                    c = neighbor.cost + dist(neighbor.position, new_pos)\n                    if c < min_cost and can_connect(neighbor.position, new_pos):\n                        min_cost = c\n                        best_parent = neighbor\n\n                best_parent.add_child(connect_node)\n                connect_node.parent = best_parent\n                connect_node.cost = min_cost\n                tree.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((best_parent, connect_node))\n\n                rewire(tree, connect_node)\n\n                if dist(connect_node.position, new_node_other.position) <= self.step_size:\n                    return connect_node\n                current = connect_node\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Alternate expanding trees\n            if itr % 2 == 0:\n                new_node_start = extend(tree_start, rand_point)\n                if new_node_start is None:\n                    continue\n                new_node_goal = connect(tree_goal, new_node_start)\n                if new_node_goal:\n                    success = True\n                    path = extract_path(new_node_start, new_node_goal)\n                    path = shortcut_path(path)\n                    break\n            else:\n                new_node_goal = extend(tree_goal, rand_point)\n                if new_node_goal is None:\n                    continue\n                new_node_start = connect(tree_start, new_node_goal)\n                if new_node_start:\n                    success = True\n                    path = extract_path(new_node_start, new_node_goal)\n                    path = shortcut_path(path)\n                    break\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 2.8521,
    "time_improvement": -8.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012337899208068848,
            "num_nodes_avg": 89.0,
            "path_length_avg": 167.54818897517407,
            "success_improvement": 0.0,
            "time_improvement": -22.292724196277504,
            "length_improvement": 16.26102553909019,
            "objective_score": -3.4356121510652122
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.02253429889678955,
            "num_nodes_avg": 235.9,
            "path_length_avg": 239.09855447284426,
            "success_improvement": -9.999999999999998,
            "time_improvement": -57.53798201531781,
            "length_improvement": 20.659010561806223,
            "objective_score": -18.129592492234096
        },
        {
            "map_id": 2,
            "success_rate": 0.8,
            "time_avg": 0.012685275077819825,
            "num_nodes_avg": 135.0,
            "path_length_avg": 111.77606263321263,
            "success_improvement": -19.999999999999996,
            "time_improvement": 55.787791637340554,
            "length_improvement": 31.362764039906683,
            "objective_score": 13.008890299183502
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner combines the best heuristics from the previous two enhanced bidirectional RRT* variants: it employs an adaptive informed ellipse sampling based on the current best path cost to direct sampling efficiently, integrates dynamic radius rewiring to optimize local path costs, and uses lazy collision checking to reduce expensive collision calls while maintaining safety. It alternately grows two balanced trees from start and goal with goal/start bias to maintain exploration-exploitation balance, and applies iterative shortcut smoothing after path extraction to minimize path length and improve smoothness. Periodic pruning removes dead-end or low-potential branches to keep the search focused and computationally efficient, achieving improved planning efficiency, path quality, and success rate.",
    "planning_mechanism": "The planner grows two bidirectional trees alternately with adaptive informed sampling inside ellipses defined by the current best path cost. Each extension attempts to rewire nearby nodes within a dynamically shrinking radius to locally optimize path costs. Lazy collision checking defers edge feasibility checks until necessary to reduce overhead. Upon connecting the trees, the path is extracted and iteratively smoothed through shortcutting. Periodic pruning discards leaves to reduce complexity and enhance robustness and efficiency. The method ensures no nodes or edges cross obstacles or exceed map boundaries.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]: 2D or 3D coordinates\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Path cost from start root\n        self.children = []                # List of child nodes\n        self.valid = True                 # Validity flag for pruning or collision\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def is_leaf(self):\n        return len(self.children) == 0\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 radius_constant: float = 30.0, radius_min: float = 5.0,\n                 prune_interval: int = 250, prune_threshold: int = 120,\n                 smoothing_trials: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                    # Tuple[int,...]\n        start_pos = map.start                # Tuple[float,...]\n        goal_pos = map.goal                  # Tuple[float,...]\n        obstacles = map.obstacles            # List of obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def heuristic(a, b):\n            return math.dist(a, b)\n\n        def dynamic_radius(n):\n            if n == 0:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(r, self.radius_min)\n\n        def steer(from_p, to_p):\n            dist_p = heuristic(from_p, to_p)\n            if dist_p <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist_p\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(len(from_p)))\n\n        def nearest(tree, pt):\n            return min(tree, key=lambda n: heuristic(n.position, pt))\n\n        def near_nodes(tree, pos, radius):\n            rad_sq = radius * radius\n            return [n for n in tree if sum((n.position[d] - pos[d]) ** 2 for d in range(len(pos))) <= rad_sq]\n\n        # Informed ellipse sampling between start and goal with cost_best\n        def informed_sample(cost_best):\n            if cost_best == float('inf'):\n                # Uniform sampling with goal/start bias\n                p_goal_bias = 0.75\n                if random.random() < self.goal_sample_rate:\n                    return goal_pos if random.random() < p_goal_bias else start_pos\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            else:\n                c_min = heuristic(start_pos, goal_pos)\n                c_best = max(cost_best, c_min * 1.0001)  # safeguard numerical stability\n                center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(len(start_pos)))\n                vec = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(len(start_pos)))\n\n                # Build rotation matrix C and axis lengths L based on dimension\n                try:\n                    import numpy as np\n                except ImportError:\n                    # Fallback: uniform random in bounding box if numpy unavailable\n                    while True:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                        if not self._is_in_obstacle(sample, obstacles, is_3d):\n                            return sample\n\n                dim = len(start_pos)\n                L_diag = [c_best / 2] + [math.sqrt(c_best ** 2 - c_min ** 2) / 2] * (dim - 1)\n                L = np.diag(L_diag)\n                e1 = np.array(vec)\n                e1 /= np.linalg.norm(e1)\n\n                if dim == 2:\n                    e2 = np.array([-e1[1], e1[0]])\n                    C = np.column_stack((e1, e2))\n                else:\n                    a = np.array([1.0, 0.0, 0.0])\n                    if abs(np.dot(a, e1)) > 0.9:\n                        a = np.array([0.0, 1.0, 0.0])\n                    v2 = a - np.dot(a, e1) * e1\n                    v2 /= np.linalg.norm(v2)\n                    v3 = np.cross(e1, v2)\n                    C = np.column_stack((e1, v2, v3))\n\n                while True:\n                    sample_ball = np.random.uniform(-1, 1, dim)\n                    norm_ball = np.linalg.norm(sample_ball)\n                    if norm_ball > 1.0:\n                        continue\n                    sample_ellipse = np.dot(C, np.dot(L, sample_ball)) + np.array(center)\n                    sample_t = tuple(sample_ellipse)\n                    if all(0 <= sample_t[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        # With goal/start bias inside ellipse\n                        if random.random() < self.goal_sample_rate:\n                            return goal_pos if random.random() < 0.5 else start_pos\n                        return sample_t\n\n        lazy_checked_edges = dict()  # {(node_id, pos): bool}\n\n        def can_connect(node, pos):\n            key = (id(node), pos)\n            if key in lazy_checked_edges:\n                return lazy_checked_edges[key]\n            valid = (not self._is_edge_in_obstacle(node.position, pos, obstacles, is_3d)) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n            lazy_checked_edges[key] = valid\n            return valid\n\n        # Extend a tree toward sample_pt with rewiring and lazy collision checking\n        def try_extend(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if not can_connect(nearest_node, new_pos):\n                return None\n\n            r = dynamic_radius(len(tree))\n            near = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + heuristic(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + heuristic(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper via new_node\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + heuristic(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        # Attempt to connect tree toward node by incremental steps with collision checks\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + heuristic(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if heuristic(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d) and not self._is_in_obstacle(node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + heuristic(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        # Prune leaf nodes to reduce tree complexity and focus search\n        def prune_dead_branches():\n            removed = []\n            for node in nodes[:]:\n                if node.is_leaf() and node is not start_root and node is not goal_root:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smooth_path = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth_path) < 3:\n                    break\n                i = random.randint(0, len(smooth_path) - 3)\n                j = random.randint(i + 2, len(smooth_path) - 1)\n                p_i, p_j = smooth_path[i], smooth_path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    del smooth_path[i + 1:j]\n            return smooth_path\n\n\n        best_path_cost = float('inf')\n        best_path = []\n\n        # Alternate growing trees and bias sampling inside ellipses per current best cost\n        tree_turn = 0\n        for itr in range(self.max_iter):\n            sample_pt = informed_sample(best_path_cost)\n\n            # Alternate to extend smaller tree to balance exploration\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node = try_extend(tree_start, sample_pt)\n            if new_node is None:\n                tree_turn = 1 - tree_turn\n                continue\n\n            connect_node = try_connect(tree_goal, new_node)\n            if connect_node:\n                success = True\n                path_start = new_node.path_from_root()\n                path_goal = connect_node.path_from_root()\n                candidate_path = path_start + path_goal[::-1][1:]\n                candidate_cost = sum(heuristic(candidate_path[i], candidate_path[i + 1]) for i in range(len(candidate_path) - 1))\n                if candidate_cost < best_path_cost:\n                    best_path_cost = candidate_cost\n                    best_path = candidate_path\n\n                # Immediate shortcut smoothing after connection to accelerate convergence\n                best_path = shortcut_path(best_path)\n                best_path_cost = sum(heuristic(best_path[i], best_path[i + 1]) for i in range(len(best_path) - 1))\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to keep trees efficient\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_branches()\n\n            tree_turn = 1 - tree_turn\n\n        # In case no connection was made but nodes exist, attempt smoothing on last best found path\n        if success and not extracted_path and best_path:\n            extracted_path = shortcut_path(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 26.15628,
    "time_improvement": -101.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009508776664733886,
            "num_nodes_avg": 91.5,
            "path_length_avg": 160.25734497796296,
            "success_improvement": 0.0,
            "time_improvement": 5.749416290918719,
            "length_improvement": 19.904919292972554,
            "objective_score": 5.705808745870127
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.030540037155151366,
            "num_nodes_avg": 198.4,
            "path_length_avg": 243.74410876682495,
            "success_improvement": 0.0,
            "time_improvement": -113.50634630930652,
            "length_improvement": 19.11745848096694,
            "objective_score": -30.22841219659857
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.08465938568115235,
            "num_nodes_avg": 203.1,
            "path_length_avg": 125.61299415101368,
            "success_improvement": 0.0,
            "time_improvement": -195.06481937742487,
            "length_improvement": 22.866054537198142,
            "objective_score": -53.946234905787826
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This enhanced hybrid bidirectional RRT* planner uses adaptive goal biasing to dynamically balance exploration and exploitation. It always extends the smaller of two trees rooted at start and goal to promote balanced growth. Nearest neighbor searches are accelerated with KDTree when available, and adaptive radius rewiring shrinks with node count to enhance convergence speed. Collision checks are aggressively early-pruned. Upon connection, path reconstruction is followed by an efficient shortcut smoothing pass to reduce unnecessary waypoints. Post-success, pruning removes orphan nodes to keep tree complexity low. These optimizations collectively reduce planning time while improving path quality, smoothness, success rate, and robustness.",
    "planning_mechanism": "The planner initializes two trees and iteratively samples either near the goal or uniformly in the free space based on an adaptively tuned goal bias. Each iteration extends the smaller tree toward the sampled point with fixed step steering and validates new nodes and edges with obstacle collision checks. Local rewiring optimizes costs within an adaptive radius computed from the current node count. After each successful extension, the planner attempts to connect the opposite tree toward the new node to form a complete path. Upon connection, the merged path undergoes shortcut smoothing, and the trees prune unreachable nodes for efficiency. The final path is returned along with all explored nodes and edges.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate_start: float = 0.1, goal_sample_rate_end: float = 0.4,\n                 radius_constant: float = 25.0, radius_min: float = 2.0,\n                 kd_tree_leafsize: int = 40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = goal_sample_rate_start\n        self.goal_sample_rate_end = goal_sample_rate_end\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.kd_tree_leafsize = kd_tree_leafsize  # leafsize tuning for KDTree optimization\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        try:\n            from scipy.spatial import cKDTree as KDTree\n        except ImportError:\n            KDTree = None\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def sample_free(iteration: int) -> Tuple[float, ...]:\n            # Adaptive goal bias increases linearly from start to end rate\n            goal_bias = (self.goal_sample_rate_end - self.goal_sample_rate_start) * (iteration / self.max_iter) + self.goal_sample_rate_start\n            r = random.random()\n            if r < goal_bias:\n                # Weighted bias: 85% goal point, 15% start point to favor connection\n                return goal_position if random.random() < 0.85 else start_position\n            else:\n                for _ in range(40):\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return start_position  # fallback\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def radius_by_nodes(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(self.radius_min, val)\n\n        def build_kdtree(tree: List[Node]):\n            if KDTree is None or not tree:\n                return None\n            pts = [node.position for node in tree]\n            return KDTree(pts, leafsize=self.kd_tree_leafsize)\n\n        def nearest(tree: List[Node], kdtree, point: Tuple[float, ...]) -> Node:\n            if kdtree:\n                dist_, idx = kdtree.query(point)\n                return tree[idx]\n            else:\n                return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree: List[Node], kdtree, pos: Tuple[float, ...], radius: float) -> List[Node]:\n            if kdtree:\n                idxs = kdtree.query_ball_point(pos, radius)\n                return [tree[i] for i in idxs]\n            else:\n                r2 = radius * radius\n                return [node for node in tree if (dist(node.position, pos) <= radius)]\n\n        def try_extend(tree: List[Node], kdtree, point: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, kdtree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            # Early collision check: new node position\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            # Edge collision check\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, kdtree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            # Find lowest cost parent within radius\n            for node in neighbors:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost + 1e-12 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            best_parent.children.append(new_node)\n            new_node.parent = best_parent\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Batch rewiring neighbors through new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_thru_new + 1e-12 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.children.remove(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, cost_thru_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree: List[Node], kdtree, node: Node) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, kdtree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    # Final segment collision check\n                    if (not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d) and\n                            not self._is_in_obstacle(node.position, obstacles, is_3d)):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def smooth_path(path: List[Tuple[float, ...]], max_trials: int = 150) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if j >= len(path):\n                    continue\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        from collections import deque\n\n        def prune_redundant_nodes(tree: List[Node]):\n            if not tree:\n                return\n            root = tree[0]\n            queue = deque([root])\n            visited = set()\n            while queue:\n                cur = queue.popleft()\n                visited.add(cur)\n                for c in cur.children:\n                    if c not in visited:\n                        queue.append(c)\n            to_remove = [node for node in tree if node not in visited]\n            for node in to_remove:\n                try:\n                    tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n                except ValueError:\n                    pass\n\n        # Cache goal bias per iteration for efficiency\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n\n            # Always extend smaller tree for balance and efficiency\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            kdtree_start = build_kdtree(tree_start)\n            kdtree_goal = build_kdtree(tree_goal)\n\n            new_node_start = try_extend(tree_start, kdtree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, kdtree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                # Concatenate paths without duplicating the connection node\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                # Shortcut smoothing to improve path quality and reduce length\n                extracted_path = smooth_path(merged_path, max_trials=150)\n\n                # Prune unreachable nodes to reduce memory and speed subsequent operations\n                prune_redundant_nodes(tree_start)\n                prune_redundant_nodes(tree_goal)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool, resolution: float = 1.0) -> bool:\n        import math\n        distance = math.dist(from_pos, to_pos)\n        if distance == 0.0:\n            return self._is_in_obstacle(from_pos, obstacles, is_3d)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 0.15869,
    "time_improvement": -14.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012440872192382813,
            "num_nodes_avg": 74.6,
            "path_length_avg": 161.6920486685267,
            "success_improvement": 0.0,
            "time_improvement": -23.313387970393908,
            "length_improvement": 19.18786817807873,
            "objective_score": -3.1564427555024257
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.021274399757385255,
            "num_nodes_avg": 262.8,
            "path_length_avg": 239.0558381698273,
            "success_improvement": 0.0,
            "time_improvement": -48.729988082439526,
            "length_improvement": 20.6731852763041,
            "objective_score": -10.484359369471036
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.020455050468444824,
            "num_nodes_avg": 223.5,
            "path_length_avg": 125.78227205147036,
            "success_improvement": 0.0,
            "time_improvement": 28.707659248093563,
            "length_improvement": 22.76210770884545,
            "objective_score": 13.164719316197157
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This implementation enhances the bidirectional RRT* with an improved adaptive sampling strategy focusing more strongly near the optimal connection frontier, a refined dynamic and decaying rewiring radius tuned to minimize path length, and intelligent mutual rewiring of nodes across both trees for further cost reduction. It includes balanced tree growth, rigorous collision checks for nodes and edges, and aggressive pruning of dead-end nodes to keep the tree lean. The path shortcutting uses a multiscale random shortcut approach iteratively improving smoothness and total path length. These optimizations collectively improve planning efficiency, robustness, success rate, and ensure smoother, shorter paths in both 2D and 3D settings.",
    "planning_mechanism": "The planner grows two trees from start and goal, always extending the smaller tree first to maintain balanced exploration. Sampling switches adaptively between goal bias, start bias, and focused exploration near the trees' connection midpoints with increased probability as iterations progress. Each extension uses a dynamic, decaying radius for rewiring neighbors, optimizing paths locally. After extending one tree, the planner attempts to connect and rewire the opposite tree toward the new node. Periodic pruning removes nodes that do not contribute to solution progress. Upon successful connection, advanced multiscale path shortcutting and smoothing reduces the final path length and enhances smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 3.0, prune_interval: int = 200,\n                 prune_threshold: int = 100, smoothing_iterations: int = 40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            new_pos = tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n            # Clamp within bounds\n            clamped = tuple(max(0, min(bounds[i], new_pos[i])) for i in range(dim))\n            return clamped\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, position) ** 2) <= radius_sq]\n\n        def radius_by_nodes_and_iter(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt(math.log(n_nodes) / n_nodes)\n            # Steeper decay with iterations to focus rewiring locally over time\n            decay_factor = math.exp(-7 * itr / self.max_iter)\n            radius = max(self.radius_min, base * decay_factor)\n            return radius\n\n        def is_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr):\n            # Adaptive heuristic sampling:\n            # Early iterations: bias strong towards goal and start\n            # Later iterations: focus exploration near midpoints of start & goal trees,\n            # and randomly sample free space less often\n            r = random.random()\n            n_start, n_goal = len(tree_start), len(tree_goal)\n            max_nodes = max(1, n_start + n_goal)\n\n            if r < self.goal_sample_rate:\n                r2 = random.random()\n                # Sample goal for convergence and start for diversification\n                if r2 < 0.65 and is_free_node(goal_position):\n                    return goal_position\n                elif r2 < 0.8 and is_free_node(start_position):\n                    return start_position\n                else:\n                    # Exploration near promising region (midpoints)\n                    if n_start > 15 and n_goal > 15:\n                        # Weight shrinkage of spread over iterations, less spread later\n                        spread = self.step_size * 4 * (1 - itr / self.max_iter)\n                        # Randomly pick pairs of nodes from both trees to find midpoints\n                        for _ in range(5):\n                            mid_s = random.choice(tree_start).position\n                            mid_g = random.choice(tree_goal).position\n                            mid = tuple((mid_s[i] + mid_g[i]) * 0.5 for i in range(dim))\n                            candidate = tuple(\n                                max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim)\n                            )\n                            if is_free_node(candidate):\n                                return candidate\n            # Fallback: uniform sampling in free space, limit attempts to avoid infinite loops\n            attempts = 0\n            while attempts < 150:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n                attempts += 1\n            return start_position\n\n        def try_extend(tree, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (not is_free_node(new_pos)) or (not is_free_edge(nearest_node.position, new_pos)):\n                return None\n\n            radius = radius_by_nodes_and_iter(len(tree), itr)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node, itr):\n            if not tree:\n                return None\n\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if (not is_free_node(new_pos)) or (not is_free_edge(last_node.position, new_pos)):\n                    return None\n\n                radius = radius_by_nodes_and_iter(len(tree), itr)\n                near = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in near:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-10 < min_cost:\n                        if is_free_edge(node.position, new_pos):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors for better costs\n                for neighbor in near:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-10 < neighbor.cost:\n                        if is_free_edge(new_node.position, neighbor.position):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if is_free_edge(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample = adaptive_sample(itr)\n\n            # Balanced tree growth: extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start, itr)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                shortcuted_path = shortcut_path(raw_path)\n                smoothed_path = smooth_path(shortcuted_path)\n\n                candidates = [raw_path, shortcuted_path, smoothed_path]\n                extracted_path = min(candidates, key=path_length)\n                break\n\n            # Periodic pruning to improve performance\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return type('PlannerResult', (), {})() if not success_state else \\\n            PlannerResult(\n                success=success_state,\n                path=extracted_path,\n                nodes=nodes,\n                edges=edges,\n            )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 3.03871,
    "time_improvement": -25.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.014606857299804687,
            "num_nodes_avg": 80.6,
            "path_length_avg": 161.9568680423742,
            "success_improvement": 0.0,
            "time_improvement": -44.782538827288285,
            "length_improvement": 19.055514000340313,
            "objective_score": -9.623658848118422
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.024406075477600098,
            "num_nodes_avg": 193.3,
            "path_length_avg": 230.43062073533875,
            "success_improvement": 0.0,
            "time_improvement": -70.62363010559125,
            "length_improvement": 23.535324225160036,
            "objective_score": -16.480024186645366
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.016912388801574706,
            "num_nodes_avg": 153.0,
            "path_length_avg": 124.81614388456349,
            "success_improvement": 0.0,
            "time_improvement": 41.0549591539453,
            "length_improvement": 23.355368603866236,
            "objective_score": 16.987561466956834
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm is an informed bidirectional RRT* variant leveraging heuristics to guide sampling within an informed ellipsoidal subset, which updates dynamically as better solutions are found. It incorporates rewiring for path optimality, a heuristic cost-to-go function to focus exploration, and lazy collision checking to reduce collision tests required. By restricting samples to a progressively shrinking ellipsoid around the current best path, it improves planning efficiency, path quality, and success rate while reducing search time and path length.",
    "planning_mechanism": "The planner grows two trees from start and goal positions bidirectionally. After the initial feasible path is found, the sampling space shrinks to an ellipsoid defined by the best cost so far. Iteratively, new samples are drawn from this ellipsoid, new nodes are extended and rewired for optimality, and attempts are made to connect the two trees. The algorithm terminates early upon reaching max iterations or converging to a near-optimal path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        new_parent.children.append(self)\n        self.cost = new_cost\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius  # rewiring radius\n\n    def plan(self, map) -> PlannerResult:\n        import random, math\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def line_cost(a, b):\n            return dist(a, b)\n\n        def heuristic_cost(node_pos):\n            # Estimated cost from node to goal (Euclidean)\n            return dist(node_pos, goal_position)\n\n        # Initialize trees\n        tree_start = [Node(start_position, cost=0.0)]\n        tree_goal = [Node(goal_position, cost=0.0)]\n        nodes = tree_start + tree_goal\n        edges = []\n        success_state = False\n        best_cost = float('inf')\n        best_connection = (None, None)\n        extracted_path = []\n\n        # Initial sampling bounds\n        lower_bounds = [0.0]*len(bounds)\n        upper_bounds = list(bounds)\n\n        # After initial solution, sample from ellipsoidal informed region\n        def sample_in_ellipsoid(c_best, c_min, start, goal):\n            # If no solution yet, uniform sample\n            if c_best == float('inf'):\n                while True:\n                    if is_3d:\n                        pt = tuple(random.uniform(lower_bounds[i], upper_bounds[i]) for i in range(3))\n                    else:\n                        pt = tuple(random.uniform(lower_bounds[i], upper_bounds[i]) for i in range(2))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n            # Sample from ellipsoid\n            # Reference: Informed RRT* (Gammell et al. 2014)\n            c = c_best\n            c_min = max(c_min, 1e-10)  # Avoid divide by zero\n\n            center = tuple((start[i] + goal[i]) / 2 for i in range(len(start)))\n            dist_start_goal = c_min\n\n            # Create rotation matrix from unit vector from start->goal\n            import numpy as np\n            a1 = np.array(goal) - np.array(start)\n            a1 = a1 / np.linalg.norm(a1)\n\n            dim = len(start)\n            id_matrix = np.eye(dim)\n            M = np.outer(a1, id_matrix[0])\n            U, _, VT = np.linalg.svd(M)\n            C = U @ np.diag([1] + [1]*(dim - 1)) @ VT\n\n            # Define ellipse axes lengths\n            r1 = c / 2.0\n            r2 = math.sqrt(c**2 - c_min**2) / 2.0\n            r = [r1] + [r2]*(dim-1)\n\n            while True:\n                # Sample unit ball\n                x = self._sample_unit_ball(dim)\n                # Scale\n                rand_ellipsoid = C @ (np.multiply(r, x)) + np.array(center)\n                pt = tuple(rand_ellipsoid.tolist())\n                if all(lower_bounds[i] <= pt[i] <= upper_bounds[i] for i in range(dim)):\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n\n        # Helpers for connecting and rewiring\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def steer(from_pos, to_pos, step_size=self.step_size):\n            d = dist(from_pos, to_pos)\n            if d <= step_size:\n                return to_pos\n            ratio = step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        # Extract final path by connecting two nodes from each tree\n        def extract_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        c_min = dist(start_position, goal_position)\n        c_best = float('inf')\n\n        for iter_i in range(self.max_iter):\n            rand_point = sample_in_ellipsoid(c_best, c_min, start_position, goal_position)\n            # Alternate trees per iteration for symmetry and better exploration\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                nearest = nearest_node(tree_a, rand_point)\n                new_pos = steer(nearest.position, rand_point)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Choose parent with minimum cost for new node (RRT* style)\n                near = near_nodes(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + line_cost(nearest.position, new_pos)\n                min_parent = nearest\n                for node_near in near:\n                    cost_near = node_near.cost + line_cost(node_near.position, new_pos)\n                    if cost_near < min_cost and not self._is_edge_in_obstacle(node_near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_near\n                        min_parent = node_near\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewiring\n                for node_near in near:\n                    if node_near == min_parent:\n                        continue\n                    new_cost = new_node.cost + line_cost(new_node.position, node_near.position)\n                    if new_cost < node_near.cost and not self._is_edge_in_obstacle(new_node.position, node_near.position, obstacles, is_3d):\n                        node_near.update_parent(new_node, new_cost)\n                        # Update edges\n                        try:\n                            edges.remove((node_near.parent, node_near))\n                        except ValueError:\n                            pass\n                        edges.append((new_node, node_near))\n\n                # Attempt to connect the other tree\n                nearest_other = nearest_node(tree_b, new_node.position)\n                dist_connect = dist(new_node.position, nearest_other.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                        # Connection found\n                        # Check if new path cost is better than best\n                        new_path_cost = new_node.cost + nearest_other.cost + dist_connect\n                        if new_path_cost < best_cost:\n                            best_cost = new_path_cost\n                            best_connection = (new_node, nearest_other)\n                            success_state = True\n\n            # Early exit if found solution and iterations limit is high\n            if success_state and iter_i > self.max_iter // 10:\n                break\n\n        if success_state and best_connection[0] and best_connection[1]:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n\n            # Optional: path smoothing via shortcutting\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_unit_ball(self, dim):\n        # Sample uniformly from unit ball in dim dimensions using Normal deviate method\n        import random, math\n        import numpy as np\n        vec = np.random.normal(0, 1, dim)\n        norm = np.linalg.norm(vec)\n        if norm == 0:\n            return self._sample_unit_ball(dim)  # Resample if zero vector\n        u = random.uniform(0, 1) ** (1/dim)\n        return (vec / norm) * u\n\n    def _smooth_path(self, path, obstacles, is_3d, max_iterations=100):\n        # Attempt shortcut smoothing to reduce unnecessary waypoints\n        import random\n        if len(path) < 3:\n            return path[:]\n        path = path[:]\n        for _ in range(max_iterations):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) -1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Remove intermediate points\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 192.63386,
    "time_improvement": -660.0,
    "length_improvement": 26.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.14361586570739746,
            "num_nodes_avg": 654.6,
            "path_length_avg": 152.4381496261331,
            "success_improvement": 0.0,
            "time_improvement": -1323.5142595165848,
            "length_improvement": 23.81287797564601,
            "objective_score": -392.29170225984626
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06920173168182372,
            "num_nodes_avg": 538.0,
            "path_length_avg": 225.0003956901418,
            "success_improvement": 0.0,
            "time_improvement": -383.79145102549353,
            "length_improvement": 25.337256607845855,
            "objective_score": -110.0699839860789
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.10662848949432373,
            "num_nodes_avg": 706.9,
            "path_length_avg": 114.3997038803127,
            "success_improvement": 0.0,
            "time_improvement": -271.6341164064778,
            "length_improvement": 29.751690263379388,
            "objective_score": -75.53989686926747
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the adaptive ellipsoidal informed sampling and KD-tree accelerated nearest neighbor and radius searches from Algorithm No.1 with the pruning, incremental rewiring, and shortcut smoothing strategies from both algorithms. It grows two bidirectional trees alternately, focusing sampling inside an adaptive informed ellipsoid around the current best path, while efficiently querying neighbors via KD-tree for rewiring and cost optimization. Collision caching avoids redundant checks. Nodes unlikely to improve the best found path are pruned periodically to reduce search complexity. Final extracted paths are shortcut-smoothed for improved smoothness and length, balancing exploration and exploitation to enhance planning efficiency, robustness, and path quality in both 2D and 3D environments.",
    "planning_mechanism": "The planner alternates between extending two trees rooted at start and goal using adaptive ellipsoidal informed sampling to bias search toward promising regions. It applies KD-tree for fast nearest neighbor and radius queries to enable efficient incremental rewiring to minimize path cost. It uses collision caching for rapid collision checks. Periodic pruning removes nodes that cannot yield better solutions. Upon connecting the trees, the merged path is shortcut-smoothed to improve smoothness and shorten length. This combination accelerates convergence, improves robustness against obstacles, and enhances final path quality and success rate.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / self.collision_check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return True\n            return False\n\n        # KDTree helper for fast neighbor search\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Collision cache for edges\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))  # unit vector start->goal\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1 * r1 - (c_min / 2) * (c_min / 2), 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    x = x * radii\n                    p = rot @ x + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback last sample\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            to_remove = []\n            for node in nodes:\n                if node is root_start or node is root_goal:\n                    continue\n                heuristic = dist(node.position, goal_position)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n\n        root_start = Node(start_position, cost=0.0)\n        root_goal = Node(goal_position, cost=0.0)\n        nodes = [root_start, root_goal]\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_position, goal_position)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_position, goal_position)\n\n            # Alternate expanding smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cost improvement\n            for neighbor in near_nodes_a:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_nodes_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -5.82745,
    "time_improvement": 6.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009006142616271973,
            "num_nodes_avg": 74.4,
            "path_length_avg": 169.31553680965735,
            "success_improvement": 0.0,
            "time_improvement": 10.731503275387798,
            "length_improvement": 15.377722078273504,
            "objective_score": 6.294995398271039
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.021878266334533693,
            "num_nodes_avg": 214.5,
            "path_length_avg": 235.5728362397851,
            "success_improvement": 0.0,
            "time_improvement": -52.95163803951964,
            "length_improvement": 21.828963151891685,
            "objective_score": -11.519698781477555
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.011098408699035644,
            "num_nodes_avg": 124.4,
            "path_length_avg": 127.74409591233731,
            "success_improvement": 0.0,
            "time_improvement": 61.318524439909226,
            "length_improvement": 21.557429676015406,
            "objective_score": 22.707043267175848
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner implements a hybrid bidirectional RRT* algorithm combining adaptive ellipsoidal informed sampling, dynamic step sizing based on obstacle proximity, and aggressive rewiring with shrinking neighborhood radius. It balances exploration and exploitation by alternating tree expansions from start and goal, focusing sampling in the ellipsoidal informed subset once a solution is found. Post-processing uses iterative shortcut smoothing for path refinement, achieving improved planning efficiency, path quality, and success rates.",
    "planning_mechanism": "The planner initializes bidirectional trees at start and goal, then iteratively samples points biased by an ellipse informed by the best path cost. Each iteration alternates growth between the two trees: extending towards samples with adaptive step sizes, rewiring neighbors within a dynamically shrinking radius, and attempting incremental connections between trees. Collision checks for nodes and edges ensure feasibility. Upon successful connection, the extracted path undergoes iterative shortcut smoothing before returning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def rewire(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.2,\n                 search_radius_factor: float=20.0, smoothing_iterations: int=40,\n                 collision_resolution: float=0.5,\n                 adaptive_step_min: float=1.5, adaptive_step_max: float=7.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.search_radius_factor = search_radius_factor\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_resolution = collision_resolution\n        self.adaptive_step_min = adaptive_step_min\n        self.adaptive_step_max = adaptive_step_max\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_path_cost = float('inf')\n        success_state = False\n        extracted_path = []\n\n        diag_dist = math.dist((0,)*dimension, bounds)\n\n        def distance(a,b):\n            return math.dist(a,b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dimension))\n\n        def calc_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 5\n            gamma = self.search_radius_factor\n            unit_ball_vol = math.pi if dimension == 2 else (4/3)*math.pi\n            r = min(self.step_size * 5,\n                    gamma * ((math.log(max(n_nodes,1)) / max(n_nodes,1)) ** (1/dimension)))\n            return max(self.step_size * 1.5, r)\n\n        def unit_vector(v):\n            norm = math.dist((0,)*len(v), v)\n            if norm < 1e-12:\n                return tuple([0]*len(v))\n            return tuple(x / norm for x in v)\n\n        def ellipse_sample(c_best, start, goal):\n            if c_best == float('inf'):\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            center = tuple((s+g)/2 for s,g in zip(start, goal))\n            a1 = tuple(g - s for s,g in zip(start, goal))\n            a1_len = distance(start, goal)/2\n            if a1_len < 1e-12:\n                return start\n\n            e_r1 = unit_vector(a1)\n\n            # Build orthonormal basis\n            if is_3d:\n                e1 = np.array(e_r1)\n                # choose vector not colinear with e1\n                v = np.array([1,0,0]) if abs(e1[0]) < abs(e1[1]) else np.array([0,1,0])\n                e2 = v - np.dot(v,e1)*e1\n                e2 /= np.linalg.norm(e2)\n                e3 = np.cross(e1, e2)\n                basis = np.stack([e1,e2,e3], axis=1)  # 3x3\n            else:\n                e1 = np.array(e_r1)\n                e2 = np.array([-e1[1], e1[0]])\n                basis = np.stack([e1,e2], axis=1)  # 2x2\n\n            r1 = c_best/2\n            inside_sqrt = max(c_best**2 - (2*a1_len)**2, 0)\n            r2 = math.sqrt(inside_sqrt)/2\n            if r2 < 1e-6:\n                r2 = self.step_size * 2\n\n            while True:\n                if is_3d:\n                    sample_ball = np.random.normal(size=3)\n                else:\n                    sample_ball = np.random.normal(size=2)\n                sample_ball /= np.linalg.norm(sample_ball)\n                uniform_radius = random.uniform(0,1) ** (1/dimension)\n                sample_ball = sample_ball * uniform_radius\n                scale = np.array([r1, r2] + ([r2] if is_3d else []))\n                offset = center + basis @ (sample_ball * scale)\n                p = tuple(offset.tolist())\n                if in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def adaptive_steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            step = min(self.adaptive_step_max, max(self.adaptive_step_min, dist))\n            if dist <= step:\n                np_new = to_pos\n            else:\n                ratio = step / dist\n                np_new = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n            # Clamp to bounds\n            np_clamped = tuple(max(0, min(np_new[i], bounds[i])) for i in range(dimension))\n            return np_clamped\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                dist = distance(node.position, point)\n                if dist < best_dist:\n                    best_dist = dist\n                    best_node = node\n            return best_node\n\n        def near(tree, pos, radius):\n            r_sq = radius*radius\n            near_nodes = []\n            for node in tree:\n                d = 0\n                for i in range(dimension):\n                    d += (node.position[i] - pos[i])**2\n                    if d > r_sq:\n                        break\n                if d <= r_sq:\n                    near_nodes.append(node)\n            return near_nodes\n\n        def collision_free(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def edge_collision_free(pos1, pos2):\n            if not in_bounds(pos2):\n                return False\n            return not self._is_edge_in_obstacle(pos1, pos2, obstacles, is_3d, self.collision_resolution)\n\n        def extend(tree, sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = adaptive_steer(nearest_node.position, sample)\n            if not collision_free(new_pos) or not edge_collision_free(nearest_node.position, new_pos):\n                return None\n\n            radius = calc_radius(len(tree))\n            near_nodes = near(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + distance(near_node.position, new_pos)\n                if temp_cost < min_cost and edge_collision_free(near_node.position, new_pos):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Aggressive rewiring around new_node\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, near_node.position)\n                if cost_through_new + 1e-12 < near_node.cost and edge_collision_free(new_node.position, near_node.position):\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                    except ValueError:\n                        pass\n                    near_node.rewire(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            dist_con = distance(nearest_node.position, node.position)\n            if dist_con <= self.step_size and edge_collision_free(nearest_node.position, node.position):\n                new_node = Node(node.position)\n                new_node.cost = nearest_node.cost + dist_con\n                new_node.parent = nearest_node\n                nearest_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n                return new_node\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if edge_collision_free(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            # Alternate tree growth: smaller tree first\n            if len(start_tree) > len(goal_tree):\n                tree_a, tree_b = goal_tree, start_tree\n                pos_a = goal_position\n                pos_b = start_position\n            else:\n                tree_a, tree_b = start_tree, goal_tree\n                pos_a = start_position\n                pos_b = goal_position\n\n            # Ellipsoidal informed sampling biased by best path cost so far\n            if random.random() < self.goal_sample_rate:\n                sample = pos_b\n            else:\n                sample = ellipse_sample(best_path_cost, pos_a, pos_b)\n\n            new_node = extend(tree_a, sample)\n            if new_node is None:\n                continue\n\n            connected_node = try_connect(tree_b, new_node)\n            if connected_node is not None:\n                candidate_path = extract_path(new_node, connected_node)\n                candidate_cost = new_node.cost + connected_node.cost\n                if candidate_cost < best_path_cost:\n                    best_path_cost = candidate_cost\n                    extracted_path = shortcut_path(candidate_path)\n                    success_state = True\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 3.47997,
    "time_improvement": -18.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.018651938438415526,
            "num_nodes_avg": 122.2,
            "path_length_avg": 173.53406029125009,
            "success_improvement": -9.999999999999998,
            "time_improvement": -84.87720840541077,
            "length_improvement": 13.269344588498397,
            "objective_score": -27.80929360392355
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.018506193161010744,
            "num_nodes_avg": 188.9,
            "path_length_avg": 243.33300847510864,
            "success_improvement": 0.0,
            "time_improvement": -29.37736996941438,
            "length_improvement": 19.253875465900265,
            "objective_score": -4.962435897644262
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.011063480377197265,
            "num_nodes_avg": 127.6,
            "path_length_avg": 131.09677616550948,
            "success_improvement": 0.0,
            "time_improvement": 61.44026072338774,
            "length_improvement": 19.49868203171122,
            "objective_score": 22.331814623358568
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "This planner is an optimized bidirectional informed RRT* variant integrating adaptive ellipsoidal sampling, KD-tree accelerated nearest neighbor searches, collision caching, incremental rewiring, pruning of non-promising nodes, and shortcut smoothing. It is tuned to improve planning efficiency, success rate, path smoothness, and quality in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal positions, sampling adaptively within an ellipsoidal region around the best path found so far to focus exploration on promising regions. KD-trees speed nearest neighbor and radius searches for rewiring and optimization. Collision checks are cached to reduce redundant computations. The planner periodically prunes nodes unlikely to improve the current best solution and applies aggressive shortcut smoothing to refine the final path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision or pruning state\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Ellipsoidal informed sampling with fallback uniform sampling\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                # Goal bias & uniform sampling when no good solution\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))  # unit vector start->goal\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) * (c_min / 2), 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    x = x * radii\n                    p = rot @ x + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            # Fallback uniform sampling if ellipsoid samples fail\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth direction based on tree sizes for balanced expansion\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring near neighbors for cost improvement with collision caching\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Prune nodes periodically for efficiency if sufficient nodes and improvement found\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 2.74527,
    "time_improvement": -24.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007837724685668946,
            "num_nodes_avg": 76.0,
            "path_length_avg": 159.82318526489865,
            "success_improvement": 0.0,
            "time_improvement": 22.312811350896585,
            "length_improvement": 20.121908144637402,
            "objective_score": 10.718225034196456
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02756030559539795,
            "num_nodes_avg": 239.4,
            "path_length_avg": 238.00382583687002,
            "success_improvement": 0.0,
            "time_improvement": -92.6749506212966,
            "length_improvement": 21.022278559540542,
            "objective_score": -23.598029474480875
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.028953123092651366,
            "num_nodes_avg": 191.9,
            "path_length_avg": 122.81180579728087,
            "success_improvement": 0.0,
            "time_improvement": -0.9108200704491538,
            "length_improvement": 24.58615293281559,
            "objective_score": 4.643984565428372
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is a streamlined bidirectional RRT* planner combining efficient tree growth from start and goal states with rewiring to improve path quality. It uses balanced expansion, adaptive neighborhood search for rewiring, and rigorous collision checks for nodes and edges to ensure valid paths. The planner aims to achieve faster convergence, shorter and smoother paths with robust success in both 2D and 3D spaces.",
    "planning_mechanism": "The planner alternates growing two trees from start and goal by sampling random free points, steering towards them within step size, and connecting new nodes to the best parent within a radius. It then rewires neighbors to reduce cost. If the two trees connect without collision, the optimal path is extracted by concatenating paths from both trees. The process iterates until success or max iterations reached.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]: coordinates (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking or pruning\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 15.0, collision_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_pos = tuple(from_pos[i] + ratio*(to_pos[i] - from_pos[i]) for i in range(dim))\n            # Clamp within bounds:\n            clamped = tuple(max(0, min(new_pos[i], bounds[i])) for i in range(dim))\n            return clamped\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(fpos, tpos):\n            return self._is_edge_in_obstacle(fpos, tpos, obstacles, is_3d, self.resolution)\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if distance(node.position, point) <= radius]\n\n        def extract_full_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success = False\n        final_path = []\n\n        for _ in range(self.max_iter):\n            # Sample random free point\n            for _ in range(50):\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    break\n            else:\n                continue  # if cannot find free sample after tries\n\n            # Alternate expanding trees for balance\n            if len(start_tree) <= len(goal_tree):\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            # Extend tree_a towards sample\n            nearest = nearest_node(tree_a, sample)\n            new_pos = steer(nearest.position, sample)\n            if not in_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            near = near_nodes(tree_a, new_pos, self.radius)\n            min_cost = nearest.cost + distance(nearest.position, new_pos)\n            best_parent = nearest\n\n            for node in near:\n                if node == nearest:\n                    continue\n                cost_candidate = node.cost + distance(node.position, new_pos)\n                if cost_candidate < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper\n            for node in near:\n                if node == best_parent:\n                    continue\n                new_cost = new_node.cost + distance(new_node.position, node.position)\n                if new_cost < node.cost and not is_edge_in_obstacle(new_node.position, node.position):\n                    if node.parent:\n                        try:\n                            edges.remove((node.parent, node))\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    node.parent = new_node\n                    node.cost = new_cost\n                    new_node.children.append(node)\n                    edges.append((new_node, node))\n\n            # Try to connect tree_b to new_node\n            nearest_b = nearest_node(tree_b, new_node.position)\n            if distance(nearest_b.position, new_node.position) <= self.step_size and \\\n               not is_edge_in_obstacle(nearest_b.position, new_node.position):\n\n                # Connect nodes\n                connect_node = Node(new_node.position, parent=nearest_b, cost=nearest_b.cost + distance(nearest_b.position, new_node.position))\n                nearest_b.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_b, connect_node))\n\n                success = True\n                if tree_a is start_tree:\n                    final_path = extract_full_path(new_node, connect_node)\n                else:\n                    final_path = extract_full_path(connect_node, new_node)\n                break\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        dim = len(from_pos)\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 14.56569,
    "time_improvement": -60.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02408256530761719,
            "num_nodes_avg": 176.5,
            "path_length_avg": 165.42585840478745,
            "success_improvement": 0.0,
            "time_improvement": -138.7053474368791,
            "length_improvement": 17.321745959395937,
            "objective_score": -38.14725503918454
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.025348377227783204,
            "num_nodes_avg": 289.0,
            "path_length_avg": 240.2153152727579,
            "success_improvement": 0.0,
            "time_improvement": -77.21129084681351,
            "length_improvement": 20.28843154669553,
            "objective_score": -19.105700944704946
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01880502700805664,
            "num_nodes_avg": 208.6,
            "path_length_avg": 136.6452058160128,
            "success_improvement": 0.0,
            "time_improvement": 34.458514518194384,
            "length_improvement": 16.091611983276565,
            "objective_score": 13.555876752113628
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This algorithm combines the strengths of both provided planners by implementing an informed, bidirectional RRT* with adaptive informed ellipse sampling, dynamic goal biasing, and efficient KDTree-based neighbor searches. It incorporates lazy collision checking to minimize overhead, batch rewiring for local cost improvements, and periodic pruning of low-quality or dead-end branches to focus computational effort on promising paths. Upon connection, the path is shortcut-smoothed to reduce jaggedness and improve path quality. The architecture balances exploration with exploitation to enhance success rate, reduce planning time, and produce shorter, smoother paths.",
    "planning_mechanism": "The planner grows two trees bidirectionally from start and goal, sampling points within an adaptively shaped ellipsoidal heuristic informed region. Each iteration attempts to extend the smaller tree first toward the sampled point, selecting parents and rewiring neighbors within an adaptive radius using KDTree for efficient queries. Lazy collision checks delay expensive verifications until necessary. When a connection between trees is formed, the path is extracted, smoothed through shortcutting, and the planner prunes unpromising nodes periodically. This results in efficient convergence, improved path quality, and reduced computational time.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def is_leaf(self):\n        return len(self.children) == 0\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate_start=0.15, goal_sample_rate_end=0.4,\n                 radius_constant: float = 25.0, radius_min: float = 3.0,\n                 prune_interval: int = 250, prune_threshold: int = 200,\n                 shortcut_trials: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = goal_sample_rate_start\n        self.goal_sample_rate_end = goal_sample_rate_end\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.shortcut_trials = shortcut_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        from collections import deque\n\n        try:\n            from scipy.spatial import cKDTree as KDTree\n        except ImportError:\n            KDTree = None\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        # Initialize trees\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def dist_sq(a,b):\n            return sum((a[i]-b[i])**2 for i in range(len(a)))\n\n        # Adaptive radius per RRT* rewiring theory\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(self.radius_min, val)\n\n        def build_kdtree(tree):\n            if KDTree is None or not tree:\n                return None\n            pts = [node.position for node in tree]\n            return KDTree(pts)\n\n        def nearest(tree, kdtree, point):\n            if kdtree is not None:\n                _, idx = kdtree.query(point)\n                return tree[idx]\n            else:\n                return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, kdtree, pos, radius):\n            if kdtree is not None:\n                idxs = kdtree.query_ball_point(pos, radius)\n                return [tree[i] for i in idxs]\n            else:\n                r2 = radius * radius\n                return [n for n in tree if dist_sq(n.position, pos) <= r2]\n\n        def steer(from_pos, to_pos):\n            distance_ = dist(from_pos, to_pos)\n            if distance_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        # Informed ellipsoidal sampling between start and goal based on best path cost\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf'):\n                return uniform_sample()\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(len(start)))\n            diff = tuple(goal[d] - start[d] for d in range(len(start)))\n            length = dist(start, goal)\n            n = len(start)\n\n            # Sample unit n-sphere using Marsaglia method\n            def sample_unit_sphere(dim):\n                vec = [random.gauss(0,1) for _ in range(dim)]\n                norm = math.sqrt(sum(x*x for x in vec))\n                u = [x / norm for x in vec]\n                r = random.uniform(0,1) ** (1.0/dim)\n                return [r*x for x in u]\n\n            if c_best**2 - c_min**2 < 0:\n                radius_minor = 0.0\n            else:\n                radius_minor = math.sqrt(c_best**2 - c_min**2)/2\n\n            if n == 2:\n                L = [length/2, radius_minor]\n            elif n == 3:\n                L = [length/2, radius_minor, radius_minor]\n            else:\n                return uniform_sample()\n\n            unit_sample = sample_unit_sphere(n)\n            sample_scaled = tuple(unit_sample[i]*L[i] for i in range(n))\n\n            # Rotation to align with start-goal vector\n            if n == 2:\n                dx, dy = diff\n                theta = math.atan2(dy, dx)\n                cos_t, sin_t = math.cos(theta), math.sin(theta)\n                x_ellip = sample_scaled[0]*cos_t - sample_scaled[1]*sin_t\n                y_ellip = sample_scaled[0]*sin_t + sample_scaled[1]*cos_t\n                sample_rotated = (x_ellip, y_ellip)\n            elif n == 3:\n                length_nonzero = length if length > 0 else 1e-8\n                ux, uy, uz = 1.0, 0.0, 0.0\n                vx, vy, vz = (diff[d]/length_nonzero for d in range(3))\n                vx, vy, vz = float(vx), float(vy), float(vz)\n\n                kx = uy*vz - uz*vy\n                ky = uz*vx - ux*vz\n                kz = ux*vy - uy*vx\n                k_norm = math.sqrt(kx*kx + ky*ky + kz*kz)\n\n                if k_norm < 1e-6:\n                    if vx < 0:\n                        R = [[-1,0,0],[0,-1,0],[0,0,1]]\n                    else:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    kx /= k_norm\n                    ky /= k_norm\n                    kz /= k_norm\n                    cos_a = ux*vx + uy*vy + uz*vz\n                    sin_a = k_norm\n                    K = [\n                        [0, -kz, ky],\n                        [kz, 0, -kx],\n                        [-ky, kx, 0]\n                    ]\n                    I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                    K2 = [[sum(K[r][m]*K[m][c] for m in range(3)) for c in range(3)] for r in range(3)]\n                    R = [[I[r][c] + sin_a*K[r][c] + (1 - cos_a)*K2[r][c] for c in range(3)] for r in range(3)]\n\n                sample_rotated = tuple(\n                    R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2],\n                    R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2],\n                    R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                )\n            else:\n                return uniform_sample()\n\n            sample_global = tuple(center[d] + sample_rotated[d] for d in range(n))\n\n            # Clamp to bounds\n            clamped = tuple(max(0.0, min(sample_global[d], bounds[d])) for d in range(n))\n\n            if self._is_in_obstacle(clamped, obstacles, is_3d):\n                return uniform_sample()\n            return clamped\n\n        def uniform_sample(max_retry=50):\n            for _ in range(max_retry):\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return start_pos\n\n        lazy_checked_edges = set()  # Store edges checked to avoid redundant checks\n\n        # Extend tree towards point with rewiring\n        def try_extend(tree, kdtree, point):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, kdtree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, kdtree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            # Lazy collision checking: skip edge checks unless necessary\n            for node in neighbors:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    edge_candidate = (node, new_pos)\n                    if edge_candidate in lazy_checked_edges:\n                        min_cost = tentative_cost\n                        best_parent = node\n                    else:\n                        if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                            lazy_checked_edges.add(edge_candidate)\n                            min_cost = tentative_cost\n                            best_parent = node\n\n            # Confirm edge feasibility to best parent\n            if self._is_edge_in_obstacle(best_parent.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if cheaper path found via new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        # Try connecting opposite tree towards node incrementally\n        def try_connect(tree, kdtree, node):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, kdtree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if (not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d) and\n                        not self._is_in_obstacle(node.position, obstacles, is_3d)):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        # Shortcut smoothing to reduce path jaggedness and length\n        def smooth_path(path, max_trials):\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Prune dead-end and low-potential branches to reduce complexity\n        def prune_dead_branches():\n            removed = []\n            queue = deque([start_root, goal_root])\n            reachable = set()\n            while queue:\n                current = queue.popleft()\n                reachable.add(current)\n                for child in current.children:\n                    if child not in reachable:\n                        queue.append(child)\n\n            to_remove = [node for node in nodes if node not in reachable]\n\n            for node in to_remove:\n                try:\n                    nodes.remove(node)\n                except Exception:\n                    continue\n                # Remove from trees if present\n                for tree in [tree_start, tree_goal]:\n                    if node in tree:\n                        tree.remove(node)\n                try:\n                    if node.parent:\n                        node.parent.children.remove(node)\n                except Exception:\n                    pass\n\n                # Remove connected edges\n                edges[:] = [e for e in edges if e[0] != node and e[1] != node]\n                removed.append(node)\n\n            return len(removed)\n\n        # Initialization of best path cost and min cost heuristic\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n\n        # For dynamic goal bias interpolation\n        def goal_bias(iteration):\n            return ((self.goal_sample_rate_end - self.goal_sample_rate_start)*iteration/self.max_iter\n                    + self.goal_sample_rate_start)\n\n        for itr in range(self.max_iter):\n            gb_rate = goal_bias(itr)\n            if random.random() < gb_rate:\n                # Sample goal with higher probability, else start\n                rand_point = goal_pos if random.random() < 0.75 else start_pos\n            else:\n                rand_point = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            rand_point = tuple(max(0.0, min(rand_point[d], bounds[d])) for d in range(len(bounds)))\n\n            # Always extend smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            kdtree_start = build_kdtree(tree_start)\n            kdtree_goal = build_kdtree(tree_goal)\n\n            new_node_start = try_extend(tree_start, kdtree_start, rand_point)\n            if new_node_start is None:\n                # Skip this iteration if extension failed\n                continue\n\n            new_node_goal = try_connect(tree_goal, kdtree_goal, new_node_start)\n            if new_node_goal is not None:\n                # Connection found\n                success_state = True\n\n                # Combine paths avoiding duplicate node\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n\n                # Evaluate cost\n                total_cost = sum(dist(merged_path[i], merged_path[i+1]) for i in range(len(merged_path)-1))\n                if total_cost + 1e-9 < c_best:\n                    c_best = total_cost\n                    extracted_path = merged_path\n\n                # Run shortcut smoothing immediately upon connection\n                extracted_path = smooth_path(extracted_path, self.shortcut_trials)\n\n                # Prune disconnected nodes periodically or immediately (keep complexity low)\n                prune_dead_branches()\n\n                # Break to return best found path early for efficiency\n                break\n\n            # Periodic pruning for efficiency if busy search tree\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_branches()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 15.28756,
    "time_improvement": -66.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.011576533317565918,
            "num_nodes_avg": 73.3,
            "path_length_avg": 156.274129124881,
            "success_improvement": 0.0,
            "time_improvement": -14.746098365614577,
            "length_improvement": 21.89569229167649,
            "objective_score": -0.044691051349074584
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03883960247039795,
            "num_nodes_avg": 309.3,
            "path_length_avg": 239.02827921944194,
            "success_improvement": 0.0,
            "time_improvement": -171.52886466484986,
            "length_improvement": 20.682330268402747,
            "objective_score": -47.32219334577441
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03190631866455078,
            "num_nodes_avg": 198.6,
            "path_length_avg": 123.23471948179215,
            "success_improvement": 0.0,
            "time_improvement": -11.203643612667538,
            "length_improvement": 24.32645845377667,
            "objective_score": 1.5041986069550735
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved planner integrates bidirectional RRT* with adaptive sampling biased around the current best path corridor and obstacles, dynamically adjusts neighbor radius based on node count for efficient rewiring, and uses lazy collision checking with caching to minimize computational cost. It balances tree growth by expanding the smaller tree per iteration and aggressively attempts to connect the opposite tree using iterative steering. Periodic pruning removes nodes that cannot improve the current best path, and intensive shortcut smoothing refines the final path for smoothness and optimality. Additional heuristics accelerate convergence and enhance robustness in complex, cluttered, 2D or 3D environments.",
    "planning_mechanism": "The planning mechanism begins with two trees rooted at start and goal. It adaptively samples new points biased around the best path or uniformly otherwise, checks for collision-free validity, and extends the smaller tree toward the sample using steering with fixed step size. Neighbors within a dynamic search radius found via KD-tree enable parent selection and rewiring for path cost improvements. The opposite tree attempts connection via iterative steering and collision checking. The best path updates upon successful connection, followed by shortcut smoothing. Periodic pruning eliminates nodes unlikely to improve the solution, keeping the search efficient and focused on promising areas.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=6.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=150,\n                 prune_threshold: int=250,\n                 smoothing_iterations: int=150,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos):\n            total_d = dist(from_pos, to_pos)\n            if total_d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / total_d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            val = self.max_neighbor_radius * math.sqrt(math.log(n_nodes)/n_nodes)\n            return max(self.min_neighbor_radius, min(val, self.max_neighbor_radius))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # Lazy collision checking cache for edges\n        edge_collision_cache = {}\n\n        def canonical_edge_key(p1, p2):\n            return (p1, p2) if p1 < p2 else (p2, p1)\n\n        def can_connect(p1, p2):\n            key = canonical_edge_key(p1, p2)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [p for p,n in points_nodes]\n                self.nodes = [n for p,n in points_nodes]\n                self.dim = dim\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p,n in zip(self.points, self.nodes):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, r):\n                r2 = r*r\n                result = []\n                for p,n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for i in range(self.dim):\n                        delta = p[i] - pt[i]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(n)\n                return result\n\n        def adaptive_sample(best_path):\n            if best_path:\n                import numpy as np\n                attempts = 30\n                for _ in range(attempts):\n                    base_point = best_path[random.randint(0, len(best_path)-1)]\n                    noise = np.random.normal(0, self.step_size*0.9, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if random.random() < 0.6 else start_pos\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_nodes(tree_nodes, best_cost, root_start, root_goal):\n            removed_nodes = 0\n            to_remove = []\n            dist_goal = dist\n            for node in tree_nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist_goal(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for rm in to_remove:\n                if rm.parent:\n                    try:\n                        rm.parent.children.remove(rm)\n                    except ValueError:\n                        pass\n                try:\n                    tree_nodes.remove(rm)\n                except ValueError:\n                    pass\n                removed_nodes += 1\n            return removed_nodes\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        nodes = [root_start, root_goal]\n        edges = []\n\n        best_path = []\n        c_best = float('inf')\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            sample_point = adaptive_sample(best_path)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(sample_point)\n            new_pos = steer(nearest_a.position, sample_point)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for nbr in near_nodes:\n                candidate_cost = nbr.cost + dist(nbr.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(nbr.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nbr in near_nodes:\n                if nbr is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                if c_via_new + 1e-12 < nbr.cost and can_connect(new_node.position, nbr.position):\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                    except ValueError:\n                        pass\n                    nbr.update_parent(new_node, c_via_new)\n                    edges.append((new_node, nbr))\n\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_connect_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 4\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes))\n                near_b_nodes = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_b_nodes:\n                    if nbr_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if c_via_new_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    connection_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=connection_cost)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if connection_cost + 1e-12 < c_best:\n                        c_best = connection_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 1.20402,
    "time_improvement": -18.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007881546020507812,
            "num_nodes_avg": 56.6,
            "path_length_avg": 155.97707175226145,
            "success_improvement": 0.0,
            "time_improvement": 21.878456172191814,
            "length_improvement": 22.044158711345755,
            "objective_score": 10.972368593926696
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.022196197509765626,
            "num_nodes_avg": 235.0,
            "path_length_avg": 244.48665407327107,
            "success_improvement": 0.0,
            "time_improvement": -55.17430473952214,
            "length_improvement": 18.871056826862365,
            "objective_score": -12.778080056484168
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03454205989837646,
            "num_nodes_avg": 238.3,
            "path_length_avg": 127.75089409516185,
            "success_improvement": 0.0,
            "time_improvement": -20.3900380664788,
            "length_improvement": 21.553255182231712,
            "objective_score": -1.8063603834972977
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved hybrid bidirectional RRT* planner enhances path quality and planning efficiency by using an adaptive bidirectional sampling strategy with increased goal bias, logarithmically shrinking rewiring radius for dynamic neighborhood optimization, and balanced tree extension from the smaller tree to maintain exploration and exploitation. It incorporates refined local rewiring for path cost minimization and smoothness, stricter collision and edge feasibility checks, and incremental connection attempts between trees to achieve faster convergence to shorter, smoother, and collision-free paths. It also features a more precise edge collision resolution and avoids unnecessary expansions by careful validation of nodes and edges.",
    "planning_mechanism": "The planner alternates extending the smaller of the two trees growing from start and goal. Sampling combines goal bias towards both start and goal for faster bridging. New nodes are generated by steering from nearest nodes within a capped step size. Each new sample undergoes collision and edge-validity checks before insertion. The dynamic rewiring radius shrinks logarithmically with tree size, enhancing local optimization. Nodes in the neighborhood are rewired to the new node if it reduces their path cost without collision. Connection attempts between the two trees happen on every successful extension, merging their optimal paths once connected. Paths are reconstructed by backtracking and combined to form shorter, smoother routes.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checks etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2, radius_constant: float=22.0, radius_min: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Combined start/goal bias probability\n        self.radius_constant = radius_constant      # For rewiring radius\n        self.radius_min = radius_min                  # Minimum radius for rewiring\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if random.random() < 0.5 else start_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: distance(n.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (node_dist := (distance(node.position, pos))) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(self.radius_min, r)\n\n        def can_add_node(pos):\n            for d, c in enumerate(pos):\n                if c < 0 or c > bounds[d]:\n                    return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not can_add_node(new_pos):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            # Choose best parent candidate with minimal cost and feasible edge\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cost improvement if valid\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                dist_to_target = distance(new_pos, node.position)\n                if dist_to_target <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + dist_to_target\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        for _ in range(self.max_iter):\n            # Always extend smaller tree first to balance exploration\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            sample_point = sample_free()\n\n            new_node_start = try_extend(tree_start, sample_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n\n                # Final optional smoothing pass: shortcutting\n                extracted_path = self._shortcut_path(extracted_path, obstacles, is_3d, bounds)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds):\n        # Try to shorten the path by skipping intermediate nodes if edge is collision-free\n        if len(path) <= 2:\n            return path\n        shortened = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            # Walk backward to find the furthest node to connect directly\n            for j in range(len(path) - 1, idx, -1):\n                if not self._is_edge_in_obstacle(path[idx], path[j], obstacles, is_3d):\n                    next_idx = j\n                    break\n            shortened.append(path[next_idx])\n            idx = next_idx\n            if idx == len(path) - 1:\n                break\n        return shortened\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 14.8769,
    "time_improvement": -58.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.017352199554443358,
            "num_nodes_avg": 78.9,
            "path_length_avg": 163.69795914086194,
            "success_improvement": -9.999999999999998,
            "time_improvement": -71.99425271058428,
            "length_improvement": 18.18533340380766,
            "objective_score": -22.96120913241375
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.030221176147460938,
            "num_nodes_avg": 311.7,
            "path_length_avg": 236.29207850100835,
            "success_improvement": 0.0,
            "time_improvement": -111.27717912176746,
            "length_improvement": 21.590294236569164,
            "objective_score": -29.065094889216407
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.026075363159179688,
            "num_nodes_avg": 237.5,
            "path_length_avg": 124.90730367880731,
            "success_improvement": 0.0,
            "time_improvement": 9.119086338031334,
            "length_improvement": 23.29939099864213,
            "objective_score": 7.395604101137827
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm introduces an Adaptive Multi-Fidelity RRT* (AMF-RRT*) planner which leverages multi-resolution sampling and adaptive step sizing to balance exploration and exploitation efficiently. It dynamically adjusts sampling density and step sizes based on local environment complexity and the current best path cost, incorporating heuristic-biased informed sampling and fast neighborhood search via spatial hashing. It applies incremental rewiring and lazy collision checking with collision caching. Once a feasible path is found, it performs progressive shortcut smoothing with collision-aware interpolation. This approach enhances planning efficiency, path quality, smoothness, robustness, and success rate, especially in cluttered 2D/3D environments.",
    "planning_mechanism": "The planner grows a single tree rooted at start, incrementally sampling either randomly or within an informed ellipsoid around the current best path to bias toward promising regions. It uses spatial hashing to quickly find neighbors within an adaptive radius derived from the current iteration and node density. Step sizes adapt locally: smaller in cluttered regions, larger in open spaces. Collision checks on nodes and edges use caching to avoid redundancy. Upon connecting to the goal region, the algorithm rewires neighbors to reduce path cost. Periodically, it performs shortcut smoothing on the best path found. The process continues until max iterations or early convergence criteria are met.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...] (2D or 3D)\n        self.parent = parent                # Node or None\n        self.cost = cost                    # Cost from root (start)\n        self.children = []                  # Child nodes\n        self.valid = True                   # For collision checking or pruning\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance_to(self, other):\n        return math.dist(self.position, other.position)\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 6000,\n                 base_step_size: float = 6.0,\n                 min_step_size: float = 1.5,\n                 max_step_size: float = 10.0,\n                 base_radius: float = 20.0,\n                 min_radius: float = 5.0,\n                 collision_check_resolution: float = 0.5,\n                 smoothing_iters: int = 120,\n                 early_stop_cost_eps: float = 1e-3):\n        self.max_iter = max_iter\n        self.base_step_size = base_step_size\n        self.min_step_size = min_step_size\n        self.max_step_size = max_step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.collision_check_resolution = collision_check_resolution\n        self.smoothing_iters = smoothing_iters\n        self.early_stop_cost_eps = early_stop_cost_eps\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n        from collections import defaultdict\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def clamp(p):\n            return tuple(max(0, min(p[i], bounds[i])) for i in range(dim))\n\n        # Adaptive step size: smaller near obstacles or in cluttered regions\n        def adaptive_step_size(pos):\n            # Sample points around pos; if near obstacles, reduce step size\n            # Checks a small neighborhood grid\n            steps_check = 8\n            radius = 2.0\n            nearby_obs = 0\n            for _ in range(steps_check):\n                offset = tuple(random.uniform(-radius, radius) for _ in range(dim))\n                sample_p = tuple(pos[i] + offset[i] for i in range(dim))\n                if not in_bounds(sample_p):\n                    continue\n                if self._is_in_obstacle(sample_p, obstacles, is_3d):\n                    nearby_obs += 1\n            frac = nearby_obs / steps_check\n            step = self.max_step_size - frac * (self.max_step_size - self.min_step_size)\n            return max(self.min_step_size, min(step, self.max_step_size))\n\n        def steer(from_p, to_p, step_size):\n            dist = distance(from_p, to_p)\n            if dist <= step_size:\n                new_p = to_p\n            else:\n                ratio = step_size / dist\n                new_p = tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n            return clamp(new_p)\n\n        def node_in_obstacle(node_pos):\n            return self._is_in_obstacle(node_pos, obstacles, is_3d)\n\n        def edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # Spatial Hashing for neighborhood queries (fast radius search)\n        class SpatialHash:\n            def __init__(self, cell_size):\n                self.cell_size = cell_size\n                self.hash = defaultdict(list)\n\n            def _hash_point(self, p):\n                return tuple(int(p[i] // self.cell_size) for i in range(dim))\n\n            def insert(self, node):\n                key = self._hash_point(node.position)\n                self.hash[key].append(node)\n\n            def near(self, p, radius):\n                cells_range = int(math.ceil(radius / self.cell_size))\n                base_cell = self._hash_point(p)\n                neighbors = []\n                r2 = radius * radius\n                for dx in range(-cells_range, cells_range + 1):\n                    for dy in range(-cells_range, cells_range + 1):\n                        for dz in ([0] if dim == 2 else range(-cells_range, cells_range + 1)):\n                            cell = list(base_cell)\n                            cell[0] += dx\n                            cell[1] += dy\n                            if dim == 3:\n                                cell[2] += dz\n                            cell = tuple(cell)\n                            if cell not in self.hash:\n                                continue\n                            for node in self.hash[cell]:\n                                d2 = 0.0\n                                for i_ in range(dim):\n                                    delta = node.position[i_] - p[i_]\n                                    d2 += delta * delta\n                                    if d2 > r2:\n                                        break\n                                if d2 <= r2:\n                                    neighbors.append(node)\n                return neighbors\n\n            def rebuild(self, nodes):\n                self.hash.clear()\n                for n in nodes:\n                    self.insert(n)\n\n        # Heuristic distance from pos to goal (Euclidean)\n        def heuristic(pos):\n            return distance(pos, goal)\n\n        # Informed sampling inside ellipsoid defined by current best path cost\n        def informed_sample(c_best, c_min):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # Uniform random sample\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not node_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Unit vector from start to goal\n            a1 = np.array([(goal[i] - start[i]) / c_min for i in range(dim)])\n            center = np.array([(start[i] + goal[i]) / 2 for i in range(dim)])\n\n            # Generate rotation matrix that aligns x-axis with vector a1 (Householder reflection)\n            id_mat = np.eye(dim)\n            e1 = np.zeros(dim)\n            e1[0] = 1.0\n            v = a1 - e1\n            s = np.linalg.norm(v)\n            if s < 1e-10:\n                rot = id_mat\n            else:\n                v = v / s\n                rot = id_mat - 2 * np.outer(v, v)\n\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(r1 * r1 - (c_min / 2.) ** 2)\n                radii = np.array([r1, r2])\n            elif dim == 3:\n                r2 = math.sqrt(max(r1*r1 - (c_min/2.)**2, 0))\n                radii = np.array([r1, r2, r2])\n            else:\n                radii = np.array([r1] + [r1]*(dim-1))  # fallback\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not node_in_obstacle(p):\n                        return p\n\n            # Fallback uniform random sample\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not node_in_obstacle(p):\n                    return p\n            return p\n\n        # Shortcut smoothing to improve path length and smoothness\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            new_path = path[:]\n            for _ in range(self.smoothing_iters):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                p1, p2 = new_path[i], new_path[j]\n                if not edge_in_obstacle(p1, p2):\n                    # Remove intermediate nodes between i and j\n                    new_path = new_path[:i + 1] + new_path[j:]\n            return new_path\n\n        # Extract path from node to root (start)\n        def extract_path(node):\n            return node.path_from_root()\n\n        # Initialization\n        root = Node(start, parent=None, cost=0.0)\n        nodes = [root]\n        edges = []\n        spatial_hash = SpatialHash(cell_size=self.base_radius / 2.5)\n        spatial_hash.insert(root)\n\n        c_min = distance(start, goal)\n        c_best = float('inf')\n        best_goal_node = None\n        best_path = []\n\n        collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in collision_cache:\n                return not collision_cache[(p1, p2)]\n            if (p2, p1) in collision_cache:\n                return not collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                collision_cache[(p1, p2)] = True\n                return False\n            collision = edge_in_obstacle(p1, p2)\n            collision_cache[(p1, p2)] = collision\n            return not collision\n\n        success_state = False\n\n        for iter_num in range(self.max_iter):\n            # Sample informed or uniform point\n            q_rand = informed_sample(c_best, c_min)\n\n            # Adaptive step size near q_rand\n            step_size = adaptive_step_size(q_rand)\n\n            # Find nearest node in tree\n            nearest_nodes = spatial_hash.near(q_rand, radius=step_size * 3)\n            if not nearest_nodes:\n                nearest_nodes = nodes\n            nearest = min(nearest_nodes, key=lambda n: distance(n.position, q_rand))\n\n            new_pos = steer(nearest.position, q_rand, step_size)\n            if not in_bounds(new_pos):\n                continue\n            if node_in_obstacle(new_pos):\n                continue\n            if not can_connect(nearest.position, new_pos):\n                continue\n\n            # Find neighbors for rewiring within radius r(iter)\n            n_nodes = len(nodes) + 1\n            gamma = self.base_radius\n            r = max(self.min_radius, min(gamma * math.sqrt((math.log(n_nodes) / n_nodes)), gamma))\n            near_nodes = spatial_hash.near(new_pos, r)\n\n            # Choose best parent among near nodes minimizing cost + distance, with collision checked edge\n            min_cost = nearest.cost + distance(nearest.position, new_pos)\n            best_parent = nearest\n            for node_near in near_nodes:\n                if node_near == nearest:\n                    continue\n                c_candidate = node_near.cost + distance(node_near.position, new_pos)\n                if c_candidate + 1e-12 < min_cost and can_connect(node_near.position, new_pos):\n                    min_cost = c_candidate\n                    best_parent = node_near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            spatial_hash.insert(new_node)\n\n            # Rewire neighbors if cheaper through new_node\n            for node_near in near_nodes:\n                if node_near == best_parent:\n                    continue\n                c_via_new = new_node.cost + distance(new_node.position, node_near.position)\n                if c_via_new + 1e-12 < node_near.cost and can_connect(new_node.position, node_near.position):\n                    try:\n                        edges.remove((node_near.parent, node_near))\n                    except ValueError:\n                        pass\n                    node_near.update_parent(new_node, c_via_new)\n                    edges.append((new_node, node_near))\n\n            # Check if new_node can connect to goal region (within step size)\n            dist_to_goal = distance(new_node.position, goal)\n            if dist_to_goal <= step_size and can_connect(new_node.position, goal) and not node_in_obstacle(goal):\n                goal_node = Node(goal, parent=new_node, cost=new_node.cost + dist_to_goal)\n                new_node.children.append(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n\n                # Extract path\n                path = extract_path(goal_node)\n                cost_path = goal_node.cost\n\n                # Update best path\n                if cost_path + 1e-12 < c_best:\n                    c_best_prev = c_best\n                    c_best = cost_path\n                    best_goal_node = goal_node\n                    best_path = shortcut_path(path)\n                    success_state = True\n\n                    # Early stop if improvement small\n                    if abs(c_best_prev - c_best) < self.early_stop_cost_eps:\n                        break\n\n            if iter_num > 0 and iter_num % 500 == 0 and success_state:\n                # Periodic optional shortcut smoothing to improve path progressively\n                best_path = shortcut_path(best_path)\n\n        # Final extracted path\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 6266.16069,
    "time_improvement": -20900.0,
    "length_improvement": 27.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 3.133392405509949,
            "num_nodes_avg": 4297.9,
            "path_length_avg": 152.6532994991108,
            "success_improvement": 0.0,
            "time_improvement": -30958.05022261294,
            "length_improvement": 23.705348137044073,
            "objective_score": -9282.673997156473
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 3.0820781707763674,
            "num_nodes_avg": 4878.7,
            "path_length_avg": 219.02173164745537,
            "success_improvement": -9.999999999999998,
            "time_improvement": -21446.904017801335,
            "length_improvement": 27.321179604415736,
            "objective_score": -6433.606969419518
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 2.9824872970581056,
            "num_nodes_avg": 5063.7,
            "path_length_avg": 111.77032449460577,
            "success_improvement": 0.0,
            "time_improvement": -10294.91449791885,
            "length_improvement": 31.36628760268258,
            "objective_score": -3082.201091855118
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines bidirectional tree growth with informed ellipsoidal sampling, adaptive neighbor radius, KD-tree accelerated nearest neighbor searches, periodic node pruning, collision caching, incremental rewiring, and shortcut smoothing. It unifies the efficiency and asymptotic optimality of RRT* variants with the fast convergence of bidirectional search to improve planning efficiency, path quality, robustness, and success rate in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling adaptively in an ellipsoidal informed region based on the current best path cost to bias samples to promising areas. Trees perform rewiring for local path optimization using neighbors found via KD-tree radius searches. Collision checks are cached to avoid redundant computations. Periodic pruning removes nodes unlikely to improve solutions, and the final path is aggressively shortcut-smoothed for quality and smoothness. The planning stops early upon successfully connecting the trees and improving the best path cost.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision/pruning state\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to map bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree for accelerated neighbor search (brute-force for simplicity)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Ellipsoidal informed sampling with fallback uniform sampling\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                # Goal bias & uniform sampling when no good solution\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))  # unit vector start->goal\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) * (c_min / 2), 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    x = x * radii\n                    p = rot @ x + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            # Fallback uniform sampling if ellipsoid samples fail\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialize roots\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth direction for balanced expansion\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors to improve path cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Try connecting the other tree towards new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    # Retrieve paths according to tree order\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning for efficiency if enough nodes and solution found\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -2.73225,
    "time_improvement": -5.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.010381293296813966,
            "num_nodes_avg": 80.0,
            "path_length_avg": 161.56607835697952,
            "success_improvement": 0.0,
            "time_improvement": -2.898930890735342,
            "length_improvement": 19.25082692902676,
            "objective_score": 2.98048611858475
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.026044535636901855,
            "num_nodes_avg": 231.1,
            "path_length_avg": 236.64448292717498,
            "success_improvement": 0.0,
            "time_improvement": -82.07815586168962,
            "length_improvement": 21.47335452559473,
            "objective_score": -20.328775853387942
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.008422541618347167,
            "num_nodes_avg": 104.8,
            "path_length_avg": 127.41733327110765,
            "success_improvement": 0.0,
            "time_improvement": 70.64477020095212,
            "length_improvement": 21.758081622243104,
            "objective_score": 25.545047384734257
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner implements an improved, adaptive bidirectional RRT* with dynamic neighborhood radius, adaptive step sizing, balanced tree growth, heuristic goal-biased sampling, and iterative shortcut smoothing. It integrates rigorous collision checks for nodes and edges, incremental connection attempts with limited steps, and rewiring for cost optimality, aiming to enhance planning efficiency, success rate, path quality, and smoothness.",
    "planning_mechanism": "The planner grows two trees from the start and goal, sampling points with adaptive goal biasing. Each iteration extends the smaller tree adaptively, rewires neighbors within a dynamic radius, and incrementally connects the other tree. Upon successful connection, it reconstructs the path and applies iterative shortcut smoothing for refinement.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.25,\n                 radius_const: float=25.0,\n                 radius_min: float=5.0,\n                 smoothing_iter: int=60,\n                 collision_resolution: float=0.5,\n                 adaptive_step_min: float=1.5,\n                 adaptive_step_max: float=7.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.smoothing_iter = smoothing_iter\n        self.collision_resolution = collision_resolution\n        self.adaptive_step_min = adaptive_step_min\n        self.adaptive_step_max = adaptive_step_max\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        import math\n        import random\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(point):\n            for i, val in enumerate(point):\n                if val < 0 or val > bounds[i]:\n                    return False\n            return True\n\n        def sample_point():\n            # Goal biasing with diversity to cover start as well\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < 0.85 else start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_const\n            r = self.radius_const * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(self.radius_min, r)\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius*radius\n            near = []\n            for node in tree:\n                dx = node.position[0] - pos[0]\n                dy = node.position[1] - pos[1]\n                dz = node.position[2] - pos[2] if is_3d else 0.0\n                dist_sq = dx*dx + dy*dy + dz*dz\n                if dist_sq <= r_sq:\n                    near.append(node)\n            return near\n\n        def adaptive_step(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            step = min(self.adaptive_step_max, max(self.adaptive_step_min, dist))\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def collision_free(node_pos):\n            return (in_bounds(node_pos) and not self._is_in_obstacle(node_pos, obstacles, is_3d))\n\n        def edge_collision_free(pos1, pos2):\n            if not in_bounds(pos2):\n                return False\n            return not self._is_edge_in_obstacle(pos1, pos2, obstacles, is_3d, self.collision_resolution)\n\n        def add_node(tree, new_node, parent_node):\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: distance(n.position, point))\n            new_pos = adaptive_step(nearest_node.position, point)\n            if not collision_free(new_pos) or not edge_collision_free(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + distance(node.position, new_pos)\n                if temp_cost < min_cost and edge_collision_free(node.position, new_pos):\n                    min_cost = temp_cost\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-12 < neighbor.cost and edge_collision_free(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: distance(n.position, node.position))\n            last_node = nearest_node\n\n            max_iters = 5  # Limit incremental connection to save time\n            for _ in range(max_iters):\n                new_pos = adaptive_step(last_node.position, node.position)\n                if not collision_free(new_pos) or not edge_collision_free(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if edge_collision_free(new_pos, node.position):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if edge_collision_free(p_i, p_j):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n\n        for itr in range(self.max_iter):\n            rand_point = sample_point()\n\n            # Always extend the smaller tree first for balance and efficiency\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                extracted_path = extract_path(new_node_start, new_node_goal)\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 5.21568,
    "time_improvement": -18.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.011061477661132812,
            "num_nodes_avg": 68.9,
            "path_length_avg": 164.79880628641746,
            "success_improvement": -9.999999999999998,
            "time_improvement": -9.640888939303705,
            "length_improvement": 17.63514058124783,
            "objective_score": -4.365238565541544
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.026488065719604492,
            "num_nodes_avg": 252.5,
            "path_length_avg": 250.82658090832538,
            "success_improvement": 0.0,
            "time_improvement": -85.17888841663125,
            "length_improvement": 16.767254613720603,
            "objective_score": -22.200215602245255
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.017284131050109862,
            "num_nodes_avg": 207.9,
            "path_length_avg": 130.35670349632775,
            "success_improvement": -9.999999999999998,
            "time_improvement": 39.759319473401256,
            "length_improvement": 19.953131233316473,
            "objective_score": 10.918422088683673
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m3",
    "algorithm_description": "This planner is a streamlined, bidirectional RRT* variant combining adaptive informed sampling biased within an ellipsoidal region, dynamic neighborhood radius, and incremental rewiring. It leverages efficient collision checking and pruning to enhance path quality, success rate, and search speed in both 2D and 3D environments. Shortcut smoothing is applied post planning to refine the path smoothness and length.",
    "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling points inside an adaptively sized ellipsoid around the best path to focus exploration. Using a dynamic radius based on iterations and node count, it connects and rewires nodes incrementally while checking collision constraints rigorously. Periodic pruning removes nodes unlikely to improve solutions. Once a connection between two trees is found, shortcut smoothing improves the path before returning the result.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Total cost from root node\n        self.children = []\n        self.valid = True               # For collision check status\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_radius: float = 5.0, max_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_iterations: int = 100,\n                 collision_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / self.collision_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        def informed_sample(c_best, c_min):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            rot = id_mat\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n\n            r1 = c_best / 2.0\n            r_else = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_else] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    sample = rot @ (x * radii) + np.array(center)\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        class KDTreeSimple:\n            def __init__(self, points_nodes):\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = self.nodes[i]\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    dist_sq = sum((p[d] - pt[d]) ** 2 for d in range(dim))\n                    if dist_sq <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        nodes = []\n        edges = []\n\n        root_start = Node(start, cost=0.0)\n        root_goal = Node(goal, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes.extend([root_start, root_goal])\n\n        c_min = dist(start, goal)\n        c_best = float('inf')\n        best_path = []\n        success = False\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            rev_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return not edge_collision_cache[rev_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_nodes(best_cost):\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                estimate = dist(node.position, goal)\n                if node.cost + estimate >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n                try:\n                    nodes.remove(node)\n                except ValueError:\n                    pass\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTreeSimple([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTreeSimple([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_cand_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_cand_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_cand_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                break\n\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                edge_collision_cache.clear()\n\n        final_path = best_path if success else []\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 11.52169,
    "time_improvement": -53.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.015595316886901855,
            "num_nodes_avg": 101.8,
            "path_length_avg": 165.23104835574372,
            "success_improvement": 0.0,
            "time_improvement": -54.580107572620975,
            "length_improvement": 17.41911014949183,
            "objective_score": -12.890210241887925
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0384274959564209,
            "num_nodes_avg": 270.9,
            "path_length_avg": 235.47690133379328,
            "success_improvement": 0.0,
            "time_improvement": -168.64781525281063,
            "length_improvement": 21.860797599322087,
            "objective_score": -46.22218505597877
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0100982666015625,
            "num_nodes_avg": 117.5,
            "path_length_avg": 121.27447277077366,
            "success_improvement": 0.0,
            "time_improvement": 64.80433696935654,
            "length_improvement": 25.53016802159066,
            "objective_score": 24.547334695125095
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This improved bidirectional RRT* planner integrates dynamic adaptive sampling biased towards start, goal, and promising midpoints with gradually decaying exploration bias, uses a refined rewiring radius adapting to iteration and tree size for balanced optimization, and performs fast spatial hashing neighbor queries for efficient rewiring. Balanced growth of two trees with mutual rewiring, dead-end pruning, and early collision rejection accelerates planning. After tree connection, advanced iterative shortcutting and smoothing improve path quality and reduce length, while strict collision and boundary checks guarantee feasibility in bounded 2D/3D environments. The algorithm emphasizes minimizing planning time, boosting success rate, and producing smooth, near-optimal paths.",
    "planning_mechanism": "The planner grows two balanced RRT* trees from start and goal by sampling with adaptive bias shifting from goal/start toward midpoint exploration. Nodes extend within step-size constraints using collision-free checks for both nodes and edges. Fast neighbor queries with spatial hashing enable efficient local rewiring within a dynamically adjusted radius that accounts for exploration versus refinement trade-offs. Periodic pruning removes dead-ends to maintain computational efficiency. Upon successful tree connection, advanced shortcutting and smoothing heuristics iteratively refine path quality. The method balances planning efficiency, path smoothness, and optimality while ensuring robustness in 2D/3D bounded obstacle environments.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 3.0, prune_interval: int = 200,\n                 prune_threshold: int = 100, smoothing_iterations: int = 40,\n                 search_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.search_resolution = search_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        import math\n        import random\n        from collections import defaultdict\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_within_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[i] <= bounds[i] for i in range(dim))\n\n        def is_free_node(pos: Tuple[float, ...]) -> bool:\n            if not is_within_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def is_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            if not is_within_bounds(p1) or not is_within_bounds(p2):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.search_resolution):\n                return False\n            return True\n\n        class SpatialHash:\n            def __init__(self, cell_size: float):\n                self.cell_size = cell_size\n                self.hash_table = defaultdict(list)\n\n            def _hash(self, pos: Tuple[float, ...]) -> Tuple[int, ...]:\n                return tuple(int(pos[i] // self.cell_size) for i in range(len(pos)))\n\n            def insert(self, node: Node):\n                key = self._hash(node.position)\n                self.hash_table[key].append(node)\n\n            def remove(self, node: Node):\n                key = self._hash(node.position)\n                if node in self.hash_table.get(key, []):\n                    self.hash_table[key].remove(node)\n                    if not self.hash_table[key]:\n                        del self.hash_table[key]\n\n            def near(self, pos: Tuple[float, ...], radius: float) -> List[Node]:\n                radius_cells = int(math.ceil(radius / self.cell_size))\n                base_key = self._hash(pos)\n                keys_to_check = []\n                if dim == 2:\n                    for dx in range(-radius_cells, radius_cells + 1):\n                        for dy in range(-radius_cells, radius_cells + 1):\n                            keys_to_check.append((base_key[0] + dx, base_key[1] + dy))\n                else:\n                    for dx in range(-radius_cells, radius_cells + 1):\n                        for dy in range(-radius_cells, radius_cells + 1):\n                            for dz in range(-radius_cells, radius_cells + 1):\n                                keys_to_check.append((base_key[0] + dx, base_key[1] + dy, base_key[2] + dz))\n                result = []\n                for key in keys_to_check:\n                    for node in self.hash_table.get(key, []):\n                        if dist(node.position, pos) <= radius:\n                            result.append(node)\n                return result\n\n        def radius_by_nodes_and_iter(n_nodes: int, itr: int) -> float:\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt(math.log(n_nodes) / n_nodes)\n            decay = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay)\n\n        def adaptive_sample(itr: int) -> Tuple[float, ...]:\n            r = random.random()\n            bias_decay = 1 - itr / self.max_iter\n            # Bias toward goal/start or midpoint shifting over iterations for exploration refinement\n            if r < self.goal_sample_rate:\n                sr = random.random()\n                if sr < 0.6 and is_free_node(goal_position):\n                    return goal_position\n                elif sr < 0.85 and is_free_node(start_position):\n                    return start_position\n                if len(tree_start) > 15 and len(tree_goal) > 15:\n                    mid_s = random.choice(tree_start).position\n                    mid_g = random.choice(tree_goal).position\n                    midpoint = tuple((mid_s[i] + mid_g[i]) / 2 for i in range(dim))\n                    spread = self.step_size * 5 * bias_decay\n                    for _ in range(7):\n                        candidate = tuple(\n                            max(0, min(bounds[d], midpoint[d] + random.uniform(-spread, spread)))\n                            for d in range(dim)\n                        )\n                        if is_free_node(candidate):\n                            return candidate\n            # Uniform sampling with rejection\n            for _ in range(75):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n            return start_position\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        # Initialize data structures\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes: List[Node] = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        cell_size = self.step_size * 1.5\n        hash_start = SpatialHash(cell_size)\n        hash_goal = SpatialHash(cell_size)\n        hash_start.insert(start_root)\n        hash_goal.insert(goal_root)\n\n        def try_extend(tree: List[Node], tree_hash: SpatialHash, target: Tuple[float, ...], itr: int) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, target)\n            new_pos = steer(nearest_node.position, target)\n            if not is_free_node(new_pos):\n                return None\n            if not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes_and_iter(len(tree), itr)\n            near_nodes = tree_hash.near(new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near_nodes:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost and is_free_edge(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            tree_hash.insert(new_node)\n\n            # Try rewiring neighbors for cost improvement\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect_and_rewire(tree: List[Node], tree_hash: SpatialHash, target_node: Node, itr: int) -> Node or None:\n            if not tree:\n                return None\n            last_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos):\n                    return None\n                if not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes_and_iter(len(tree), itr)\n                near_nodes_ = tree_hash.near(new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n\n                for node in near_nodes_:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-10 < min_cost and is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                tree_hash.insert(new_node)\n\n                for neighbor in near_nodes_:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-10 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        tree_hash.insert(final_node)\n                        return final_node\n                    return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            # Remove nodes with no children except start/goal roots\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        hash_start.remove(node)\n                        hash_goal.remove(node)\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path: List[Tuple[float, ...]]) -> float:\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def smooth_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if is_free_edge(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            sample = adaptive_sample(itr)\n\n            # Extend the smaller tree for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n                hash_start, hash_goal = hash_goal, hash_start\n\n            new_node_start = try_extend(tree_start, hash_start, sample, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, hash_goal, new_node_start, itr)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                # Advanced smoothing and shortcutting for quality\n                shortcuted_path = shortcut_path(raw_path)\n                smoothed_path = smooth_path(shortcuted_path)\n\n                candidates = [raw_path, shortcuted_path, smoothed_path]\n                extracted_path = min(candidates, key=path_length)\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) !=6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) !=4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -0.71088,
    "time_improvement": -13.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.014388227462768554,
            "num_nodes_avg": 72.6,
            "path_length_avg": 153.10938511332458,
            "success_improvement": 0.0,
            "time_improvement": -42.61548932308653,
            "length_improvement": 23.47740093072545,
            "objective_score": -8.089166610780868
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02143435478210449,
            "num_nodes_avg": 206.3,
            "path_length_avg": 236.15937859139632,
            "success_improvement": 0.0,
            "time_improvement": -49.84823861789634,
            "length_improvement": 21.63432855601618,
            "objective_score": -10.627605874165667
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.013490009307861327,
            "num_nodes_avg": 142.6,
            "path_length_avg": 122.50835528802918,
            "success_improvement": 0.0,
            "time_improvement": 52.98303752385907,
            "length_improvement": 24.77248982566236,
            "objective_score": 20.84940922229019
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved planner implements an enhanced bidirectional RRT* algorithm with adaptive ellipsoidal informed sampling after finding an initial solution, accelerated nearest neighbor search using spatial hashing, and lazy collision checking with caching for both nodes and edges. It dynamically adjusts neighbor radius based on node density, uses incremental steering for smoother connections, and applies iterative path shortcutting to reduce path length and improve smoothness. These enhancements collectively reduce planning time while improving success rate, path quality, and robustness.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal points, alternating expansions per iteration. Initially, it samples uniformly in free space; once an initial path is found, subsequent samples are restricted to an informed ellipsoid to focus search where better solutions are possible. New nodes are added only if collision-free, and rewiring of nearby nodes is performed within a dynamically computed radius using cached collision checks. A spatial hashing technique accelerates nearest neighbor and neighbor radius queries. The trees attempt connection after each expansion with incremental steps, minimizing collision checks via lazy evaluation and caching. On finding a path, iterative shortcutting refines it for smoothness and reduced length, returning the optimized solution efficiently.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n        self._in_collision = None      # Lazy collision cache\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self._edge_collision_cache = dict()\n        self._node_collision_cache = dict()\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Precompute bounding box clamp function\n        def clamp_pos(pos):\n            return tuple(max(0.0, min(pos[d], bounds[d])) for d in range(dim))\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0.0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / distance\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n            return clamp_pos(new_p)\n\n        # Lazy collision checking for nodes with caching\n        def node_in_collision(pos):\n            key = tuple(round(c, 5) for c in pos)\n            if key in self._node_collision_cache:\n                return self._node_collision_cache[key]\n            collision = self._is_in_obstacle(pos, obstacles, is_3d)\n            self._node_collision_cache[key] = collision\n            return collision\n\n        # Edge collision checking with caching\n        def edge_key(pos1, pos2):\n            return tuple(sorted([tuple(round(c, 5) for c in pos1), tuple(round(c, 5) for c in pos2)]))\n\n        def edge_collision_cached(pos1, pos2):\n            key = edge_key(pos1, pos2)\n            return self._edge_collision_cache.get(key, None)\n\n        def cache_edge_collision(pos1, pos2, val):\n            key = edge_key(pos1, pos2)\n            self._edge_collision_cache[key] = val\n\n        # Uniform sampling in free space\n        def sample_free_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not node_in_collision(p):\n                    return p\n\n        # Adaptive informed ellipsoid sampling after first solution\n        def ellipse_sample(center, c_min, c_max, start, goal):\n            if c_max < c_min:\n                c_max = c_min\n            if is_3d:\n                import numpy as np\n\n                center_np = np.array(center)\n                start_np = np.array(start)\n                goal_np = np.array(goal)\n                a1 = (goal_np - start_np)\n                norm_a1 = np.linalg.norm(a1)\n                if norm_a1 == 0:\n                    return tuple(start_np)\n\n                a1 /= norm_a1\n\n                # Build orthonormal basis\n                tmp = np.array([1., 0., 0.])\n                if np.allclose(a1, tmp):\n                    tmp = np.array([0., 1., 0.])\n                e2 = np.cross(a1, tmp)\n                e2 /= np.linalg.norm(e2)\n                e3 = np.cross(a1, e2)\n                C = np.column_stack((a1, e2, e3))\n\n                r1 = c_max / 2.0\n                r2 = math.sqrt(abs(c_max**2 - c_min**2)) / 2.0\n                r3 = r2\n\n                while True:\n                    u = np.random.normal(0, 1, 3)\n                    norm_u = np.linalg.norm(u)\n                    if norm_u == 0:\n                        continue\n                    # Uniform sampling in unit ball\n                    u = u / norm_u * (random.random() ** (1/3))\n                    sample = center_np + C @ np.array([r1 * u[0], r2 * u[1], r3 * u[2]])\n                    sample_clamped = np.clip(sample, np.zeros(3), np.array(bounds))\n                    sample_t = tuple(sample_clamped)\n                    if not node_in_collision(sample_t):\n                        return sample_t\n            else:\n                c1, c2 = center\n                r1 = c_max / 2.0\n                r2 = math.sqrt(abs(c_max**2 - c_min**2)) / 2.0\n\n                dx = goal[0] - start[0]\n                dy = goal[1] - start[1]\n                length = math.hypot(dx, dy)\n                if length == 0:\n                    return start\n                cos_angle = dx / length\n                sin_angle = dy / length\n\n                while True:\n                    theta = random.uniform(0, 2 * math.pi)\n                    rho = random.uniform(0, 1) ** 0.5  # sqrt for uniform in circle\n                    x_ball = rho * math.cos(theta)\n                    y_ball = rho * math.sin(theta)\n                    x_ell = r1 * x_ball\n                    y_ell = r2 * y_ball\n                    x_rot = cos_angle * x_ell - sin_angle * y_ell\n                    y_rot = sin_angle * x_ell + cos_angle * y_ell\n                    sample = (c1 + x_rot, c2 + y_rot)\n                    if in_bounds(sample) and not node_in_collision(sample):\n                        return sample\n\n        # Spatial hashing for efficient nearest neighbor and neighbor queries\n        class SpatialHash:\n            def __init__(self, bounds, dim, cell_size):\n                self.cell_size = cell_size\n                self.dim = dim\n                self.bounds = bounds\n                self.hash = dict()\n\n            def _hash_pos(self, pos):\n                return tuple(int(pos[d] // self.cell_size) for d in range(self.dim))\n\n            def insert(self, node):\n                key = self._hash_pos(node.position)\n                if key not in self.hash:\n                    self.hash[key] = []\n                self.hash[key].append(node)\n\n            def remove(self, node):\n                key = self._hash_pos(node.position)\n                if key in self.hash and node in self.hash[key]:\n                    self.hash[key].remove(node)\n                    if not self.hash[key]:\n                        del self.hash[key]\n\n            def nearby_nodes(self, pos, radius):\n                base_key = self._hash_pos(pos)\n                r_cells = int(math.ceil(radius / self.cell_size))\n                candidates = []\n                for offset in self._offsets(r_cells):\n                    neighbor_key = tuple(base_key[d] + offset[d] for d in range(self.dim))\n                    if neighbor_key in self.hash:\n                        candidates.extend(self.hash[neighbor_key])\n                return candidates\n\n            def _offsets(self, r_cells):\n                from itertools import product\n                ranges = [range(-r_cells, r_cells + 1) for _ in range(self.dim)]\n                return list(product(*ranges))\n\n        # Distance functions\n        def nearest_node(tree_spatialhash, point):\n            # Search over nearby nodes; if none found, fallback to all nodes\n            r_search = self.step_size * 2.5\n            candidates = tree_spatialhash.nearby_nodes(point, r_search)\n            if not candidates:\n                # fallback all nodes in spatial hash\n                candidates = []\n                for nodes in tree_spatialhash.hash.values():\n                    candidates.extend(nodes)\n                if not candidates:\n                    return None\n            nearest_n = min(candidates, key=lambda n: dist(n.position, point))\n            return nearest_n\n\n        def neighbors(tree_spatialhash, pos, radius):\n            candidates = tree_spatialhash.nearby_nodes(pos, radius)\n            return [node for node in candidates if dist(node.position, pos) <= radius]\n\n        # Dynamic neighbor radius as in RRT*\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return float('inf')\n            gamma = 20.0 if dim == 2 else 35.0\n            # Unit ball volume\n            unit_ball_vol = math.pi if dim == 2 else (4.0 / 3.0) * math.pi\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1 / dim))\n            return max(r, self.step_size)\n\n        # Path length calculation\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        # Iterative path shortcutting to improve path smoothness and length\n        def shortcut_path(path, trials=300):\n            path = path[:]\n            if len(path) < 3:\n                return path\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Initialize trees and spatial hashes\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        spatial_start = SpatialHash(bounds, dim, self.step_size * 2)\n        spatial_goal = SpatialHash(bounds, dim, self.step_size * 2)\n        spatial_start.insert(start_root)\n        spatial_goal.insert(goal_root)\n\n        c_min = dist(start, goal)\n        c_max = float('inf')\n        center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n        path_found = False\n\n        connect_start = None\n        connect_goal = None\n        success_state = False\n\n        for itr in range(self.max_iter):\n            q_rand = ellipse_sample(center, c_min, c_max, start, goal) if path_found else sample_free_uniform()\n\n            # Alternate tree expansion\n            tree_a, tree_b = (tree_start, tree_goal) if itr % 2 == 0 else (tree_goal, tree_start)\n            spatial_a, spatial_b = (spatial_start, spatial_goal) if itr % 2 == 0 else (spatial_goal, spatial_start)\n\n            nearest_node_a = nearest_node(spatial_a, q_rand)\n            if nearest_node_a is None:\n                continue\n\n            new_pos = steer(nearest_node_a.position, q_rand)\n            if node_in_collision(new_pos):\n                continue\n\n            cached_col = edge_collision_cached(nearest_node_a.position, new_pos)\n            if cached_col is None:\n                in_collision = self._is_edge_in_obstacle(nearest_node_a.position, new_pos, obstacles, is_3d)\n                cache_edge_collision(nearest_node_a.position, new_pos, in_collision)\n                if in_collision:\n                    continue\n            elif cached_col:\n                continue\n\n            new_cost = nearest_node_a.cost + dist(nearest_node_a.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node_a, cost=new_cost)\n            nearest_node_a.children.append(new_node)\n            tree_a.append(new_node)\n            spatial_a.insert(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node_a, new_node))\n\n            # Rewire neighbors in radius\n            r = neighbor_radius(len(tree_a))\n            nearby_nodes = neighbors(spatial_a, new_pos, r)\n            for near_node in nearby_nodes:\n                if near_node is nearest_node_a or near_node is new_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new + 1e-8 < near_node.cost:\n                    cached_rewire = edge_collision_cached(new_node.position, near_node.position)\n                    if cached_rewire is None:\n                        in_col = self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d)\n                        cache_edge_collision(new_node.position, near_node.position, in_col)\n                    else:\n                        in_col = cached_rewire\n                    if not in_col:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Attempt to connect expanded node to opposite tree with incremental steer\n            connect_node_b = nearest_node(spatial_b, new_node.position)\n            if connect_node_b is None:\n                continue\n            prev_node_b = connect_node_b\n            connected = False\n\n            while True:\n                next_pos_b = steer(prev_node_b.position, new_node.position)\n                if node_in_collision(next_pos_b):\n                    break\n\n                cached_edge_b = edge_collision_cached(prev_node_b.position, next_pos_b)\n                if cached_edge_b is None:\n                    collides = self._is_edge_in_obstacle(prev_node_b.position, next_pos_b, obstacles, is_3d)\n                    cache_edge_collision(prev_node_b.position, next_pos_b, collides)\n                    if collides:\n                        break\n                elif cached_edge_b:\n                    break\n\n                cost_b = prev_node_b.cost + dist(prev_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=prev_node_b, cost=cost_b)\n                prev_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                spatial_b.insert(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((prev_node_b, new_node_b))\n\n                r_b = neighbor_radius(len(tree_b))\n                near_b = neighbors(spatial_b, next_pos_b, r_b)\n                for nb_node in near_b:\n                    if nb_node is prev_node_b or nb_node is new_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, nb_node.position)\n                    if cost_via_new_b + 1e-8 < nb_node.cost:\n                        cached_rewire_b = edge_collision_cached(new_node_b.position, nb_node.position)\n                        if cached_rewire_b is None:\n                            in_col_b = self._is_edge_in_obstacle(new_node_b.position, nb_node.position, obstacles, is_3d)\n                            cache_edge_collision(new_node_b.position, nb_node.position, in_col_b)\n                        else:\n                            in_col_b = cached_rewire_b\n                        if not in_col_b:\n                            try:\n                                edges.remove((nb_node.parent, nb_node))\n                            except ValueError:\n                                pass\n                            nb_node.update_parent(new_node_b, cost_via_new_b)\n                            edges.append((new_node_b, nb_node))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size:\n                    cached_final = edge_collision_cached(new_node_b.position, new_node.position)\n                    if cached_final is None:\n                        col_final = self._is_edge_in_obstacle(new_node_b.position, new_node.position, obstacles, is_3d)\n                        cache_edge_collision(new_node_b.position, new_node.position, col_final)\n                    else:\n                        col_final = cached_final\n                    if not col_final:\n                        final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                        connect_node_goal = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                        new_node_b.children.append(connect_node_goal)\n                        tree_b.append(connect_node_goal)\n                        spatial_b.insert(connect_node_goal)\n                        nodes.append(connect_node_goal)\n                        edges.append((new_node_b, connect_node_goal))\n\n                        if tree_a is tree_start:\n                            connect_start, connect_goal = new_node, connect_node_goal\n                        else:\n                            connect_start, connect_goal = connect_node_goal, new_node\n                        success_state = True\n                    break\n                prev_node_b = new_node_b\n\n            if success_state:\n                path_start = connect_start.path_from_root()\n                path_goal = connect_goal.path_from_root()\n                full_path = path_start + path_goal[::-1][1:]\n\n                c_max = path_length(full_path) + 1e-6\n                center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n                path_found = True\n\n                full_path = shortcut_path(full_path, trials=300)\n\n                return PlannerResult(\n                    success=True,\n                    path=full_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 48.41677,
    "time_improvement": -169.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.030681538581848144,
            "num_nodes_avg": 76.2,
            "path_length_avg": 158.0507715204049,
            "success_improvement": -9.999999999999998,
            "time_improvement": -204.11408558545787,
            "length_improvement": 21.007743498586343,
            "objective_score": -62.03267697592009
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05256407260894776,
            "num_nodes_avg": 240.0,
            "path_length_avg": 240.22936375735034,
            "success_improvement": 0.0,
            "time_improvement": -267.4770607795585,
            "length_improvement": 20.283769784226372,
            "objective_score": -76.18636427702228
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03869655132293701,
            "num_nodes_avg": 264.1,
            "path_length_avg": 134.92451224472887,
            "success_improvement": 0.0,
            "time_improvement": -34.869758795965836,
            "length_improvement": 17.148221492369597,
            "objective_score": -7.031283340315831
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved bidirectional RRT* planner enhances path quality by incorporating adaptive rewiring with dynamic radius shrinking, an informed heuristic for goal biasing, and improved parent selection prioritizing minimal cost paths. It performs collision-aware node additions and edge connections with efficient rewiring to minimize path lengths while preserving safety. The planner balances exploration and exploitation by alternately expanding start and goal trees, dynamically adjusting connection strategies based on their sizes, thereby improving convergence speed, success rate, and path smoothness.",
    "planning_mechanism": "The planner alternates between expanding trees from start and goal, sampling points with adaptive bias towards the goal, steering with a fixed step size, and rewiring neighbors within a shrinking radius to improve local path costs. It connects trees by attempting feasible edge extensions and reconstructs the shortest collision-free path upon connection. Careful collision checks on nodes and edges maintain robust tree growth within map bounds and obstacle-free space, resulting in efficient, optimized incremental planning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]: 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0, radius_min: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            # Adaptive goal biasing:\n            r = random.random()\n            if r < self.goal_sample_rate:\n                # 80% bias towards goal, 20% back to start to allow bidirectional growth priority\n                return goal_position if random.random() < 0.8 else start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r_sqr = radius * radius\n            return [node for node in tree if (distance(node.position, pos)**2) <= r_sqr]\n\n        def radius_by_nodes(n_nodes):\n            # RRT* radius shrinking with minimum threshold\n            if n_nodes <= 1:\n                return self.radius_constant\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            # Choose parent with minimal cost + local feasibility\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + distance(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost paths locally\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                next_pos = steer(last_node.position, node.position)\n                if not in_bounds(next_pos):\n                    return None\n                if self._is_in_obstacle(next_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, next_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, next_pos)\n                new_node = Node(next_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                dist_to_goal_node = distance(next_pos, node.position)\n                if dist_to_goal_node <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + dist_to_goal_node\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        # Alternate growing trees, always extend the smaller for balanced exploration\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n\n                # Merge paths, avoid duplicate connection node\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 4.68182,
    "time_improvement": -22.0,
    "length_improvement": 10.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01147768497467041,
            "num_nodes_avg": 121.6,
            "path_length_avg": 175.93946913810302,
            "success_improvement": 0.0,
            "time_improvement": -13.7663178591347,
            "length_improvement": 12.067144366420735,
            "objective_score": -1.7164664844562632
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02119283676147461,
            "num_nodes_avg": 289.7,
            "path_length_avg": 289.0887413087682,
            "success_improvement": 0.0,
            "time_improvement": -48.15977865006541,
            "length_improvement": 4.0705753263567095,
            "objective_score": -13.633818529748282
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.030138540267944335,
            "num_nodes_avg": 269.2,
            "path_length_avg": 139.9086196603454,
            "success_improvement": 0.0,
            "time_improvement": -5.042375029187617,
            "length_improvement": 14.087679291498818,
            "objective_score": 1.3048233495434787
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This planner implements an advanced bidirectional RRT* with adaptive dynamic informed sampling and multi-resolution local exploration. It balances global exploration and focused exploitation by progressively shrinking a dynamically computed informed ellipsoid based on the best current path cost. It uses KDTree for efficient nearest and nearby node queries, aggressive early collision pruning, adaptive rewiring radius based on both node count and iteration, and introduces a multi-resolution steering that attempts variable step sizes adaptively to jump over small obstacles and improve shortcut chances. After forming a connection, the planner performs an iterative shortcut smoothing with probabilistic node skipping and edge checking to enhance path smoothness and quality. Periodic pruning minimizes tree complexity without losing promising regions, improving computational efficiency and robustness across 2D and 3D spaces.",
    "planning_mechanism": "The planner grows two RRT* trees from start and goal positions, alternating expansions biased within an adaptive informed ellipsoid that shrinks as better paths are found. The sampling adapts based on path quality and iteration count to balance exploration and exploitation. Each extension applies multi-resolution variable step steering to improve reachability over obstacles. KDTree accelerates nearest neighbor and radius searches for rewiring. After connecting the trees when possible, the combined path undergoes intensive shortcut smoothing iterations. Trees prune nodes periodically to maintain efficiency. The algorithm guarantees collision-free edges and nodes, keeps samples within bounds, and returns a high-quality, smooth, and short collision-free path within max iterations.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = 2.0\n        self.max_radius = 30.0\n        self.kd_tree_leafsize = 40\n        self.collision_resolution = 0.5\n        self.smoothing_iterations = 100\n        self.prune_interval = 250\n        self.prune_threshold = 300\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        try:\n            from scipy.spatial import cKDTree as KDTree\n        except ImportError:\n            KDTree = None\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Core data\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                new_p = to_p\n            else:\n                ratio = max_step / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp inside bounds\n            clamped = tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n            return clamped\n\n        def radius(iteration, n_nodes):\n            if n_nodes <= 1:\n                return self.min_radius\n            r_iter = self.max_radius * (1 - (iteration / self.max_iter) ** 0.8)\n            r_log = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(self.min_radius, min(r_iter, r_log))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance_edge = dist(p1, p2)\n            steps = max(1, int(distance_edge / self.collision_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def build_kdtree(tree):\n            if KDTree is None or not tree:\n                return None\n            pts = [node.position for node in tree]\n            return KDTree(pts, leafsize=self.kd_tree_leafsize)\n\n        def nearest(tree, kdtree, point):\n            if kdtree:\n                dist_, idx = kdtree.query(point)\n                return tree[idx]\n            else:\n                return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, kdtree, point, radius):\n            if kdtree:\n                idxs = kdtree.query_ball_point(point, radius)\n                return [tree[i] for i in idxs]\n            else:\n                r2 = radius * radius\n                return [node for node in tree if (dist(node.position, point) <= radius)]\n\n        def adaptive_informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n            # If no path found yet, uniform random sampling inside bounds avoiding obstacles\n            if c_best == float('inf') or c_best < c_min * 1.0000001:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback uniform if fail\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            I = np.eye(dim)\n            u = direction - I[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = I - 2 * np.outer(u, u)  # Householder transform for reflection\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(150):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            # fallback uniform sampling with obstacle check\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        # Multi-resolution steer attempts: tries to extend by 2x step then 1x step for better jump\n        def multi_steer(from_p, to_p):\n            doubled_step = self.step_size * 2\n            pos_dbl = steer(from_p, to_p, doubled_step)\n            if pos_dbl != from_p and not is_edge_in_obstacle(from_p, pos_dbl) and not is_in_obstacle(pos_dbl):\n                return pos_dbl\n            # fallback standard step\n            pos_std = steer(from_p, to_p, self.step_size)\n            if pos_std != from_p and not is_edge_in_obstacle(from_p, pos_std) and not is_in_obstacle(pos_std):\n                return pos_std\n            return None\n\n        def try_extend(tree, kdtree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, kdtree, point)\n\n            new_pos = multi_steer(nearest_node.position, point)\n            if new_pos is None:\n                return None\n\n            # Collision checks already done in multi_steer\n            # Rewiring neighborhood radius\n            r = radius(itr, len(tree))\n            neighbors = near_nodes(tree, kdtree, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            best_parent.children.append(new_node)\n            new_node.parent = best_parent\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if cheaper\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, kdtree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, kdtree, node.position)\n            last_node = nearest_node\n\n            max_steps = int(math.ceil(dist(last_node.position, node.position) / self.step_size))\n            for _ in range(max_steps):\n                new_pos = multi_steer(last_node.position, node.position)\n                if new_pos is None:\n                    return None\n                # Collision checks done in multi_steer\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    # Final segment check\n                    if not is_edge_in_obstacle(new_pos, node.position) and not is_in_obstacle(node.position):\n                        final_node_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_node_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n            return None\n\n        def shortcut_smooth(path):\n            if len(path) < 3:\n                return path\n            path = list(path)\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i, p_j = path[i], path[j]\n                if not is_edge_in_obstacle(p_i, p_j):\n                    # Remove intermediate nodes between i and j\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        from collections import deque\n\n        def prune_unreachable_nodes(tree, root):\n            if not tree:\n                return\n            visited = set()\n            queue = deque([root])\n            while queue:\n                current = queue.popleft()\n                visited.add(current)\n                for c in current.children:\n                    if c not in visited:\n                        queue.append(c)\n            to_remove = [node for node in tree if node not in visited]\n            for node in to_remove:\n                try:\n                    tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n                except ValueError:\n                    pass\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes.extend([root_start, root_goal])\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n\n        for itr in range(self.max_iter):\n            q_rand = adaptive_informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Grow smaller tree for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = build_kdtree(tree_a)\n            kdtree_b = build_kdtree(tree_b)\n\n            new_node_a = try_extend(tree_a, kdtree_a, q_rand)\n            if new_node_a is None:\n                continue\n\n            new_node_b = try_connect(tree_b, kdtree_b, new_node_a)\n            if new_node_b is not None:\n                success_state = True\n                # Extract paths\n                if tree_a is tree_start:\n                    path_start = new_node_a.path_from_root()\n                    path_goal = new_node_b.path_from_root()\n                else:\n                    path_start = new_node_b.path_from_root()\n                    path_goal = new_node_a.path_from_root()\n\n                merged = path_start + path_goal[::-1][1:]  # merge paths without duplicate node\n\n                smoothed = shortcut_smooth(merged)\n                path_cost = 0.0\n                for idx in range(len(smoothed) - 1):\n                    path_cost += dist(smoothed[idx], smoothed[idx + 1])\n\n                if path_cost + 1e-12 < c_best:\n                    c_best = path_cost\n                    best_path = smoothed\n\n                # Prune unreachable nodes to reduce complexity\n                prune_unreachable_nodes(tree_start, root_start)\n                prune_unreachable_nodes(tree_goal, root_goal)\n\n                # Stop early at first found path improving significantly\n                if c_best < float('inf'):\n                    extracted_path = best_path\n                    break\n\n            # Periodic pruning inside both trees for large explored nodes\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                # Prune nodes that can't improve path cost in both trees\n                def prune_low_quality_nodes(tree, root):\n                    to_remove = []\n                    for node in tree:\n                        if node is root:\n                            continue\n                        heuristic = dist(node.position, goal_pos if root is root_start else start_pos)\n                        if node.cost + heuristic >= c_best:\n                            to_remove.append(node)\n                    for node in to_remove:\n                        if node.parent:\n                            try:\n                                node.parent.children.remove(node)\n                            except ValueError:\n                                pass\n                        try:\n                            tree.remove(node)\n                            if node in nodes:\n                                nodes.remove(node)\n                        except ValueError:\n                            pass\n\n                prune_low_quality_nodes(tree_start, root_start)\n                prune_low_quality_nodes(tree_goal, root_goal)\n\n        if success_state and not extracted_path:\n            # Possibly found path but did not break early -> rebuild path\n            # Try to find lowest cost node connecting two trees:\n            # Fallback: find best connection by minimal sum of costs and edge\n            min_path = None\n            min_cost = float('inf')\n            kdtree_start = build_kdtree(tree_start)\n            kdtree_goal = build_kdtree(tree_goal)\n            if kdtree_start and kdtree_goal:\n                for n_goal in tree_goal:\n                    nearest_start = nearest(tree_start, kdtree_start, n_goal.position)\n                    if not is_edge_in_obstacle(nearest_start.position, n_goal.position):\n                        cost_candidate = nearest_start.cost + dist(nearest_start.position, n_goal.position) + n_goal.cost\n                        if cost_candidate + 1e-12 < min_cost:\n                            min_cost = cost_candidate\n                            path_start = nearest_start.path_from_root()\n                            path_goal = n_goal.path_from_root()\n                            min_path = path_start + path_goal[::-1][1:]\n                if min_path:\n                    extracted_path = shortcut_smooth(min_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )",
    "objective": 7.99607,
    "time_improvement": -33.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.02058405876159668,
            "num_nodes_avg": 67.5,
            "path_length_avg": 166.0791240029239,
            "success_improvement": -9.999999999999998,
            "time_improvement": -104.028301619261,
            "length_improvement": 16.995250092307547,
            "objective_score": -32.80944046731679
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.018507838249206543,
            "num_nodes_avg": 127.1,
            "path_length_avg": 248.0911941449859,
            "success_improvement": 0.0,
            "time_improvement": -29.388870831979062,
            "length_improvement": 17.674948484049466,
            "objective_score": -5.281671552783825
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01851332187652588,
            "num_nodes_avg": 122.7,
            "path_length_avg": 134.67456003147632,
            "success_improvement": 0.0,
            "time_improvement": 35.475199452228274,
            "length_improvement": 17.30170720868133,
            "objective_score": 14.102901277404747
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the bidirectional tree growth of RRT-Connect with the adaptive, cost-aware rewiring and roadmap construction of a PRM*-inspired algorithm. It grows two trees simultaneously from start and goal positions with adaptive sampling biased near the current best path, dynamically adjusting connection radius, lazy collision checking, and rewiring to improve path quality and efficiency. Periodic pruning removes nodes unlikely to improve the solution, and shortcut smoothing refines the final path, enhancing success rate, path length, and smoothness across 2D/3D maps.",
    "planning_mechanism": "The planner alternates expanding two trees with adaptive sampling biased near the best path corridor or uniform otherwise. New nodes are connected with neighbors in adaptive radius, rewiring to minimize cost, with lazy collision checks cached for efficiency. The two trees attempt connection with incremental extension steps, and when connected, the path is shortcut-smoothed. Periodic node pruning speeds convergence by removing unpromising nodes, producing efficient, robust, and high-quality paths.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float = 8.0,\n                 max_neighbor_radius: float = 35.0,\n                 prune_interval: int = 250,\n                 prune_threshold: int = 400,\n                 smoothing_iterations: int = 120,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp within bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            factor = math.log(n_nodes) / n_nodes\n            r = self.max_neighbor_radius * math.sqrt(factor)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        # KD-tree helper for nearest and radius search (naive O(n))\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best = self.nodes[i]\n                        best_dist = d\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        # Adaptive sampling biased towards corridor around last best path or uniform if none\n        def adaptive_sample(best_path):\n            if best_path:\n                import numpy as np\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 1.2, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            # fallback uniform sampling\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            # final fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_nodes(nodes_list, best_cost, root_start, root_goal):\n            removed = 0\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(rm_node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialize roots and graphs\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        best_path: List[Tuple[float, ...]] = []\n        c_best = float('inf')\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for it in range(self.max_iter):\n            sample_point = adaptive_sample(best_path)\n\n            # Alternate expanding smaller tree for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            if not tree_a:\n                continue\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(sample_point)\n            new_pos = steer(nearest_a.position, sample_point)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            # Choose parent minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for nbr in near_nodes:\n                cost_candidate = nbr.cost + dist(nbr.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(nbr.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = nbr\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for potential cost improvement\n            for nbr in near_nodes:\n                if nbr is best_parent:\n                    continue\n                c_new = new_node.cost + dist(new_node.position, nbr.position)\n                if c_new + 1e-12 < nbr.cost and can_connect(new_node.position, nbr.position):\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                    except ValueError:\n                        pass\n                    nbr.update_parent(new_node, c_new)\n                    edges.append((new_node, nbr))\n\n            # Attempt to connect the other tree to new_node incrementally\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_connect_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes))\n                near_b_nodes = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_b_nodes:\n                    if nbr_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if c_via_new_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, nbr_b))\n\n                # Check if reached close enough to new_node\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    connection_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=connection_cost)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if connection_cost + 1e-12 < c_best:\n                        c_best = connection_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to remove nodes unlikely to improve best solution\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 0.68324,
    "time_improvement": -15.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.010347294807434081,
            "num_nodes_avg": 79.4,
            "path_length_avg": 163.65471316877972,
            "success_improvement": 0.0,
            "time_improvement": -2.561939332066658,
            "length_improvement": 18.20694732499583,
            "objective_score": 2.872807665379169
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02134273052215576,
            "num_nodes_avg": 210.7,
            "path_length_avg": 241.35899656225337,
            "success_improvement": 0.0,
            "time_improvement": -49.20769057679325,
            "length_improvement": 19.90891940238089,
            "objective_score": -10.780523292561796
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02678365707397461,
            "num_nodes_avg": 191.7,
            "path_length_avg": 131.39710291349533,
            "success_improvement": 0.0,
            "time_improvement": 6.650457321253329,
            "length_improvement": 19.31426331646022,
            "objective_score": 5.857989859668043
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm integrates bidirectional RRT* with informed ellipsoidal sampling, adaptive neighbor radius, KD-tree accelerated neighbor search, collision caching, periodic pruning, incremental rewiring, and aggressive path shortcut smoothing. It aims to achieve fast convergence, high-quality, smooth, and robust path planning in both 2D and 3D environments, while reducing search time and improving success rates.",
    "planning_mechanism": "The planner alternately grows two trees from start and goal positions, biased by ellipsoidal informed sampling based on the current best path cost. KD-tree structures accelerate nearest neighbor and radius searches for efficient rewiring and local optimization. Collision checks are cached to minimize repeated computations. Periodic pruning removes nodes unlikely to help improve the solution, and the best path is shortcut-smoothed to enhance smoothness and reduce path length. The planning terminates early once a satisfactory connecting path is found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision/pruning etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) * (c_min / 2), 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    x = x * radii\n                    p = rot @ x + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree growth for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Incremental rewiring neighbors\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Connect other tree towards new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -2.43652,
    "time_improvement": -6.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007726073265075684,
            "num_nodes_avg": 73.3,
            "path_length_avg": 164.5787043153917,
            "success_improvement": 0.0,
            "time_improvement": 23.419495410675967,
            "length_improvement": 17.745145430857118,
            "objective_score": 10.574877709374213
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.025020694732666014,
            "num_nodes_avg": 218.8,
            "path_length_avg": 236.9837400124963,
            "success_improvement": 0.0,
            "time_improvement": -74.92045236726086,
            "length_improvement": 21.36077754710711,
            "objective_score": -18.20398020075684
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.018914246559143068,
            "num_nodes_avg": 152.4,
            "path_length_avg": 124.45601646326448,
            "success_improvement": 0.0,
            "time_improvement": 34.07784973006122,
            "length_improvement": 23.576508534984686,
            "objective_score": 14.938656626015302
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner is an enhanced bidirectional RRT* variant with adaptive goal biasing, dynamic neighborhood radius shrinking with tree size, and adaptive step sizing based on distance. It balances tree growth by extending the smaller tree first, performs rigorous collision checks on nodes and edges before insertion, and applies iterative shortcut smoothing to improve path quality and smoothness for efficient, robust, and high-success path planning.",
    "planning_mechanism": "The planner alternates expansion of two trees from start and goal. Samples are biased toward goals with adaptive probability. Neighborhood radius shrinks as the tree grows to optimize local rewiring. Step sizes adapt to obstacle proximity and distances, ensuring efficient exploration. The trees attempt incremental collision-free connections. Once connected, shortcut smoothing is applied to refine the final path, reducing length and improving smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.3,\n                 radius_const: float = 20.0,\n                 radius_min: float = 4.0,\n                 smoothing_iter: int = 80,\n                 collision_resolution: float = 0.3,\n                 adaptive_step_min: float = 2.0,\n                 adaptive_step_max: float = 7.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.smoothing_iter = smoothing_iter\n        self.collision_resolution = collision_resolution\n        self.adaptive_step_min = adaptive_step_min\n        self.adaptive_step_max = adaptive_step_max\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(point):\n            for i, val in enumerate(point):\n                if val < 0 or val > bounds[i]:\n                    return False\n            return True\n\n        def sample_point():\n            # Adaptive goal biasing with majority bias to goal and some towards start for diversification\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < 0.9 else start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                        return p\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_const\n            r = self.radius_const * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, r)\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            near = []\n            for node in tree:\n                dx = node.position[0] - pos[0]\n                dy = node.position[1] - pos[1]\n                dz = node.position[2] - pos[2] if is_3d else 0.0\n                dist_sq = dx * dx + dy * dy + dz * dz\n                if dist_sq <= r_sq:\n                    near.append(node)\n            return near\n\n        def adaptive_step(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            step = min(self.adaptive_step_max, max(self.adaptive_step_min, dist))\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def collision_free(node_pos):\n            return in_bounds(node_pos) and not self._is_in_obstacle(node_pos, obstacles, is_3d)\n\n        def edge_collision_free(pos1, pos2):\n            if not in_bounds(pos2):\n                return False\n            return not self._is_edge_in_obstacle(pos1, pos2, obstacles, is_3d, self.collision_resolution)\n\n        def add_node(tree, new_node, parent_node):\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: distance(n.position, point))\n            new_pos = adaptive_step(nearest_node.position, point)\n\n            if not collision_free(new_pos) or not edge_collision_free(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + distance(node.position, new_pos)\n                if temp_cost < min_cost and edge_collision_free(node.position, new_pos):\n                    min_cost = temp_cost\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-12 < neighbor.cost and edge_collision_free(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: distance(n.position, node.position))\n            last_node = nearest_node\n\n            max_iters = 7  # Increase increment steps for finer connection attempts\n            for _ in range(max_iters):\n                new_pos = adaptive_step(last_node.position, node.position)\n                if not collision_free(new_pos) or not edge_collision_free(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                dist_to_goal = distance(new_pos, node.position)\n                if dist_to_goal <= self.step_size:\n                    if edge_collision_free(new_pos, node.position):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + dist_to_goal\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if edge_collision_free(p_i, p_j):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            rand_point = sample_point()\n\n            # Balance tree growth by extending the smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                extracted_path = extract_path(new_node_start, new_node_goal)\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 28.85669,
    "time_improvement": -102.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.02193615436553955,
            "num_nodes_avg": 101.0,
            "path_length_avg": 171.25238652487502,
            "success_improvement": -9.999999999999998,
            "time_improvement": -117.43021486165858,
            "length_improvement": 14.409703206632548,
            "objective_score": -37.34712381717107
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03264803886413574,
            "num_nodes_avg": 267.6,
            "path_length_avg": 250.0641317618825,
            "success_improvement": 0.0,
            "time_improvement": -128.24345159220275,
            "length_improvement": 17.020261035312984,
            "objective_score": -35.068983270598224
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04573802947998047,
            "num_nodes_avg": 321.4,
            "path_length_avg": 132.97145970601065,
            "success_improvement": 0.0,
            "time_improvement": -59.41154425591709,
            "length_improvement": 18.34751340500699,
            "objective_score": -14.153960595773729
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is an optimized bidirectional RRT* variant that grows two trees from the start and goal positions. It incorporates rewiring to optimize path costs dynamically, ensuring asymptotic optimality. The planner efficiently connects these trees while enforcing strict collision and edge validations to generate high-quality, smooth, and feasible paths.",
    "planning_mechanism": "The planner alternates sampling random collision-free points, extending one tree towards the sample and rewiring nearby nodes to minimize the total cost. It then attempts to connect the other tree towards this new node with similar rewiring. If the trees connect, the combined path is extracted. Throughout, collision and edge checks guarantee valid expansions, leading to improved planning efficiency, robustness, and path quality.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_a, tree_b = [start_root], [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        radius = 20.0  # Rewiring neighborhood radius\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, position):\n            return [n for n in tree if math.dist(n.position, position) <= radius]\n\n        def check_and_add_node(tree, point):\n            if self._is_in_obstacle(point, obstacles, is_3d):\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                cost = nbr.cost + math.dist(nbr.position, new_pos)\n                if cost < min_cost:\n                    if not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if possible\n            for nbr in neighbors:\n                if nbr == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        if nbr.parent:\n                            if (nbr.parent, nbr) in edges:\n                                edges.remove((nbr.parent, nbr))\n                            nbr.parent.children.remove(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = new_cost\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n            return new_node\n\n        def connect_trees(tree_from, node_to_connect):\n            nearest_in_tree = nearest(tree_from, node_to_connect.position)\n            curr_node = nearest_in_tree\n            while True:\n                new_pos = steer(curr_node.position, node_to_connect.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                neighbors = near_nodes(tree_from, new_pos)\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    cost = nbr.cost + math.dist(nbr.position, new_pos)\n                    if cost < min_cost:\n                        if not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                            min_cost = cost\n                            best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                new_node.parent = best_parent\n                tree_from.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for nbr in neighbors:\n                    if nbr == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if new_cost < nbr.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                            if nbr.parent:\n                                if (nbr.parent, nbr) in edges:\n                                    edges.remove((nbr.parent, nbr))\n                                nbr.parent.children.remove(nbr)\n                            nbr.parent = new_node\n                            nbr.cost = new_cost\n                            new_node.add_child(nbr)\n                            edges.append((new_node, nbr))\n\n                if math.dist(new_node.position, node_to_connect.position) <= self.step_size:\n                    return new_node\n                curr_node = new_node\n\n        for i in range(self.max_iter):\n            rand_point = sample_free()\n            new_node_a = check_and_add_node(tree_a, rand_point)\n            if not new_node_a:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = connect_trees(tree_b, new_node_a)\n            if new_node_b:\n                success_state = True\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -0.38431,
    "time_improvement": 1.0,
    "length_improvement": 25.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009291505813598633,
            "num_nodes_avg": 69.5,
            "path_length_avg": 162.093117915655,
            "success_improvement": 0.0,
            "time_improvement": 7.902995585552366,
            "length_improvement": 18.98741762323979,
            "objective_score": 6.168382200313668
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.01983826160430908,
            "num_nodes_avg": 238.3,
            "path_length_avg": 240.76554409201225,
            "success_improvement": 0.0,
            "time_improvement": -38.689901742630695,
            "length_improvement": 20.10584700939751,
            "objective_score": -7.585801120909705
        },
        {
            "map_id": 2,
            "success_rate": 0.7,
            "time_avg": 0.018627142906188963,
            "num_nodes_avg": 222.6,
            "path_length_avg": 105.47175169776385,
            "success_improvement": -30.000000000000004,
            "time_improvement": 35.07849705132286,
            "length_improvement": 35.23399073235255,
            "objective_score": 2.5703472618673686
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "time_expert",
    "algorithm_description": "This implementation improves the bidirectional RRT* planner by implementing adaptive step sizing based on distance to samples, incorporating informed sampling via elliptical heuristic biasing to focus growth near the least-cost path estimate, and efficiently balancing tree expansions. It applies dynamic neighborhood radius shrinking with logarithmic scaling for rewiring, rigorous collision checks on nodes and edges, and path shortcut smoothing post planning to enhance path quality and smoothness. By refining sampling and steering strategies and optimizing rewiring, it reduces planning time and increases success rates while producing shorter, smoother paths.",
    "planning_mechanism": "The planner grows two trees from start and goal by alternately extending the smaller tree toward adaptively sampled points biased via an elliptical heuristic around the best path estimate. Steer step size adapts to proximity, preventing overshoot and promoting efficient expansions. New nodes connect via lowest-cost parent within a dynamically shrinking radius, enabling local rewiring to optimize costs incrementally. Trees attempt connection via direct motions checked for collisions. After successful connection, the path is extracted and shortcut smoothed to eliminate unnecessary detours and improve smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]: 2D (x,y) or 3D (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from start/root to this node\n        self.children = []\n        self.valid = True               # For collision checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 radius_const: float = 30.0,\n                 radius_min: float = 5.0,\n                 smoothing_iter: int = 50):\n        self.max_iter = max_iter\n        self.step_size_base = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.smoothing_iter = smoothing_iter\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size          # Tuple[int,...] (W,H) or (W,H,D)\n        start_position = map.start # Tuple\n        goal_position = map.goal   # Tuple\n        obstacles = map.obstacles  # List of tuples\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Store best path cost found so far, used for informed sampling\n        best_path_cost = math.inf\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, adapt_step=None):\n            dist = distance(from_pos, to_pos)\n            max_step = adapt_step if adapt_step is not None else self.step_size_base\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (sum((node.position[d] - pos[d])**2 for d in range(len(pos))) <= radius_sq)]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_const\n            return max(self.radius_min,\n                       self.radius_const * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n        \n        def collision_free(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def edge_collision_free(pos1, pos2):\n            return not self._is_edge_in_obstacle(pos1, pos2, obstacles, is_3d, resolution=max(0.25, self.step_size_base/5))\n\n        def add_node(tree, new_node, parent_node):\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n\n        def informed_sample():\n            # If no solution found yet, sample uniformly with goal bias\n            if best_path_cost == math.inf:\n                return uniform_sample()\n            # Ellipse parameters for 2D or 3D informed sampling:\n            c_best = best_path_cost\n            c_min = distance(start_position, goal_position)\n            if c_best <= c_min:\n                # path cost equals minimum distance: sample goal to speed convergence\n                return goal_position if random.random() < 0.9 else uniform_sample()\n            \n            # Compute center point and rotated frame\n            center = tuple((start_position[d] + goal_position[d]) / 2.0 for d in range(len(bounds)))\n            a1 = tuple((goal_position[d] - start_position[d]) / c_min for d in range(len(bounds)))  # unit vector from start to goal\n\n            # Build orthonormal basis via Gram-Schmidt or direct (for dim=2 or 3)\n            # For simplicity, generate random samples in ellipse aligned to axis of direction\n            dim = len(bounds)\n            r1 = c_best / 2.0  # major axis length\n            r2 = math.sqrt(c_best**2 - c_min**2) / 2.0 # minor axis radius in 2D or max minor radius in 3D, else approximate\n            \n            def sample_unit_ball():\n                if dim == 2:\n                    # Uniform in unit circle\n                    while True:\n                        x = random.uniform(-1,1)\n                        y = random.uniform(-1,1)\n                        if x*x + y*y <= 1:\n                            return (x, y)\n                else:\n                    # 3D uniform unit ball sampling\n                    import random as rnd\n                    import math\n                    while True:\n                        x, y, z = rnd.uniform(-1,1), rnd.uniform(-1,1), rnd.uniform(-1,1)\n                        if x*x + y*y + z*z <= 1:\n                            return (x,y,z)\n            sample_ball = sample_unit_ball()\n            \n            # Scale sample_ball to ellipse axes\n            if dim ==2:\n                # Rotate sample so major axis aligns with a1 unit vector\n                # build rotation angle from (1,0) to a1\n                ang = math.atan2(a1[1], a1[0])\n                x_ball, y_ball = sample_ball\n                x_ellipse = r1 * x_ball\n                y_ellipse = r2 * y_ball\n                cos_ang = math.cos(ang)\n                sin_ang = math.sin(ang)\n                # rotate back\n                sample_rotated = (\n                    center[0] + cos_ang * x_ellipse - sin_ang * y_ellipse,\n                    center[1] + sin_ang * x_ellipse + cos_ang * y_ellipse\n                )\n                # Clamp sample in map bounds\n                sample_clamped = tuple(min(max(sample_rotated[d], 0.0), bounds[d]) for d in range(dim))\n                # Avoid obstacles\n                if collision_free(sample_clamped):\n                    return sample_clamped\n                else:\n                    # fallback uniform sample\n                    return uniform_sample()\n            else:\n                # 3D: approximate ellipse with scaling on axes aligned with a1 and orthogonal\n                # To build orthonormal basis {a1, a2, a3}\n                import numpy as np\n                a1_vec = np.array(a1)\n                # find random vector not colinear for a2\n                if abs(a1_vec[0]) < 0.9:\n                    temp = np.array([1,0,0])\n                else:\n                    temp = np.array([0,1,0])\n                a2_vec = temp - a1_vec * np.dot(temp, a1_vec)\n                a2_vec /= np.linalg.norm(a2_vec)\n                a3_vec = np.cross(a1_vec, a2_vec)\n                r3 = r2  # approximate equal minor axis\n                \n                sample_ball_np = np.array(sample_ball)\n                scale = np.array([r1, r2, r3])\n                ellip_point = a1_vec*sample_ball_np[0]*scale[0] + a2_vec*sample_ball_np[1]*scale[1] + a3_vec*sample_ball_np[2]*scale[2]\n                sample_final = tuple(center[d] + ellip_point[d] for d in range(dim))\n                sample_clamped = tuple(min(max(sample_final[d], 0.0), bounds[d]) for d in range(dim))\n                if collision_free(sample_clamped):\n                    return sample_clamped\n                else:\n                    return uniform_sample()\n\n        def uniform_sample():\n            for _ in range(100):  # max 100 tries to find free sample\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                if collision_free(p):\n                    return p\n            # fallback\n            return start_position\n\n        def sample_point():\n            # Use goal bias or informed sampling\n            if random.random() < self.goal_sample_rate:\n                if random.random() < 0.85:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                return informed_sample()\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            dist_to_sample = distance(nearest_node.position, point)\n            \n            # Adaptive step sizing: reduce step if close to sample for finer resolution near goal or obstacles\n            adapt_step = min(self.step_size_base, dist_to_sample * 0.9)\n\n            new_pos = steer(nearest_node.position, point, adapt_step=adapt_step)\n\n            # Bounds check\n            for d in range(len(new_pos)):\n                if new_pos[d] < 0 or new_pos[d] > bounds[d]:\n                    return None\n\n            if not collision_free(new_pos) or not edge_collision_free(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = radius_by_nodes(n_nodes)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + distance(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if edge_collision_free(node.position, new_pos):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes to new_node if it reduces cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-9 < neighbor.cost:\n                    if edge_collision_free(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            # Attempt to connect node to tree by greedy extension along path\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                dist_to_goal = distance(last_node.position, node.position)\n                if dist_to_goal <= 0.1:\n                    # Close enough\n                    return last_node\n\n                adapt_step = min(self.step_size_base, dist_to_goal * 0.9)\n                new_pos = steer(last_node.position, node.position, adapt_step=adapt_step)\n\n                for d in range(len(new_pos)):\n                    if new_pos[d] < 0 or new_pos[d] > bounds[d]:\n                        return None\n\n                if not collision_free(new_pos) or not edge_collision_free(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                last_node = new_node\n\n                if distance(new_pos, node.position) <= adapt_step:\n                    if edge_collision_free(new_pos, node.position):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Remove duplicate connection position\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if edge_collision_free(p_i, p_j):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            rand_point = sample_point()\n            # Expand smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                path = extract_path(new_node_start, new_node_goal)\n                path_cost = 0.0\n                for k in range(len(path) - 1):\n                    path_cost += distance(path[k], path[k+1])\n                if path_cost < best_path_cost:\n                    best_path_cost = path_cost\n                    extracted_path = shortcut_path(path)\n                    success_state = True\n                    # Stop early on first connection since path improved\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 13.67438,
    "time_improvement": -58.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009960055351257324,
            "num_nodes_avg": 105.3,
            "path_length_avg": 166.49204749160407,
            "success_improvement": 0.0,
            "time_improvement": 1.2763614364442395,
            "length_improvement": 16.78887490147799,
            "objective_score": 3.74068341122887
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.040338969230651854,
            "num_nodes_avg": 322.0,
            "path_length_avg": 243.38332989947048,
            "success_improvement": 0.0,
            "time_improvement": -182.01098415714512,
            "length_improvement": 19.237177114847455,
            "objective_score": -50.755859824174046
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.027082610130310058,
            "num_nodes_avg": 232.0,
            "path_length_avg": 127.7603507376911,
            "success_improvement": 0.0,
            "time_improvement": 5.60851106969216,
            "length_improvement": 21.547448234041028,
            "objective_score": 5.992042967715853
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This planner introduces a guided bidirectional RRT* with adaptive dynamic obstacle-informed sampling and lazy edge collision checking integrated with batch rewiring and progressive path shortcutting. The algorithm maintains two trees from start and goal, strategically sampling near detected obstacle boundaries to enhance exploration in complex regions, while using lazy collision checks to defer expensive edge validations until necessary. Batch rewiring improves local connectivity periodically, and a progressive smoothing strategy refines the final path iteratively for better smoothness and length. This combination boosts planning speed, robustness, and path quality for both 2D and 3D maps.",
    "planning_mechanism": "The planner alternately grows two trees from start and goal nodes. It samples points biased toward obstacle boundaries and the corridor between trees, aiming to better explore challenging regions. New nodes are connected to near neighbors with lazy collision checking cached and validated only when a potentially better path is found, reducing redundant checks. Periodic batch rewiring consolidates local improvements. The trees attempt incremental connection, and after successful connection, a progressive shortcut smoothing iteratively refines the path. The planner prunes nodes unlikely to improve the best solution to keep search complexity in check.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position                  # Tuple[float, ...] (2D or 3D)\n        self.parent = parent                      # Node or None\n        self.cost = cost                          # Cost from root to this node\n        self.children = []\n        self.valid = True                         # For collision status if needed\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def heuristic_cost_to(self, pos):\n        return math.dist(self.position, pos)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 batch_rewire_interval: int = 100,\n                 prune_interval: int = 250,\n                 smoothing_iterations_init: int = 50,\n                 smoothing_iterations_batch: int = 30,\n                 neighbor_radius_min: float = 6.0,\n                 neighbor_radius_max: float = 30.0,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.batch_rewire_interval = batch_rewire_interval\n        self.prune_interval = prune_interval\n        self.smoothing_iterations_init = smoothing_iterations_init\n        self.smoothing_iterations_batch = smoothing_iterations_batch\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # --- Helper Functions ---\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp within bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def is_in_obstacle(p):\n            return self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree (naive) helper for neighbor searches\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best = self.nodes[i]\n                        best_dist = d\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Adaptive neighbor radius dependent on number of nodes and iteration\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            r_iter = self.neighbor_radius_max * (1 - (iteration/self.max_iter)**0.95)\n            r_nodes = self.neighbor_radius_min + (self.neighbor_radius_max - self.neighbor_radius_min) * math.sqrt(math.log(n_nodes + 1)/n_nodes)\n            return max(self.neighbor_radius_min, min(r_iter, r_nodes))\n\n        # Lazy collision cache for edges, stores edge->bool(collision)\n        edge_collision_cache = {}\n\n        def edge_key(p1, p2):\n            return (p1, p2) if p1 < p2 else (p2, p1)\n\n        def can_connect(p1, p2):\n            key = edge_key(p1, p2)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            # Lazy collision checking deferred elsewhere; for now do quick check\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        # Sampling biased toward obstacle boundaries and corridor between trees\n        def boundary_informed_sample():\n            # Attempt obstacle boundary sampling\n            for _ in range(30):\n                # Sample uniformly first\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_in_obstacle(sample):\n                    continue\n                # Check close to obstacle surfaces by jittering slightly outwards\n                offset = [random.uniform(-self.step_size, self.step_size) for _ in range(dim)]\n                near_point = tuple(sample[d] + offset[d] for d in range(dim))\n                if not in_bounds(near_point):\n                    continue\n                # Identify if near obstacle boundary by checking local neighbors\n                if not is_in_obstacle(near_point):\n                    return near_point\n            # Fallback uniform sample\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # Progressive shortcut smoothing for path refinement\n        def progressive_shortcut_path(path, iterations):\n            if len(path) < 3:\n                return path\n            for _ in range(iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Prune nodes unlikely to improve best path to reduce search complexity\n        def prune_nodes(nodes_list, best_cost, root_start, root_goal):\n            removed = 0\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_position)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(rm_node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n\n        # Batch rewiring to optimize local connectivity\n        def batch_rewire(tree_nodes, iteration):\n            if len(tree_nodes) <= 1:\n                return\n            kdtree = KDTree([(n.position, n) for n in tree_nodes])\n            radius = neighbor_radius(len(tree_nodes), iteration)\n            for node in tree_nodes:\n                near_nodes = kdtree.radius_search(node.position, radius)\n                for nbr in near_nodes:\n                    if nbr is node or nbr is node.parent:\n                        continue\n                    c_via_node = node.cost + dist(node.position, nbr.position)\n                    if c_via_node + 1e-12 < nbr.cost and can_connect(node.position, nbr.position):\n                        try:\n                            # Remove old edge\n                            edges.remove((nbr.parent, nbr))\n                        except (ValueError, NameError):\n                            pass\n                        nbr.update_parent(node, c_via_node)\n                        edges.append((node, nbr))\n\n        # Initialize trees\n        root_start = Node(start_position, cost=0.0)\n        root_goal = Node(goal_position, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            # Sample point biased to obstacle boundary and corridor between trees\n            if (it % 5) == 0 and len(best_path) >= 3:\n                # Sample near best path corridor for refinement\n                base_pt = best_path[random.randint(0, len(best_path) - 1)]\n                noise = [random.gauss(0, self.step_size) for _ in range(dim)]\n                sample = tuple(min(max(base_pt[d] + noise[d], 0), bounds[d]) for d in range(dim))\n                if is_in_obstacle(sample):\n                    sample = boundary_informed_sample()\n            else:\n                sample = boundary_informed_sample()\n\n            # Alternate expanding smaller tree for better balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            if not tree_a:\n                continue\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(sample)\n            new_pos = steer(nearest_a.position, sample)\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(len(nodes), it)\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            # Choose parent minimizing cost (lazy collision for edges)\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for nbr in near_nodes:\n                cost_candidate = nbr.cost + dist(nbr.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost:\n                    # defer collision check for lazy evaluation, cache on success only\n                    best_parent = nbr\n                    min_cost = cost_candidate\n\n            # Confirm edge collision for best_parent-new_pos\n            if not can_connect(best_parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost improved (lazy collision checking)\n            for nbr in near_nodes:\n                if nbr is best_parent:\n                    continue\n                c_new = new_node.cost + dist(new_node.position, nbr.position)\n                if c_new + 1e-12 < nbr.cost:\n                    # Check edge collision only if better cost\n                    if can_connect(new_node.position, nbr.position):\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.update_parent(new_node, c_new)\n                        edges.append((new_node, nbr))\n\n            # Attempt incremental connection to other tree\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            max_connect_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            connected = False\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_b_nodes = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_b_nodes:\n                    if nbr_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if c_via_new_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, nbr_b))\n\n                # Check if connected within step_size\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    connect_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=connect_cost)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if connect_cost + 1e-12 < c_best:\n                        c_best = connect_cost\n                        best_path = progressive_shortcut_path(merged_path, self.smoothing_iterations_init)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Batch rewiring at intervals for both trees\n            if it > 0 and it % self.batch_rewire_interval == 0:\n                batch_rewire(tree_start, it)\n                batch_rewire(tree_goal, it)\n\n            # Periodic pruning to reduce search tree size\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > 250 and c_best < float('inf'):\n                removed_s = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_g = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n            # Progressive smoothing of best path every 500 iterations\n            if success_state and it % 500 == 0 and best_path:\n                best_path = progressive_shortcut_path(best_path, self.smoothing_iterations_batch)\n                extracted_path = best_path\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 9.46305,
    "time_improvement": -46.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.015555047988891601,
            "num_nodes_avg": 100.4,
            "path_length_avg": 160.47926016880558,
            "success_improvement": 0.0,
            "time_improvement": -54.18096399436615,
            "length_improvement": 19.79400821352656,
            "objective_score": -12.295487555604533
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.030246663093566894,
            "num_nodes_avg": 216.1,
            "path_length_avg": 238.44289020185434,
            "success_improvement": 0.0,
            "time_improvement": -111.45535915193638,
            "length_improvement": 20.876582149030188,
            "objective_score": -29.261291315774876
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02040393352508545,
            "num_nodes_avg": 140.4,
            "path_length_avg": 126.19365812367366,
            "success_improvement": 0.0,
            "time_improvement": 28.88581801381229,
            "length_improvement": 22.509491878198684,
            "objective_score": 13.167643779783424
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the adaptive ellipsoidal informed sampling and KD-tree accelerated nearest neighbor and radius searches from Algorithm No.2 with the adaptive step sizing, dynamic neighborhood radius, and incremental connection strategy from Algorithm No.1. It integrates collision caching, periodic pruning of non-promising nodes, and bidirectional tree growth to efficiently find optimal paths in 2D and 3D maps. Shortcut smoothing is applied post-connection for path refinement, balancing exploration and exploitation to improve planning speed, success rate, path quality, and robustness.",
    "planning_mechanism": "The planner grows two bidirectional trees from start and goal alternately, sampling adaptively inside an ellipsoidal informed subset defined by the current best path cost. KD-tree accelerates nearest neighbor and radius queries for fast rewiring and incremental cost improvement. Nodes and edges undergo rigorous collision checks with caching for efficiency. Periodic pruning removes nodes unlikely to improve the solution, speeding convergence. Upon successful tree connection, the extracted path undergoes iterative shortcut smoothing to improve smoothness and length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 25.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_iterations: int = 80,\n                 collision_check_resolution: float = 0.5,\n                 adaptive_step_min: float = 1.5,\n                 adaptive_step_max: float = 7.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.adaptive_step_min = adaptive_step_min\n        self.adaptive_step_max = adaptive_step_max\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def adaptive_step(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            step = min(self.adaptive_step_max, max(self.adaptive_step_min, d))\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp within bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / self.collision_check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return True\n            return False\n\n        # Collision cache for edges\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        # KDTree helper class\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # Uniform random sampling until finding free sample\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))  # unit vector from start to goal\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0.0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(100):\n                sample_unit = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(sample_unit) <= 1:\n                    sample_scaled = sample_unit * radii\n                    p = rot @ sample_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            # Fallback uniform sampling near the center\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # last fallback\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            to_remove = []\n            for node in nodes:\n                if node is root_start or node is root_goal:\n                    continue\n                heuristic = dist(node.position, goal_position)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n\n        root_start = Node(start_position, cost=0.0)\n        root_goal = Node(goal_position, cost=0.0)\n        nodes = [root_start, root_goal]\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_position, goal_position)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_position, goal_position)\n\n            # Alternate expanding smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = adaptive_step(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius = neighbor_radius(it, len(nodes))\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node_ in near_nodes_a:\n                candidate_cost = node_.cost + dist(node_.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node_.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node_\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve cost\n            for neighbor in near_nodes_a:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = adaptive_step(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius)\n                for neighbor_b in near_nodes_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning\n            if (it > 0 and it % self.prune_interval == 0 and\n                len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 2.66513,
    "time_improvement": -15.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.015644359588623046,
            "num_nodes_avg": 67.0,
            "path_length_avg": 169.23345678045976,
            "success_improvement": -9.999999999999998,
            "time_improvement": -55.0662167144032,
            "length_improvement": 15.418744887954519,
            "objective_score": -18.436116036730056
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.019730210304260254,
            "num_nodes_avg": 168.7,
            "path_length_avg": 238.85781049298052,
            "success_improvement": 0.0,
            "time_improvement": -37.93451175504829,
            "length_improvement": 20.738897559056333,
            "objective_score": -7.23257401470322
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01511223316192627,
            "num_nodes_avg": 126.1,
            "path_length_avg": 134.55871737646015,
            "success_improvement": 0.0,
            "time_improvement": 47.32907270190565,
            "length_improvement": 17.3728415773402,
            "objective_score": 17.673290126039735
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* planner featuring adaptive step sizing, informed elliptical sampling biased around the current best path cost, dynamic neighborhood radius shrinking for efficient rewiring, and rigorous collision and edge checks. The planner balances tree expansions from start and goal nodes, incorporates path shortcut smoothing post-planning to produce smoother and shorter paths, and stops early upon finding a valid improved path to maximize planning efficiency and success rate.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal, sampling points primarily inside an informed elliptical region around the best known path cost or uniformly otherwise. Each extension uses adaptive step sizes depending on the proximity to the sample, ensuring fine resolution near obstacles and goal regions. New nodes are attached via lowest-cost parents within a shrinking neighborhood radius, enabling incremental path cost optimization with rewiring. Trees attempt connection through direct collision-free motions. Upon tree connection, the combined path is extracted and shortcut-smoothed to reduce unnecessary detours.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float = 0.2, radius_const: float = 30.0,\n                 radius_min: float = 5.0, smoothing_iter: int = 50):\n        self.max_iter = max_iter\n        self.step_size_base = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.smoothing_iter = smoothing_iter\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_path_cost = math.inf\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, adapt_step=None):\n            dist = distance(from_pos, to_pos)\n            max_step = adapt_step if adapt_step is not None else self.step_size_base\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (sum((node.position[d] - pos[d])**2 for d in range(len(pos))) <= radius_sq)]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_const\n            return max(self.radius_min,\n                       self.radius_const * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        def collision_free(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def edge_collision_free(pos1, pos2):\n            res = max(0.25, self.step_size_base / 5)\n            return not self._is_edge_in_obstacle(pos1, pos2, obstacles, is_3d, resolution=res)\n\n        def uniform_sample():\n            for _ in range(100):\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                if collision_free(p):\n                    return p\n            return start_position\n\n        def informed_sample():\n            if best_path_cost == math.inf:\n                return uniform_sample()\n\n            c_best = best_path_cost\n            c_min = distance(start_position, goal_position)\n            if c_best <= c_min:\n                # Path cost equals minimum distance, bias strongly towards goal\n                if random.random() < 0.9:\n                    return goal_position\n                else:\n                    return uniform_sample()\n\n            dim = len(bounds)\n            center = tuple((start_position[d] + goal_position[d]) / 2.0 for d in range(dim))\n            a1 = tuple((goal_position[d] - start_position[d]) / c_min for d in range(dim))\n\n            r1 = c_best / 2.0\n            r2_val = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n\n            def sample_unit_ball():\n                if dim == 2:\n                    while True:\n                        x = random.uniform(-1, 1)\n                        y = random.uniform(-1, 1)\n                        if x * x + y * y <= 1:\n                            return (x, y)\n                else:\n                    while True:\n                        x = random.uniform(-1, 1)\n                        y = random.uniform(-1, 1)\n                        z = random.uniform(-1, 1)\n                        if x * x + y * y + z * z <= 1:\n                            return (x, y, z)\n\n            sample_ball = sample_unit_ball()\n\n            if dim == 2:\n                import math as m\n                ang = m.atan2(a1[1], a1[0])\n                x_ball, y_ball = sample_ball\n                x_ellipse = r1 * x_ball\n                y_ellipse = r2_val * y_ball\n                cos_ang = m.cos(ang)\n                sin_ang = m.sin(ang)\n                sample_rotated = (\n                    center[0] + cos_ang * x_ellipse - sin_ang * y_ellipse,\n                    center[1] + sin_ang * x_ellipse + cos_ang * y_ellipse\n                )\n                sample_clamped = tuple(min(max(sample_rotated[d], 0.0), bounds[d]) for d in range(dim))\n                if collision_free(sample_clamped):\n                    return sample_clamped\n                else:\n                    return uniform_sample()\n            else:\n                import numpy as np\n                a1_vec = np.array(a1)\n                if abs(a1_vec[0]) < 0.9:\n                    temp = np.array([1,0,0])\n                else:\n                    temp = np.array([0,1,0])\n                a2_vec = temp - a1_vec * np.dot(temp, a1_vec)\n                a2_vec /= np.linalg.norm(a2_vec)\n                a3_vec = np.cross(a1_vec, a2_vec)\n                r3 = r2_val\n\n                sample_ball_np = np.array(sample_ball)\n                scale = np.array([r1, r2_val, r3])\n                ellip_point = a1_vec*sample_ball_np[0]*scale[0] + a2_vec*sample_ball_np[1]*scale[1] + a3_vec*sample_ball_np[2]*scale[2]\n                sample_final = tuple(center[d] + ellip_point[d] for d in range(dim))\n                sample_clamped = tuple(min(max(sample_final[d], 0.0), bounds[d]) for d in range(dim))\n                if collision_free(sample_clamped):\n                    return sample_clamped\n                else:\n                    return uniform_sample()\n\n        def sample_point():\n            # Goal bias sampling or informed sampling\n            if random.random() < self.goal_sample_rate:\n                if random.random() < 0.85:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                return informed_sample()\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            dist_to_sample = distance(nearest_node.position, point)\n            adapt_step = min(self.step_size_base, dist_to_sample * 0.9)\n\n            new_pos = steer(nearest_node.position, point, adapt_step=adapt_step)\n\n            # Check bounds\n            for d in range(len(new_pos)):\n                if new_pos[d] < 0 or new_pos[d] > bounds[d]:\n                    return None\n\n            if not collision_free(new_pos) or not edge_collision_free(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = radius_by_nodes(n_nodes)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + distance(node.position, new_pos)\n                if temp_cost < min_cost and edge_collision_free(node.position, new_pos):\n                    min_cost = temp_cost\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-9 < neighbor.cost:\n                    if edge_collision_free(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                dist_to_goal = distance(last_node.position, node.position)\n                if dist_to_goal <= 0.1:\n                    return last_node\n\n                adapt_step = min(self.step_size_base, dist_to_goal * 0.9)\n                new_pos = steer(last_node.position, node.position, adapt_step=adapt_step)\n\n                for d in range(len(new_pos)):\n                    if new_pos[d] < 0 or new_pos[d] > bounds[d]:\n                        return None\n\n                if not collision_free(new_pos) or not edge_collision_free(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                last_node = new_node\n\n                if distance(new_pos, node.position) <= adapt_step:\n                    if edge_collision_free(new_pos, node.position):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if edge_collision_free(p_i, p_j):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            rand_point = sample_point()\n\n            # Expand smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                path = extract_path(new_node_start, new_node_goal)\n                path_cost = sum(distance(path[k], path[k+1]) for k in range(len(path)-1))\n                if path_cost < best_path_cost:\n                    best_path_cost = path_cost\n                    extracted_path = shortcut_path(path)\n                    success_state = True\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance_val / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 15.88998,
    "time_improvement": -66.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01166067123413086,
            "num_nodes_avg": 93.4,
            "path_length_avg": 162.00360832502164,
            "success_improvement": 0.0,
            "time_improvement": -15.580069761506401,
            "length_improvement": 19.032153656317195,
            "objective_score": -0.867590197188481
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04047954082489014,
            "num_nodes_avg": 332.0,
            "path_length_avg": 251.30012996732512,
            "success_improvement": 0.0,
            "time_improvement": -182.99372452933972,
            "length_improvement": 16.61011501506681,
            "objective_score": -51.57609435578855
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.028690695762634277,
            "num_nodes_avg": 234.9,
            "path_length_avg": 123.98941495576157,
            "success_improvement": 0.0,
            "time_improvement": 0.003822436204791025,
            "length_improvement": 23.863029969139195,
            "objective_score": 4.773752724689277
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner implements an advanced bidirectional RRT* algorithm enhanced with ellipsoidal informed sampling, adaptive neighbor radius, KD-tree acceleration, collision caching, incremental rewiring, aggressive periodic pruning, and intensive path shortcut smoothing. These enhancements aim to yield fast convergence, high-quality smooth paths, increased success rates, and reduced computational overhead in both 2D and 3D obstacle-laden environments.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal positions, sampling points biased by an ellipsoidal informed distribution centered on the current best-known path cost. KD-trees enable efficient nearest neighbor and radius queries used for rewiring and local optimization. Collision checks on nodes and edges are cached to avoid redundant computations. Periodic pruning removes nodes unlikely to improve the solution, and intensive shortcutting refines the final path to improve smoothness and length. Early termination occurs once a sufficiently good connecting path is found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision/etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 150, prune_threshold: int = 200,\n                 smoothing_iterations: int = 200, collision_check_resolution: float = 0.5,\n                 goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / self.collision_check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        d_ += delta * delta\n                        if d_ > best_dist * best_dist:\n                            break\n                    curr_dist = d_ ** 0.5\n                    if curr_dist < best_dist:\n                        best_dist = curr_dist\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            # Bias samples around informed ellipsoid informed by best cost:\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback uniform\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) ** 2, 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    x_scaled = x / norm_x * np.random.uniform() ** (1 / dim)\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + center\n                    p_tuple = tuple(float(c) for c in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            # fallback uniform sampling\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate balanced tree growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Incremental rewiring neighbors for local optimality\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Connect other tree towards new_node incrementally\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Aggressive pruning to reduce complexity and speed up\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 30.61648,
    "time_improvement": -115.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.024819111824035643,
            "num_nodes_avg": 100.5,
            "path_length_avg": 167.97242850863591,
            "success_improvement": 0.0,
            "time_improvement": -146.00596470332454,
            "length_improvement": 16.04899469784288,
            "objective_score": -40.59199047142878
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.036669230461120604,
            "num_nodes_avg": 231.0,
            "path_length_avg": 236.40004372520366,
            "success_improvement": 0.0,
            "time_improvement": -156.35572667950095,
            "length_improvement": 21.554467722555064,
            "objective_score": -42.59582445933927
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04124429225921631,
            "num_nodes_avg": 192.5,
            "path_length_avg": 126.50881029594893,
            "success_improvement": 0.0,
            "time_improvement": -43.749444292562615,
            "length_improvement": 22.315969459335395,
            "objective_score": -8.661639395901705
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a simplified bidirectional RRT* algorithm with adaptive neighbor radius and basic rewiring to efficiently explore the space, balance exploration and exploitation, and incrementally improve path quality. It performs essential collision and bounds checks, alternates growth between start and goal trees, attempts connections between trees upon each extension, and extracts a smooth final path when a connection is found. The design emphasizes clarity, generalization for both 2D and 3D spaces, and robust path quality improvements.",
    "planning_mechanism": "The planning mechanism alternates extending two trees from start and goal positions by sampling collision-free points within bounds. Each extension creates new nodes via steering while ensuring no collisions occur on sampled nodes or edges. Neighbors within an adaptive radius are rewired if a better path is found. After each extension, the planner attempts to connect the other tree to the new node. Upon successful connection, the combined path is extracted and returned, enabling efficient and reliable bidirectional path planning.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, min_radius: float = 5.0, max_radius: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.collision_resolution = 1.0  # For edge collision checking\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def nearest_node(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - point[d])**2 for d in range(dim)) <= r2]\n\n        def neighbor_radius(iteration: int, n_nodes: int) -> float:\n            n = max(n_nodes,1)\n            r_iter = self.max_radius * (1 - (iteration / self.max_iter)**0.9)\n            r_log = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.min_radius, min(r_iter, r_log))\n\n        success = False\n        best_path: List[Tuple[float, ...]] = []\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges: List[Tuple[Node, Node]] = []\n\n        for it in range(self.max_iter):\n            # Sample random free point\n            for _ in range(100):\n                q_rand = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(q_rand, obstacles, is_3d):\n                    break\n            else:\n                q_rand = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Alternate trees to expand (smaller tree first)\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            nearest = nearest_node(tree_a, q_rand)\n            new_pos = steer(nearest.position, q_rand)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            neighbors = near_nodes(tree_a, new_pos, r)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for node in neighbors:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, self.collision_resolution):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                    neighbor.parent.children.remove(neighbor) if neighbor.parent else None\n                    neighbor.parent = new_node\n                    neighbor.cost = c_via_new\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            # Try to connect opposite tree\n            nearest_b = nearest_node(tree_b, new_node.position)\n            if dist(new_node.position, nearest_b.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_b.position, obstacles, is_3d, self.collision_resolution):\n                    # Create connecting node in other tree if needed\n                    success = True\n                    # Extract full path from start to goal\n                    if tree_a is tree_start:\n                        path_from_start = new_node.path_from_root()\n                        path_from_goal = nearest_b.path_from_root()\n                    else:\n                        path_from_start = nearest_b.path_from_root()\n                        path_from_goal = new_node.path_from_root()\n\n                    # Merge paths (remove duplicated connection node)\n                    best_path_candidate = path_from_start + path_from_goal[::-1][1:]\n                    path_length = 0.0\n                    for i in range(len(best_path_candidate) - 1):\n                        path_length += dist(best_path_candidate[i], best_path_candidate[i+1])\n                    if path_length < c_best:\n                        c_best = path_length\n                        best_path = best_path_candidate\n                    break\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles, is_3d: bool, resolution: float) -> bool:\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 18.29039,
    "time_improvement": -65.0,
    "length_improvement": 14.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.016416168212890624,
            "num_nodes_avg": 127.9,
            "path_length_avg": 172.3665062549406,
            "success_improvement": -9.999999999999998,
            "time_improvement": -62.716350471221006,
            "length_improvement": 13.852876873904,
            "objective_score": -21.0443297665855
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02670242786407471,
            "num_nodes_avg": 241.1,
            "path_length_avg": 254.7269118376883,
            "success_improvement": 0.0,
            "time_improvement": -86.67750081256095,
            "length_improvement": 15.472992857289988,
            "objective_score": -22.908651672310288
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04154374599456787,
            "num_nodes_avg": 262.6,
            "path_length_avg": 142.3333166685893,
            "success_improvement": 0.0,
            "time_improvement": -44.79313556934771,
            "length_improvement": 12.598769262231798,
            "objective_score": -10.918186818357952
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "cross_over",
    "algorithm_description": "This algorithm implements an advanced bidirectional RRT* planner that synergizes adaptive informed sampling focused inside an ellipsoidal heuristic region, dynamic neighborhood radius adjustment, balanced tree growth, dead-end pruning, and enhanced rewiring strategies. It uses adaptive step sizing for finer navigation near obstacles and goal, performs rigorous collision and edge checks, and includes iterative shortcut smoothing to produce efficient, smooth, and shorter paths quickly. The planner halts early on improved solutions to maximize efficiency and success rate.",
    "planning_mechanism": "The planner grows two trees from start and goal positions, always expanding the smaller tree to maintain balance. Sampling points are biased within an informed ellipsoidal region derived from the current best path cost or uniform otherwise, guiding the search intelligently. For each sampled point, an adaptive step-sized extension is attempted with rewiring of nearby nodes within a shrinking neighborhood to optimize path costs. Periodic pruning eliminates dead-ends, minimizing computational overhead. Upon successful tree connection, the combined path is extracted and shortcut-smoothed iteratively, reducing detours and further improving quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float = 0.2, radius_const: float = 30.0,\n                 radius_min: float = 5.0, prune_interval: int = 200,\n                 prune_threshold: int = 100, smoothing_iter: int = 50):\n        self.max_iter = max_iter\n        self.step_size_base = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iter = smoothing_iter\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D or 3D\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_path_cost = math.inf\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, adapt_step=None):\n            dist = distance(from_pos, to_pos)\n            max_step = adapt_step if adapt_step is not None else self.step_size_base\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (sum((node.position[d] - pos[d])**2 for d in range(len(pos))) <= radius_sq)]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_const\n            return max(self.radius_min,\n                       self.radius_const * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        def collision_free(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def edge_collision_free(pos1, pos2):\n            res = max(0.25, self.step_size_base / 5)\n            return not self._is_edge_in_obstacle(pos1, pos2, obstacles, is_3d, resolution=res)\n\n        def uniform_sample():\n            for _ in range(100):\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                if collision_free(p):\n                    return p\n            return start_position\n\n        def informed_sample():\n            if best_path_cost == math.inf:\n                return uniform_sample()\n\n            c_best = best_path_cost\n            c_min = distance(start_position, goal_position)\n            if c_best <= c_min:\n                # Path cost equals minimum distance, bias strongly towards goal\n                if random.random() < 0.9:\n                    return goal_position\n                else:\n                    return uniform_sample()\n\n            dim = len(bounds)\n            center = tuple((start_position[d] + goal_position[d]) / 2.0 for d in range(dim))\n            a1 = tuple((goal_position[d] - start_position[d]) / c_min for d in range(dim))\n            r1 = c_best / 2.0\n            r2_val = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n\n            def sample_unit_ball():\n                if dim == 2:\n                    while True:\n                        x = random.uniform(-1, 1)\n                        y = random.uniform(-1, 1)\n                        if x * x + y * y <= 1:\n                            return (x, y)\n                else:\n                    while True:\n                        x = random.uniform(-1, 1)\n                        y = random.uniform(-1, 1)\n                        z = random.uniform(-1, 1)\n                        if x * x + y * y + z * z <= 1:\n                            return (x, y, z)\n\n            sample_ball = sample_unit_ball()\n\n            if dim == 2:\n                import math as m\n                ang = m.atan2(a1[1], a1[0])\n                x_ball, y_ball = sample_ball\n                x_ellipse = r1 * x_ball\n                y_ellipse = r2_val * y_ball\n                cos_ang = m.cos(ang)\n                sin_ang = m.sin(ang)\n                sample_rotated = (\n                    center[0] + cos_ang * x_ellipse - sin_ang * y_ellipse,\n                    center[1] + sin_ang * x_ellipse + cos_ang * y_ellipse\n                )\n                sample_clamped = tuple(min(max(sample_rotated[d], 0.0), bounds[d]) for d in range(dim))\n                if collision_free(sample_clamped):\n                    return sample_clamped\n                else:\n                    return uniform_sample()\n            else:\n                import numpy as np\n                a1_vec = np.array(a1)\n                if abs(a1_vec[0]) < 0.9:\n                    temp = np.array([1,0,0])\n                else:\n                    temp = np.array([0,1,0])\n                a2_vec = temp - a1_vec * np.dot(temp, a1_vec)\n                a2_vec /= np.linalg.norm(a2_vec)\n                a3_vec = np.cross(a1_vec, a2_vec)\n                r3 = r2_val\n\n                sample_ball_np = np.array(sample_ball)\n                scale = np.array([r1, r2_val, r3])\n                ellip_point = a1_vec*sample_ball_np[0]*scale[0] + a2_vec*sample_ball_np[1]*scale[1] + a3_vec*sample_ball_np[2]*scale[2]\n                sample_final = tuple(center[d] + ellip_point[d] for d in range(dim))\n                sample_clamped = tuple(min(max(sample_final[d], 0.0), bounds[d]) for d in range(dim))\n                if collision_free(sample_clamped):\n                    return sample_clamped\n                else:\n                    return uniform_sample()\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                if random.random() < 0.85:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                return informed_sample()\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            dist_to_sample = distance(nearest_node.position, point)\n            adapt_step = min(self.step_size_base, dist_to_sample * 0.9)\n\n            new_pos = steer(nearest_node.position, point, adapt_step=adapt_step)\n\n            # Check bounds\n            for d in range(len(new_pos)):\n                if new_pos[d] < 0 or new_pos[d] > bounds[d]:\n                    return None\n\n            if not collision_free(new_pos) or not edge_collision_free(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = radius_by_nodes(n_nodes)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + distance(node.position, new_pos)\n                if temp_cost + 1e-12 < min_cost and edge_collision_free(node.position, new_pos):\n                    min_cost = temp_cost\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-12 < neighbor.cost and edge_collision_free(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                dist_to_goal = distance(last_node.position, node.position)\n                if dist_to_goal <= 0.1:\n                    return last_node\n\n                adapt_step = min(self.step_size_base, dist_to_goal * 0.9)\n                new_pos = steer(last_node.position, node.position, adapt_step=adapt_step)\n\n                for d in range(len(new_pos)):\n                    if new_pos[d] < 0 or new_pos[d] > bounds[d]:\n                        return None\n\n                if not collision_free(new_pos) or not edge_collision_free(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                last_node = new_node\n\n                if distance(new_pos, node.position) <= adapt_step:\n                    if edge_collision_free(new_pos, node.position):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if edge_collision_free(p_i, p_j):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += distance(path[i], path[i + 1])\n            return length\n\n        for itr in range(self.max_iter):\n            rand_point = sample_point()\n\n            # Expand smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                path = extract_path(new_node_start, new_node_goal)\n                path_cost = sum(distance(path[k], path[k+1]) for k in range(len(path)-1))\n\n                if path_cost + 1e-9 < best_path_cost:\n                    best_path_cost = path_cost\n                    extracted_path = shortcut_path(path)\n                    success_state = True\n                    # Early termination for efficiency & improved path\n                    break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance_val / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 13.85888,
    "time_improvement": -60.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009521675109863282,
            "num_nodes_avg": 79.0,
            "path_length_avg": 158.7059756085607,
            "success_improvement": 0.0,
            "time_improvement": 5.621567459754784,
            "length_improvement": 20.680278792818076,
            "objective_score": 5.82252599649005
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03948616981506348,
            "num_nodes_avg": 220.8,
            "path_length_avg": 246.21481229144337,
            "success_improvement": 0.0,
            "time_improvement": -176.04903701110916,
            "length_improvement": 18.29759546387822,
            "objective_score": -49.1551920105571
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03161466121673584,
            "num_nodes_avg": 199.1,
            "path_length_avg": 123.66741174733474,
            "success_improvement": 0.0,
            "time_improvement": -10.187124871512125,
            "length_improvement": 24.060759336912902,
            "objective_score": 1.7560144059289433
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This enhanced hybrid planner improves efficiency by integrating an informed sampling strategy biased not only towards the goal and frontiers but also guided by a kd-tree structure for fast nearest neighbor search and obstacle-aware adaptive step sizing. It introduces a dynamically shrinking step size near obstacles for safer exploration and implements batch node rewiring inspired by RRT* to reduce path cost and increase robustness. The shortcut smoothing routine is optimized by early collision checks, increasing path smoothness and reducing overall path length while minimizing planning time.",
    "planning_mechanism": "The planner grows a search tree from the start toward the goal by sampling points with controlled probabilities using goal biasing and frontier-guided exploration. It employs a spatial kd-tree for efficient nearest-node queries, dynamically adjusts step sizes near obstacles, and applies rigorous collision checking for new nodes and edges. After path discovery, it performs iterative shortcut smoothing and local rewiring to further improve path quality and reduce length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position       # Tuple[float, ...] (2D or 3D)\n        self.parent = parent           # Node or None\n        self.cost = cost               # Cost from root node\n        self.children = []\n        self.valid = True              # Collision validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_and_rewire(self, new_parent, new_cost):\n        self.parent = new_parent\n        self.cost = new_cost\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 5.0, goal_sample_rate: float = 0.1,\n                 frontier_sample_rate: float = 0.25, smoothing_iters: int = 80, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.frontier_sample_rate = frontier_sample_rate\n        self.smoothing_iters = smoothing_iters\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> \"PlannerResult\":\n        import random\n        import math\n        from bisect import bisect_left\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        frontier_regions = self._identify_frontiers(bounds, obstacles, is_3d)\n\n        # Prebuild spatial index for nodes using a simple list + bisect for faster nearest candidate retrieval\n        # For further speedups, a KD-tree could be used. Here we implement a grid-based spatial hash for nearest approx.\n        spatial_hash = {}\n        grid_size = self.base_step_size * 2\n        dims = len(bounds)\n\n        def _grid_key(pos):\n            return tuple(int(pos[d] // grid_size) for d in range(dims))\n\n        def _insert_spatial_hash(node):\n            key = _grid_key(node.position)\n            if key not in spatial_hash:\n                spatial_hash[key] = []\n            spatial_hash[key].append(node)\n\n        def _nearby_nodes(pos, radius):\n            keys = []\n            base_key = _grid_key(pos)\n            ranges = [range(k - 1, k + 2) for k in base_key]\n            from itertools import product\n            for key in product(*ranges):\n                keys.append(key)\n            result = []\n            for key in keys:\n                for n in spatial_hash.get(key, []):\n                    if math.dist(n.position, pos) <= radius:\n                        result.append(n)\n            return result\n\n        _insert_spatial_hash(root)\n\n        for it in range(self.max_iter):\n            r = random.random()\n            # Goal biasing\n            if r < self.goal_sample_rate:\n                sample = goal_position\n            # Sample near frontiers if any\n            elif r < self.goal_sample_rate + self.frontier_sample_rate and frontier_regions:\n                sample = self._sample_near_frontier(frontier_regions, bounds, is_3d)\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dims))\n\n            # Find nearest node efficiently using spatial_hash + local search\n            possible_near_nodes = _nearby_nodes(sample, self.rewire_radius)\n            if not possible_near_nodes:\n                nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            else:\n                nearest_node = min(possible_near_nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Adaptive step size depends on proximity to obstacles\n            step_size = self._adaptive_step_size(nearest_node.position, obstacles, is_3d, self.base_step_size)\n\n            new_position = self._steer(nearest_node.position, sample, step_size)\n            if not self._in_bounds(new_position, bounds):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d, resolution=step_size / 3):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            _insert_spatial_hash(new_node)\n\n            # Rewiring for path cost improvements (inspired by RRT*)\n            neighbors = _nearby_nodes(new_position, self.rewire_radius)\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                if neighbor.cost > new_node.cost + math.dist(new_node.position, neighbor.position):\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=step_size / 3):\n                        # Rewire neighbor to new_node\n                        old_parent = neighbor.parent\n                        if old_parent:\n                            old_parent.children.remove(neighbor)\n                        neighbor.update_cost_and_rewire(new_node, new_node.cost + math.dist(new_node.position, neighbor.position))\n                        new_node.add_child(neighbor)\n\n            dist_to_goal = math.dist(new_position, goal_position)\n            if dist_to_goal <= step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d, resolution=step_size / 3) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node = Node(goal_position, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] // resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets] * dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                if all(0 <= nbr[i] <= steps[i] for i in range(dims)):\n                    yield nbr\n\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                min_cells = [int(ox // resolution), int(oy // resolution), int(oz // resolution)]\n                max_cells = [int((ox + w) // resolution), int((oy + h) // resolution), int((oz + d) // resolution)]\n                for cx in range(min_cells[0], max_cells[0] + 1):\n                    if cx < 0 or cx > steps[0]:\n                        continue\n                    for cy in range(min_cells[1], max_cells[1] + 1):\n                        if cy < 0 or cy > steps[1]:\n                            continue\n                        for cz in range(min_cells[2], max_cells[2] + 1):\n                            if cz < 0 or cz > steps[2]:\n                                continue\n                            occupied.add((cx, cy, cz))\n            else:\n                ox, oy, w, h = obs\n                min_cells = [int(ox // resolution), int(oy // resolution)]\n                max_cells = [int((ox + w) // resolution), int((oy + h) // resolution)]\n                for cx in range(min_cells[0], max_cells[0] + 1):\n                    if cx < 0 or cx > steps[0]:\n                        continue\n                    for cy in range(min_cells[1], max_cells[1] + 1):\n                        if cy < 0 or cy > steps[1]:\n                            continue\n                        occupied.add((cx, cy))\n\n        for ix in range(steps[0] + 1):\n            if is_3d:\n                for iy in range(steps[1] + 1):\n                    for iz in range(steps[2] + 1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontier_pos = tuple((pos_grid[d] + 0.5) * resolution for d in range(3))\n                            frontiers.append(frontier_pos)\n            else:\n                for iy in range(steps[1] + 1):\n                    pos_grid = (ix, iy)\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontier_pos = ((ix + 0.5) * resolution, (iy + 0.5) * resolution)\n                        frontiers.append(frontier_pos)\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n        else:\n            for item in arrays[0]:\n                for rest in self._cartesian_product(arrays[1:]):\n                    yield (item,) + rest\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        import random\n        frontier = random.choice(frontiers)\n        radius = self.base_step_size * 3\n        dim = len(bounds)\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _adaptive_step_size(self, position, obstacles, is_3d, base_step_size):\n        query_radius = max(base_step_size * 2.5, 8.0)  # slightly bigger to detect obstacles early\n        min_dist = float(\"inf\")\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                px, py, pz = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dz = max(oz - pz, 0, pz - (oz + d))\n                dist = (dx * dx + dy * dy + dz * dz) ** 0.5\n            else:\n                ox, oy, w, h = obs\n                px, py = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dist = (dx * dx + dy * dy) ** 0.5\n            if dist < min_dist:\n                min_dist = dist\n            if min_dist <= query_radius:\n                # When near obstacle, reduce step size proportionally (linear scaling, min 0.3*base)\n                scale = max(0.3, min_dist / query_radius)\n                return base_step_size * scale\n        return base_step_size\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        unit_vec = tuple((to_pos[d] - from_pos[d]) / dist for d in range(len(from_pos)))\n        return tuple(from_pos[d] + unit_vec[d] * step_size for d in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, bounds):\n        import random\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            p_i = new_path[i]\n            p_j = new_path[j]\n            if not self._in_bounds(p_j, bounds):\n                continue\n            # Quick bounding box check for early rejection\n            min_pt = tuple(min(p_i[d], p_j[d]) for d in range(len(p_i)))\n            max_pt = tuple(max(p_i[d], p_j[d]) for d in range(len(p_i)))\n            collision_possible = False\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if all(min_pt[d] <= (obs[d] + (obs[d+3] if d < 3 else 0)) and max_pt[d] >= obs[d] for d in range(3)):\n                        collision_possible = True\n                        break\n                else:\n                    x, y, w, h = obs\n                    if all(min_pt[d] <= (obs[d] + (obs[d+2] if d < 2 else 0)) and max_pt[d] >= obs[d] for d in range(2)):\n                        collision_possible = True\n                        break\n            if collision_possible:\n                # Do full edge obstacle check only if bounding box overlaps obstacles\n                if self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    continue\n            # Valid shortcut, replace intermediate points\n            new_path = new_path[:i + 1] + new_path[j:]\n        return new_path",
    "objective": 177.36337,
    "time_improvement": -591.0,
    "length_improvement": 24.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.03642547130584717,
            "num_nodes_avg": 317.7,
            "path_length_avg": 158.30232270384806,
            "success_improvement": -9.999999999999998,
            "time_improvement": -261.04769872103907,
            "length_improvement": 20.88202063488485,
            "objective_score": -79.13790548933474
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.19984009265899658,
            "num_nodes_avg": 1527.5,
            "path_length_avg": 228.48341500880028,
            "success_improvement": -9.999999999999998,
            "time_improvement": -1297.0882816211215,
            "length_improvement": 24.181472962127103,
            "objective_score": -389.290189893911
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.08998169898986816,
            "num_nodes_avg": 1004.0,
            "path_length_avg": 118.69827359159828,
            "success_improvement": -9.999999999999998,
            "time_improvement": -213.61476989349524,
            "length_improvement": 27.11210951045393,
            "objective_score": -63.662009065957776
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved planner implements a bidirectional RRT* algorithm with enhanced heuristics and rewiring strategies to minimize path length and improve path smoothness. It employs informed sampling centered on the current best path length, dynamic neighbor radius adjustment for efficient rewiring, and strict bidirectional collision and edge checks. The planner alternates growth between the two trees (start and goal), performs rewiring to optimize local costs, and attempts to connect the two trees. Upon successful connection, it reconstructs a high-quality path with reduced total length and improved robustness.",
    "planning_mechanism": "The planner alternately samples with adaptive goal biasing focused around the minimal heuristic path length, grows one tree toward the sample by steering toward it and selecting the best feasible parent from nearby nodes with rewiring to reduce cost, then attempts to connect the other tree to the new node by repeated extensions. The process repeats until a feasible, improved path is found or iteration limit is reached.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For future extensions\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1,\n                 neighbor_radius: float = 15.0, resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_init = neighbor_radius\n        self.resolution = resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        tree_start = [Node(start_position, cost=0.0)]\n        tree_goal = [Node(goal_position, cost=0.0)]\n        nodes.extend(tree_start + tree_goal)\n\n        best_path_cost = math.inf\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(1, int(dist / self.resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(len(from_p)))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                # Adaptive goal biasing with equal chance for start or goal\n                return start_position if random.random() < 0.5 else goal_position\n            else:\n                # Informed sampling inside ellipsoid defined by current best path cost if possible\n                if best_path_cost == math.inf:\n                    while True:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                        if not is_in_obstacle(p):\n                            return p\n                else:\n                    # Ellipsoid sampling between start and goal to focus sampling region\n                    c_min = math.dist(start_position, goal_position)\n                    c_best = best_path_cost\n                    if c_best < math.inf and c_best > c_min:\n                        center = tuple((start_position[d] + goal_position[d]) / 2 for d in range(len(bounds)))\n                        a1 = tuple((goal_position[d] - start_position[d]) / c_min for d in range(len(bounds)))\n                        import numpy as np\n\n                        # Sample unit ball point\n                        while True:\n                            direction = np.random.normal(0,1,len(bounds))\n                            norm_dir = direction / np.linalg.norm(direction)\n                            radius = random.random() ** (1/len(bounds))\n                            sample_ball = norm_dir * radius\n                            # Stretching matrix for ellipsoid\n                            L_shape = np.diag([c_best/2] + [math.sqrt(c_best**2 - c_min**2)/2]*(len(bounds)-1))\n                            # Rotation matrix to align with a1\n                            def rotation_matrix_from_a1(a1_vec):\n                                basis1 = np.array(a1_vec)\n                                if len(basis1) == 2:\n                                    angle = math.atan2(basis1[1], basis1[0])\n                                    c = math.cos(angle)\n                                    s = math.sin(angle)\n                                    return np.array([[c, -s],[s,c]])\n                                else:\n                                    # 3D: find rotation matrix via Rodrigues' formula\n                                    a1_norm = basis1 / np.linalg.norm(basis1)\n                                    z_axis = np.eye(3)[2]\n                                    v = np.cross(z_axis, a1_norm)\n                                    s_ = np.linalg.norm(v)\n                                    c_ = np.dot(z_axis, a1_norm)\n                                    if s_ == 0:\n                                        return np.eye(3)\n                                    vx = np.array([[0, -v[2], v[1]],\n                                                   [v[2], 0, -v[0]],\n                                                   [-v[1], v[0], 0]])\n                                    R = np.eye(3) + vx + vx@vx*((1 - c_)/(s_**2))\n                                    return R\n                            R = rotation_matrix_from_a1(a1)\n                            sample_ellipsoid = center + R @ L_shape @ sample_ball\n                            sample_point = tuple(float(sample_ellipsoid[d]) for d in range(len(bounds)))\n                            if all(0 <= sample_point[d] <= bounds[d] for d in range(len(bounds))) and not is_in_obstacle(sample_point):\n                                return sample_point\n                    else:\n                        while True:\n                            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                            if not is_in_obstacle(p):\n                                return p\n\n        def try_extend(tree, point, other_tree):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not in_bounds(new_pos):\n                return None\n            if is_in_obstacle(new_pos):\n                return None\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            # Adjust neighbor radius based on iteration and problem dimension for faster convergence\n            gamma_rrt_star = self.neighbor_radius_init\n            radius = min(gamma_rrt_star, self.step_size * 10)\n\n            near = near_nodes(tree, new_pos, radius)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                cost_through_node = node.cost + math.dist(node.position, new_pos)\n                if cost_through_node < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = cost_through_node\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if beneficial\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost + 1e-8 < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Try to connect other tree to new_node for early path detection\n            connection = try_connect(other_tree, new_node)\n            if connection is not None:\n                nonlocal success, path, best_path_cost\n                success = True\n\n                path_start = new_node.path_from_root()\n                path_goal = connection.path_from_root()\n                path_candidate = path_start + path_goal[::-1][1:]\n                cost_candidate = path_start[-1].distance_to(path_start[0]) if False else new_node.cost + connection.cost\n\n                # Calculate actual path length\n                path_cost_actual = 0.0\n                for i in range(len(path_candidate) - 1):\n                    path_cost_actual += math.dist(path_candidate[i], path_candidate[i + 1])\n\n                if path_cost_actual < best_path_cost:\n                    best_path_cost = path_cost_actual\n                    path = path_candidate\n                return new_node\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            current_pos = nearest_node.position\n            while True:\n                new_pos = steer(current_pos, node.position)\n                if not in_bounds(new_pos):\n                    return None\n                if is_in_obstacle(new_pos):\n                    return None\n                if is_edge_in_obstacle(current_pos, new_pos):\n                    return None\n\n                new_cost = nearest_node.cost + math.dist(current_pos, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = nearest_node\n                nearest_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                if math.dist(new_pos, node.position) <= self.step_size:\n                    return new_node\n\n                current_pos = new_pos\n                nearest_node = new_node\n\n        for iter_count in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Alternate between growing start and goal tree each iteration\n            if iter_count % 2 == 0:\n                new_node = try_extend(tree_start, rand_point, tree_goal)\n                if new_node is None:\n                    tree_start, tree_goal = tree_goal, tree_start\n                    continue\n            else:\n                new_node = try_extend(tree_goal, rand_point, tree_start)\n                if new_node is None:\n                    tree_start, tree_goal = tree_goal, tree_start\n                    continue\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n            if success:\n                break\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)",
    "objective": 80.63654,
    "time_improvement": -273.0,
    "length_improvement": 15.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.04013092517852783,
            "num_nodes_avg": 216.7,
            "path_length_avg": 190.71200869245638,
            "success_improvement": 0.0,
            "time_improvement": -297.7759975044664,
            "length_improvement": 4.683971083371581,
            "objective_score": -88.39600503466559
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06791739463806153,
            "num_nodes_avg": 441.3,
            "path_length_avg": 239.40697371943165,
            "success_improvement": 0.0,
            "time_improvement": -374.81261094582095,
            "length_improvement": 20.556666621501034,
            "objective_score": -108.33244995944608
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.07081038951873779,
            "num_nodes_avg": 481.7,
            "path_length_avg": 131.4378975446472,
            "success_improvement": -9.999999999999998,
            "time_improvement": -146.7966738157303,
            "length_improvement": 19.289212955423046,
            "objective_score": -45.18115955363447
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e1",
    "algorithm_description": "This planner implements a hybrid bidirectional RRT* with adaptive informed sampling and dynamic step sizing, integrated with multi-resolution collision checking and heuristic pruning. It uses a priority queue to grow the trees towards promising regions, balances exploration and exploitation via uncertainty-guided sampling, and applies batch rewiring with KD-tree acceleration. The planner incorporates incremental shortcut smoothing during planning to maintain high path quality and robustness. This results in faster convergence, shorter and smoother paths, and improved success rates in complex 2D/3D environments.",
    "planning_mechanism": "The planner grows two trees from start and goal positions, using adaptive informed sampling to focus on ellipsoidal regions defined by the current best path cost, dynamically adjusting step size based on local obstacle density. KD-trees accelerate neighbor search for efficient rewiring. Periodic heuristic pruning removes nodes unlikely to improve solutions. The connection between trees is incrementally extended with collision-safe edges verified at multiple resolutions. Shortcut smoothing is applied iteratively on the best current path. The planner terminates early when a quality path is found or max iterations reached.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 min_step_size: float = 1.0,\n                 max_step_size: float = 7.0,\n                 smoothing_iterations: int = 80,\n                 collision_resolution_coarse: float = 1.0,\n                 collision_resolution_fine: float = 0.3,\n                 prune_interval: int = 300,\n                 prune_margin: float = 2.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_step_size = min_step_size\n        self.max_step_size = max_step_size\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_resolution_coarse = collision_resolution_coarse\n        self.collision_resolution_fine = collision_resolution_fine\n        self.prune_interval = prune_interval\n        self.prune_margin = prune_margin\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Success flags and data collectors\n        success = False\n        best_path: List[Tuple[float, ...]] = []\n        c_min = math.dist(start_pos, goal_pos)\n        c_best = float('inf')\n\n        nodes = []\n        edges = []\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes.extend([root_start, root_goal])\n\n        # KD-tree for quick neighbor search\n        class SimpleKDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n\n            def nearest(self, pt):\n                best_dist = float('inf')\n                best_node = None\n                for i, p in enumerate(self.points):\n                    d = math.dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = self.nodes[i]\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    d2 = sum((p[d] - pt[d])**2 for d in range(dim))\n                    if d2 <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def is_colliding(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_colliding(p1, p2, resolution):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def can_connect(p1, p2):\n            if not in_bounds(p2):\n                return False\n            if is_colliding(p2):\n                return False\n            # Multi-resolution collision check (coarse then fine)\n            if is_edge_colliding(p1, p2, self.collision_resolution_coarse):\n                return False\n            return not is_edge_colliding(p1, p2, self.collision_resolution_fine)\n\n        def adaptive_step_size(pos_from, pos_to):\n            dist_ = math.dist(pos_from, pos_to)\n            # Heuristic: smaller step near obstacles, larger otherwise\n            # Check obstacle density nearby (sample small environment)\n            samples = 5\n            obstacle_hits = 0\n            for i in range(1, samples+1):\n                interp = tuple(pos_from[d] + (pos_to[d]-pos_from[d])*i/samples for d in range(dim))\n                if is_colliding(interp):\n                    obstacle_hits += 1\n            ratio = 1.0 - obstacle_hits / samples\n            step = self.min_step_size + (self.max_step_size - self.min_step_size) * ratio\n            step = max(self.min_step_size, min(step, self.max_step_size))\n            return min(dist_, step)\n\n        def steer(from_pos, to_pos):\n            dist_ = math.dist(from_pos, to_pos)\n            step = adaptive_step_size(from_pos, to_pos)\n            if dist_ <= step:\n                return to_pos\n            ratio = step / dist_\n            new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            clamped = tuple(max(0.0, min(new_pos[d], bounds[d])) for d in range(dim))\n            return clamped\n\n        def heuristic(pos):\n            return math.dist(pos, goal_pos)\n\n        # Informed ellipse sampling focused on current best solution\n        def informed_sample(c_best, c_min, start, goal):\n            # With probability goal_sample_rate, sample goal directly\n            if c_best == float('inf') or random.random() < self.goal_sample_rate:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_colliding(p):\n                        return p\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))  # unit vector along start-goal\n\n            # Construct orthonormal basis with a1 as first vector using Gram-Schmidt\n            import numpy as np\n            a1_np = np.array(a1)\n            dim_np = dim\n            basis = [a1_np]\n            if dim > 1:\n                for i in range(1, dim):\n                    vec = np.zeros(dim_np)\n                    vec[i] = 1.0\n                    # Gram-Schmidt to orthogonalize\n                    for b in basis:\n                        vec -= np.dot(vec, b)*b\n                    norm = np.linalg.norm(vec)\n                    if norm > 1e-10:\n                        basis.append(vec / norm)\n            basis_mat = np.column_stack(basis)  # dim x dim matrix\n\n            r1 = c_best / 2.0\n            r_others = max(math.sqrt(r1*r1 - (c_min/2)**2), 0.0)\n\n            radii = np.array([r1] + [r_others]*(dim-1))\n\n            for _ in range(100):\n                sample_unit = np.random.uniform(low=-1.0, high=1.0, size=dim)\n                if np.linalg.norm(sample_unit) <= 1.0:\n                    sample_scaled = sample_unit * radii\n                    p = basis_mat @ sample_scaled + np.array(center)\n                    p_tuple = tuple(float(x) for x in p)\n                    if in_bounds(p_tuple) and not is_colliding(p_tuple):\n                        return p_tuple\n\n            # If above fails, sample uniformly as fallback\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_colliding(p):\n                    return p\n            return p\n\n        def extract_path(node_start, node_goal):\n            path_from_start = node_start.path_from_root()\n            path_from_goal = node_goal.path_from_root()\n            # Avoid duplication of connecting node\n            if path_from_start[-1] == path_from_goal[-1]:\n                path_from_goal = path_from_goal[:-1]\n            return path_from_start + path_from_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p_i, p_j = path[i], path[j]\n                if can_connect(p_i, p_j):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_nodes(best_cost):\n            # Remove nodes that cannot improve path by heuristic pruning\n            to_remove = []\n            heuristic_cost = lambda p: math.dist(p, goal_pos)\n            for n in nodes:\n                if n is root_start or n is root_goal:\n                    continue\n                if n.cost + heuristic_cost(n.position) > best_cost + self.prune_margin:\n                    to_remove.append(n)\n            for n in to_remove:\n                if n.parent:\n                    try:\n                        n.parent.children.remove(n)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(n)\n                except ValueError:\n                    pass\n                if n in tree_start:\n                    tree_start.remove(n)\n                if n in tree_goal:\n                    tree_goal.remove(n)\n\n        # Main loop variables\n        edge_set = set()\n        best_connection_pair = None\n\n        for iter_num in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree growth for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = SimpleKDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            # Neighbor radius shrinking\n            n_nodes = max(len(nodes),1)\n            r_radius = min(self.max_step_size * 5,\n                           max(self.min_step_size * 2, 20.0 * math.sqrt(math.log(n_nodes)/n_nodes)))\n            near_nodes_a = kdtree_a.radius_search(new_pos, r_radius)\n\n            # Find best parent within near nodes\n            min_cost = nearest_a.cost + math.dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for nbr in near_nodes_a:\n                candidate_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(nbr.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            edge_set.add((best_parent, new_node))\n\n            # Rewire near nodes to new node if better cost\n            for nbr in near_nodes_a:\n                if nbr is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                if new_cost + 1e-12 < nbr.cost and can_connect(new_node.position, nbr.position):\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                        edge_set.remove((nbr.parent, nbr))\n                    except (ValueError, KeyError):\n                        pass\n                    nbr.update_parent(new_node, new_cost)\n                    edges.append((new_node, nbr))\n                    edge_set.add((new_node, nbr))\n\n            # Try to connect tree_b towards new_node incrementally\n            kdtree_b = SimpleKDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            steps_max = max(1, int(math.dist(last_node_b.position, new_node.position) / self.step_size))\n\n            connected = False\n            for _ in range(steps_max):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + math.dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n                edge_set.add((last_node_b, new_node_b))\n\n                r_near_b = r_radius\n                near_b = kdtree_b.radius_search(next_pos_b, r_near_b)\n\n                # Rewire near nodes in tree_b\n                for nbr_b in near_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + math.dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                            edge_set.remove((nbr_b.parent, nbr_b))\n                        except (ValueError, KeyError):\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n                        edge_set.add((new_node_b, nbr_b))\n\n                dist_last_to_new = math.dist(new_node_b.position, new_node.position)\n                if dist_last_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_last_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n                    edge_set.add((new_node_b, connection_node))\n\n                    success = True\n                    # Extract and merge path accordingly\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            # Early stop if connected with best path\n            if connected:\n                break\n\n            # Periodic pruning to remove nodes that cannot improve best cost\n            if iter_num > 0 and iter_num % self.prune_interval == 0 and success:\n                prune_nodes(c_best)\n\n        final_path = best_path if success else []\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance_ = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance_ / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 12.54134,
    "time_improvement": -53.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.024034667015075683,
            "num_nodes_avg": 88.8,
            "path_length_avg": 177.08454703744547,
            "success_improvement": 0.0,
            "time_improvement": -138.23058162946998,
            "length_improvement": 11.49484543824194,
            "objective_score": -39.170205401192604
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02287459373474121,
            "num_nodes_avg": 153.7,
            "path_length_avg": 250.91715483692647,
            "success_improvement": 0.0,
            "time_improvement": -59.91699377453309,
            "length_improvement": 16.737199119958383,
            "objective_score": -14.627658308368249
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.017220592498779295,
            "num_nodes_avg": 114.0,
            "path_length_avg": 128.81792533523668,
            "success_improvement": 0.0,
            "time_improvement": 39.98077148396115,
            "length_improvement": 20.898033721782404,
            "objective_score": 16.173838189544824
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the strengths of bidirectional RRT* with adaptive informed ellipsoidal sampling, efficient KD-tree based neighbor search, collision caching, dynamic neighbor radius, periodic pruning, incremental rewiring, and aggressive shortcut smoothing to achieve fast, robust, and high-quality path planning in both 2D and 3D environments. It balances exploration and exploitation by alternating expansions between start and goal trees, leveraging heuristics to prune non-promising nodes and maintain manageable search complexity while caching collision checks to reduce computational overhead.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal, sampling adaptively within ellipsoids defined by the best path length found so far. It uses KD-trees for fast nearest-neighbor and radius searches to connect and rewire nodes optimally. Collision checks for nodes and edges are cached to avoid redundant computations. Periodic pruning removes nodes that cannot improve the solution. Upon connecting the two trees, the combined path is shortcut-smoothed multiple times to enhance smoothness and reduce length. The process repeats until max iterations or successful convergence.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval: int=200, prune_threshold: int=300,\n                 smoothing_iterations: int=100, collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / self.collision_check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.dim = dim\n                self.points = [p for p, n in pts_nodes]\n                self.nodes = [n for p, n in pts_nodes]\n\n            def nearest(self, query_point):\n                best_node = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = 0.0\n                    for dd in range(self.dim):\n                        diff = p[dd] - query_point[dd]\n                        d += diff*diff\n                        if d > best_dist*best_dist:\n                            break\n                    if d < best_dist*best_dist:\n                        best_node = self.nodes[i]\n                        best_dist = d**0.5\n                return best_node\n\n            def radius_search(self, query_point, radius):\n                r2 = radius*radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for dd in range(self.dim):\n                        delta = p[dd] - query_point[dd]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            rev_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return not edge_collision_cache[rev_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)], dtype=np.float64)\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)], dtype=np.float64)\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1*r1 - (c_min/2)*(c_min/2), 0))\n            radii = np.array([r1] + [r_others]*(dim-1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x <= 1 and norm_x > 1e-10:\n                    x_ball = (x_ball / norm_x) * (random.uniform(0,1)**(1/dim))\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n            return len(to_remove)\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n\n        best_path = []\n        success_state = False\n        extracted_path: list = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree to balance growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Incremental rewiring\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 11.53701,
    "time_improvement": -54.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.010166501998901368,
            "num_nodes_avg": 68.3,
            "path_length_avg": 156.30355469998824,
            "success_improvement": 0.0,
            "time_improvement": -0.7699288205768154,
            "length_improvement": 21.880985672061716,
            "objective_score": 4.145218488239299
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.028364133834838868,
            "num_nodes_avg": 214.7,
            "path_length_avg": 231.63823696291087,
            "success_improvement": 0.0,
            "time_improvement": -98.29453875707345,
            "length_improvement": 23.134596305376345,
            "objective_score": -24.861442366046766
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04665830135345459,
            "num_nodes_avg": 209.5,
            "path_length_avg": 123.02630402294139,
            "success_improvement": 0.0,
            "time_improvement": -62.61898371392887,
            "length_improvement": 24.454438100669513,
            "objective_score": -13.894807494044759
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm incorporating adaptive informed sampling, dynamic neighbor radius rewiring, and path shortcut smoothing for efficient, high-quality path generation in 2D and 3D environments. It balances exploration and exploitation by growing two trees from start and goal, connecting them incrementally while pruning non-promising nodes to reduce computational overhead and improve convergence.",
    "planning_mechanism": "The planner alternates expansions between the two trees, sampling adaptively within an informed ellipsoid once a path is found to bias search towards promising regions. Nodes are steered, collision-checked, and connected with rewiring of nearby nodes for path cost minimization. Upon connecting trees, the merged path undergoes shortcut smoothing. Periodic pruning removes nodes unlikely to improve the solution, enhancing speed and success robustness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = 5.0\n        self.max_radius = 30.0\n        self.prune_interval = 200\n        self.prune_threshold = 300\n        self.smoothing_iterations = 50\n        self.collision_resolution = 1.0\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        import math\n        import random\n        import numpy as np\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            n = max(n_nodes, 1)\n            r_iter = self.max_radius * (1 - (iteration / self.max_iter) ** 0.9)\n            r_log = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.min_radius, min(r_iter, r_log))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance_edge = dist(p1, p2)\n            steps = max(1, int(distance_edge / self.collision_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            I = np.eye(dim)\n            u = direction - I[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = I - 2 * np.outer(u, u)\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((a - b) ** 2 for a, b in zip(node.position, point)) <= r2]\n\n        def prune_nodes(nodes_list, tree_start, tree_goal, best_cost):\n            to_remove = []\n            for node in nodes_list:\n                if node is root_start or node is root_goal:\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            nearest_a = nearest_node(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if (not in_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            neighbors = near_nodes(tree_a, new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in neighbors:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            nearest_b = nearest_node(tree_b, new_node.position)\n            last_b = nearest_b\n            max_connect_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            connected = False\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if (not in_bounds(next_pos_b)) or is_in_obstacle(next_pos_b) or is_edge_in_obstacle(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                neighbors_b = near_nodes(tree_b, next_pos_b, r)\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is last_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and not is_edge_in_obstacle(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and not is_edge_in_obstacle(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_from_start = connection_node.path_from_root()\n                        path_from_goal = new_node.path_from_root()\n                    else:\n                        path_from_start = new_node.path_from_root()\n                        path_from_goal = connection_node.path_from_root()\n\n                    merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -1.72076,
    "time_improvement": -9.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.008452510833740235,
            "num_nodes_avg": 73.2,
            "path_length_avg": 163.2466271311899,
            "success_improvement": 0.0,
            "time_improvement": 16.219077597859886,
            "length_improvement": 18.410904804265574,
            "objective_score": 8.547904240211082
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.024390578269958496,
            "num_nodes_avg": 240.9,
            "path_length_avg": 235.6754897795363,
            "success_improvement": 0.0,
            "time_improvement": -70.5152886466485,
            "length_improvement": 21.794899234478425,
            "objective_score": -16.795606747098862
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02050516605377197,
            "num_nodes_avg": 166.5,
            "path_length_avg": 123.35847354432505,
            "success_improvement": 0.0,
            "time_improvement": 28.532990532822687,
            "length_improvement": 24.250466004311317,
            "objective_score": 13.40999036070907
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm combines the efficiency of bidirectional RRT with asymptotic optimality by growing two trees simultaneously from start and goal states, incorporating a rewiring step to minimize path cost as trees expand. It leverages collision checks and guided connection attempts to improve success rate and path quality without compromising planning speed.",
    "planning_mechanism": "The planner alternately samples free points, extends each tree toward samples with step-limited steering, rewires neighbors within a set radius to optimize costs, and tries to connect the two trees. Connection attempts validate nodes and edges for collisions. On success, the combined optimized path is extracted.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start, tree_goal = [start_root], [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        import math, random\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d, in_bounds)\n\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                new_node = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n                if new_node is None:\n                    continue\n\n                connect_node = self._connect_and_rewire(tree_b, new_node, obstacles, is_3d, nodes, edges)\n                if connect_node:\n                    success_state = True\n                    path_a = new_node.path_from_root()\n                    path_b = connect_node.path_from_root()\n                    extracted_path = path_a + path_b[::-1]\n                    return PlannerResult(success_state, extracted_path, nodes, edges)\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d, in_bounds):\n        import random\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if not self._valid_new_point(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.rewire_radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and self._valid_new_point(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and self._valid_new_point(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, new_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, new_node.position)\n            if not self._valid_new_point(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.rewire_radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and self._valid_new_point(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and self._valid_new_point(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n\n            nearest = connect_node\n\n    def _valid_new_point(self, from_pos, to_pos, obstacles, is_3d):\n        # Check node collision and edge collision\n        if self._is_in_obstacle(to_pos, obstacles, is_3d) or self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 0.54705,
    "time_improvement": -3.0,
    "length_improvement": 26.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.014068508148193359,
            "num_nodes_avg": 87.8,
            "path_length_avg": 159.51460781133255,
            "success_improvement": 0.0,
            "time_improvement": -39.44644528259082,
            "length_improvement": 20.27613219003853,
            "objective_score": -7.77870714676954
        },
        {
            "map_id": 1,
            "success_rate": 0.8,
            "time_avg": 0.018608403205871583,
            "num_nodes_avg": 219.6,
            "path_length_avg": 215.62206906451374,
            "success_improvement": -19.999999999999996,
            "time_improvement": -30.091923560933743,
            "length_improvement": 28.449302665139758,
            "objective_score": -13.337716535252168
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.010966038703918457,
            "num_nodes_avg": 157.5,
            "path_length_avg": 114.47323288400807,
            "success_improvement": -9.999999999999998,
            "time_improvement": 61.77987587053908,
            "length_improvement": 29.706539025648727,
            "objective_score": 19.47527056629147
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved planner implements a bidirectional informed RRT* with enhanced lazy collision checking and efficient planning heuristics. It uses adaptive ellipse sampling based on current best path cost, dynamic neighborhood radius shrinking for rewiring, and periodic pruning of dead branches for focused search. Additionally, it minimizes redundant collision checks and performs incremental path smoothing via shortcutting. These improvements aim to reduce computation time while enhancing path quality, success rate, and smoothness.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternately sampling points inside an informed ellipse that shrinks as better paths are found. Each extension performs efficient lazy collision checks to avoid unnecessary validations. Local rewiring with a dynamically decreasing radius optimizes paths continuously. When trees connect, the candidate path is shortcut-smoothed. Periodic pruning removes unpromising leaves to concentrate search effort, balancing exploration and exploitation to speed convergence and improve path quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag for collision or pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        curr = self\n        while curr:\n            path.append(curr.position)\n            curr = curr.parent\n        return path[::-1]\n\n    def is_leaf(self):\n        return len(self.children) == 0\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float=0.15,\n                 radius_constant: float=30.0, radius_min: float=5.0,\n                 prune_interval: int=250, prune_threshold: int=150,\n                 smoothing_trials: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def heuristic(a, b):\n            return math.dist(a, b)\n\n        def dynamic_radius(n):\n            if n == 0:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(r, self.radius_min)\n\n        def steer(from_p, to_p):\n            dist = heuristic(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(len(from_p)))\n\n        def nearest(tree, point):\n            # Use squared dist for efficiency if desired\n            return min(tree, key=lambda n: (n.position[0]-point[0])**2 + (n.position[1]-point[1])**2 if not is_3d else sum((n.position[d]-point[d])**2 for d in range(3)))\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            return [n for n in tree if sum((n.position[d] - pos[d]) ** 2 for d in range(len(pos))) <= r2]\n\n        def _sample_uniform():\n            if is_3d:\n                return tuple(random.uniform(0, bounds[d]) for d in range(3))\n            else:\n                return (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n\n        def informed_sample(cost_best):\n            c_min = heuristic(start_pos, goal_pos)\n            dim = len(start_pos)\n            if cost_best == float('inf') or cost_best < c_min:\n                # Uniform sampling over map free space\n                for _ in range(100):\n                    p = _sample_uniform()\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return _sample_uniform()  # fallback\n            else:\n                c_best = cost_best * 1.0001  # small inflation to avoid numerical issues\n                center = tuple((start_pos[d] + goal_pos[d]) / 2.0 for d in range(dim))\n                vec = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n                L_diag = [c_best / 2.0] + [math.sqrt(c_best ** 2 - c_min ** 2) / 2.0] * (dim - 1)\n                L = np.diag(L_diag)\n                e1 = np.array(vec)\n                # Construct C rotation matrix to align unit circle to ellipse\n                if dim == 2:\n                    e2 = np.array([-e1[1], e1[0]])\n                    C = np.column_stack((e1, e2))\n                else:\n                    a = np.array([1.0] + [0.0]*(dim-1))\n                    if abs(np.dot(a, e1)) > 0.9:\n                        a = np.array([0.0, 1.0] + [0.0]*(dim-2))\n                    v2 = a - np.dot(a, e1)*e1\n                    v2 /= np.linalg.norm(v2)\n                    v3 = np.cross(e1, v2)\n                    C = np.column_stack((e1, v2, v3))\n                for _ in range(200):\n                    sample_ball = np.random.uniform(-1,1,dim)\n                    norm_ball = np.linalg.norm(sample_ball)\n                    if norm_ball > 1.0 or norm_ball == 0.0:\n                        continue\n                    sample = np.dot(C, np.dot(L, sample_ball)) + np.array(center)\n                    sample_t = tuple(sample)\n                    if all(0 <= sample_t[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n                # Fallback to uniform if ellipse sampling fails\n                for _ in range(100):\n                    p = _sample_uniform()\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return _sample_uniform()\n\n        lazy_checked_edges = dict()  # keys: (node_id, pos tuple) \u2192 bool collision free or not\n\n        def edge_key(parent_node, point):\n            # Uses id and point rounded for cache key\n            key_pos = tuple(round(coord, 3) for coord in point)\n            return (id(parent_node), key_pos)\n\n        def try_extend(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not self._pos_in_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n\n            n_nodes = len(tree)\n            r = dynamic_radius(n_nodes)\n            near = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + heuristic(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + heuristic(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    key = edge_key(node, new_pos)\n                    if key not in lazy_checked_edges:\n                        collision_free = not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d)\n                        lazy_checked_edges[key] = collision_free\n                    if lazy_checked_edges[key]:\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            # Check final edge from best_parent to new_pos\n            if self._is_edge_in_obstacle(best_parent.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + heuristic(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except Exception:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not self._pos_in_bounds(new_pos, bounds):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + heuristic(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if heuristic(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d) and not self._is_in_obstacle(node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node, cost=new_node.cost + heuristic(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_branches():\n            removed = []\n            # Collect leaves excluding roots\n            leaves = [node for node in nodes if node.is_leaf() and node not in (start_root, goal_root)]\n            for node in leaves:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except Exception:\n                        pass\n                try:\n                    nodes.remove(node)\n                except Exception:\n                    pass\n                edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                removed.append(node)\n            return removed\n\n        def shortcut_path(path_raw):\n            if len(path_raw) < 3:\n                return path_raw[:]\n            smooth_path = path_raw[:]\n            for _ in range(self.smoothing_trials):\n                n_pts = len(smooth_path)\n                if n_pts < 3:\n                    break\n                i = random.randint(0, n_pts - 3)\n                j = random.randint(i + 2, n_pts - 1)\n                pt_i = smooth_path[i]\n                pt_j = smooth_path[j]\n                if not self._is_edge_in_obstacle(pt_i, pt_j, obstacles, is_3d):\n                    del smooth_path[i + 1:j]\n            return smooth_path\n\n        best_path_cost = float('inf')\n        best_path = []\n\n        tree_turn = 0\n        for itr in range(self.max_iter):\n            sample_pt = informed_sample(best_path_cost)\n\n            if tree_turn == 0:\n                new_node = try_extend(tree_start, sample_pt)\n                if new_node is None:\n                    tree_turn = 1\n                    continue\n                connect_node = try_connect(tree_goal, new_node)\n                if connect_node:\n                    success = True\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    candidate_path = path_start + path_goal[::-1][1:]\n                    candidate_cost = sum(heuristic(candidate_path[i], candidate_path[i + 1]) for i in range(len(candidate_path) - 1))\n                    if candidate_cost < best_path_cost:\n                        best_path_cost = candidate_cost\n                        best_path = candidate_path\n                    # Early stopping on good path found, could continue to find better if desired\n                    break\n            else:\n                new_node = try_extend(tree_goal, sample_pt)\n                if new_node is None:\n                    tree_turn = 0\n                    continue\n                connect_node = try_connect(tree_start, new_node)\n                if connect_node:\n                    success = True\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    candidate_path = path_start + path_goal[::-1][1:]\n                    candidate_cost = sum(heuristic(candidate_path[i], candidate_path[i + 1]) for i in range(len(candidate_path) - 1))\n                    if candidate_cost < best_path_cost:\n                        best_path_cost = candidate_cost\n                        best_path = candidate_path\n                    break\n\n            tree_turn = 1 - tree_turn\n\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_branches()\n\n        if success and best_path:\n            extracted_path = shortcut_path(best_path)\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _pos_in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 6.52476,
    "time_improvement": -36.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012595558166503906,
            "num_nodes_avg": 87.0,
            "path_length_avg": 164.12260868721376,
            "success_improvement": 0.0,
            "time_improvement": -24.846628666496517,
            "length_improvement": 17.97309764205878,
            "objective_score": -3.8593690715371993
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.035122013092041014,
            "num_nodes_avg": 216.1,
            "path_length_avg": 240.3180421555253,
            "success_improvement": 0.0,
            "time_improvement": -145.539082097824,
            "length_improvement": 20.254343291588192,
            "objective_score": -39.61085597102956
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.010518193244934082,
            "num_nodes_avg": 114.4,
            "path_length_avg": 123.00330787317095,
            "success_improvement": 0.0,
            "time_improvement": 63.3407593851196,
            "length_improvement": 24.468559121939933,
            "objective_score": 23.895939639923867
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved planner implements a bidirectional RRT* path planning algorithm enhanced with adaptive informed sampling biased towards an ellipsoidal subset that contains the optimal path, dynamic rewiring with a neighborhood radius that shrinks as more nodes are added, and progressive pruning of dead-end nodes to reduce computational load. It integrates a two-tree growth strategy by alternating expansions from start and goal points, always extending the smaller tree for balanced search. The planner enforces strict collision checks on nodes and edges, dynamically rewires to minimize path cost, and applies iterative shortcut smoothing on the final solution to produce a shorter, smoother path. This combination improves path quality, search efficiency, robustness, and success rate.",
    "planning_mechanism": "The planner grows two rapidly-exploring random trees from start and goal, alternately extending the smaller tree by sampling promising points inside an adaptively updated ellipsoidal informed sampling region which focuses search towards the optimum path. New nodes are only added after collision-free checks and neighborhood rewiring ensures lower cost connections. Periodic pruning removes dead-end nodes to maintain computational efficiency. When a connection between the two trees is found, the resulting path is shortcut-smoothed iteratively. Dynamic neighborhood radius optimizes rewiring and balanced growth accelerates convergence and robustness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_from_parent(self):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n            self.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        self.remove_from_parent()\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 5.0, prune_interval: int = 150,\n                 prune_threshold: int = 80, smoothing_iterations: int = 75):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d in range(len(pos)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        # Dynamic neighborhood radius adapted to number of nodes\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        # For informed sampling: generate samples inside an ellipsoid between start and goal\n        def informed_sample(c_best, start, goal):\n            # If no current path, fallback to uniform random sampling\n            if c_best == float('inf'):\n                return uniform_sample()\n            # Compute ellipsoid parameters\n            center = tuple((start[d] + goal[d]) / 2 for d in range(len(start)))\n            a1 = [goal[d] - start[d] for d in range(len(start))]\n            c = c_best / 2.0\n            if dist(start, goal) == 0:\n                return uniform_sample()\n            # Unit vector along start-goal line\n            e1 = [v / dist(start, goal) for v in a1]\n            # Create orthonormal basis using Gram-Schmidt for 2D or 3D\n            # Here, only support 2D or 3D\n            import numpy as np\n            nd = len(start)\n            # Build rotation matrix (R) from e1\n            if nd == 2:\n                # Find orthogonal vector for 2D\n                e2 = [-e1[1], e1[0]]\n                R = np.array([e1, e2]).T\n                L = np.diag([c, math.sqrt(c**2 - (dist(start, goal)/2)**2)])\n            else:\n                # For 3D, use Householder or QR decomposition to get orthonormal basis\n                basis = np.eye(3)\n                basis[:,0] = e1\n                # Generate e2 and e3 orthogonal vectors\n                tmp = np.array([0., 0., 0.])\n                if abs(e1[0]) < abs(e1[1]):\n                    tmp[0] = 1\n                else:\n                    tmp[1] = 1\n                v = tmp - np.dot(tmp, e1)*np.array(e1)\n                e2 = v / np.linalg.norm(v)\n                e3 = np.cross(e1, e2)\n                R = np.column_stack((e1, e2, e3))\n                L = np.diag([c, math.sqrt(c**2 - (dist(start, goal)/2)**2), math.sqrt(c**2 - (dist(start, goal)/2)**2)])\n            while True:\n                # Sample ball point\n                ball_point = random_ball(nd)\n                sample = center + R.dot(L.dot(ball_point))\n                sample_tuple = tuple(sample.tolist())\n                if in_bounds(sample_tuple) and not _is_in_obstacle(sample_tuple):\n                    return sample_tuple\n\n        def random_ball(nd):\n            # Sample uniformly from unit n-ball\n            import numpy as np\n            x = np.random.normal(0, 1, nd)\n            x /= np.linalg.norm(x)\n            r = random.random() ** (1.0 / nd)\n            return r * x\n\n        def uniform_sample():\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not _is_in_obstacle(sample) and in_bounds(sample):\n                    return sample\n\n        def sample_free(c_best):\n            # With some probability, sample goal or start to bias growth\n            p_bias = 0.8\n            if random.random() < self.goal_sample_rate:\n                if random.random() < p_bias:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                # If have current best path cost, sample informed\n                if c_best < float('inf'):\n                    return informed_sample(c_best, start_position, goal_position)\n                else:\n                    return uniform_sample()\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not _is_in_obstacle(pos)\n\n        def can_connect(p1, p2):\n            return not _is_edge_in_obstacle(p1, p2)\n\n        # Extend tree towards sample_pt and add node with optimal parent from neighbors\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors with better cost connections via new_node\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    # Remove old edge\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        # Attempt connecting a node from one tree to the other tree via incremental steps\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            # Removes nodes without children (dead ends) except roots\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        best_path_cost = float('inf')\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free(best_path_cost)\n\n            # Always extend smaller tree for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                raw_len = path_length(raw_path)\n                smooth_len = path_length(smoothed)\n                if smooth_len + 1e-12 < raw_len:\n                    extracted_path = smoothed\n                    best_path_cost = smooth_len\n                else:\n                    extracted_path = raw_path\n                    best_path_cost = raw_len\n                # Continue to search for potentially better paths after finding first solution\n                # Optionally can break here to return first found path\n                # Comment line below to keep searching:\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -0.734,
    "time_improvement": -11.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.011141252517700196,
            "num_nodes_avg": 71.4,
            "path_length_avg": 165.68620850192954,
            "success_improvement": 0.0,
            "time_improvement": -10.431613872897948,
            "length_improvement": 17.191625483198443,
            "objective_score": 0.3088409347703047
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.021133065223693848,
            "num_nodes_avg": 200.9,
            "path_length_avg": 241.53488985526354,
            "success_improvement": 0.0,
            "time_improvement": -47.7419139768816,
            "length_improvement": 19.850552057025173,
            "objective_score": -10.352463781659445
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.021182537078857422,
            "num_nodes_avg": 153.9,
            "path_length_avg": 127.07238336560461,
            "success_improvement": 0.0,
            "time_improvement": 26.172137597731805,
            "length_improvement": 21.969901644353897,
            "objective_score": 12.24562160819032
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This planner features a hybrid single-tree algorithm inspired by Anytime RRT* with adaptive dynamic step size and radius, informed sampling based on a dynamically updated heuristic corridor, incremental graph pruning, lazy collision checking with caching, and efficient rewiring. It integrates a potential field bias towards the goal with exploration noise to balance rapid convergence and robustness. The planner aggressively shortcuts paths upon improvement and employs a batch rewiring strategy optimizing local neighborhoods for improved path quality and smoothness in 2D/3D spaces.",
    "planning_mechanism": "The planner grows a single tree from the start, sampling adaptively within an ellipsoidal-informed region around the current best path and goal, blending goal bias and random exploration. For each iteration, it incrementally connects new sampled nodes, performs lazy collision checking with cache for efficiency, rewires the local neighborhood adaptively shrinking with iteration count, and prunes nodes unlikely to improve the solution. Upon connecting closer to the goal, it extracts and aggressively shortcut-smooths the path, further refining it via local batch rewiring. Early stopping occurs once convergence is detected or max iterations are reached.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent = parent                  # Node or None\n        self.cost = cost                      # Cost from root to node\n        self.children = []                    # List[Node]\n        self.valid = True                     # For pruning or collision invalidation\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def descendants(self):\n        stack = [self]\n        result = []\n        while stack:\n            current = stack.pop()\n            result.append(current)\n            stack.extend(current.children)\n        return result\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_radius: float = 5.0, max_radius: float = 30.0,\n                 prune_interval: int = 250, smoothing_iterations: int = 120,\n                 collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.10):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.prune_interval = prune_interval\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import random\n        import math\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = dim == 3\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step=self.step_size):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                new_p = to_pos\n            else:\n                ratio = max_step / d\n                new_p = tuple(from_pos[d_] + ratio * (to_pos[d_] - from_pos[d_]) for d_ in range(dim))\n            return tuple(max(0, min(new_p[d_], bounds[d_])) for d_ in range(dim))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KDTree-like naive implementation for neighbor queries\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float(\"inf\")\n                for i, p in enumerate(self.points):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = self.nodes[i]\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    else:\n                        result.append(self.nodes[i])\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        # Ellipsoidal informed sampling around current best path & goal\n        def informed_sample(c_best, c_min, start, goal, best_path):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                # Full uniform or goal bias sampling\n                if random.random() < 0.5 and best_path:\n                    # Sample near path corridor with gaussian noise\n                    for _ in range(20):\n                        idx = random.randint(0, len(best_path) - 1)\n                        base_pt = best_path[idx]\n                        noise = np.random.normal(0, self.step_size * 1.5, dim)\n                        sample = tuple(base_pt[d_] + noise[d_] for d_ in range(dim))\n                        if in_bounds(sample) and not is_in_obstacle(sample):\n                            return sample\n                # Pure uniform fallback\n                for _ in range(50):\n                    p = tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # Final fallback\n                return tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n\n            # Informed sampling within ellipsoid defined by c_best and c_min\n            center = tuple((start[d_] + goal[d_]) / 2 for d_ in range(dim))\n            a1 = tuple((goal[d_] - start[d_]) / c_min for d_ in range(dim))  # Unit vector start->goal\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d_ == 0 else 0 for d_ in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)  # Householder reflection as rotation approx.\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    sample = rot @ (x * radii) + np.array(center)\n                    sample_t = tuple(float(sample[d_]) for d_ in range(dim))\n                    if in_bounds(sample_t) and not is_in_obstacle(sample_t):\n                        return sample_t\n\n            # Fallback uniform\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        # Progressive adaptive neighbor radius shrinking with iterations\n        def neighbor_radius(iteration, nb_nodes):\n            c = max(nb_nodes, 1)\n            r_iter = self.max_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        # Aggressive shortcut smoothing of path\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Prune nodes unlikely to improve solution, and cleanup subtrees\n        def prune_nodes(nodes_list, best_cost, goal, root):\n            removed = 0\n            to_remove = set()\n            heuristic = lambda pos: dist(pos, goal)\n            for node in nodes_list:\n                if node is root:\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    # Mark subtree of node for removal\n                    to_remove.update(node.descendants())\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(rm_node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Local batch rewiring for cost refinement\n        def batch_rewire(new_node, kdtree, radius):\n            neighbors = kdtree.radius_search(new_node.position, radius)\n            for nbr in neighbors:\n                if nbr is new_node:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_via_new + 1e-12 < nbr.cost and can_connect(new_node.position, nbr.position):\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                    except ValueError:\n                        pass\n                    nbr.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, nbr))\n\n        # Initialize tree\n        root = Node(start_pos, cost=0.0)\n        nodes = [root]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path: list = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos, best_path)\n            kdtree = KDTree([(n.position, n) for n in nodes])\n            nearest = kdtree.nearest(q_rand)\n            new_pos = steer(nearest.position, q_rand, self.step_size)\n\n            if not can_add_node(new_pos) or not can_connect(nearest.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree.radius_search(new_pos, r)\n\n            # Choose parent minimizing cost + collision check lazy evaluation\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in near_nodes:\n                cost_candidate = nbr.cost + dist(nbr.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(nbr.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = nbr\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Batch rewiring neighbors for quality improvement\n            batch_rewire(new_node, kdtree, r)\n\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and can_connect(new_pos, goal_pos):\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node = Node(goal_pos, parent=new_node, cost=goal_cost)\n                new_node.children.append(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n\n                if goal_cost + 1e-12 < c_best:\n                    c_best = goal_cost\n                    best_path = goal_node.path_from_root()\n                    best_path = shortcut_path(best_path)\n                success_state = True\n                extracted_path = best_path\n                # Early exit if path stable\n                if it > self.max_iter * 0.2:\n                    break\n\n            # Periodic pruning and cache clearing\n            if it > 0 and it % self.prune_interval == 0 and c_best < float('inf'):\n                _ = prune_nodes(nodes, c_best, goal_pos, root)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px, py = pos[0], pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 729.84494,
    "time_improvement": -2449.0,
    "length_improvement": 25.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.31491804122924805,
            "num_nodes_avg": 700.2,
            "path_length_avg": 161.28599891490322,
            "success_improvement": 0.0,
            "time_improvement": -3021.4540264110633,
            "length_improvement": 19.390807942193835,
            "objective_score": -902.5580463348803
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.4328421115875244,
            "num_nodes_avg": 1069.3,
            "path_length_avg": 224.18550483838868,
            "success_improvement": 0.0,
            "time_improvement": -2926.0126176129875,
            "length_improvement": 25.607664961442016,
            "objective_score": -872.6822522916078
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.4305222988128662,
            "num_nodes_avg": 918.4,
            "path_length_avg": 115.15545256179408,
            "success_improvement": 0.0,
            "time_improvement": -1400.506805182891,
            "length_improvement": 29.287615045883282,
            "objective_score": -414.2945185456906
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines strengths of both given bidirectional RRT* variants by integrating adaptive informed sampling with an ellipse-based heuristic, dynamically shrinking neighbor radius for rewiring, balanced tree growth, incremental attempts to connect opposing trees, and periodic pruning of non-promising and dead nodes. After identifying a path, a robust shortcut smoothing is applied to enhance smoothness and path optimality. The approach balances exploration and exploitation, improves efficiency, robustness, and path quality in 2D and 3D cluttered environments.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal, sampling adaptively within ellipsoids informed by best path cost to focus search. It always expands the smaller tree, steering to sampled points within bounds and collision-free constraints. Rewiring occurs locally within a dynamically updated radius adjusting with iterations and node count. After each extension, incremental connections to the opposite tree are attempted to quickly find feasible paths. Non-promising and dead-end nodes are periodically pruned to maintain efficiency. The found path is shortcut-smoothed with collision checking, producing shorter, smoother trajectories.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = 5.0\n        self.max_radius = 30.0\n        self.prune_interval = 200\n        self.prune_threshold = 300\n        self.smoothing_iters = 50\n        self.collision_resolution = 1.0\n        self.connect_steps_factor = 5  # max incremental connect steps multiplier\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                    # Tuple[int, ...]: (W,H) or (W,H,D)\n        start = map.start                    # Tuple[float, ...]\n        goal = map.goal                      # Tuple[float, ...]\n        obstacles = map.obstacles            # List of obstacle tuples\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        root_start = Node(start, cost=0.0)\n        root_goal = Node(goal, cost=0.0)\n        nodes.extend([root_start, root_goal])\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = math.dist(start, goal)\n        best_path = []\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp to bounds strictly\n            new_p = tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n            return new_p\n\n        def radius_by_iteration_and_nodes(iteration, n_nodes):\n            n = max(n_nodes, 1)\n            r_iter = self.max_radius * (1 - (iteration / self.max_iter)**0.9)\n            r_log = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.min_radius, min(r_iter, r_log))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance_edge = dist(p1, p2)\n            steps = max(1, int(distance_edge / self.collision_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def informed_sample(c_best, c_min, start, goal):\n            # If no path or path close to min dist, sample uniformly\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Ellipsoidal sampling inside informed subset (L2 ball scaled with best cost)\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            I = np.eye(dim)\n            u_vec = direction - I[:, 0]\n            norm_u = np.linalg.norm(u_vec)\n            if norm_u > 1e-10:\n                u_vec /= norm_u\n                rot = I - 2 * np.outer(u_vec, u_vec)\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1**2 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r_other]*(dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # fallback uniform sampling\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius*radius\n            return [node for node in tree if sum((node.position[d]-point[d])**2 for d in range(dim)) <= r2]\n\n        def prune_dead_and_loose(nodes_list, tree_s, tree_g, c_best_current):\n            # Remove dead nodes (no children) and nodes not promising (based on heuristic and cost)\n            remove_cands = []\n            for node in nodes_list:\n                if node is root_start or node is root_goal:\n                    continue\n                # Dead node detection\n                if not node.children:\n                    remove_cands.append(node)\n                    continue\n                # Non-promising pruning (cost + heuristic)\n                h_cost = dist(node.position, goal)\n                if node.cost + h_cost >= c_best_current:\n                    remove_cands.append(node)\n\n            for node in remove_cands:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_s:\n                    try: tree_s.remove(node)\n                    except ValueError: pass\n                if node in tree_g:\n                    try: tree_g.remove(node)\n                    except ValueError: pass\n\n        def shortcut_path(path: list):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start, goal)\n\n            # Alternate tree expansion: always expand smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            nearest_a = nearest_node(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if (not in_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_a.position, new_pos):\n                continue\n\n            r = radius_by_iteration_and_nodes(itr, len(nodes))\n            neighbors = near_nodes(tree_a, new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in neighbors:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improvements\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connection attempt from other tree (tree_b) to new_node\n            nearest_b = nearest_node(tree_b, new_node.position)\n            last_b = nearest_b\n            max_connect_steps = int(dist(last_b.position, new_node.position) / self.step_size) * self.connect_steps_factor + 1\n            connected = False\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if (not in_bounds(next_pos_b)) or is_in_obstacle(next_pos_b) or is_edge_in_obstacle(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                # Rewire neighbors in tree_b around new_node_b\n                neighbors_b = near_nodes(tree_b, next_pos_b, r)\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is last_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and not is_edge_in_obstacle(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                # Check if connection close enough to new_node\n                if dist(new_node_b.position, new_node.position) <= self.step_size and not is_edge_in_obstacle(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Extract paths from start and goal trees accordingly\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning for efficiency and robustness\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_dead_and_loose(nodes, tree_start, tree_goal, c_best)\n\n        if success_state and extracted_path:\n            # One last smoothing pass in case of leftover improvements\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -1.19616,
    "time_improvement": -10.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009530758857727051,
            "num_nodes_avg": 64.9,
            "path_length_avg": 155.86985190731778,
            "success_improvement": 0.0,
            "time_improvement": 5.531529743167997,
            "length_improvement": 22.097746159305405,
            "objective_score": 6.079008154811481
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02357330322265625,
            "num_nodes_avg": 217.3,
            "path_length_avg": 242.70226598899868,
            "success_improvement": 0.0,
            "time_improvement": -64.80169346034288,
            "length_improvement": 19.463177161759553,
            "objective_score": -15.547872605750952
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.020624661445617677,
            "num_nodes_avg": 169.4,
            "path_length_avg": 125.21244109141927,
            "success_improvement": 0.0,
            "time_improvement": 28.11651117937945,
            "length_improvement": 23.112018245511393,
            "objective_score": 13.057357002916113
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This improved planner integrates bidirectional RRT* search with informed ellipsoidal sampling, adaptive neighbor radius, KD-tree accelerated nearest and radius queries, collision caching, incremental rewiring, and adaptive pruning. Additionally, it applies post-processing shortcut smoothing to refine the found path, aiming to enhance planning efficiency, path quality, success rate, and robustness in 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees from start and goal, alternating expansions using ellipsoid-biased sampling focused on promising regions. KD-trees enable efficient neighbor search and rewiring within a dynamic radius that shrinks over iterations. Collision checks leverage caching for efficiency. The planner prunes non-promising nodes periodically to reduce search space complexity and smooths the resulting path via shortcutting before returning it.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-12:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(0.0, r1**2 - (c_min / 2.0) ** 2)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    u_ball = x / norm_x * np.random.uniform(0, 1) ** (1/dim)\n                    p = rot @ (u_ball * radii) + center\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            # fallback uniform\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_position)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_position, cost=0.0)\n        root_goal = Node(goal_position, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_position, goal_position)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_position, goal_position)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 4.66147,
    "time_improvement": -29.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012890052795410157,
            "num_nodes_avg": 80.4,
            "path_length_avg": 161.6637851572127,
            "success_improvement": 0.0,
            "time_improvement": -27.765646711850962,
            "length_improvement": 19.201994009378822,
            "objective_score": -4.489295211679524
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.027151322364807128,
            "num_nodes_avg": 216.3,
            "path_length_avg": 240.3728949365362,
            "success_improvement": 0.0,
            "time_improvement": -89.8157361802135,
            "length_improvement": 20.2361412830966,
            "objective_score": -22.89749259744473
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.019553017616271973,
            "num_nodes_avg": 150.5,
            "path_length_avg": 131.52691055731262,
            "success_improvement": 0.0,
            "time_improvement": 31.851529930090965,
            "length_improvement": 19.23455360341238,
            "objective_score": 13.402369699709766
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This enhanced bidirectional RRT* planner integrates adaptive sampling biased toward start, goal, and dynamic midpoints with gradually decaying exploration bias to improve search efficiency and path quality. It uses a dynamically adjusted rewiring radius based on iteration and tree size, fast spatial hashing for neighbor queries, balanced tree growth, pruning of dead ends, and early collision rejection. After connecting the two trees, advanced shortcutting and smoothing heuristics refine the path to achieve smoothness and near-optimality, guaranteeing robustness, reduced planning time, and higher success rates in bounded 2D/3D obstacle environments.",
    "planning_mechanism": "The planner grows two RRT* trees from start and goal simultaneously with adaptive bias sampling transitioning from goal/start focus to midpoint exploration. Nodes are extended respecting step size and validated by quick collision and boundary checks. Spatial hashing accelerates neighborhood queries for efficient rewiring. Dead-end pruning maintains manageable tree size. Tree connection triggers iterative shortcutting and smoothing to optimize path length and smoothness. The method balances exploration and exploitation dynamically for efficient, reliable, and high-quality path planning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position       # Tuple[float, ...] (2D or 3D)\n        self.parent = parent           # Node or None\n        self.cost = cost               # Total path cost from root\n        self.children = []\n        self.valid = True              # Validity flag (for collisions etc.)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0,\n                 goal_sample_rate=0.15, radius_constant=30.0,\n                 radius_min=3.0, prune_interval=200,\n                 prune_threshold=100, smoothing_iterations=40,\n                 search_resolution=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.search_resolution = search_resolution\n\n    def plan(self, map):\n        import math\n        import random\n        from collections import defaultdict\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_within_bounds(pos):\n            return all(0 <= pos[i] <= bounds[i] for i in range(dim))\n\n        def is_free_node(pos):\n            if not is_within_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def is_free_edge(p1, p2):\n            if not is_within_bounds(p1) or not is_within_bounds(p2):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.search_resolution):\n                return False\n            return True\n\n        class SpatialHash:\n            def __init__(self, cell_size):\n                self.cell_size = cell_size\n                self.hash_table = defaultdict(list)\n\n            def _hash(self, pos):\n                return tuple(int(pos[i] // self.cell_size) for i in range(len(pos)))\n\n            def insert(self, node):\n                key = self._hash(node.position)\n                self.hash_table[key].append(node)\n\n            def remove(self, node):\n                key = self._hash(node.position)\n                if node in self.hash_table.get(key, []):\n                    self.hash_table[key].remove(node)\n                    if not self.hash_table[key]:\n                        del self.hash_table[key]\n\n            def near(self, pos, radius):\n                radius_cells = int(math.ceil(radius / self.cell_size))\n                base_key = self._hash(pos)\n                keys_to_check = []\n                if dim == 2:\n                    for dx in range(-radius_cells, radius_cells + 1):\n                        for dy in range(-radius_cells, radius_cells + 1):\n                            keys_to_check.append((base_key[0] + dx, base_key[1] + dy))\n                else:\n                    for dx in range(-radius_cells, radius_cells + 1):\n                        for dy in range(-radius_cells, radius_cells + 1):\n                            for dz in range(-radius_cells, radius_cells + 1):\n                                keys_to_check.append((base_key[0] + dx, base_key[1] + dy, base_key[2] + dz))\n                result = []\n                for key in keys_to_check:\n                    for node in self.hash_table.get(key, []):\n                        if dist(node.position, pos) <= radius:\n                            result.append(node)\n                return result\n\n        def radius_by_nodes_and_iter(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt(math.log(n_nodes) / n_nodes)\n            decay = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay)\n\n        def adaptive_sample(itr):\n            r = random.random()\n            bias_decay = 1 - itr / self.max_iter\n            # Bias toward goal/start or midpoint shifting over iterations for exploration refinement\n            if r < self.goal_sample_rate:\n                sr = random.random()\n                if sr < 0.6 and is_free_node(goal_position):\n                    return goal_position\n                elif sr < 0.85 and is_free_node(start_position):\n                    return start_position\n                if len(tree_start) > 15 and len(tree_goal) > 15:\n                    mid_s = random.choice(tree_start).position\n                    mid_g = random.choice(tree_goal).position\n                    midpoint = tuple((mid_s[i] + mid_g[i]) / 2 for i in range(dim))\n                    spread = self.step_size * 5 * bias_decay\n                    for _ in range(7):\n                        candidate = tuple(\n                            max(0, min(bounds[d], midpoint[d] + random.uniform(-spread, spread)))\n                            for d in range(dim)\n                        )\n                        if is_free_node(candidate):\n                            return candidate\n            # Uniform sampling with rejection\n            for _ in range(75):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n            return start_position\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        cell_size = self.step_size * 1.5\n        hash_start = SpatialHash(cell_size)\n        hash_goal = SpatialHash(cell_size)\n        hash_start.insert(start_root)\n        hash_goal.insert(goal_root)\n\n        def try_extend(tree, tree_hash, target, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, target)\n            new_pos = steer(nearest_node.position, target)\n            if not is_free_node(new_pos):\n                return None\n            if not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes_and_iter(len(tree), itr)\n            near_nodes = tree_hash.near(new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near_nodes:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost and is_free_edge(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            tree_hash.insert(new_node)\n\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect_and_rewire(tree, tree_hash, target_node, itr):\n            if not tree:\n                return None\n            last_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos):\n                    return None\n                if not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes_and_iter(len(tree), itr)\n                near_nodes_ = tree_hash.near(new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n\n                for node in near_nodes_:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-10 < min_cost and is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                tree_hash.insert(new_node)\n\n                for neighbor in near_nodes_:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-10 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        tree_hash.insert(final_node)\n                        return final_node\n                    return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        hash_start.remove(node)\n                        hash_goal.remove(node)\n                        removed.append(node)\n                    except Exception:\n                        pass\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if is_free_edge(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            sample = adaptive_sample(itr)\n\n            # Balanced growth: extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n                hash_start, hash_goal = hash_goal, hash_start\n\n            new_node_start = try_extend(tree_start, hash_start, sample, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, hash_goal, new_node_start, itr)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]  # concatenate without duplicate node\n\n                shortcuted_path = shortcut_path(raw_path)\n                smoothed_path = smooth_path(shortcuted_path)\n\n                candidates = [raw_path, shortcuted_path, smoothed_path]\n                extracted_path = min(candidates, key=path_length)\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 2.34021,
    "time_improvement": -23.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.013739061355590821,
            "num_nodes_avg": 78.4,
            "path_length_avg": 159.68692206302808,
            "success_improvement": 0.0,
            "time_improvement": -36.18098289992344,
            "length_improvement": 20.190011183238987,
            "objective_score": -6.816292633329234
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.022696256637573242,
            "num_nodes_avg": 178.9,
            "path_length_avg": 238.68157118477416,
            "success_improvement": 0.0,
            "time_improvement": -58.67023360085339,
            "length_improvement": 20.79737972396036,
            "objective_score": -13.441594135463946
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.020851445198059083,
            "num_nodes_avg": 128.4,
            "path_length_avg": 121.81686837022878,
            "success_improvement": 0.0,
            "time_improvement": 27.32609784938106,
            "length_improvement": 25.19710444906457,
            "objective_score": 13.237250244627232
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a bidirectional informed RRT* algorithm simplified for generalization, combining efficient ellipse sampling, adaptive neighborhood radius, lazy collision checking, incremental rewiring, and periodic pruning. It balances exploration and exploitation to rapidly find high-quality, smooth, and feasible paths in 2D or 3D spaces.",
    "planning_mechanism": "The planner alternates expanding two trees from start and goal within an informed ellipsoidal sampling region that shrinks based on the current best path cost. New nodes are connected via collision-checked edges, and local rewiring optimizes the tree connectivity. Periodic pruning removes unpromising nodes to focus the search, while shortcut smoothing refines the best found path before returning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]: 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision/pruning status\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except Exception:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def is_leaf(self):\n        return len(self.children) == 0\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_radius: float = 5.0, max_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_trials: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp to bounds\n            new_p = tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n            return new_p\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        # KDTree substitute: brute force for simplicity and generality\n        def nearest_node(tree, point):\n            best = None\n            bd = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < bd:\n                    bd = d\n                    best = node\n            return best\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d]-pos[d])**2 for d in range(dim)) <= r2]\n\n        def ellipse_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback uniform sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)  # Householder reflection\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2_val = math.sqrt(max(r1*r1 - (c_min/2)*(c_min/2), 0))\n            radii = np.array([r1] + [r2_val]*(dim-1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-10:\n                    x = x / norm_x\n                    x = x * np.power(np.random.uniform(0,1), 1/dim)  # Uniform in unit ball\n                    p = rot @ (x * radii) + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n            # fallback uniform\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth_path = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth_path) < 3:\n                    break\n                i = random.randint(0, len(smooth_path) - 3)\n                j = random.randint(i + 2, len(smooth_path) -1)\n                p1, p2 = smooth_path[i], smooth_path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    smooth_path = smooth_path[:i+1] + smooth_path[j:]\n            return smooth_path\n\n        def prune_nodes(best_cost):\n            to_remove = []\n            h = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + h(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except Exception:\n                        pass\n                try:\n                    nodes.remove(node)\n                except Exception:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n            return len(to_remove)\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = ellipse_sample(c_best, c_min, start_pos, goal_pos)\n            # Alternate tree growth for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            nearest_a = nearest_node(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not in_bounds(new_pos) or is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes_a = near_nodes(tree_a, new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near_nodes_a:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Connect other tree toward new node\n            nearest_b = nearest_node(tree_b, new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not in_bounds(next_pos_b) or is_in_obstacle(next_pos_b):\n                    break\n                if is_edge_in_obstacle(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_nodes_b = near_nodes(tree_b, next_pos_b, r)\n                for neighbor_b in near_nodes_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if new_cost_b + 1e-12 < neighbor_b.cost and not is_edge_in_obstacle(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and not is_edge_in_obstacle(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -5.68873,
    "time_improvement": 4.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009312152862548828,
            "num_nodes_avg": 77.3,
            "path_length_avg": 161.23883571484998,
            "success_improvement": 0.0,
            "time_improvement": 7.698342927903654,
            "length_improvement": 19.414379656271496,
            "objective_score": 6.192378809625396
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02024998664855957,
            "num_nodes_avg": 227.4,
            "path_length_avg": 236.57062578872734,
            "success_improvement": 0.0,
            "time_improvement": -41.56828428798828,
            "length_improvement": 21.497862822829855,
            "objective_score": -8.170912721830511
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.015281963348388671,
            "num_nodes_avg": 149.1,
            "path_length_avg": 121.9467869215883,
            "success_improvement": 0.0,
            "time_improvement": 46.73750915099538,
            "length_improvement": 25.117326632104614,
            "objective_score": 19.044718071719537
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This improved planner is a bidirectional RRT* variant with enhanced heuristics focused on reducing path length and planning time. It uses dynamic neighborhood radius based on node count for efficient rewiring, adaptive sampling biased towards start and goal to speed convergence, balanced tree expansion favoring the smaller tree, and incremental rewiring in both trees. Additionally, it integrates direct connection attempts between trees as early as possible for fast success detection, and applies a robust shortcut path smoothing at the end to improve path quality and smoothness, resulting in high success rates and shorter paths in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees from start and goal alternately but always extends the smaller tree first to maintain balanced exploration. It samples points adaptively biased towards the goal and start positions. Upon extending a tree toward a sampled point, it rewires neighbors within a dynamic radius to reduce local costs. Then, it attempts to connect and rewire the opposite tree toward the newly added node with collision checks for nodes and connecting edges to ensure safety. Upon successfully connecting both trees, it reconstructs and shortcut-smooths the path for improved quality and returns the final result.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For potential future collision invalidation\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 radius_constant: float=30.0, radius_min: float=5.0,\n                 smoothing_iterations: int = 120,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def distance(a, b):\n            # Euclidean distance\n            return math.dist(a, b)\n\n        def sample_free():\n            # Adaptive sampling biased towards goal and start for better convergence\n            r = random.random()\n            if r < self.goal_sample_rate:\n                # Further 80% goal bias, 20% start bias within goal_sample_rate usage\n                if random.random() < 0.8 and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    return goal_position\n                elif not self._is_in_obstacle(start_position, obstacles, is_3d):\n                    return start_position\n            # Uniform random sampling in free space\n            for _ in range(50):  # max tries for free sample\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback rare case, just return random point\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist_between = distance(from_pos, to_pos)\n            if dist_between <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / dist_between\n                new_pos = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n            # Clamp to bounds strictly\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_constant\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes) / n_nodes)))\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if sum((node.position[d] - pos[d])**2 for d in range(dim)) <= radius_sq]\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n        def try_extend(tree, target_point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                if can_connect(node.position, new_pos):\n                    tentative_cost = node.cost + distance(node.position, new_pos)\n                    if tentative_cost + 1e-10 < min_cost:\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.children.append(new_node)\n            new_node.parent = best_parent\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, target_node.position)\n            current_node = nearest_node\n\n            while True:\n                new_pos = steer(current_node.position, target_node.position)\n                if not can_add_node(new_pos) or not can_connect(current_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current_node.cost + distance(current_node.position, new_pos)\n                best_parent = current_node\n                for node in neighbors:\n                    if can_connect(node.position, new_pos):\n                        tentative_cost = node.cost + distance(node.position, new_pos)\n                        if tentative_cost + 1e-10 < min_cost:\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                best_parent.children.append(new_node)\n                new_node.parent = best_parent\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewire(tree, new_node, neighbors)\n\n                if distance(new_pos, target_node.position) <= self.step_size:\n                    if can_connect(new_pos, target_node.position):\n                        final_node = Node(target_node.position, cost=new_node.cost + distance(new_pos, target_node.position))\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                current_node = new_node\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Initialize trees\n        tree_start = []\n        tree_goal = []\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start.append(start_root)\n        tree_goal.append(goal_root)\n        nodes.extend([start_root, goal_root])\n\n        for iteration in range(self.max_iter):\n            sample_point = sample_free()\n\n            # Always extend smaller tree to balance growth and improve efficiency\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                # Successful connection: reconstruct and smooth path\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                combined_path = path_start + path_goal[::-1][1:]\n                extracted_path = shortcut_smoothing(combined_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 286.90425,
    "time_improvement": -971.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.08638050556182861,
            "num_nodes_avg": 88.7,
            "path_length_avg": 156.4683068758133,
            "success_improvement": 0.0,
            "time_improvement": -756.1998411933188,
            "length_improvement": 21.798644118099354,
            "objective_score": -222.50022353437578
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.21071832180023192,
            "num_nodes_avg": 268.6,
            "path_length_avg": 234.1672787612208,
            "success_improvement": 0.0,
            "time_improvement": -1373.1383187072363,
            "length_improvement": 22.295374675405135,
            "objective_score": -407.4824206770898
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.253314733505249,
            "num_nodes_avg": 239.0,
            "path_length_avg": 129.1847570186566,
            "success_improvement": 0.0,
            "time_improvement": -782.8822166141358,
            "length_improvement": 20.672776969850172,
            "objective_score": -230.7301095902707
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved planner utilizes an optimized bidirectional RRT* framework with adaptive sampling heuristics biased between start, goal, and intermediate promising areas. It employs a dynamically decaying rewiring radius and balanced tree growth by always extending the smaller tree first. Spatial hashing accelerates neighbor searches, and edge collision checking uses adaptive resolution for efficiency. The planner prunes dead-end nodes regularly to reduce search space overhead. After a successful connection, advanced shortcutting and iterative smoothing produce high-quality paths, minimizing planning time while maximizing success rate and path smoothness in both 2D and 3D bounded environments.",
    "planning_mechanism": "The planner grows two trees from start and goal with balanced expansions, sampling adaptively towards goal, start, and midpoint areas. Each extension rewires nearby nodes within a dynamically shrinking radius to improve path cost. Dead-end nodes are periodically pruned to optimize graph size. After connecting both trees, the path undergoes shortcutting and smoothing to ensure collision-free, optimal navigation paths with reduced length and complexity.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For potential future use (collision, pruning)\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0,\n                 radius_min: float=3.0, prune_interval: int=200, prune_threshold: int=50,\n                 smoothing_iterations: int=30, search_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.search_resolution = search_resolution\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        import random\n        import math\n        from collections import defaultdict\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            # Approximate nearest by hashing acceleration will be used for near()\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        class SpatialHash:\n            def __init__(self, cell_size):\n                self.cell_size = cell_size\n                self.hash_table = defaultdict(list)\n\n            def _hash(self, pos):\n                return tuple(int(pos[i] // self.cell_size) for i in range(dim))\n\n            def insert(self, node):\n                key = self._hash(node.position)\n                self.hash_table[key].append(node)\n\n            def remove(self, node):\n                key = self._hash(node.position)\n                if node in self.hash_table.get(key, []):\n                    self.hash_table[key].remove(node)\n                    if not self.hash_table[key]:\n                        del self.hash_table[key]\n\n            def near(self, position, radius):\n                radius_cells = int(math.ceil(radius / self.cell_size))\n                base_key = self._hash(position)\n                keys_to_check = []\n                for dx in range(-radius_cells, radius_cells + 1):\n                    for dy in range(-radius_cells, radius_cells + 1):\n                        if dim == 2:\n                            keys_to_check.append((base_key[0] + dx, base_key[1] + dy))\n                        else:\n                            for dz in range(-radius_cells, radius_cells + 1):\n                                keys_to_check.append((base_key[0] + dx, base_key[1] + dy, base_key[2] + dz))\n                result = []\n                for k in keys_to_check:\n                    if k in self.hash_table:\n                        for node in self.hash_table[k]:\n                            if dist(position, node.position) <= radius:\n                                result.append(node)\n                return result\n\n        cell_size = max(self.step_size * 1.5, 1.0)\n        hash_start = SpatialHash(cell_size)\n        hash_goal = SpatialHash(cell_size)\n        hash_start.insert(start_root)\n        hash_goal.insert(goal_root)\n\n        def radius_by_nodes_and_iter(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt(math.log(n_nodes) / n_nodes)\n            decay_factor = math.exp(-6 * itr / self.max_iter)\n            radius = max(self.radius_min, base * decay_factor)\n            return radius\n\n        def _is_free_node(pos):\n            if not self._within_bounds(pos, bounds):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def _is_free_edge(p1, p2):\n            if not self._within_bounds(p1, bounds) or not self._within_bounds(p2, bounds):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.search_resolution)\n\n        def adaptive_sample(itr):\n            r = random.random()\n            bias_decay = 1 - itr / self.max_iter\n            # Bias sampling to goal, start, or midpoint region adaptively\n            if r < self.goal_sample_rate:\n                s_r = random.random()\n                if s_r < 0.6 and _is_free_node(goal_position):\n                    return goal_position\n                elif s_r < 0.85 and _is_free_node(start_position):\n                    return start_position\n                elif len(tree_start) > 15 and len(tree_goal) > 15:\n                    mid_s = random.choice(tree_start).position\n                    mid_g = random.choice(tree_goal).position\n                    mid = tuple((mid_s[i] + mid_g[i]) * 0.5 for i in range(dim))\n                    spread = self.step_size * 5 * bias_decay\n                    for _ in range(8):\n                        candidate = tuple(\n                            min(max(0, mid[d] + random.uniform(-spread, spread)), bounds[d]) for d in range(dim)\n                        )\n                        if _is_free_node(candidate):\n                            return candidate\n            for _ in range(75):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if _is_free_node(sample):\n                    return sample\n            return start_position  # safe fallback\n\n        def try_extend(tree, tree_hash, point, itr):\n            if not tree:\n                return None\n            n_node = nearest(tree, point)\n            new_pos = steer(n_node.position, point)\n            if not _is_free_node(new_pos) or not _is_free_edge(n_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes_and_iter(len(tree), itr)\n            near_nodes = tree_hash.near(new_pos, radius)\n\n            min_cost = n_node.cost + dist(n_node.position, new_pos)\n            best_parent = n_node\n\n            for node in near_nodes:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and _is_free_edge(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            tree_hash.insert(new_node)\n\n            # Mutual rewiring attempt to optimize paths\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-12 < neighbor.cost and _is_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except Exception:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect_and_rewire(tree, tree_hash, target_node, itr):\n            if not tree:\n                return None\n            last_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not _is_free_node(new_pos) or not _is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes_and_iter(len(tree), itr)\n                near_nodes = tree_hash.near(new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n\n                for node in near_nodes:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-12 < min_cost and _is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                tree_hash.insert(new_node)\n\n                for neighbor in near_nodes:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-12 < neighbor.cost and _is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except Exception:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if _is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        tree_hash.insert(final_node)\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            # Collect dead-end nodes with no children except start/goal roots\n            dead_ends = [node for node in nodes if node is not start_root and node is not goal_root and not node.children]\n            for node in dead_ends:\n                try:\n                    if node.parent and node in node.parent.children:\n                        node.parent.children.remove(node)\n                    nodes.remove(node)\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    hash_start.remove(node)\n                    hash_goal.remove(node)\n                    removed.append(node)\n                except Exception:\n                    pass\n            return removed\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if _is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def path_length(path):\n            return sum(dist(path[i], path[i + 1]) for i in range(len(path) - 1))\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            path = list(path)\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if _is_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Main planning loop\n        for itr in range(self.max_iter):\n            sample = adaptive_sample(itr)\n\n            # Always extend smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n                hash_start, hash_goal = hash_goal, hash_start\n\n            new_node_start = try_extend(tree_start, hash_start, sample, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, hash_goal, new_node_start, itr)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                shortcuted_path = shortcut_path(raw_path)\n                smoothed_path = smooth_path(shortcuted_path)\n\n                candidates = [raw_path, shortcuted_path, smoothed_path]\n                extracted_path = min(candidates, key=path_length)\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        for i, v in enumerate(pos):\n            if not (0 <= v <= bounds[i]):\n                return False\n        return True",
    "objective": 6.05909,
    "time_improvement": -34.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0153336763381958,
            "num_nodes_avg": 71.6,
            "path_length_avg": 160.52284872641798,
            "success_improvement": 0.0,
            "time_improvement": -51.986737751562075,
            "length_improvement": 19.772223071383166,
            "objective_score": -11.641576711191988
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.025638389587402343,
            "num_nodes_avg": 191.8,
            "path_length_avg": 242.93669356008786,
            "success_improvement": 0.0,
            "time_improvement": -79.23877624155145,
            "length_improvement": 19.38538616263446,
            "objective_score": -19.89455563993854
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.020666122436523438,
            "num_nodes_avg": 153.6,
            "path_length_avg": 122.40432813257601,
            "success_improvement": 0.0,
            "time_improvement": 27.972006471550692,
            "length_improvement": 24.83636876581188,
            "objective_score": 13.358875694627585
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved planner builds upon the bidirectional RRT* framework with enhanced adaptive sampling biasing and dynamic radius rewiring, integrating heuristic-driven node selection and incremental path shortcutting to minimize overall path length and increase planning efficiency. It balances tree growth through simultaneous expansions and rewiring in both trees, incorporates cost-aware rewiring with tighter collision checks, and applies local path smoothing post-connection to produce high-quality smooth paths with shorter lengths, reducing search time and improving success rate and robustness in 2D and 3D environments.",
    "planning_mechanism": "The planner alternately extends two trees grown from start and goal states, using an adaptive sampling strategy biased towards both ends and near promising nodes. It dynamically adjusts the rewiring radius shrinking with node density, and carefully rewires in local neighborhoods to optimize path costs. Upon successful connection of trees, it conducts incremental shortcutting on the extracted path to smooth and shorten it. Rigorous collision checks prevent invalid expansions, while balancing tree growth and biased sampling speeds convergence to an optimal feasible path efficiently.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1, radius_constant: float = 25.0, radius_min: float = 3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            # Adaptive sampling bias:\n            # 15% goal, 15% start, 20% near best path nodes, 50% uniform free samples\n            r = random.random()\n            # Precompute nodes sorted by heuristic to goal - helps to bias near promising nodes\n            if len(nodes) > 10 and r < 0.35:\n                # bias near nodes with low heuristic cost to goal (cost + distance to goal)\n                def heuristic(n):\n                    return n.cost + math.dist(n.position, goal_position)\n                candidates = sorted(nodes, key=heuristic)\n                for attempt in range(10):\n                    base_node = random.choice(candidates[:min(10, len(candidates))])\n                    # sample near base_node within step_size radius\n                    offset = tuple(random.uniform(-self.step_size, self.step_size) for _ in range(dim))\n                    sample = tuple(max(0.0, min(bounds[d], base_node.position[d] + offset[d])) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            if r < 0.15:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    return goal_position\n            if r < 0.3:\n                if not self._is_in_obstacle(start_position, obstacles, is_3d):\n                    return start_position\n            # Uniform sample\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            # Use squared distance for speed\n            def sqdist(p1, p2):\n                return sum((p1[d] - p2[d]) ** 2 for d in range(dim))\n            return min(tree, key=lambda n: sqdist(n.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - pos[d]) ** 2 for d in range(dim)) <= r2]\n\n        def radius_by_nodes(n_nodes):\n            # Dynamic radius shrinking with node count, minimum radius enforced\n            if n_nodes <= 1:\n                return self.radius_constant\n            return max(self.radius_min, self.radius_constant * (math.log(n_nodes) / n_nodes) ** 0.5)\n\n        def can_connect(pos_from, pos_to):\n            if self._is_in_obstacle(pos_to, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(pos_from, pos_to, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve local connectivity and path cost\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, target_node.position)\n            last_node = nearest_node\n            max_iterations = 50  # prevent infinite loop\n\n            for _ in range(max_iterations):\n                new_pos = steer(last_node.position, target_node.position)\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + distance(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + distance(node.position, new_pos)\n                    if tentative_cost + 1e-12 < min_cost:\n                        if can_connect(node.position, new_pos):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors around new_node\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-12 < neighbor.cost:\n                        if can_connect(new_node.position, neighbor.position):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                if distance(new_pos, target_node.position) <= self.step_size:\n                    if can_connect(new_pos, target_node.position):\n                        final_node = Node(target_node.position,\n                                         cost=new_node.cost + distance(new_pos, target_node.position))\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n            return None\n\n        def shortcut_path(path):\n            # Incremental shortcutting to smooth and shorten path\n            if len(path) < 3:\n                return path\n            optimized = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                optimized.append(path[j])\n                i = j\n            return optimized\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Balance trees: extend smaller first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                # Found connection - reconstruct path\n                success_state = True\n\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                combined_path = path_from_start + path_from_goal[::-1][1:]\n                # Apply shortcutting to improve smoothness and reduce length\n                extracted_path = shortcut_path(combined_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 170.14878,
    "time_improvement": -575.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.03833372592926025,
            "num_nodes_avg": 133.0,
            "path_length_avg": 167.79792540803354,
            "success_improvement": -9.999999999999998,
            "time_improvement": -279.9622361493161,
            "length_improvement": 16.136209670287954,
            "objective_score": -85.76142891073724
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.17756438255310059,
            "num_nodes_avg": 469.2,
            "path_length_avg": 234.46678483290526,
            "success_improvement": 0.0,
            "time_improvement": -1141.3581018576392,
            "length_improvement": 22.19598842807887,
            "objective_score": -337.968232871676
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.11581101417541503,
            "num_nodes_avg": 341.4,
            "path_length_avg": 127.2289080337544,
            "success_improvement": 0.0,
            "time_improvement": -303.6381283025641,
            "length_improvement": 21.87378606890528,
            "objective_score": -86.71668127698817
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm combines the strengths of informed sampling, lazy collision checking, and bidirectional tree growth with an adaptive dynamic neighbor radius. It integrates a fast approximate nearest neighbor KD-tree for efficient rewiring, incremental path cost updates, and a heuristic-guided pruning mechanism to discard suboptimal branches early. After a valid connection between start and goal trees is found, an aggressive segment-wise path smoothing with collision-aware shortcuts is applied to optimize path length and smoothness while ensuring robustness in both 2D and 3D environments. The algorithm prioritizes balancing exploration and exploitation, achieving high success rates, reduced search times, and high-quality paths.",
    "planning_mechanism": "The planner grows two trees from start and goal positions alternately using informed ellipsoidal sampling constrained by the current best path cost. It employs lazy collision checking: nodes are added optimistically, and edges are checked on-demand, reducing unnecessary collision tests. KD-tree structures speed up nearest neighbor and radius queries. An adaptive neighbor radius shrinks as the graph grows and iterations increase, improving local rewiring quality. The trees connect by steering toward nodes in the opposite tree, and on successful connection, a collision-free path is extracted. A post-processing step aggressively shortcuts path segments by attempting direct connections between non-consecutive nodes, enhancing smoothness and reducing path length while ensuring no collisions occur.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost from root\n        self.children = []\n        self.valid = True               # For potential future flags\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.1,\n                 smoothing_iterations: int=150,\n                 prune_interval: int=250,\n                 prune_factor: float=0.95):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n        self.smoothing_iterations = smoothing_iterations\n        self.prune_interval = prune_interval\n        self.prune_factor = prune_factor\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clip to bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def heuristic(p):\n            # Euclidean heuristic from position p to goal\n            return dist(p, goal_pos)\n\n        def informed_sample(c_best, c_min, start, goal):\n            # Ellipsoidal informed sampling centered at midpoint with axes scaled by current best path\n            if c_best == float('inf') or random.random() < self.goal_sample_rate:\n                for _ in range(10):\n                    rand_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(rand_pt, obstacles, is_3d):\n                        return rand_pt\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])  # Unit direction vector along line start-goal\n\n            # Calculate rotation matrix using Householder transformation\n            id_mat = np.eye(dim)\n            e1 = np.zeros(dim)\n            e1[0] = 1.0\n            v = a1 - e1\n            s = np.linalg.norm(v)\n            if s > 1e-10:\n                u = v / s\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1**2 - (c_min / 2.0)**2, 0))\n            radii = np.array([r1] + [r_other]*(dim-1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1,1,dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    x_ellipse = x_ball * radii\n                    sample = rot @ x_ellipse + np.array(center)\n                    sample_t = tuple(float(v) for v in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n            # Fallback uniform sampling\n            for _ in range(10):\n                rand_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(rand_pt, obstacles, is_3d):\n                    return rand_pt\n            # Final fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        class KDTree:\n            # Simple KDTree wrapper for neighbor queries using exact linear scan to avoid dependency\n            def __init__(self, data_nodes):\n                self.dim = dim\n                self.points = [node.position for node in data_nodes]\n                self.nodes = data_nodes\n\n            def nearest(self, point):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, point)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, point, radius):\n                r2 = radius * radius\n                result = []\n                for p, n in zip(self.points, self.nodes):\n                    diff_sqd = 0.0\n                    for d_ in range(self.dim):\n                        diff = p[d_] - point[d_]\n                        diff_sqd += diff * diff\n                        if diff_sqd > r2:\n                            break\n                    if diff_sqd <= r2:\n                        result.append(n)\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(p):\n            if not in_bounds(p):\n                return False\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return False\n            return True\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes,1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 1.1)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius)*math.sqrt(math.log(c+1)/c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2,len(path)-1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1,p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_nodes(best_cost):\n            # Prune nodes whose cost + heuristic >= best_cost * prune_factor\n            to_remove = []\n            h = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + h(node.position) >= best_cost * self.prune_factor:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try: node.parent.children.remove(node)\n                    except ValueError: pass\n                try:\n                    nodes.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n\n        # Initialize trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth direction\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree(tree_a)\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for near_node in near_nodes:\n                cost_cand = near_node.cost + dist(near_node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(near_node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors around new_node\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-12 < near_node.cost and can_connect(new_node.position, near_node.position):\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                    except ValueError:\n                        pass\n                    near_node.update_parent(new_node, new_cost)\n                    edges.append((new_node, near_node))\n\n            # Connect tree_b toward new_node\n            kdtree_b = KDTree(tree_b)\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_b.position, new_node.position)//self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = merged_path\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                # Aggressive path smoothing before return\n                extracted_path = shortcut_path(best_path)\n                break\n\n            # Periodic pruning to improve efficiency\n            if iteration > 0 and iteration % self.prune_interval == 0 and c_best < float('inf'):\n                prune_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = shortcut_path(best_path) if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 0.08611,
    "time_improvement": -15.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009737563133239747,
            "num_nodes_avg": 65.6,
            "path_length_avg": 161.6019305614488,
            "success_improvement": 0.0,
            "time_improvement": 3.4816946941553364,
            "length_improvement": 19.232908341826366,
            "objective_score": 4.891090076611874
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.021660804748535156,
            "num_nodes_avg": 214.8,
            "path_length_avg": 233.90771499280368,
            "success_improvement": 0.0,
            "time_improvement": -51.43135735180139,
            "length_improvement": 22.38150671519905,
            "objective_score": -10.953105862500607
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.027735424041748048,
            "num_nodes_avg": 187.0,
            "path_length_avg": 123.73608896707222,
            "success_improvement": 0.0,
            "time_improvement": 3.3332474670127934,
            "length_improvement": 24.018587386808765,
            "objective_score": 5.8036917174655915
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines bidirectional RRT* with informed ellipsoidal sampling, an adaptive neighbor radius based on iteration and node count, KD-tree accelerated nearest neighbor and radius searches, collision caching for pruning redundant checks, incremental rewiring for path cost improvement, and periodic pruning of non-promising nodes. Additionally, it features an aggressive shortcut smoothing step applied to the best path found. The algorithm balances exploration and exploitation, ensuring fast convergence, improved path quality, robustness, and higher success rate in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal alternatively towards informed samples within an ellipsoidal domain shaped by the current best path cost. KD-trees speed up nearest neighbor and radius queries for efficient rewiring. Collision checks are cached to minimize redundant computations. After each successful connection, the best path is shortcut-smoothed aggressively. Periodic pruning removes nodes unlikely to yield better solutions, reducing search complexity and improving planner responsiveness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=150,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle tuples\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                # Uniform sampling with rejection inside obstacles\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) * (c_min / 2), 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    # Uniform sampling inside unit ball\n                    radius_factor = np.random.uniform(0,1) ** (1/dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Balance tree extension: smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new node\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connect opposite tree towards new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -6.37314,
    "time_improvement": 7.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009961986541748047,
            "num_nodes_avg": 73.0,
            "path_length_avg": 164.05118532208425,
            "success_improvement": 0.0,
            "time_improvement": 1.2572195596895708,
            "length_improvement": 18.00879435346506,
            "objective_score": 3.9789247385998836
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02033553123474121,
            "num_nodes_avg": 203.2,
            "path_length_avg": 232.0172630653562,
            "success_improvement": 0.0,
            "time_improvement": -42.16632914135226,
            "length_improvement": 23.008822621561247,
            "objective_score": -8.048134218093427
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.010979962348937989,
            "num_nodes_avg": 114.1,
            "path_length_avg": 124.8312232300356,
            "success_improvement": 0.0,
            "time_improvement": 61.73134755002613,
            "length_improvement": 23.346108977351303,
            "objective_score": 23.1886260604781
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner integrates bidirectional RRT* search with adaptive informed ellipsoidal sampling, KD-tree accelerated neighbor searches, collision caching, incremental rewiring, balanced tree expansion, and periodic pruning. It emphasizes efficiency and robustness by dynamically adjusting neighbor radius, aggressively pruning non-promising nodes, and caching collision results. The planner applies repeated shortcut smoothing on discovered paths to improve smoothness and path length, aiming for faster convergence and higher path quality in both 2D and 3D cluttered spaces.",
    "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling adaptively within an ellipsoidal informed subset shaped by the current best path cost to bias sampling towards promising regions. Nearest neighbors and near nodes are found efficiently via a KD-tree structure. Nodes are added only after thorough collision checking for positions and edges, and rewiring in local neighborhoods improves path optimality incrementally. When trees are close enough, incremental connections are attempted along edges with collision checks and rewiring for smooth connectivity. Periodic pruning removes dead-end and non-promising nodes to boost efficiency. Final found paths undergo iterative shortcut smoothing to enhance trajectory smoothness and reduce length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio*(to_pos[d]-from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1**2 - (c_min / 2)**2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    sample = rot @ (x * radii) + center\n                    sample_t = tuple(float(coord) for coord in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            reverse_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            elif reverse_key in edge_collision_cache:\n                return not edge_collision_cache[reverse_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        # KD-tree substitute for nearest and radius searches, brute-force for clarity & correctness\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius*radius\n                res = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        diff = p[d_] - pt[d_]\n                        sqd += diff*diff\n                        if sqd > r2:\n                            break\n                    else:\n                        res.append(n)\n                return res\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_nonpromising_nodes(nodes_list, tree_s, tree_g, best_cost):\n            # Remove dead-end (no children) and nodes with cost+heuristic >= best_cost\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                if not node.children:\n                    to_remove.append(node)\n                    continue\n                h_cost = dist(node.position, goal_pos)\n                if node.cost + h_cost >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_s:\n                    try:\n                        tree_s.remove(node)\n                    except ValueError:\n                        pass\n                if node in tree_g:\n                    try:\n                        tree_g.remove(node)\n                    except ValueError:\n                        pass\n            return len(to_remove)\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree expansion for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(itr, len(nodes))\n            near_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors in tree_a\n            for neighbor in near_a:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Incrementally connect tree_b to new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Extract and merge paths according to expansion order\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning for efficiency & robustness\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nonpromising_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        if success_state and extracted_path:\n            # Final smoothing\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -3.8343,
    "time_improvement": -1.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.011786651611328126,
            "num_nodes_avg": 69.6,
            "path_length_avg": 165.00672698196314,
            "success_improvement": 0.0,
            "time_improvement": -16.828781820416122,
            "length_improvement": 17.531223816043198,
            "objective_score": -1.5423897829161968
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02196238040924072,
            "num_nodes_avg": 211.6,
            "path_length_avg": 240.82774028752243,
            "success_improvement": 0.0,
            "time_improvement": -53.539682142827374,
            "length_improvement": 20.085208207536294,
            "objective_score": -12.044863001340953
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.009235286712646484,
            "num_nodes_avg": 107.8,
            "path_length_avg": 124.20167944050509,
            "success_improvement": 0.0,
            "time_improvement": 67.81209568388785,
            "length_improvement": 23.73268678847898,
            "objective_score": 25.09016606286215
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner implements an adaptive bidirectional RRT* algorithm with enhanced informed sampling, dynamic neighbor radius adjustment, and periodic path shortcut smoothing. It improves planning efficiency and path quality by balancing exploration and exploitation, pruning non-promising nodes, and intelligently rewiring the trees to minimize overall path cost while ensuring collision-free connections.",
    "planning_mechanism": "The planner grows two trees from start and goal, alternately expanding them through sampled points biased within an informed ellipsoid after a feasible path is found. It dynamically adjusts neighbor radius for rewiring, performs collision checks on nodes and edges, prunes nodes unlikely to improve the solution at intervals, and refines the final path through shortcut smoothing to ensure smooth and optimized paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = 5.0\n        self.max_radius = 30.0\n        self.prune_interval = 150\n        self.prune_threshold = 250\n        self.smoothing_iterations = 50\n        self.collision_resolution = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            n = max(n_nodes, 1)\n            r_iter = self.max_radius * (1 - (iteration / self.max_iter) ** 0.9)\n            r_log = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.min_radius, min(r_iter, r_log))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance_edge = dist(p1, p2)\n            steps = max(1, int(distance_edge / self.collision_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            I = np.eye(dim)\n            u = direction - I[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = I - 2 * np.outer(u, u)\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((a - b) ** 2 for a, b in zip(node.position, point)) <= r2]\n\n        def prune_nodes(nodes_list, tree_start, tree_goal, best_cost):\n            to_remove = []\n            for node in nodes_list:\n                if node is root_start or node is root_goal:\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree expansion\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            nearest_a = nearest_node(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            # Collision and bounds checks\n            if (not in_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            neighbors = near_nodes(tree_a, new_pos, r)\n\n            # Choose best parent minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in neighbors:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better path via new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt connection from tree_b to new_node incrementally\n            nearest_b = nearest_node(tree_b, new_node.position)\n            last_b = nearest_b\n            max_connect_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            connected = False\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if (not in_bounds(next_pos_b)) or is_in_obstacle(next_pos_b) or is_edge_in_obstacle(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                neighbors_b = near_nodes(tree_b, next_pos_b, r)\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is last_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and not is_edge_in_obstacle(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                # Check if we can connect new_node_b directly to new_node\n                if dist(new_node_b.position, new_node.position) <= self.step_size and not is_edge_in_obstacle(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic pruning to reduce search space and improve speed\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -1.63515,
    "time_improvement": -8.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.00947272777557373,
            "num_nodes_avg": 77.8,
            "path_length_avg": 163.7737858499551,
            "success_improvement": 0.0,
            "time_improvement": 6.10673132367259,
            "length_improvement": 18.147435943411075,
            "objective_score": 5.461506585783992
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.019690179824829103,
            "num_nodes_avg": 203.3,
            "path_length_avg": 241.18177500808025,
            "success_improvement": 0.0,
            "time_improvement": -37.65465743264079,
            "length_improvement": 19.96772750972755,
            "objective_score": -7.3028517278467255
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02638061046600342,
            "num_nodes_avg": 195.3,
            "path_length_avg": 127.59143182722558,
            "success_improvement": 0.0,
            "time_improvement": 8.055202626512253,
            "length_improvement": 21.651174620913228,
            "objective_score": 6.746795712136322
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a simplified bidirectional RRT* path planning algorithm with adaptive informed sampling within an ellipsoidal region, dynamic neighborhood rewiring, and iterative shortcut smoothing to efficiently generate high-quality, collision-free paths in 2D or 3D environments. It balances exploration and exploitation by extending the smaller of two trees grown from start and goal, applies strict collision and edge checks before adding nodes or edges, and prunes unnecessary nodes to maintain computational efficiency. The final path is smoothed to reduce unnecessary detours and improve smoothness and length.",
    "planning_mechanism": "The planner alternates tree expansions, sampling points biased towards an informed ellipsoid once a solution path is found, dynamically adapts neighborhood radius for rewiring, connects and rewires nodes to reduce path cost, prunes unpromising nodes periodically, and applies shortcut smoothing to the resulting path upon successful connection of the two trees.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = 5.0\n        self.max_radius = 30.0\n        self.prune_interval = 150\n        self.prune_threshold = 100\n        self.smoothing_iterations = 50\n        self.collision_resolution = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            clamped = tuple(max(0.0, min(new_pos[d], bounds[d])) for d in range(dim))\n            return clamped\n\n        def neighbor_radius(iteration: int, n_nodes: int) -> float:\n            n = max(n_nodes, 1)\n            r_iter = self.max_radius * (1 - (iteration / self.max_iter) ** 0.9)\n            r_log = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.min_radius, min(r_iter, r_log))\n\n        def is_in_obstacle(p: Tuple[float, ...]) -> bool:\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            distance_edge = dist(p1, p2)\n            steps = max(1, int(distance_edge / self.collision_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def informed_sample(c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            if c_best == float('inf') or c_best <= c_min * 1.00001:\n                # Uniform random sampling\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            I = np.eye(dim)\n            u = direction - I[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = I - 2 * np.outer(u, u)  # Householder transform\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            # Fallback uniform samples if informed fails\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def nearest_node(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree if sum((node.position[d]-point[d])**2 for d in range(dim)) <= r_sq]\n\n        def prune_nodes(nodes_list: List[Node], tree_start: List[Node], tree_goal: List[Node], best_cost: float):\n            to_remove = []\n            for node in nodes_list:\n                if node is root_start or node is root_goal:\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            length = len(path)\n            if length < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes.extend([root_start, root_goal])\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        edges: List[Tuple[Node, Node]] = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path: List[Tuple[float, ...]] = []\n\n        for itr in range(self.max_iter):\n            sample_pt = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Always extend smaller tree for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            nearest_a = nearest_node(tree_a, sample_pt)\n            new_pos = steer(nearest_a.position, sample_pt)\n\n            if (not in_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_a.position, new_pos):\n                continue\n\n            radius = neighbor_radius(itr, len(nodes))\n            neighbors = near_nodes(tree_a, new_pos, radius)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in neighbors:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try connecting other tree towards new_node incrementally\n            nearest_b = nearest_node(tree_b, new_node.position)\n            last_b = nearest_b\n            max_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos = steer(last_b.position, new_node.position)\n                if (not in_bounds(next_pos)) or is_in_obstacle(next_pos) or is_edge_in_obstacle(last_b.position, next_pos):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos)\n                new_node_b = Node(next_pos, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                neighbors_b = near_nodes(tree_b, next_pos, radius)\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_b_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_b_via_new + 1e-12 < neighbor_b.cost and not is_edge_in_obstacle(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_b_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and not is_edge_in_obstacle(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_a = connection_node.path_from_root()\n                        path_b = new_node.path_from_root()\n                    else:\n                        path_a = new_node.path_from_root()\n                        path_b = connection_node.path_from_root()\n\n                    merged_path = path_a + path_b[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -0.43573,
    "time_improvement": -13.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.00977623462677002,
            "num_nodes_avg": 70.0,
            "path_length_avg": 160.08831471550397,
            "success_improvement": 0.0,
            "time_improvement": 3.098384520129689,
            "length_improvement": 19.98939899351573,
            "objective_score": 4.927395154742053
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.021201300621032714,
            "num_nodes_avg": 210.2,
            "path_length_avg": 240.65853603597742,
            "success_improvement": 0.0,
            "time_improvement": -48.218949754564925,
            "length_improvement": 20.141355902633524,
            "objective_score": -10.437413745842772
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.026948428153991698,
            "num_nodes_avg": 194.1,
            "path_length_avg": 122.18374856757812,
            "success_improvement": 0.0,
            "time_improvement": 6.076177829703829,
            "length_improvement": 24.971817906657144,
            "objective_score": 6.817216930242577
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner integrates the bidirectional anytime RRT* framework with adaptive informed ellipsoidal sampling, lazy collision checking, KD-tree accelerated nearest neighbor queries, and dynamic neighborhood radius based on node density. It incorporates batch rewiring for path cost improvement, periodic pruning of low-potential nodes, and intensive shortcut smoothing at the end. The algorithm balances exploration and exploitation, adapting the sample domain to the current best path cost, ensuring fast convergence, minimal path length, and high success rate, while maintaining computational efficiency and robust collision avoidance in 2D and 3D spaces.",
    "planning_mechanism": "The planning mechanism grows two trees simultaneously from the start and goal, extending the smaller one towards samples drawn within an informed ellipse shaped by the best path cost. It uses KD-trees for efficient nearest and radius queries, performs lazy collision checks when rewiring neighbors, and prunes unpromising nodes periodically to focus search efforts. Upon successful connection, extensive shortcut smoothing refines the path and reduces jaggedness. The strategy adaptively controls neighborhood size and exploration-exploitation trade-off to optimize both performance and path quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag for collision/pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def is_leaf(self):\n        return len(self.children) == 0\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 prune_interval: int = 150, prune_threshold: int = 200,\n                 smoothing_rounds: int = 100, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_rounds = smoothing_rounds\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree for fast nearest and radius neighbor queries\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                if points_nodes:\n                    self.points = np.array([p for p, n in points_nodes])\n                    self.nodes = [n for p, n in points_nodes]\n                else:\n                    self.points = np.empty((0, dim))\n                    self.nodes = []\n\n            def nearest(self, point):\n                if len(self.points) == 0:\n                    return None\n                diff = self.points - np.array(point)\n                dists = np.linalg.norm(diff, axis=1)\n                idx = np.argmin(dists)\n                return self.nodes[idx]\n\n            def radius_search(self, point, radius):\n                if len(self.points) == 0:\n                    return []\n                diff = self.points - np.array(point)\n                dists = np.linalg.norm(diff, axis=1)\n                idxs = np.where(dists <= radius)[0]\n                return [self.nodes[i] for i in idxs]\n\n        # Caches for collision checks to speed up repeated checks\n        node_collision_cache = {}\n        edge_collision_cache = {}\n\n        def can_add_node(pos):\n            if pos in node_collision_cache:\n                return node_collision_cache[pos] is False\n            if not in_bounds(pos) or is_in_obstacle(pos):\n                node_collision_cache[pos] = True\n                return False\n            node_collision_cache[pos] = False\n            return True\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            rev_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return not edge_collision_cache[rev_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            coll = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = coll\n            return not coll\n\n        # Informed ellipsoidal sampling with fallback random sampling\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) * 0.5 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            e1 = np.zeros(dim)\n            e1[0] = 1.0\n            v = a1 - e1\n            s = np.linalg.norm(v)\n            if s > 1e-10:\n                u = v / s\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    sample = rot @ (radii * x) + center\n                    point = tuple(float(coord) for coord in sample)\n                    if in_bounds(point) and not is_in_obstacle(point):\n                        return point\n            # Fallback uniform sample\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        # Dynamic radius shrinking with number of nodes and iteration count for rewiring\n        def neighbor_radius(iteration, n_nodes):\n            if n_nodes == 0:\n                return self.step_size * 3\n            r_iter = 40 * (1 - (iteration / self.max_iter) ** 0.9)\n            r_log = self.step_size + 30 * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.step_size, min(r_iter, r_log))\n\n        # Shortcut smoothing by shortcutting edges along path\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path[:]\n            path = path[:]\n            for _ in range(self.smoothing_rounds):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Prune low-potential nodes unlikely to improve best path\n        def prune_nodes(best_cost):\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except Exception:\n                        pass\n                try:\n                    nodes.remove(node)\n                except Exception:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n            return len(to_remove)\n\n        # Initialize trees and nodes\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Always extend smaller tree first for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            # Build KD-tree for tree_a\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            if nearest_a is None:\n                continue\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                c_tent = node.cost + dist(node.position, new_pos)\n                if c_tent + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = c_tent\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node for optimized paths\n            for neighbor in near_nodes_a:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except Exception:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt connection from tree_b incrementally toward new_node (stepped connection)\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            if nearest_b is None:\n                continue\n\n            last_node_b = nearest_b\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            connection_made = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except Exception:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Update best path if improved\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_smoothing(merged_path)\n\n                    connection_made = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connection_made:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to reduce overhead and refocus search\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                node_collision_cache.clear()\n                edge_collision_cache.clear()\n\n        # If connected but no extracted path yet, fallback copy best path\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 0.3064,
    "time_improvement": -15.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01530156135559082,
            "num_nodes_avg": 75.5,
            "path_length_avg": 158.3303862890627,
            "success_improvement": 0.0,
            "time_improvement": -51.66841543071586,
            "length_improvement": 20.867994724727637,
            "objective_score": -11.32692568426923
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.019670820236206053,
            "num_nodes_avg": 188.9,
            "path_length_avg": 233.0507547630685,
            "success_improvement": 0.0,
            "time_improvement": -37.51931394854613,
            "length_improvement": 22.665875111680055,
            "objective_score": -6.722619162227827
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.016363692283630372,
            "num_nodes_avg": 137.4,
            "path_length_avg": 128.32497309545965,
            "success_improvement": 0.0,
            "time_improvement": 42.96734060648767,
            "length_improvement": 21.200736092948045,
            "objective_score": 17.13034940053591
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved planner leverages bidirectional RRT* enhanced with goal and start adaptive informed sampling to guide exploration more efficiently. It incorporates dynamic neighbor radius rewiring for cost optimality and balances tree growth by always extending the smaller tree. Collision checks are performed lazily and aggressively prunes dead-end nodes periodically to maintain manageable tree size and reduce computation. A carefully implemented iterative shortcut smoothing refines the final path to be shorter and smoother, improving overall path quality and success rate. The planner uses efficient nearest neighbor search via incremental tree size and introduces early termination upon optimal connection to save planning time.",
    "planning_mechanism": "The planner initializes two trees rooted at the start and goal. In each iteration, it samples points biased adaptively toward start or goal to guide exploration. The smaller tree is always extended, promoting balanced bidirectional growth. Nodes are created after collision checks and connected via dynamically sized radius-based rewiring, improving path cost. After connecting the two trees, the planner extracts the combined path and applies iterative randomized shortcut smoothing. Periodic pruning removes dead-end leaf nodes to reduce search complexity. These combined enhancements optimize planning speed, path length, and smoothness while ensuring robust feasibility checks throughout.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.18, radius_constant: float = 30.0,\n                 radius_min: float = 5.0, prune_interval: int = 100,\n                 prune_threshold: int = 100, smoothing_iterations: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        import math\n        import random\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            # Adaptive bias: 60% towards goal, 40% towards start when goal_sample_rate triggers\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < 0.6 else start_position\n            attempts = 0\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d)):\n                    return p\n                attempts += 1\n                if attempts > 30:\n                    # Fallback bias to avoid stalling\n                    return goal_position if random.random() < 0.6 else start_position\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d_] + (to_pos[d_] - from_pos[d_]) * ratio for d_ in range(len(from_pos)))\n            # Clamp to bounds strictly\n            clamped = tuple(max(0, min(new_pos[d_], bounds[d_])) for d_ in range(len(bounds)))\n            return clamped\n\n        def nearest(tree, point):\n            # Efficient linear search as nodes remain moderate due to pruning\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            result = []\n            px = pos\n            for node in tree:\n                dx = node.position[0] - px[0]\n                dy = node.position[1] - px[1]\n                if len(bounds) == 2:\n                    if dx * dx + dy * dy <= r2:\n                        result.append(node)\n                else:\n                    dz = node.position[2] - px[2]\n                    if dx * dx + dy * dy + dz * dz <= r2:\n                        result.append(node)\n            return result\n\n        def radius_dynamic(n):\n            if n <= 1:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n) / n)\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def can_connect(p1, p2):\n            if dist(p1, p2) < 1e-9:\n                return True\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            # Remove leaf nodes except roots to control tree size and prune dead-ends rapidly\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            total = 0.0\n            for i in range(len(path) - 1):\n                total += dist(path[i], path[i + 1])\n            return total\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path[:]\n            path = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    # Shortcut the path segment\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Balance growth by always extending smaller tree\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                # Prune periodically to maintain efficiency\n                if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                    prune_dead_nodes()\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n\n                raw_path = path_start + path_goal[::-1][1:]  # joint path\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 4.92071,
    "time_improvement": -31.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.015637302398681642,
            "num_nodes_avg": 77.3,
            "path_length_avg": 161.88671941326749,
            "success_improvement": 0.0,
            "time_improvement": -54.996266152435524,
            "length_improvement": 19.090573610934523,
            "objective_score": -12.68076512354375
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.029185771942138672,
            "num_nodes_avg": 95.7,
            "path_length_avg": 237.0559897685307,
            "success_improvement": 0.0,
            "time_improvement": -104.03863623105065,
            "length_improvement": 21.336802633736855,
            "objective_score": -26.94423034256782
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.009496164321899415,
            "num_nodes_avg": 94.7,
            "path_length_avg": 123.83143260487927,
            "success_improvement": 0.0,
            "time_improvement": 66.90285444578414,
            "length_improvement": 23.960040649597865,
            "objective_score": 24.862864463654816
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved bidirectional RRT* planner enhances path quality and planning efficiency by integrating adaptive goal/start bias sampling with an informed sampling heuristic biased towards the current best path. It dynamically adjusts neighbor search radius using the number of nodes, applies rigorous node and edge collision checks, rewires locally for cost optimality, and periodically prunes dead-end nodes to keep the trees efficient. Upon successful connection of the trees, an iterative shortcut smoothing using collision-aware shortcuts further minimizes the path length and smoothness. The planner balances exploration and exploitation by always extending the smaller tree first and uses heuristic-informed sampling to reduce search space and improve success rate.",
    "planning_mechanism": "The planner grows two bidirectional trees rooted at the start and goal, alternating growth of the smaller tree. Sampling is adaptively biased either towards the goal/start positions or the informed ellipse around the current best path thus focusing search. Extension includes collision checks and neighbor rewiring for path cost improvement. Once trees connect, the combined path undergoes shortcut smoothing. Periodic pruning of dead-end nodes reduces tree complexity, promoting faster subsequent expansions.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 20.0,\n                 radius_min: float = 5.0, prune_interval: int = 150,\n                 prune_threshold: int = 150, smoothing_iterations: int = 75):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        import random\n        import math\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def can_add_node(pos):\n            if not in_bounds(pos) or self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        # Informed sampling ellipse calculation for 2D/3D to bias sampling near best_path length\n        def informed_sample(best_path_length, start, goal):\n            # If no best path found yet, sample uniformly\n            if best_path_length is None:\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            c_best = best_path_length\n            c_min = dist(start, goal)\n            if c_best < float('inf'):\n                # Build informed sampling ellipse parameters\n                center = tuple((start[i] + goal[i]) / 2 for i in range(len(bounds)))\n                diff = [goal[i] - start[i] for i in range(len(bounds))]\n                if is_3d:\n                    # 3D: ellipse inside ellipsoid\n                    import numpy as np\n\n                    def sample_unit_ball():\n                        # Sample uniformly inside unit ball\n                        while True:\n                            p = np.random.uniform(-1,1,3)\n                            if np.linalg.norm(p) <= 1:\n                                return p\n\n                    a1 = np.array(diff) / c_min if c_min > 0 else np.array([1,0,0])\n                    U, _, _ = np.linalg.svd(a1.reshape(-1,1))\n                    L = np.diag([c_best/2.0] + [math.sqrt(c_best**2 - c_min**2)/2.0]*(len(bounds)-1))\n                    r = sample_unit_ball()\n                    sample = np.dot(U, np.dot(L, r)) + np.array(center)\n                    sample_tuple = tuple(sample.tolist())\n                    if in_bounds(sample_tuple) and not self._is_in_obstacle(sample_tuple, obstacles, is_3d):\n                        return sample_tuple\n                    # fallback to uniform if not successful\n                    return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                else:\n                    # 2D case\n                    x_len = c_best / 2.0\n                    y_len = math.sqrt(c_best**2 - c_min**2) / 2.0 if c_best > c_min else 0.0\n                    angle = math.atan2(diff[1], diff[0])\n\n                    while True:\n                        # Sample point in unit circle\n                        theta = random.uniform(0, 2 * math.pi)\n                        r = math.sqrt(random.uniform(0,1))\n                        x_ball = r * math.cos(theta)\n                        y_ball = r * math.sin(theta)\n                        # Scale and rotate to ellipse\n                        x_ellipse = x_len * x_ball\n                        y_ellipse = y_len * y_ball\n\n                        # Rotation\n                        sample_x = math.cos(angle) * x_ellipse - math.sin(angle) * y_ellipse + center[0]\n                        sample_y = math.sin(angle) * x_ellipse + math.cos(angle) * y_ellipse + center[1]\n                        sample_point = (sample_x, sample_y)\n                        if in_bounds(sample_point) and not self._is_in_obstacle(sample_point, obstacles, is_3d):\n                            return sample_point\n            # Default fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def sample_free(best_path_length):\n            # Adaptive biasing towards goal or start or informed sampling\n            prob = random.random()\n            if prob < self.goal_sample_rate:\n                # bias 70% goal, 30% start to break symmetry\n                return goal_position if random.random() < 0.7 else start_position\n            elif prob < self.goal_sample_rate + 0.15 and best_path_length is not None and best_path_length < float('inf'):\n                # informed sample bias near best path for better path quality\n                return informed_sample(best_path_length, start_position, goal_position)\n            else:\n                # uniform random sample in free space\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            to_remove = [node for node in nodes if node is not start_root and node is not goal_root and not node.children]\n            for node in to_remove:\n                try:\n                    if node.parent:\n                        node.parent.children.remove(node)\n                    nodes.remove(node)\n                    edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                    removed.append(node)\n                except Exception:\n                    continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    # Remove intermediate nodes between i+1 and j-1\n                    path = path[:i+1] + path[j:]\n            return path\n\n        best_path_length = None\n\n        for itr in range(self.max_iter):\n\n            # Always extend the smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            sample_pt = sample_free(best_path_length)\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                # prune occasionally to maintain efficiency\n                if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                    prune_dead_nodes()\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                path_len_raw = path_length(raw_path)\n                best_path_length = path_len_raw if best_path_length is None else min(best_path_length, path_len_raw)\n\n                smoothed_path = shortcut_smoothing(raw_path)\n                path_len_smoothed = path_length(smoothed_path)\n\n                if path_len_smoothed + 1e-12 < path_len_raw:\n                    extracted_path = smoothed_path\n                    best_path_length = path_len_smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 7.62076,
    "time_improvement": -38.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012272286415100097,
            "num_nodes_avg": 84.4,
            "path_length_avg": 164.77457625294045,
            "success_improvement": 0.0,
            "time_improvement": -21.642373025550857,
            "length_improvement": 17.64725051909275,
            "objective_score": -2.9632618038467062
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03176336288452149,
            "num_nodes_avg": 155.0,
            "path_length_avg": 244.88901923294526,
            "success_improvement": 0.0,
            "time_improvement": -122.05865439907994,
            "length_improvement": 18.73753845426328,
            "objective_score": -32.87008862887132
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.020570755004882812,
            "num_nodes_avg": 118.1,
            "path_length_avg": 126.37388973369407,
            "success_improvement": 0.0,
            "time_improvement": 28.304392228488624,
            "length_improvement": 22.398818812311294,
            "objective_score": 12.971081431008846
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This planner implements a bidirectional RRT*-like algorithm enhanced with adaptive heuristic-guided sampling, KD-tree accelerated neighbor search, incremental rewiring, collision caching, and multi-level path smoothing including post-processing with cubic B-spline fitting. It integrates goal bias, informed sampling within an adaptive ellipsoid, dynamic neighbor radius shrinking, and progressive pruning to rapidly converge to high-quality, smooth, and feasible paths in both 2D and 3D spaces. The planner balances exploration and exploitation efficiently, reduces redundant collision checks, and aggressively shortens and smooths paths to improve path length, smoothness, and planning speed.",
    "planning_mechanism": "The planner grows two trees from start and goal positions, alternating expansion directions. Sampling is biased inside an adaptive informed ellipsoid around the current best path cost to focus on promising regions, combined with goal bias for faster convergence. Nearest neighbors and near nodes for rewiring are found efficiently via a simple KD-tree structure. Collision checks for edges and nodes are cached to avoid redundancy. Trees are rewired incrementally to optimize path cost locally. Periodic pruning removes nodes unlikely to improve the solution. After a path is found, multi-stage shortcut smoothing followed by cubic B-spline fitting is applied to enhance path smoothness without compromising collision-free guarantees. The process stops early upon path convergence or maximum iteration limit.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position                 # Tuple[float, ...]: 2D or 3D coords\n        self.parent = parent                     # Parent Node or None\n        self.cost = cost                         # Cost from root\n        self.children = []                       # List[Node]\n        self.valid = True                        # Validity flag for pruning/collision\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 25.0,\n                 goal_sample_rate: float = 0.2, prune_interval: int = 150,\n                 prune_threshold: int = 250, smoothing_iterations: int = 80,\n                 collision_check_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            dist_f = distance(from_pos, to_pos)\n            if dist_f <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist_f\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp within bounds strictly\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            n = max(n_nodes, 1)\n            # Linearly shrink radius to min_neighbor_radius over iterations (slow decay)\n            r_decay = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.85)\n            # Logarithmic neighbor radius\n            r_log = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.min_neighbor_radius, min(r_decay, r_log))\n\n        def is_in_obstacle(pos):\n            # Check if pos inside any obstacle box\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            dist_e = distance(p1, p2)\n            steps = max(1, int(dist_e / self.collision_check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        # Informed Ellipsoidal Sampling centered on current best path cost\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                # Goal bias and uniform sampling when no known path or random goal bias\n                for _ in range(15):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center_np = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            # Householder reflection to align sampling ellipsoid\n            I = np.eye(dim)\n            u = direction - I[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                H = I - 2 * np.outer(u, u)  # Householder matrix\n            else:\n                H = I\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2)**2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    sample = H @ (x_ball * radii) + center_np\n                    pt = tuple(float(c) for c in sample)\n                    if in_bounds(pt) and not is_in_obstacle(pt):\n                        return pt\n\n            # fallback uniform sampling\n            for _ in range(15):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n            return sample\n\n        # Simple KD-tree for neighbor search (brute force for code simplicity)\n        class KDTree:\n            def __init__(self, nodes_list):\n                self.nodes = nodes_list\n\n            def nearest(self, point):\n                best_node = None\n                min_dist = float('inf')\n                for node in self.nodes:\n                    d = distance(point, node.position)\n                    if d < min_dist:\n                        min_dist = d\n                        best_node = node\n                return best_node\n\n            def radius_search(self, point, radius):\n                r2 = radius * radius\n                results = []\n                for node in self.nodes:\n                    sqd = 0.0\n                    for i in range(dim):\n                        delta = node.position[i] - point[i]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(node)\n                return results\n\n        # Cache collision checks for edges to improve speed\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            rev_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return not edge_collision_cache[rev_key]\n\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        # Path shortcut smoothing - randomized shortcut with caching edge checks\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            iterations = self.smoothing_iterations\n            for _ in range(iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Cubic B-Spline smooth the path while ensuring collision checking on generated segments\n        def bspline_smooth(path):\n            if len(path) < 4:\n                return path\n\n            import numpy as np\n\n            def bspline(control_points, degree=3, num_samples=100):\n                control_points = np.array(control_points)\n                n = len(control_points)\n                k = degree\n\n                # Knot vector with clamping\n                knots = np.concatenate((\n                    np.zeros(k),\n                    np.linspace(0, 1, n - k + 1),\n                    np.ones(k)\n                ))\n\n                def basis_func(i, k, t):\n                    if k == 0:\n                        return 1.0 if knots[i] <= t < knots[i + 1] else 0.0\n                    den1 = knots[i + k] - knots[i]\n                    den2 = knots[i + k + 1] - knots[i + 1]\n                    val1 = 0.0 if den1 == 0 else ((t - knots[i]) / den1) * basis_func(i, k - 1, t)\n                    val2 = 0.0 if den2 == 0 else ((knots[i + k + 1] - t) / den2) * basis_func(i + 1, k - 1, t)\n                    return val1 + val2\n\n                t_vals = np.linspace(knots[k], knots[n], num_samples)\n                curve = []\n                for t in t_vals:\n                    point = np.zeros(dim)\n                    for i in range(n):\n                        b = basis_func(i, k, t)\n                        point += b * control_points[i]\n                    curve.append(tuple(point))\n                return curve\n\n            smoothed = bspline(path, degree=3, num_samples=max(len(path)*10, 100))\n\n            # Verify no collision on smoothed path segments, revert to original on failure\n            # Check edge collisions at fine resolution\n            valid = True\n            for i in range(len(smoothed) - 1):\n                if not can_connect(smoothed[i], smoothed[i + 1]):\n                    valid = False\n                    break\n\n            return smoothed if valid else path\n\n        # Prune nodes that cannot improve current best cost\n        def prune_nodes(best_cost):\n            to_remove = []\n            heuristic = lambda pos: distance(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n\n        # Initialize trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = distance(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree expansion for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree(tree_a)\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            # Node collision and edge collision checks for connection to nearest_a\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            # Choose parent minimizing cost + connection collision-free\n            min_cost = nearest_a.cost + distance(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                c_candidate = node.cost + distance(node.position, new_pos)\n                if c_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = c_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Incremental rewiring of neighbors to improve cost\n            for neighbour in near_nodes:\n                if neighbour is best_parent:\n                    continue\n                new_cost = new_node.cost + distance(new_node.position, neighbour.position)\n                if new_cost + 1e-12 < neighbour.cost and can_connect(new_node.position, neighbour.position):\n                    try:\n                        edges.remove((neighbour.parent, neighbour))\n                    except ValueError:\n                        pass\n                    neighbour.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbour))\n\n            # Attempt to connect tree_b towards new_node incrementally\n            kdtree_b = KDTree(tree_b)\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(distance(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + distance(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new = new_node_b.cost + distance(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = distance(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Assemble path from start to goal concatenated from both trees\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged = path_start + path_goal[::-1][1:]  # avoid duplicate node at connection\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged)\n                        best_path = bspline_smooth(best_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            # Early stop if connected\n            if connected:\n                break\n\n            # Periodic pruning to reduce complexity and speed up search space refinement\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                edge_collision_cache.clear()  # Clear cache as nodes removed\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 24.36213,
    "time_improvement": -89.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.030577445030212404,
            "num_nodes_avg": 84.6,
            "path_length_avg": 170.6283420126719,
            "success_improvement": -9.999999999999998,
            "time_improvement": -203.08231479643442,
            "length_improvement": 14.721594655829835,
            "objective_score": -62.98037550776435
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.026729369163513185,
            "num_nodes_avg": 215.3,
            "path_length_avg": 236.9016264260315,
            "success_improvement": 0.0,
            "time_improvement": -86.86584827195374,
            "length_improvement": 21.388025613122394,
            "objective_score": -21.782149358961643
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.021841144561767577,
            "num_nodes_avg": 157.7,
            "path_length_avg": 126.10231083213162,
            "success_improvement": 0.0,
            "time_improvement": 23.876681560318467,
            "length_improvement": 22.56558461805892,
            "objective_score": 11.676121391707325
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid path planner synergizes bidirectional RRT* growth with ellipsoidal informed sampling, adaptive neighbor radius, KD-tree accelerated neighbor search, collision caching, incremental rewiring, and dynamic pruning. It optimizes exploration by focusing samples within promising regions, rewires locally for path cost improvement, aggressively smooths found paths, prunes nodes unlikely to contribute to better solutions, and terminates early upon successfully connecting start and goal trees, aiming for efficient, high-quality, robust, and smooth paths in 2D and 3D environments.",
    "planning_mechanism": "The planner alternately grows two trees from start and goal positions using ellipsoidal informed sampling biased by the current best solution cost. Efficient KD-tree radius and nearest neighbor searches accelerate rewiring and local optimization. Collision checks are cached to reduce redundant computations. Periodic pruning removes nodes whose cost plus heuristic exceeds the current best path cost, improving efficiency. Aggressive shortcut smoothing refines the final path. Expansion stops as soon as a satisfactory connection between trees is found, prioritizing planning speed and path quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision/pruning etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=120,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree acceleration (brute-force)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Ellipsoidal informed sampling with fallback uniform & goal bias\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(15):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p): return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))  # unit vector start->goal\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) * (c_min / 2), 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    x = x * radii\n                    p = rot @ x + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p): \n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            path = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialize tree roots\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float(\"inf\")\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path: list = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree selection for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Incremental rewiring in tree_a\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Attempt connecting tree_b toward new_node by incremental extension & rewiring\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning accelerates convergence and memory usage\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 0.06148,
    "time_improvement": -15.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009427666664123535,
            "num_nodes_avg": 72.7,
            "path_length_avg": 154.28035357860705,
            "success_improvement": 0.0,
            "time_improvement": 6.553375114614937,
            "length_improvement": 22.89216214653693,
            "objective_score": 6.544444963691867
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.026660346984863283,
            "num_nodes_avg": 231.8,
            "path_length_avg": 235.57003780298646,
            "success_improvement": 0.0,
            "time_improvement": -86.38331208173948,
            "length_improvement": 21.829891767896804,
            "objective_score": -21.54901527094248
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01898953914642334,
            "num_nodes_avg": 161.2,
            "path_length_avg": 124.7801116182216,
            "success_improvement": 0.0,
            "time_improvement": 33.81543117495873,
            "length_improvement": 23.377494586020404,
            "objective_score": 14.8201282696917
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner combines the adaptive informed sampling strategy of bidirectional informed RRT* with KD-tree accelerated neighbor queries and lazy collision checking inspired by bidirectional PRM*. It dynamically samples within an ellipsoidal informed domain biased by the current best solution, employs efficient rewiring with adaptive neighborhood radius, and leverages pruning to discard unpromising nodes. This hybrid approach enhances exploration-exploitation balance, reduces collision checks, improves path quality and smoothness, and accelerates convergence in both 2D and 3D spaces.",
    "planning_mechanism": "The planner grows two roadmaps simultaneously from start and goal positions by sampling informed ellipsoidal regions around the best path found so far or uniform if none, using KD-tree for efficient neighbor searches. Nodes are connected and rewired using lazy collision checking, prioritizing low-cost edges. Trees attempt connection via incremental steering steps and, upon success, extract and shortcut smooth the combined path. Periodic pruning discards nodes unlikely to improve the solution, enhancing planning efficiency and success rate.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position            # Tuple[float, ...] (2D or 3D)\n        self.parent = parent                # Node or None\n        self.cost = cost                   # Cost from root/start of tree\n        self.children: List[Node] = []     # For rewiring and pruning\n        self.valid = True                  # Mark node as valid or pruned\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_trials: int=50,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            factor = math.log(n_nodes) / n_nodes\n            r = self.max_neighbor_radius * (factor ** 0.5)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        # KD-tree helper for nearest and radius search (brute-force for portability)\n        class KDTree:\n            def __init__(self, points_nodes: List[Tuple[Tuple[float, ...], Node]]):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # Edge collision cache for lazy collision checking\n        edge_collision_cache = {}\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def ellipse_sample(c_best: float, c_min: float,\n                           start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            # Informed sampling inside ellipse around current best path\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback uniform\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)  # Householder reflection\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r2]*(dim-1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1,1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.power(np.random.uniform(0,1), 1/dim)  # Uniform in unit ball\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n\n            # fallback uniform\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def adaptive_sample(best_path: List[Tuple[float, ...]]) -> Tuple[float, ...]:\n            # Sample near path with Gaussian noise with fallback to ellipse sampling\n            if best_path:\n                import numpy as np\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            # fallback to ellipse sample with worst cost if available\n            return ellipse_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth)-3)\n                j = random.randint(i+2, len(smooth)-1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i+1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(nodes_list: List[Node], best_cost: float, root_s: Node, root_g: Node) -> int:\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialize roots\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path)\n\n            # Alternate growth of smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(len(nodes))\n            near_nodes_a = kdtree_a.radius_search(new_pos, r)\n\n            # Choose parent minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Try connecting tree_b to new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes))\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic pruning\n            if (it > 0 and it % self.prune_interval == 0 and\n                len(nodes) > self.prune_threshold and c_best < float('inf')):\n                removed_s = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_g = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -7.12118,
    "time_improvement": 10.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007959723472595215,
            "num_nodes_avg": 63.1,
            "path_length_avg": 166.1777904320498,
            "success_improvement": 0.0,
            "time_improvement": 21.103564642826754,
            "length_improvement": 16.94593755936249,
            "objective_score": 9.720256904720525
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.01784951686859131,
            "num_nodes_avg": 199.8,
            "path_length_avg": 235.0571101756468,
            "success_improvement": 0.0,
            "time_improvement": -24.786525656090877,
            "length_improvement": 22.000098507762036,
            "objective_score": -3.035937995274855
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.019048786163330077,
            "num_nodes_avg": 157.5,
            "path_length_avg": 125.4230613012865,
            "success_improvement": 0.0,
            "time_improvement": 33.60893652346104,
            "length_improvement": 22.982684748678,
            "objective_score": 14.67921790677391
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner is an enhanced bidirectional RRT* variant that utilizes adaptive informed sampling within an ellipsoidal subset defined by the current best path cost, lazy collision checks, KD-tree accelerated nearest and radius neighbor searches, and incremental rewiring with an adaptive neighbor radius. It balances exploration and exploitation via alternating tree expansion, employs a heuristic-guided pruning mechanism to remove non-promising nodes periodically, and applies aggressive collision-aware shortcut smoothing for path optimization. The design aims to maximize success rate, path quality, smoothness, and efficiency in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees from start and goal positions alternately using ellipsoidal informed samples biased by the current best path cost. New nodes are added only after confirming collision-free status and connectivity with parents, with incremental rewiring applied to improve path costs locally. Trees attempt connection via steering toward nearest nodes in the opposite tree, and on successful connection, the combined path undergoes aggressive segment-wise smoothing. Pruning removes nodes unlikely to contribute to better paths, maintaining computational efficiency and robustness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost from root\n        self.children = []\n        self.valid = True               # For collision checking flags\n    \n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_iterations: int = 150,\n                 collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.12):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clip to bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def heuristic(p):\n            return dist(p, goal_pos)\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or random.random() < self.goal_sample_rate:\n                for _ in range(10):\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1**2 - (c_min/2.0)**2, 0))\n            radii = np.array([r1] + [r_others]*(dim-1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    x_ellipse = x_ball * radii\n                    sample = rot @ x_ellipse + center\n                    sample_t = tuple(float(v) for v in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n\n            # Fallback uniform sampling\n            for _ in range(10):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        class KDTree:\n            def __init__(self, nodes_list):\n                self.dim = dim\n                self.points = [node.position for node in nodes_list]\n                self.nodes = nodes_list\n\n            def nearest(self, point):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, point)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, point, radius):\n                r2 = radius * radius\n                result = []\n                for p, n in zip(self.points, self.nodes):\n                    diff_sq = 0.0\n                    for d_ in range(self.dim):\n                        diff = p[d_] - point[d_]\n                        diff_sq += diff * diff\n                        if diff_sq > r2:\n                            break\n                    else:\n                        result.append(n)\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 1.0)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_nodes(nodes_list, tree_s, tree_g, best_cost):\n            h = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                if not node.children and (node.cost + h(node.position) >= best_cost * 1.01):\n                    to_remove.append(node)\n                    continue\n                if node.cost + h(node.position) >= best_cost * 0.98:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_s:\n                    try: tree_s.remove(node)\n                    except ValueError: pass\n                if node in tree_g:\n                    try: tree_g.remove(node)\n                    except ValueError: pass\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree expansion for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree(tree_a)\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for near in near_nodes:\n                cost_cand = near.cost + dist(near.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(near.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-12 < near.cost and can_connect(new_node.position, near.position):\n                    try:\n                        edges.remove((near.parent, near))\n                    except ValueError:\n                        pass\n                    near.update_parent(new_node, new_cost)\n                    edges.append((new_node, near))\n\n            # Incrementally connect tree_b toward new_node\n            kdtree_b = KDTree(tree_b)\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b_nodes = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b_nodes:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = merged_path\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                # Aggressive final shortcut smoothing\n                extracted_path = shortcut_path(best_path)\n                break\n\n            # Periodic pruning to remove non-promising nodes and maintain efficiency\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = shortcut_path(best_path) if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -2.05071,
    "time_improvement": -7.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009228992462158202,
            "num_nodes_avg": 56.1,
            "path_length_avg": 161.33118873166296,
            "success_improvement": 0.0,
            "time_improvement": 8.522625225685093,
            "length_improvement": 19.368222506119096,
            "objective_score": 6.430432068929347
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0187880277633667,
            "num_nodes_avg": 207.4,
            "path_length_avg": 235.26781767077213,
            "success_improvement": 0.0,
            "time_improvement": -31.34768440966405,
            "length_improvement": 21.93017863232764,
            "objective_score": -5.018269596433687
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.028017711639404298,
            "num_nodes_avg": 203.4,
            "path_length_avg": 129.9941932905919,
            "success_improvement": 0.0,
            "time_improvement": 2.349385626476522,
            "length_improvement": 20.175734337620487,
            "objective_score": 4.739962555467054
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a simplified bidirectional informed RRT* algorithm combining heuristic ellipsoidal sampling, incremental rewiring, collision caching, and periodic pruning. It focuses search within an adaptive ellipsoidal domain defined by the best path cost found so far, uses KD-tree accelerated neighbor queries for efficient rewiring, and applies shortcut smoothing to improve path quality. The planner balances exploration and exploitation, prunes suboptimal nodes to reduce complexity, and ensures collision-free node placement and edge connections, targeting efficient, robust, and high-quality path planning in 2D or 3D environments.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal positions, alternately extending the smaller tree toward sampled points biased inside an informed ellipsoid. Neighbors within a dynamic radius are searched via KD-tree to find optimal parent nodes and allow rewiring for cost reduction. Collision caches speed up validation, and nodes unlikely to improve the current best path are pruned periodically. Upon connecting the trees, the path is shortcut-smoothed to enhance smoothness and shorten length. This mechanism accelerates convergence, improves success rates, and enhances final solution quality.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List['Node'] = []\n        self.valid = True\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_iterations: int = 100, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d_] + ratio * (to_pos[d_] - from_pos[d_]) for d_ in range(dim))\n            return tuple(max(0, min(new_p[d_], bounds[d_])) for d_ in range(dim))\n\n        def neighbor_radius(iteration: int, n_nodes: int) -> float:\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes: List[Tuple[Tuple[float, ...], Node]]):\n                self.points = [p for p, _ in points_nodes]\n                self.nodes = [n for _, n in points_nodes]\n                self.dim = dim\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best_node = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = 0.0\n                    for d_ in range(self.dim):\n                        diff = p[d_] - pt[d_]\n                        d += diff * diff\n                        if d > best_dist * best_dist:  # early break\n                            break\n                    if d < best_dist * best_dist:\n                        best_dist = math.sqrt(d)\n                        best_node = self.nodes[i]\n                return best_node\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                r_sq = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r_sq:\n                            break\n                    if sqd <= r_sq:\n                        result.append(self.nodes[i])\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            if not in_bounds(pos) or is_in_obstacle(pos):\n                return False\n            return True\n\n        def informed_sample(c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            rot = id_mat\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    x = x * radii\n                    p = rot @ x + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost: float):\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        edges: List[Tuple[Node, Node]] = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path: List[Tuple[float, ...]] = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near_nodes_a:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_nodes_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles, is_3d: bool) -> bool:\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles, is_3d: bool, resolution: float = 1.0) -> bool:\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 9.89691,
    "time_improvement": -47.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012067699432373047,
            "num_nodes_avg": 71.4,
            "path_length_avg": 159.73296090832199,
            "success_improvement": 0.0,
            "time_improvement": -19.61451568688616,
            "length_improvement": 20.167001410863307,
            "objective_score": -1.850954423893187
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03041536808013916,
            "num_nodes_avg": 222.5,
            "path_length_avg": 240.551110797702,
            "success_improvement": 0.0,
            "time_improvement": -112.63478094190398,
            "length_improvement": 20.17700323105087,
            "objective_score": -29.755033636361016
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.031632089614868165,
            "num_nodes_avg": 183.6,
            "path_length_avg": 122.22229348620654,
            "success_improvement": 0.0,
            "time_improvement": -10.247868368592536,
            "length_improvement": 24.94814900463433,
            "objective_score": 1.915269290349106
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "The planner implements an enhanced bidirectional RRT* algorithm that integrates adaptive informed sampling within an ellipsoidal region once a feasible path is found, dynamic neighbor radius shrinking, and balanced tree extension. It includes rigorous collision and edge checking, periodic pruning of unpromising and dead-end nodes, and iterative shortcut smoothing for path refinement. By combining goal-start biased sampling, neighborhood rewiring, and efficient pruning strategies, the planner optimizes both planning speed and path quality in 2D and 3D environments.",
    "planning_mechanism": "The planner alternates growth between two trees rooted at start and goal positions, extending the smaller tree for balanced expansion. Initially, it samples uniformly, switching to adaptive informed sampling using ellipsoidal sampling when a solution exists. Each extension steers toward sampled points within bounds, conducts extensive collision checks, and rewires neighbors to minimize path cost. After connecting trees, shortcut smoothing refines the path. Periodic pruning removes dead or costly nodes to maintain computational efficiency, resulting in faster convergence to shorter, smoother paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] for 2D or 3D coords\n        self.parent = parent            # Parent node or None\n        self.cost = cost                # Cost from root node\n        self.children = []\n        self.valid = True               # For collision validity\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 prune_interval: int=150, prune_threshold: int=100,\n                 smoothing_iterations: int=50, collision_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_resolution = collision_resolution\n        self.min_radius = 5.0\n        self.max_radius = 30.0\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio*(to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp within bounds\n            clamped = tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n            return clamped\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            d_edge = dist(p1, p2)\n            steps = max(1, int(d_edge / self.collision_resolution))\n            for i in range(steps +1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])* i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def neighbor_radius(iter, n_nodes):\n            n = max(n_nodes, 1)\n            r_iter = self.max_radius * (1 - (iter / self.max_iter)**0.9)\n            r_log = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(n+1)/n)\n            return max(self.min_radius, min(r_iter, r_log))\n\n        def uniform_sample():\n            for _ in range(20):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            # fallback random if all fail\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best <= c_min * 1.00001:\n                return uniform_sample()\n\n            center = np.array([(start[d] + goal[d])/2 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d])/c_min for d in range(dim)])\n            I = np.eye(dim)\n            u = direction - I[:,0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = I - 2 * np.outer(u,u)\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1**2 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r_other]*(dim-1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1,1,dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(v) for v in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            return uniform_sample()\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            r_sq = radius*radius\n            return [node for node in tree if sum((node.position[d]-point[d])**2 for d in range(dim)) <= r_sq]\n\n        def prune_nodes(all_nodes, tree_start, tree_goal, best_cost):\n            to_remove = []\n            for node in all_nodes:\n                if node is root_start or node is root_goal:\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    all_nodes.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n                node.valid = False\n\n        def prune_dead_end_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is root_start or node is root_goal:\n                    continue\n                if not node.children and node.valid:\n                    if node.parent:\n                        try:\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    try:\n                        nodes.remove(node)\n                    except ValueError:\n                        pass\n                    edges[:] = [(p,c) for (p,c) in edges if p != node and c != node]\n                    node.valid = False\n                    removed.append(node)\n            return removed\n\n        def shortcut_path(path):\n            length = len(path)\n            if length < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes.extend([root_start, root_goal])\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        for itr in range(self.max_iter):\n            sample_pt = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth of smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            nearest_a = nearest(tree_a, sample_pt)\n            new_pos = steer(nearest_a.position, sample_pt)\n\n            if (not in_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_a.position, new_pos):\n                continue\n\n            radius = neighbor_radius(itr, len(nodes))\n            neighbors = near_nodes(tree_a, new_pos, radius)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in neighbors:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Connect tree_b towards new_node incrementally\n            nearest_b = nearest(tree_b, new_node.position)\n            last_b = nearest_b\n            max_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos = steer(last_b.position, new_node.position)\n                if (not in_bounds(next_pos)) or is_in_obstacle(next_pos) or is_edge_in_obstacle(last_b.position, next_pos):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos)\n                new_node_b = Node(next_pos, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b = near_nodes(tree_b, next_pos, radius)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_b_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_b_via_new + 1e-12 < neighbor_b.cost and not is_edge_in_obstacle(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_b_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and not is_edge_in_obstacle(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_a = connection_node.path_from_root()\n                        path_b = new_node.path_from_root()\n                    else:\n                        path_a = new_node.path_from_root()\n                        path_b = connection_node.path_from_root()\n\n                    merged_path = path_a + path_b[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n                prune_dead_end_nodes()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -5.84788,
    "time_improvement": 5.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009490442276000977,
            "num_nodes_avg": 65.4,
            "path_length_avg": 158.71176529717673,
            "success_improvement": 0.0,
            "time_improvement": 5.931145960355036,
            "length_improvement": 20.67738516209536,
            "objective_score": 5.914820820525582
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.020306205749511717,
            "num_nodes_avg": 207.6,
            "path_length_avg": 236.37021311919233,
            "success_improvement": 0.0,
            "time_improvement": -41.96131376519905,
            "length_improvement": 21.56436652684394,
            "objective_score": -8.275520824190927
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.013994884490966798,
            "num_nodes_avg": 150.9,
            "path_length_avg": 125.90527752025034,
            "success_improvement": 0.0,
            "time_improvement": 51.22338732662966,
            "length_improvement": 22.686574941040437,
            "objective_score": 19.904331186196984
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This implementation enhances the bidirectional RRT* planner by incorporating adaptive informed sampling within ellipsoidal domains post initial path discovery, dynamic neighbor radius scaling to leverage local node density for efficient rewiring, and lazy collision checking with caching to minimize redundant computations. Additionally, it integrates an iterative shortcutting mechanism applied after path connection to smooth the trajectory, improving path quality and shortening length. These improvements combined reduce planning time and increase robustness and success rates while maintaining path optimality.",
    "planning_mechanism": "The planner simultaneously grows two trees from the start and goal, alternating expansions. Sampling is uniform initially, then focused inside an informed ellipse after finding a path. Each extension steers incrementally toward sampled points, adds collision-free nodes, and rewires within a radius computed considering the node count and dimensionality. Trees attempt connection after each expansion with incremental steps, aided by lazy collision checks and cached results. Upon successful connection, an iterative shortcutting refines the found path for smoother, shorter routes, balancing exploration and exploitation to accelerate planning and improve solution quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n        self._in_collision = None      # Lazy collision check cache for this node if needed\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self._edge_collision_cache = dict()\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / distance\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n            # Clamp to bounds (ensure no overflow)\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def sample_free_uniform():\n            for _ in range(100):  # Try at most 100 times to sample free\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback: try start to goal midpoint if stuck\n            midpoint = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n            if not self._is_in_obstacle(midpoint, obstacles, is_3d):\n                return midpoint\n            return start  # fallback\n\n        def ellipse_sample(center, c_min, c_max, start, goal):\n            if is_3d:\n                import numpy as np\n\n                if c_max < c_min:\n                    c_max = c_min\n                center_np = np.array(center)\n                start_np = np.array(start)\n                goal_np = np.array(goal)\n                a1 = (goal_np - start_np) / np.linalg.norm(goal_np - start_np)\n\n                temp = np.array([1., 0., 0.])\n                if np.allclose(a1, temp):\n                    temp = np.array([0., 1., 0.])\n                e2 = np.cross(a1, temp)\n                norm_e2 = np.linalg.norm(e2)\n                if norm_e2 == 0:\n                    e2 = np.array([0., 0., 1.])\n                else:\n                    e2 /= norm_e2\n                e3 = np.cross(a1, e2)\n                C = np.column_stack((a1, e2, e3))\n\n                r1 = c_max / 2.0\n                r2 = math.sqrt(abs(c_max**2 - c_min**2)) / 2.0\n                r3 = r2\n\n                for _ in range(100):\n                    u = np.random.normal(0, 1, 3)\n                    norm_u = np.linalg.norm(u)\n                    if norm_u == 0:\n                        continue\n                    u = u / norm_u * (random.random() ** (1/3))\n                    sample = center_np + C @ np.array([r1 * u[0], r2 * u[1], r3 * u[2]])\n                    sample_clamped = np.clip(sample, np.zeros(3), np.array(bounds))\n                    sample_t = tuple(sample_clamped)\n                    if not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n                return start\n            else:\n                if c_max < c_min:\n                    c_max = c_min\n                c1, c2 = center\n                r1 = c_max / 2.0\n                r2 = math.sqrt(abs(c_max**2 - c_min**2)) / 2.0\n\n                dx = goal[0] - start[0]\n                dy = goal[1] - start[1]\n                length = math.hypot(dx, dy)\n                if length == 0:\n                    return start\n                cos_angle = dx / length\n                sin_angle = dy / length\n\n                for _ in range(100):\n                    theta = random.uniform(0, 2 * math.pi)\n                    rho = math.sqrt(random.uniform(0, 1))\n                    x_ball = rho * math.cos(theta)\n                    y_ball = rho * math.sin(theta)\n                    x_ell = r1 * x_ball\n                    y_ell = r2 * y_ball\n                    x_rot = cos_angle * x_ell - sin_angle * y_ell\n                    y_rot = sin_angle * x_ell + cos_angle * y_ell\n                    sample = (c1 + x_rot, c2 + y_rot)\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                return start\n\n        def edge_key(pos1, pos2):\n            return tuple(sorted([pos1, pos2]))\n\n        def edge_collision_cached(pos1, pos2):\n            key = edge_key(pos1, pos2)\n            return self._edge_collision_cache.get(key, None)\n\n        def cache_edge_collision(pos1, pos2, val):\n            key = edge_key(pos1, pos2)\n            self._edge_collision_cache[key] = val\n\n        def nearest(tree, point):\n            # Efficient nearest - improved in large scale with spatial index (omitted here)\n            min_node = None\n            min_dist = float('inf')\n            for n in tree:\n                d = dist(n.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = n\n            return min_node\n\n        def near(tree, pos, radius):\n            # Return nodes within radius\n            r2 = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= r2]\n\n        def neighbor_radius(num_nodes):\n            if num_nodes < 2:\n                return float('inf')\n            gamma = 30.0  # tuned gamma for practical performance (slightly smaller than reference)\n            unit_ball_vol = math.pi if dim == 2 else 4/3*math.pi\n            r = gamma * ((math.log(num_nodes) / num_nodes) ** (1/dim))\n            return max(r, self.step_size)\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        def shortcut_path(path, trials=300):\n            # Iterative shortcutting to improve smoothness and length\n            path = path[:]\n            if len(path) < 3:\n                return path\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        connect_start = None\n        connect_goal = None\n\n        c_min = dist(start, goal)\n        c_max = float('inf')\n        center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n        path_found = False\n\n        for itr in range(self.max_iter):\n            q_rand = ellipse_sample(center, c_min, c_max, start, goal) if path_found else sample_free_uniform()\n\n            # Alternate growth between two trees\n            tree_a, tree_b = (tree_start, tree_goal) if itr % 2 == 0 else (tree_goal, tree_start)\n\n            # Nearest node in the active tree\n            nearest_node = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_node.position, q_rand)\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            cached_col = edge_collision_cached(nearest_node.position, new_pos)\n            if cached_col is None:\n                in_collision = self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n                cache_edge_collision(nearest_node.position, new_pos, in_collision)\n                if in_collision:\n                    continue\n            elif cached_col:\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            r = neighbor_radius(len(tree_a))\n            nearby_nodes = near(tree_a, new_pos, r)\n\n            # Attempt rewiring for better path cost leveraging new node\n            for near_node in nearby_nodes:\n                if near_node is nearest_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new + 1e-8 < near_node.cost:\n                    cached_rewire = edge_collision_cached(new_node.position, near_node.position)\n                    if cached_rewire is None:\n                        in_col = self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d)\n                        cache_edge_collision(new_node.position, near_node.position, in_col)\n                    else:\n                        in_col = cached_rewire\n                    if not in_col:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Try connecting the opposite tree towards the new node\n            connect_node_b = nearest(tree_b, new_node.position)\n            prev_node_b = connect_node_b\n            connected = False\n\n            while True:\n                next_pos_b = steer(prev_node_b.position, new_node.position)\n                if not in_bounds(next_pos_b):\n                    break\n                if self._is_in_obstacle(next_pos_b, obstacles, is_3d):\n                    break\n\n                cached_edge_b = edge_collision_cached(prev_node_b.position, next_pos_b)\n                if cached_edge_b is None:\n                    collides = self._is_edge_in_obstacle(prev_node_b.position, next_pos_b, obstacles, is_3d)\n                    cache_edge_collision(prev_node_b.position, next_pos_b, collides)\n                    if collides:\n                        break\n                elif cached_edge_b:\n                    break\n\n                cost_b = prev_node_b.cost + dist(prev_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=prev_node_b, cost=cost_b)\n                prev_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((prev_node_b, new_node_b))\n\n                r_b = neighbor_radius(len(tree_b))\n                near_b = near(tree_b, next_pos_b, r_b)\n\n                # Rewire in tree_b if better cost routes found\n                for nb_node in near_b:\n                    if nb_node is prev_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, nb_node.position)\n                    if cost_via_new_b + 1e-8 < nb_node.cost:\n                        cached_rewire_b = edge_collision_cached(new_node_b.position, nb_node.position)\n                        if cached_rewire_b is None:\n                            in_col_b = self._is_edge_in_obstacle(new_node_b.position, nb_node.position, obstacles, is_3d)\n                            cache_edge_collision(new_node_b.position, nb_node.position, in_col_b)\n                        else:\n                            in_col_b = cached_rewire_b\n                        if not in_col_b:\n                            try:\n                                edges.remove((nb_node.parent, nb_node))\n                            except ValueError:\n                                pass\n                            nb_node.update_parent(new_node_b, cost_via_new_b)\n                            edges.append((new_node_b, nb_node))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size:\n                    cached_final = edge_collision_cached(new_node_b.position, new_node.position)\n                    if cached_final is None:\n                        col_final = self._is_edge_in_obstacle(new_node_b.position, new_node.position, obstacles, is_3d)\n                        cache_edge_collision(new_node_b.position, new_node.position, col_final)\n                    else:\n                        col_final = cached_final\n                    if not col_final:\n                        final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                        connect_node_goal = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                        new_node_b.children.append(connect_node_goal)\n                        tree_b.append(connect_node_goal)\n                        nodes.append(connect_node_goal)\n                        edges.append((new_node_b, connect_node_goal))\n\n                        if tree_a is tree_start:\n                            connect_start, connect_goal = new_node, connect_node_goal\n                        else:\n                            connect_start, connect_goal = connect_node_goal, new_node\n                        success_state = True\n                    break\n\n                prev_node_b = new_node_b\n\n            if success_state:\n                path_start = connect_start.path_from_root()\n                path_goal = connect_goal.path_from_root()\n                full_path = path_start + path_goal[::-1][1:]\n\n                c_max = path_length(full_path) + 1e-6\n                center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n                path_found = True\n\n                full_path = shortcut_path(full_path, trials=300)\n\n                return PlannerResult(\n                    success=True,\n                    path=full_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 27.08766,
    "time_improvement": -99.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.026720237731933594,
            "num_nodes_avg": 85.5,
            "path_length_avg": 160.015288134177,
            "success_improvement": -9.999999999999998,
            "time_improvement": -164.8498426112356,
            "length_improvement": 20.02589697696819,
            "objective_score": -50.44977338797704
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03510458469390869,
            "num_nodes_avg": 221.6,
            "path_length_avg": 236.88357593231632,
            "success_improvement": 0.0,
            "time_improvement": -145.41723962630527,
            "length_improvement": 21.394015377612472,
            "objective_score": -39.346368812369086
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02464323043823242,
            "num_nodes_avg": 258.4,
            "path_length_avg": 127.83759617032572,
            "success_improvement": 0.0,
            "time_improvement": 14.110523249968221,
            "length_improvement": 21.500014885060214,
            "objective_score": 8.53315995200251
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm presents an Enhanced Bi-directional Informed RRT* with adaptive multi-resolution sampling, KD-tree accelerated nearest neighbor search, collision caching, and dynamic replanning with lazy collision checking. It integrates visibility graph inspired edge batching for local shortcutting, and applies path smoothing via spline interpolation to produce high-quality, smooth, and robust paths efficiently while reducing computational overhead and improving success rates in complex 2D/3D environments.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal using an informed sampling strategy within an adaptive ellipsoidal region to focus search around promising path costs. It employs KD-tree structures for scalable nearest neighbor and radius queries. An edge-cache maintains collision results for faster pruning and rewiring decisions. Instead of immediate full collision checks on all rewires, lazy evaluation delays some checks until necessary, improving efficiency. Local shortcut edges connecting visibility neighbors are added to accelerate convergence. Once trees connect, a spline-smoothed path is extracted and further refined by shortcutting, ensuring smooth, shorter paths with reduced vertices.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]: 2D or 3D coords\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from root\n        self.children = []\n        self.valid = True                 # For collision and pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def is_leaf(self):\n        return len(self.children) == 0\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float=4.0,\n                 min_radius: float=5.0, max_radius: float=25.0,\n                 prune_interval: int=150, prune_threshold: int=250,\n                 smoothing_trials: int=75, collision_check_resolution: float=0.5,\n                 goal_sample_prob: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_prob = goal_sample_prob\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n        from collections import deque\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_radius * (1.0 - (iteration / self.max_iter) ** 0.98)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree substitute brute force for simplicity\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = self.nodes[i]\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Cached collision results for edges and nodes\n        edge_collision_cache = {}\n        node_collision_cache = {}\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if pos in node_collision_cache:\n                return not node_collision_cache[pos]\n            coll = is_in_obstacle(pos)\n            node_collision_cache[pos] = coll\n            return not coll\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            inv_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if inv_key in edge_collision_cache:\n                return not edge_collision_cache[inv_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            coll = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = coll\n            return not coll\n\n        def ellipse_sample(c_best, c_min, start, goal):\n            # Sample either uniformly or inside ellipsoid around best path\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_prob:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if can_add_node(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            diff = tuple(goal[d] - start[d] for d in range(dim))\n            a1 = tuple(diff[d] / c_min for d in range(dim))  # Unit vector along line\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2_val = math.sqrt(max(r1*r1 - (c_min/2)*(c_min/2), 0))\n            radii = np.array([r1] + [r2_val]*(dim-1))\n\n            tries = 100\n            for _ in range(tries):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-10:\n                    unit_x = x / norm_x\n                    scale = np.power(np.random.uniform(0, 1), 1/dim)\n                    sample = unit_x * scale * radii\n                    p = rot @ sample + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and can_add_node(p_tuple):\n                        return p_tuple\n            # fallback uniform\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if can_add_node(p):\n                    return p\n            return p  # last attempt\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth_path = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth_path) < 3:\n                    break\n                i = random.randint(0, len(smooth_path) - 3)\n                j = random.randint(i+2, len(smooth_path) - 1)\n                p1, p2 = smooth_path[i], smooth_path[j]\n                if can_connect(p1, p2):\n                    smooth_path = smooth_path[:i+1] + smooth_path[j:]\n            return smooth_path\n\n        def spline_smooth(path):\n            # If path length less than 4 or environment 1D, return path\n            if len(path) < 4 or dim < 2:\n                return path[:]\n            try:\n                import scipy.interpolate\n            except ImportError:\n                return path[:]\n\n            pts = np.array(path)\n            t = np.linspace(0, 1, len(pts))\n            splines = []\n            for d_ in range(dim):\n                spl = scipy.interpolate.UnivariateSpline(t, pts[:, d_], k=3, s=1e-1)\n                splines.append(spl)\n            fine_t = np.linspace(0, 1, max(len(pts)*5, 100))\n            smooth_pts = []\n            for ft in fine_t:\n                coord = tuple(float(spl(ft)) for spl in splines)\n                if not in_bounds(coord) or is_in_obstacle(coord):\n                    # fallback to original path on any invalid spline point\n                    return path[:]\n                smooth_pts.append(coord)\n            return smooth_pts\n\n        def prune_nodes(current_best_cost):\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= current_best_cost - 1e-8:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n            return len(to_remove)\n\n        # Visibility based edge batching for local shortcutting (connect within neighbor radius)\n        def add_visibility_edges(new_node, tree_nodes, radius):\n            if len(tree_nodes) < 2:\n                return\n            kdtree = KDTree([(n.position, n) for n in tree_nodes])\n            near = kdtree.radius_search(new_node.position, radius)\n            for neighbor in near:\n                if neighbor is new_node or neighbor is new_node.parent:\n                    continue\n                if can_connect(new_node.position, neighbor.position):\n                    cost_candidate = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_candidate + 1e-12 < neighbor.cost:\n                        try: edges.remove((neighbor.parent, neighbor))\n                        except ValueError: pass\n                        neighbor.update_parent(new_node, cost_candidate)\n                        edges.append((new_node, neighbor))\n                    elif neighbor.cost + 1e-12 < new_node.cost:\n                        cost_candidate = neighbor.cost + dist(neighbor.position, new_node.position)\n                        if cost_candidate + 1e-12 < new_node.cost and can_connect(neighbor.position, new_node.position):\n                            try: edges.remove((new_node.parent, new_node))\n                            except ValueError: pass\n                            new_node.update_parent(neighbor, cost_candidate)\n                            edges.append((neighbor, new_node))\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        # To limit repeated KD-tree rebuilds, update only once per iteration\n        for it in range(self.max_iter):\n            q_rand = ellipse_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_a:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Visibility edges local shortcutting\n            add_visibility_edges(new_node, tree_a, r)\n\n            # Rewire neighbors lazily with collision caching; do minimal checks here\n            for neighbor in near_a:\n                if neighbor is best_parent or neighbor is new_node:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, potential_cost)\n                    edges.append((new_node, neighbor))\n\n            # Connect other tree towards new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            for _step in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n\n                        # Shortcut and spline smooth\n                        shortcuted = shortcut_path(merged_path)\n                        smoothed = spline_smooth(shortcuted)\n                        best_path = smoothed if smoothed else shortcuted\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                edge_collision_cache.clear()\n                node_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 37.7429,
    "time_improvement": -140.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.017691659927368163,
            "num_nodes_avg": 77.0,
            "path_length_avg": 159.2966342497898,
            "success_improvement": 0.0,
            "time_improvement": -75.35896926901663,
            "length_improvement": 20.385073281045408,
            "objective_score": -18.530676124495905
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0584583044052124,
            "num_nodes_avg": 285.0,
            "path_length_avg": 237.22321480336223,
            "success_improvement": 0.0,
            "time_improvement": -308.68381795301315,
            "length_improvement": 21.281311709705044,
            "objective_score": -88.34888304396293
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03943338394165039,
            "num_nodes_avg": 183.9,
            "path_length_avg": 123.09702866575098,
            "success_improvement": 0.0,
            "time_improvement": -37.437854250507506,
            "length_improvement": 24.41100890946026,
            "objective_score": -6.349154493260198
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner synergizes the anytime informed bidirectional RRT* and adaptive lazy-collision bidirectional PRM* concepts to maximize efficiency, solution quality, and robustness. It leverages informed ellipsoidal sampling biased by the current best path, uses KD-tree accelerated neighbor searches, applies lazy collision checking with caching, adaptively adjusts neighbor radius, and prunes nodes that cannot improve the solution. Bidirectional asynchronous tree growth prioritizes the smaller tree for extension, with incremental backward connection attempts, iterative rewiring for cost improvements, and periodic aggressive pruning. Final paths undergo shortcut smoothing to enhance smoothness and quality, yielding faster convergence to shorter, smoother, and more reliable paths in both 2D and 3D environments.",
    "planning_mechanism": "The planner initializes two trees from start and goal, expanding the smaller tree each iteration by sampling in an evolving informed ellipsoid or adaptively near the best path. It efficiently connects and rewires neighbors using cached lazy collision checks and KD-tree queries, while incremental multi-step connection attempts link the trees. Periodic pruning discards nodes unlikely to improve the best path, maintaining manageable search space and high efficiency. Upon successfully connecting trees, the planner extracts and iteratively smooths the path with shortcutting to optimize quality before returning.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position             # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent                 # Node or None\n        self.cost = cost                    # Path cost from root\n        self.children: List[Node] = []      # For rewiring & pruning\n        self.valid = True                   # Mark valid/pruned\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_trials: int = 100, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math, random, numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes: int, iteration: int) -> float:\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            const_factor = max(n_nodes,1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration/self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(const_factor+1)/const_factor)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree helper (brute-force for portability)\n        class KDTree:\n            def __init__(self, points_nodes: List[Tuple[Tuple[float, ...], Node]]):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        edge_collision_cache = {}\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        # Informed ellipsoidal sample inside evolving domain biased by current best cost c_best\n        def informed_sample(c_best: float, c_min: float,\n                            start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)  # Householder reflection\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r2]*(dim-1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.power(np.random.uniform(0,1), 1/dim)  # Uniform in unit ball\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        # Adaptive sampling: sample near best known path with Gaussian noise, fallback to informed_sample\n        def adaptive_sample(best_path: List[Tuple[float, ...]], c_best: float, c_min: float) -> Tuple[float, ...]:\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size*0.5, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        # Shortcut smoothing by attempting to replace path segments with direct edges\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth)-3)\n                j = random.randint(i+2, len(smooth)-1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i+1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(nodes_list: List[Node], best_cost: float, root_s: Node, root_g: Node) -> int:\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialize roots and data structures\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            # Parent selection minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Connect tree_b to new_node incrementally\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _step in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                # Check connection to new_node position\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic pruning when a good path exists and node count is high\n            if (it > 0 and it % self.prune_interval == 0 and\n                len(nodes) > self.prune_threshold and c_best < float('inf')):\n                removed_s = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_g = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -3.32505,
    "time_improvement": -3.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.00928337574005127,
            "num_nodes_avg": 67.8,
            "path_length_avg": 158.71141409519754,
            "success_improvement": 0.0,
            "time_improvement": 7.9835805234948705,
            "length_improvement": 20.677560689468976,
            "objective_score": 6.530586294942257
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.019699525833129884,
            "num_nodes_avg": 196.3,
            "path_length_avg": 239.21164857839057,
            "success_improvement": 0.0,
            "time_improvement": -37.719995666341646,
            "length_improvement": 20.621482111442084,
            "objective_score": -7.191702277614077
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.022746777534484862,
            "num_nodes_avg": 159.5,
            "path_length_avg": 126.85899801843861,
            "success_improvement": 0.0,
            "time_improvement": 20.720263315996654,
            "length_improvement": 22.1009331020634,
            "objective_score": 10.636265615211677
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner that integrates informed ellipsoidal sampling, adaptive neighbor radius, KD-tree accelerated nearest neighbor searches, collision caching, incremental rewiring, periodic pruning, and aggressive shortcut smoothing. It focuses on improving planning efficiency, path quality, robustness, success rate, and path smoothness in both 2D and 3D spaces.",
    "planning_mechanism": "The planner grows two trees from start and goal by alternately sampling points inside an informed ellipsoidal domain based on the best path cost. It uses KD-trees for efficient nearest neighbor and radius searches, caches collision checks to minimize redundant tests, and dynamically adjusts neighbor radius for rewiring. After successful connections, it aggressively smooths the path and periodically prunes nodes unlikely to improve solutions, thereby reducing computational overhead and boosting convergence speed and solution quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=150,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle tuples\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                # Uniform sampling with rejection inside obstacles\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) * (c_min / 2), 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    # Uniform sampling inside unit ball\n                    radius_factor = np.random.uniform(0,1) ** (1/dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Balance tree extension: extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node_ in near_nodes:\n                candidate_cost = node_.cost + dist(node_.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node_.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node_\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connect opposite tree towards new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to reduce search space and improve efficiency\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -4.01111,
    "time_improvement": -1.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.008940935134887695,
            "num_nodes_avg": 64.8,
            "path_length_avg": 155.6068476254887,
            "success_improvement": 0.0,
            "time_improvement": 11.377837015190611,
            "length_improvement": 22.229193171498764,
            "objective_score": 7.859189738856937
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02347726821899414,
            "num_nodes_avg": 211.7,
            "path_length_avg": 233.929666318002,
            "success_improvement": 0.0,
            "time_improvement": -64.130309773233,
            "length_improvement": 22.37422252285186,
            "objective_score": -14.764248427399524
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.014677858352661133,
            "num_nodes_avg": 137.3,
            "path_length_avg": 127.9558261152494,
            "success_improvement": 0.0,
            "time_improvement": 48.84300672831869,
            "length_improvement": 21.42741457658537,
            "objective_score": 18.93838493381268
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner implements a bidirectional RRT*-inspired algorithm using adaptive informed ellipsoidal sampling combined with KD-tree assisted neighbor queries and lazy collision checking for efficient rewiring. It dynamically adjusts the neighborhood radius for rewiring, prunes nodes unlikely to improve the current best path, and applies iterative shortcut smoothing to generate smooth, high-quality paths. This approach balances exploration and exploitation, reducing collision checks and computational overhead, thus improving planning efficiency, robustness, path quality, and success rate in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees from start and goal, alternately extending the smaller tree by sampling new points inside an adaptively updated ellipsoidal subset informed by the current best path cost. KD-trees accelerate nearest neighbor and radius searches. Nodes and edges are added only after strict collision checks. Rewiring is performed locally to minimize path costs. Periodic pruning discards nodes unlikely to yield better paths. Upon connecting the two trees, the extracted path is shortcut smoothed iteratively to enhance smoothness and reduce length.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position            # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent                # Node or None\n        self.cost = cost                   # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True                  # For pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_from_parent(self):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n            self.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        self.remove_from_parent()\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval: int=150, prune_threshold: int=250,\n                 smoothing_trials: int=75, collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            factor = math.log(n_nodes) / n_nodes\n            r = self.max_neighbor_radius * (factor ** 0.5)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        # KD-tree helper (brute-force for portability)\n        class KDTree:\n            def __init__(self, points_nodes: List[Tuple[Tuple[float, ...], Node]]):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        edge_collision_cache = {}\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def ellipse_sample(c_best: float, c_min: float,\n                           start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            import numpy as np\n\n            # If no valid best path or spiraling conditions, random sample\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)  # Householder reflection\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r2]*(dim-1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1,1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.power(np.random.uniform(0,1), 1/dim)  # Uniform in unit ball\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p_tuple  # fallback\n\n        def adaptive_sample(best_path: List[Tuple[float, ...]]) -> Tuple[float, ...]:\n            import numpy as np\n            if best_path:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size/2, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return ellipse_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth)-3)\n                j = random.randint(i+2, len(smooth)-1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i+1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(nodes_list: List[Node], best_cost: float, root_s: Node, root_g: Node) -> int:\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialize start and goal nodes and trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges: List[Tuple[Node, Node]] = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path)\n\n            # Grow smaller tree to balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(len(nodes))\n            near_nodes_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if better\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Try connecting tree_b towards new_node incrementally\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes))\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                # Optional: keep searching for better paths after found first\n                pass\n\n            # Periodic pruning to reduce size and improve efficiency\n            if (it > 0 and it % self.prune_interval == 0 and\n                len(nodes) > self.prune_threshold and c_best < float('inf')):\n                removed_s = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_g = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 1106.26517,
    "time_improvement": -3705.0,
    "length_improvement": 25.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.48041601181030275,
            "num_nodes_avg": 3452.8,
            "path_length_avg": 148.61774976768814,
            "success_improvement": 0.0,
            "time_improvement": -4661.8627645596425,
            "length_improvement": 25.722277105135795,
            "objective_score": -1393.4143739468655
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.6483152151107788,
            "num_nodes_avg": 1857.1,
            "path_length_avg": 240.55289922888738,
            "success_improvement": 0.0,
            "time_improvement": -4432.391762715538,
            "length_improvement": 20.176409769078237,
            "objective_score": -1325.6822468608457
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.6080802202224731,
            "num_nodes_avg": 4622.0,
            "path_length_avg": 113.12523283456942,
            "success_improvement": 0.0,
            "time_improvement": -2019.3524959261968,
            "length_improvement": 30.53429226089327,
            "objective_score": -599.6988903256803
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a streamlined bidirectional RRT* algorithm with informed ellipsoidal sampling, adaptive neighbor radius, efficient collision checking, incremental rewiring, and periodic pruning to optimize path quality and planning speed. It is designed for general 2D/3D environments, balancing exploration and exploitation for robust and smooth path generation.",
    "planning_mechanism": "The planner grows two trees from start and goal, alternately expanding toward adaptively sampled points within an informed ellipsoid once a preliminary path is found. Nearest neighbor and radius searches are done directly for simplicity, with strict collision checks on nodes and edges. Incremental rewiring improves path cost locally. When the two trees connect, the combined path undergoes shortcut smoothing. Periodic pruning removes nodes unlikely to yield better solutions, accelerating convergence and improving success rates.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D point\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking or pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = 5.0\n        self.max_radius = 30.0\n        self.prune_interval = 200\n        self.prune_threshold = 300\n        self.smoothing_iterations = 50\n        self.collision_resolution = 1.0\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                    # Tuple[int, ...]\n        start_pos = map.start                # Tuple[float, ...]\n        goal_pos = map.goal                  # Tuple[float, ...]\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        import math\n        import random\n        import numpy as np\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            length = dist(p1, p2)\n            steps = max(1, int(length / self.collision_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def neighbor_radius(iteration, n_nodes):\n            n = max(n_nodes, 1)\n            r_iter = self.max_radius * (1 - (iteration / self.max_iter) ** 0.9)\n            r_log = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.min_radius, min(r_iter, r_log))\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            I = np.eye(dim)\n            u = a1 - I[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = I - 2 * np.outer(u, u)\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1**2 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r_others] * (dim-1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n            return p\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((a - b)**2 for a,b in zip(node.position, point)) <= r2]\n\n        def prune_nodes(nodes_list, tree_start, tree_goal, best_cost):\n            to_remove = []\n            for node in nodes_list:\n                if node is root_start or node is root_goal:\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n\n        for iter_count in range(self.max_iter):\n            sample = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            nearest_a = nearest_node(tree_a, sample)\n            new_pos = steer(nearest_a.position, sample)\n\n            if (not in_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_a.position, new_pos):\n                continue\n\n            radius = neighbor_radius(iter_count, len(nodes))\n            neighbors = near_nodes(tree_a, new_pos, radius)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in neighbors:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            nearest_b = nearest_node(tree_b, new_node.position)\n            last_node_b = nearest_b\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not in_bounds(next_pos_b) or is_in_obstacle(next_pos_b) or is_edge_in_obstacle(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = radius\n                neighbors_b = near_nodes(tree_b, next_pos_b, radius_b)\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new + 1e-12 < neighbor_b.cost and not is_edge_in_obstacle(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and not is_edge_in_obstacle(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            if iter_count > 0 and iter_count % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -7.23208,
    "time_improvement": 10.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007624602317810059,
            "num_nodes_avg": 74.4,
            "path_length_avg": 161.42554980527825,
            "success_improvement": 0.0,
            "time_improvement": 24.42527105842762,
            "length_improvement": 19.32106174847733,
            "objective_score": 11.19179366722375
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.018499875068664552,
            "num_nodes_avg": 204.4,
            "path_length_avg": 235.10113718615062,
            "success_improvement": 0.0,
            "time_improvement": -29.333199989999258,
            "length_improvement": 21.985488856176815,
            "objective_score": -4.402862225764413
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.018863773345947264,
            "num_nodes_avg": 168.3,
            "path_length_avg": 125.14108614416223,
            "success_improvement": 0.0,
            "time_improvement": 34.253764891920625,
            "length_improvement": 23.155834481621554,
            "objective_score": 14.907296363900498
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner implements a highly optimized bidirectional RRT* algorithm integrating adaptive informed sampling that balances bias towards start and goal, dynamically shrinking neighbor radius for efficient rewiring, and aggressive pruning of dead nodes to maintain search space efficiency. It alternates growth on the smaller tree to balance exploration, uses strict collision and edge checks for safety and robustness, and applies an advanced multi-iteration shortcut smoothing method post path extraction to minimize path length and improve path smoothness. These combined strategies reduce planning time, increase success rates, and produce shorter, smoother paths with robustness in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two RRT* trees simultaneously from start and goal points, sampling points adaptively biased towards both roots to focus search on promising regions. Each iteration extends the smaller tree towards sampled points, rewires neighbors using a dynamically reduced radius, then attempts to connect the other tree to form a full path. Dead-end nodes are periodically pruned to avoid unnecessary growth. Once a feasible path is found, extensive randomized shortcut smoothing is applied to iteratively improve path quality while ensuring collision-free connectivity, resulting in efficient, high-quality path planning.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=25.0,\n                 radius_min: float=4.0, prune_interval: int=200,\n                 prune_threshold: int=100, smoothing_iterations: int=80,\n                 edge_resolution: float=0.25):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.edge_resolution = edge_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def dist_sq(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return sum((a[d] - b[d])**2 for d in range(len(a)))\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def sample_free() -> Tuple[float, ...]:\n            p_bias = 0.75\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: dist_sq(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree if dist_sq(node.position, pos) <= r_sq]\n\n        def radius_dynamic(n_nodes: int) -> float:\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.edge_resolution)\n\n        def add_node(parent: Node, new_pos: Tuple[float, ...], cost_to_new: float, tree: List[Node]) -> Node:\n            new_node = Node(new_pos, parent=parent, cost=cost_to_new)\n            parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node\n\n        def try_extend(tree: List[Node], sample_pt: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = add_node(best_parent, new_pos, min_cost, tree)\n\n            # Rewire neighbors for local optimization\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree: List[Node], target_node: Node) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, target_node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not can_add_node(new_pos) or not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = add_node(last_node, new_pos, new_cost, tree)\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if can_connect(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    if node.parent:\n                        try:\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    try:\n                        nodes.remove(node)\n                    except ValueError:\n                        pass\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    if node in tree_start:\n                        tree_start.remove(node)\n                    if node in tree_goal:\n                        tree_goal.remove(node)\n                    removed.append(node)\n            return removed\n\n        def path_length(path: List[Tuple[float, ...]]) -> float:\n            total = 0.0\n            for i in range(len(path) - 1):\n                total += dist(path[i], path[i + 1])\n            return total\n\n        def shortcut_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            smoothed_path = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(smoothed_path) < 3:\n                    break\n                i = random.randint(0, len(smoothed_path) - 3)\n                j = random.randint(i + 2, len(smoothed_path) - 1)\n                p1 = smoothed_path[i]\n                p2 = smoothed_path[j]\n                if can_connect(p1, p2):\n                    smoothed_path = smoothed_path[:i+1] + smoothed_path[j:]\n            return smoothed_path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Alternate growth on the smaller tree\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                    prune_dead_nodes()\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed_path = shortcut_smoothing(raw_path)\n                if path_length(smoothed_path) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 56.61114,
    "time_improvement": -202.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03484635353088379,
            "num_nodes_avg": 88.2,
            "path_length_avg": 163.0556780735417,
            "success_improvement": 0.0,
            "time_improvement": -245.39555152237003,
            "length_improvement": 18.506339307971885,
            "objective_score": -69.91739759511663
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06296405792236329,
            "num_nodes_avg": 143.7,
            "path_length_avg": 238.73741435960497,
            "success_improvement": 0.0,
            "time_improvement": -340.18368044269994,
            "length_improvement": 20.77884906929281,
            "objective_score": -97.89933431895142
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03466134071350098,
            "num_nodes_avg": 90.5,
            "path_length_avg": 128.44805978648338,
            "success_improvement": 0.0,
            "time_improvement": -20.805769551968933,
            "length_improvement": 21.125153449792457,
            "objective_score": -2.016700175632188
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved planner implements a bidirectional RRT* algorithm incorporating adaptive goal/start bias sampling with dynamic neighbor radius rewiring to minimize path cost. It balances growth by always extending the smaller tree, rigorously applies collision and edge feasibility checks, and optimizes the found path with iterative shortcut smoothing. Additionally, it performs periodic pruning of dead-end nodes to keep tree sizes manageable and improves convergence speed and path quality. The rewiring step carefully updates parents to ensure minimal-cost routes, enhancing path optimality and robustness.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal, alternately extending the smaller tree towards biased random samples favoring start or goal positions. It uses a dynamic neighbor radius for local rewiring to improve path costs continuously. Periodic pruning removes dead-end nodes to maintain efficiency, while shortcut smoothing is applied after path connection to reduce length and improve smoothness. This combination balances exploration versus exploitation, leading to faster convergence, increased success rate, and shorter, smoother paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=20.0,\n                 radius_min: float=5.0, prune_interval: int=150,\n                 prune_threshold: int=150, smoothing_iterations: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        import random\n        import math\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            # Adaptive bias towards goal and start to promote faster connections\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < 0.6 else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            if not in_bounds(pos) or self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            to_remove = [node for node in nodes if node not in (start_root, goal_root) and not node.children]\n            for node in to_remove:\n                try:\n                    if node.parent:\n                        node.parent.children.remove(node)\n                    nodes.remove(node)\n                    edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                    removed.append(node)\n                except Exception:\n                    continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend smaller tree to balance exploration/exploitation\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed_path = shortcut_smoothing(raw_path)\n                if path_length(smoothed_path) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -4.59249,
    "time_improvement": 1.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.004982614517211914,
            "num_nodes_avg": 68.5,
            "path_length_avg": 157.43983697259313,
            "success_improvement": 0.0,
            "time_improvement": 50.6125400561495,
            "length_improvement": 21.313082713587217,
            "objective_score": 19.44637855956229
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.026825737953186036,
            "num_nodes_avg": 179.7,
            "path_length_avg": 240.30043302847486,
            "success_improvement": 0.0,
            "time_improvement": -87.53956546741006,
            "length_improvement": 20.260186595686807,
            "objective_score": -22.209832321085653
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01701357364654541,
            "num_nodes_avg": 144.0,
            "path_length_avg": 127.59148971666832,
            "success_improvement": 0.0,
            "time_improvement": 40.70229786583415,
            "length_improvement": 21.651139073308062,
            "objective_score": 16.540917174411856
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This planner leverages a hybrid anytime RRT*-based algorithm with adaptive heuristic-biased sampling and dynamic tree balancing. It integrates a dynamic neighbor radius based on iteration count and node density, collision caching for efficient repeated checks, and bidirectional incremental rewiring with asymmetrical tree growth prioritizing the smaller tree. To enhance performance and path quality, the algorithm incorporates a multi-resolution shortcut smoothing with adaptive node pruning guided by heuristic cost-to-go estimates and cost improvements. The approach emphasizes robust rapid convergence toward the optimum path with minimal computational overhead, ensuring smoother, shorter, and feasible paths in both 2D and 3D spaces.",
    "planning_mechanism": "The planner alternately extends two trees rooted at start and goal by sampling points weighted by a heuristic-informed mechanism that biases sampling nearer the current best path and goal vicinities. It adaptively calculates neighbor radius for rewiring to optimize local paths while collision caches eliminate redundant checks. Extending nodes occur only if collision-free at node and edge levels, and trees attempt connections incrementally, rewiring neighbors to improve costs. Periodic pruning removes nodes unlikely to improve the path. After finding a connection, a multi-pass shortcut smoothing process refines path quality. The planner balances exploration and exploitation dynamically, aiming for fast convergence to a high-quality, smooth path within bounded iterations.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision/validation flags\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        # Parameters for adaptive radius and pruning\n        self.min_neighbor_radius = 3.5\n        self.max_neighbor_radius = 25.0\n        self.prune_interval = 150\n        self.prune_threshold = 250\n        self.smoothing_passes = 3\n        self.shortcut_iterations_per_pass = 75\n        self.collision_check_resolution = 1.0\n        self.goal_sample_rate = 0.18  # Bias towards goal\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def heuristic(p):\n            return dist(p, goal_pos)\n\n        def adaptive_neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            decay_factor = 1.0 - (iteration / self.max_iter) ** 1.05\n            r_iter = self.max_neighbor_radius * decay_factor\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or random.random() < self.goal_sample_rate:\n                for _ in range(15):\n                    sample_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample_pt, obstacles, is_3d):\n                        return sample_pt\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center_np = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            vec = a1 - id_mat[:, 0]\n            norm_vec = np.linalg.norm(vec)\n            if norm_vec > 1e-10:\n                u = vec / norm_vec\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_orth = math.sqrt(max(r1**2 - (c_min/2.0)**2, 0))\n            radii = np.array([r1] + [r_orth] * (dim - 1))\n\n            for _ in range(120):\n                x_ball = np.random.uniform(-1, 1, size=dim)\n                norm_x = np.linalg.norm(x_ball)\n                if 1e-15 < norm_x <= 1.0:\n                    radius_scale = np.random.uniform() ** (1/dim)\n                    x_scaled = (x_ball / norm_x) * radius_scale\n                    sample_ellipse = x_scaled * radii\n                    sample_np = rot @ sample_ellipse + center_np\n                    sample = tuple(float(v) for v in sample_np)\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            # Fallback uniform random sampling\n            for _ in range(15):\n                sample_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample_pt, obstacles, is_3d):\n                    return sample_pt\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        class KDTree:\n            def __init__(self, nodes_list):\n                self.dim = dim\n                self.points = [node.position for node in nodes_list]\n                self.nodes = nodes_list\n\n            def nearest(self, point):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, point)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, point, radius):\n                r2 = radius * radius\n                result = []\n                for p, n in zip(self.points, self.nodes):\n                    diff_sq = 0.0\n                    for d_ in range(self.dim):\n                        diff = p[d_] - point[d_]\n                        diff_sq += diff * diff\n                        if diff_sq > r2:\n                            break\n                    else:\n                        result.append(n)\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]  # True if free\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos): \n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def shortcut_path(path):\n            path = list(path)\n            if len(path) < 3:\n                return path\n\n            for _ in range(self.smoothing_passes):\n                num_iterations = self.shortcut_iterations_per_pass\n                attempts = 0\n                while attempts < num_iterations and len(path) >= 3:\n                    i = random.randint(0, len(path) - 3)\n                    j = random.randint(i + 2, len(path) - 1)\n                    if can_connect(path[i], path[j]):\n                        path = path[:i + 1] + path[j:]\n                    attempts += 1\n            return path\n\n        def prune_nodes(nodes_list, tree_s, tree_g, best_cost):\n            h = lambda p: dist(p, goal_pos)\n            to_remove = []\n            threshold_upper = best_cost * 1.005\n            threshold_lower = best_cost * 0.99\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                est_cost = node.cost + h(node.position)\n                if est_cost > threshold_upper or (not node.children and est_cost >= threshold_lower):\n                    to_remove.append(node)\n\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_s:\n                    try: tree_s.remove(node)\n                    except ValueError: pass\n                if node in tree_g:\n                    try: tree_g.remove(node)\n                    except ValueError: pass\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Always grow smaller tree first to balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree(tree_a)\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = adaptive_neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + dist(near_node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(near_node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near neighbors to go via the new node if cheaper\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_via_new + 1e-12 < near_node.cost and can_connect(new_node.position, near_node.position):\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                    except ValueError:\n                        pass\n                    near_node.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, near_node))\n\n            # Incremental connection attempts from opposite tree toward new_node\n            kdtree_b = KDTree(tree_b)\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = merged_path\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                # Multi-pass shortcut smoothing for improved path quality\n                extracted_path = shortcut_path(best_path)\n                break\n\n            # Periodic pruning for efficiency and robustness\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = shortcut_path(best_path) if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -6.4631,
    "time_improvement": 7.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009128785133361817,
            "num_nodes_avg": 69.5,
            "path_length_avg": 158.07584947840263,
            "success_improvement": 0.0,
            "time_improvement": 9.515875941733066,
            "length_improvement": 20.99520977621579,
            "objective_score": 7.053804737763079
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.018969392776489256,
            "num_nodes_avg": 220.7,
            "path_length_avg": 236.91172981208757,
            "success_improvement": 0.0,
            "time_improvement": -32.615612837629484,
            "length_improvement": 21.384672967816226,
            "objective_score": -5.5077492577255995
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.015922069549560547,
            "num_nodes_avg": 157.2,
            "path_length_avg": 126.28001688452363,
            "success_improvement": 0.0,
            "time_improvement": 44.50653595042799,
            "length_improvement": 22.456462396697518,
            "objective_score": 17.8432532644679
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid path planning algorithm synergizes adaptive informed ellipsoidal sampling, bidirectional tree growth, dynamic neighbor radius rewiring, goal/start biased sampling, incremental connection attempts, and periodic pruning. It balances exploration and exploitation by always extending the smaller tree, focuses sampling within an informed subset when a solution is found, and applies rigorous collision and edge feasibility checks. After path discovery, the algorithm performs iterative shortcut smoothing to improve smoothness and optimality while pruning non-promising and dead-end nodes to maintain computational efficiency and robustness. This integrated approach aims to enhance planning efficiency, path quality, robustness, and success rate in both 2D and 3D cluttered environments.",
    "planning_mechanism": "The planner grows two trees from start and goal with bidirectional RRT*-inspired rewiring and adaptive informed ellipsoidal sampling to focus search in promising areas. Goal/start biased sampling promotes faster connections. Expansion always occurs on the smaller tree to balance growth. Incremental connection attempts between trees help accelerate feasible path discovery. Periodic pruning removes dead-end and non-promising nodes. After path extraction, iterative shortcut smoothing refines the trajectory for smoothness and length optimization. Collision checking ensures nodes and edges lie in free space, preventing invalid expansions.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 prune_interval: int = 150, prune_threshold: int = 200,\n                 smoothing_iterations: int = 50, collision_resolution: float = 1.0,\n                 connect_steps_factor: int = 5,\n                 radius_max: float = 30.0, radius_min: float = 5.0,\n                 radius_constant: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_resolution = collision_resolution\n        self.connect_steps_factor = connect_steps_factor\n        self.radius_max = radius_max\n        self.radius_min = radius_min\n        self.radius_constant = radius_constant\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size              # Tuple[int, ...] (W,H) or (W,H,D)\n        start = map.start              # Tuple[float, ...]\n        goal = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles      # Obstacles list (2D or 3D)\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root_start = Node(start, cost=0.0)\n        root_goal = Node(goal, cost=0.0)\n        nodes.extend([root_start, root_goal])\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = math.dist(start, goal)\n        best_path = []\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp strictly\n            new_p = tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n            return new_p\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance_edge = dist(p1, p2)\n            steps = max(1, int(distance_edge / self.collision_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def radius_by_iteration_and_nodes(iteration, n_nodes):\n            n = max(n_nodes, 1)\n            r_iter = self.radius_max * (1 - (iteration / self.max_iter) ** 0.9)\n            r_log = self.radius_min + (self.radius_max - self.radius_min) * math.sqrt(math.log(n + 1) / n)\n            return max(self.radius_min, min(r_iter, r_log))\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def informed_sample(c_best, c_min, start, goal):\n            # If no path or path close to min dist, sample uniformly with goal/start bias\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # Goal/start bias sampling for efficiency\n                for _ in range(10):\n                    if random.random() < self.goal_sample_rate:\n                        p = goal if random.random() < 0.6 else start\n                    else:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Ellipsoidal informed sampling inside ellipsoid subset defined by c_best\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            # Construct rotation matrix for ellipse principal axis alignment\n            I = np.eye(dim)\n            u_vec = direction - I[:, 0]\n            norm_u = np.linalg.norm(u_vec)\n            if norm_u > 1e-10:\n                u_vec /= norm_u\n                rot = I - 2 * np.outer(u_vec, u_vec)\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # fallback uniform sampling\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - point[d]) ** 2 for d in range(dim)) <= r2]\n\n        def prune_dead_and_nonpromising(nodes_list, tree_s, tree_g, c_best_current):\n            remove_cands = []\n            for node in nodes_list:\n                if node is root_start or node is root_goal:\n                    continue\n                # Dead node detection: no children\n                if not node.children:\n                    remove_cands.append(node)\n                    continue\n                # Heuristic cost pruning (cost + heuristic)\n                h_cost = dist(node.position, goal)\n                if node.cost + h_cost >= c_best_current:\n                    remove_cands.append(node)\n            for node in remove_cands:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_s:\n                    try:\n                        tree_s.remove(node)\n                    except ValueError:\n                        pass\n                if node in tree_g:\n                    try:\n                        tree_g.remove(node)\n                    except ValueError:\n                        pass\n\n        def shortcut_path(path: list):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Planning main loop\n        for itr in range(self.max_iter):\n            sample_pt = informed_sample(c_best, c_min, start, goal)\n\n            # Always extend smaller tree to balance exploration/exploitation\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            nearest_a = nearest_node(tree_a, sample_pt)\n            new_pos = steer(nearest_a.position, sample_pt)\n\n            if (not in_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_a.position, new_pos):\n                continue\n\n            r = radius_by_iteration_and_nodes(itr, len(nodes))\n            neighbors = near_nodes(tree_a, new_pos, r)\n\n            # Choose best parent from neighbors minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in neighbors:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors locally in tree_a\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connection attempt from other tree (tree_b)\n            nearest_b = nearest_node(tree_b, new_node.position)\n            last_b = nearest_b\n            max_connect_steps = int(dist(last_b.position, new_node.position) / self.step_size) * self.connect_steps_factor + 1\n            connected = False\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if (not in_bounds(next_pos_b)) or is_in_obstacle(next_pos_b) or is_edge_in_obstacle(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                # Rewire neighbors in tree_b around new_node_b\n                neighbors_b = near_nodes(tree_b, next_pos_b, r)\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and not is_edge_in_obstacle(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                # Check if close enough to connect\n                if dist(new_node_b.position, new_node.position) <= self.step_size and not is_edge_in_obstacle(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Extract full path from start to goal\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning of dead and non-promising nodes to improve efficiency\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_dead_and_nonpromising(nodes, tree_start, tree_goal, c_best)\n\n        if success_state and extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 9.25748,
    "time_improvement": -45.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.00981605052947998,
            "num_nodes_avg": 88.5,
            "path_length_avg": 158.95333344852241,
            "success_improvement": 0.0,
            "time_improvement": 2.703731011730895,
            "length_improvement": 20.556651721884293,
            "objective_score": 4.922449647896127
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03134276866912842,
            "num_nodes_avg": 270.7,
            "path_length_avg": 240.42870944172887,
            "success_improvement": 0.0,
            "time_improvement": -119.11826720337359,
            "length_improvement": 20.21762014198492,
            "objective_score": -31.691956132615093
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.034293508529663085,
            "num_nodes_avg": 240.8,
            "path_length_avg": 123.32504919577585,
            "success_improvement": 0.0,
            "time_improvement": -19.523757687459323,
            "length_improvement": 24.27099056783716,
            "objective_score": -1.002929192670365
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner merges the bidirectional RRT* approach with adaptive ellipsoidal informed sampling, KD-tree assisted neighbor search, collision caching, dynamic rewiring, and progressive pruning of suboptimal nodes. It emphasizes balanced tree growth, fast neighbor retrieval, and iterative shortcut smoothing to efficiently find high-quality, smooth paths in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees from start and goal, alternately extending the smaller tree towards samples biased inside an ellipsoidal informed set defined by the current best path. KD-trees accelerate nearest and radius neighbor searches for rewiring. Collision checks are cached to reduce redundant computation. After each new node addition and rewiring, the opposite tree tries incremental connection. Periodic pruning removes nodes unlikely to improve solutions. Finally, the best path is shortcut-smoothed iteratively for improved quality and smoothness.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position          # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Path cost from root\n        self.children = []\n        self.valid = True                 # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_from_parent(self):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n            self.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        self.remove_from_parent()\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval: int=200, prune_threshold: int=300,\n                 smoothing_iterations: int=100, collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d_] + ratio * (to_pos[d_] - from_pos[d_]) for d_ in range(dim))\n            return tuple(max(0, min(new_pos[d_], bounds[d_])) for d_ in range(dim))\n\n        def neighbor_radius(iteration: int, n_nodes: int) -> float:\n            c = max(n_nodes,1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c+1)/c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def _is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def _is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-Tree substitute for simplicity (brute force)\n        class KDTree:\n            def __init__(self, pts_nodes: List[Tuple[Tuple[float, ...], Node]]):\n                self.dim = dim\n                self.points = [p for p,n in pts_nodes]\n                self.nodes = [n for p,n in pts_nodes]\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt,p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                r2 = radius*radius\n                result = []\n                for i,p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best: float, c_min: float,\n                            start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not _is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d]+goal[d])/2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - np.array([1 if d==0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2*np.outer(u,u)\n            else:\n                rot = id_mat\n\n            r1 = c_best/2.0\n            val = max(r1**2 - (c_min/2)**2,0)\n            r_others = math.sqrt(val) if val>0 else 0.0\n            radii = np.array([r1] + [r_others]*(dim-1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    x_scaled = x/norm_x * (random.uniform(0,1)**(1/dim))\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + center\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not _is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not _is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = _is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and not _is_in_obstacle(pos)\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost: float) -> int:\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_position)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_position, cost=0.0)\n        root_goal = Node(goal_position, cost=0.0)\n        nodes: List[Node] = [root_start, root_goal]\n        edges: List[Tuple[Node, Node]] = []\n        tree_start: List[Node] = [root_start]\n        tree_goal: List[Node] = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_position, goal_position)\n        best_path: List[Tuple[float, ...]] = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_position, goal_position)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connect opposite tree\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 4.94049,
    "time_improvement": -31.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.011316800117492675,
            "num_nodes_avg": 78.3,
            "path_length_avg": 160.73744750936106,
            "success_improvement": 0.0,
            "time_improvement": -12.171634101844237,
            "length_improvement": 19.664968662283727,
            "objective_score": 0.2815035019034746
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.025171446800231933,
            "num_nodes_avg": 232.3,
            "path_length_avg": 234.5763235176912,
            "success_improvement": 0.0,
            "time_improvement": -75.97436474402247,
            "length_improvement": 22.159639786608256,
            "objective_score": -18.360381465885087
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03008854389190674,
            "num_nodes_avg": 217.1,
            "path_length_avg": 124.43530379349541,
            "success_improvement": 0.0,
            "time_improvement": -4.86812179611291,
            "length_improvement": 23.589227361975116,
            "objective_score": 3.25740893356115
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This improved planner implements an adaptive bidirectional RRT* algorithm with informed ellipsoidal sampling, KD-tree accelerated nearest neighbor and radius searches, incremental rewiring, collision caching, node pruning, and shortcut path smoothing. Parameters are tuned for balanced exploration and exploitation to optimize planning efficiency, path quality, robustness, success rate, and path smoothness in 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal by alternately sampling within an adaptive informed ellipsoid around the best path found so far, steering and connecting nodes with collision checks. KD-tree enables efficient rewiring and neighbor search to minimize path costs. Periodic pruning removes unpromising nodes, while shortcut smoothing refines the final path to improve smoothness and shorten length, effectively reducing search time and increasing solution quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000,\n                 step_size: float = 7.0,\n                 min_neighbor_radius: float = 8.0,\n                 max_neighbor_radius: float = 25.0,\n                 prune_interval: int = 150,\n                 prune_threshold: int = 250,\n                 smoothing_iterations: int = 75,\n                 collision_check_resolution: float = 0.8):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.92)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / self.collision_check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return True\n            return False\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, _ in points_nodes]\n                self.nodes = [n for _, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            rev_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return not edge_collision_cache[rev_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(15):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(120):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    x = x * radii\n                    p = rot @ x + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            to_remove = []\n            for node in nodes:\n                if node is root_start or node is root_goal:\n                    continue\n                heuristic = dist(node.position, goal_position)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n\n        root_start = Node(start_position, cost=0.0)\n        root_goal = Node(goal_position, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_position, goal_position)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_position, goal_position)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors for cost improvement\n            for neighbor in near_nodes_a:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 2\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_nodes_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 0.80819,
    "time_improvement": 7.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.012637472152709961,
            "num_nodes_avg": 64.7,
            "path_length_avg": 170.93077416424242,
            "success_improvement": -9.999999999999998,
            "time_improvement": -25.262078287912736,
            "length_improvement": 14.570441973300548,
            "objective_score": -9.66453509171371
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.014993429183959961,
            "num_nodes_avg": 147.2,
            "path_length_avg": 239.8349819129623,
            "success_improvement": 0.0,
            "time_improvement": -4.819528131276512,
            "length_improvement": 20.414639022725936,
            "objective_score": 2.637069365162234
        },
        {
            "map_id": 2,
            "success_rate": 0.7,
            "time_avg": 0.014238810539245606,
            "num_nodes_avg": 121.3,
            "path_length_avg": 126.28298006652187,
            "success_improvement": -30.000000000000004,
            "time_improvement": 50.37322765682168,
            "length_improvement": 22.454642824445514,
            "objective_score": 4.602896861935605
        }
    ],
    "success_rate": 0.8666666666666666
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a simplified and generalized bidirectional informed RRT* algorithm that balances exploration and exploitation through adaptive informed ellipsoidal sampling, efficient neighbor selection, lazy collision checking, incremental rewiring, and periodic pruning. It aims to improve path quality, smoothness, success rate, and planning efficiency in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal positions within an adaptively shrinking ellipsoidal sampling region informed by the best path found so far. Nodes are steered towards sampled points with careful bound and collision checks. Neighborhood radius adapts dynamically with tree growth for effective rewiring aimed at lowering path cost. Trees attempt incremental connection via collision-checked edges, and periodic pruning removes nodes unlikely to improve the best path. The final path undergoes shortcut smoothing to enhance smoothness and reduce length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...] (2D or 3D)\n        self.parent = parent              # Parent Node or None\n        self.cost = cost                  # Cost from root\n        self.children = []\n        self.valid = True                 # For pruning or collision status\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_from_parent(self):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n            self.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        self.remove_from_parent()\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 150, prune_threshold: int = 300,\n                 smoothing_trials: int = 50, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(src, dest):\n            d = dist(src, dest)\n            if d <= self.step_size:\n                new_p = dest\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(src[d] + ratio * (dest[d] - src[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(min(max(new_p[d], 0), bounds[d]) for d in range(dim))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            factor = math.log(n_nodes) / n_nodes\n            r = self.max_neighbor_radius * (factor ** 0.5)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        class KDTree:\n            def __init__(self, nodes):\n                self.nodes = nodes\n                self.points = [node.position for node in nodes]\n\n            def nearest(self, point):\n                best_node = None\n                best_dist = float('inf')\n                for node in self.nodes:\n                    d = dist(point, node.position)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = node\n                return best_node\n\n            def radius_search(self, point, radius):\n                radius_sq = radius * radius\n                res = []\n                for node in self.nodes:\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = node.position[d_] - point[d_]\n                        sqd += delta * delta\n                        if sqd > radius_sq:\n                            break\n                    else:\n                        res.append(node)\n                return res\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not (in_bounds(p1) and in_bounds(p2)):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def ellipse_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)  # Householder reflection\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.power(np.random.uniform(0, 1), 1 / dim)  # Uniform in unit ball\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p_tuple  # fallback\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i + 2, len(smooth) - 1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i + 1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(tree_nodes, best_cost, root_s, root_g):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in tree_nodes:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    tree_nodes.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = ellipse_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree(tree_a)\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(len(nodes))\n            near_nodes_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better via new_node\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Attempt connect other tree incrementally\n            kdtree_b = KDTree(tree_b)\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes))\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            # Optional: could continue searching for better paths after first success\n\n            # Periodic pruning for efficiency\n            if (it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n            if connected:\n                # Break early or continue to improve paths (choice here: break)\n                break\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -11.12807,
    "time_improvement": 24.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.006794548034667969,
            "num_nodes_avg": 67.8,
            "path_length_avg": 164.9801412286517,
            "success_improvement": 0.0,
            "time_improvement": 32.65273327094499,
            "length_improvement": 17.544511120019376,
            "objective_score": 13.304722205287373
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.015869450569152833,
            "num_nodes_avg": 198.3,
            "path_length_avg": 243.29064806763898,
            "success_improvement": 0.0,
            "time_improvement": -10.943820786558996,
            "length_improvement": 19.267932082215065,
            "objective_score": 0.5704401804753148
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.014382410049438476,
            "num_nodes_avg": 157.7,
            "path_length_avg": 125.82457365547616,
            "success_improvement": 0.0,
            "time_improvement": 49.8727378033124,
            "length_improvement": 22.73613197569439,
            "objective_score": 19.509047736132597
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner implements an improved bidirectional informed RRT* algorithm combining adaptive informed ellipse sampling, balanced tree growth, lazy collision checking, dynamic neighborhood rewiring radius, periodic pruning of low-potential branches, and iterative shortcut smoothing. It integrates incremental lazy edge validation to reduce collision check overhead, applies heuristic-driven guidance to sample efficiently within promising regions, and employs pruning to focus search and reduce planning time while improving path quality, success rate, and smoothness in both 2D and 3D maps.",
    "planning_mechanism": "The planner grows two trees bidirectionally from start and goal, alternately expanding the smaller tree for balanced growth. Sampling is done using an informed ellipse bounded by the current best path cost, concentrating exploration on promising areas. Nodes are added after collision and lazy edge collision checks. Dynamic rewiring optimizes path costs locally. Dead-end and low-potential branches are pruned periodically to enhance efficiency. On successful connection, the path is extracted and smoothed with shortcutting to reduce length and jaggedness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def is_leaf(self):\n        return len(self.children) == 0\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float = 0.15,\n                 radius_constant: float = 30.0, radius_min: float = 5.0,\n                 prune_interval: int = 300, prune_threshold: int = 150,\n                 smoothing_trials: int = 60):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_pos = map.goal                # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n\n        success = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def heuristic(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def steer(from_p, to_p):\n            dist = heuristic(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(len(from_p)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: heuristic(n.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            dim = len(pos)\n            result = []\n            for n in tree:\n                dist_sq = 0.0\n                for d in range(dim):\n                    dist_sq += (n.position[d] - pos[d])**2\n                    if dist_sq > r2:\n                        break\n                if dist_sq <= r2:\n                    result.append(n)\n            return result\n\n        def dynamic_radius(n):\n            if n <= 1:\n                return self.radius_constant\n            return max(self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1)), self.radius_min)\n\n        # Informed sampling inside an ellipse between start and goal based on best cost\n        def informed_sample(cost_best):\n            if cost_best == float('inf'):\n                # Uniform random sampling in bounds avoiding obstacles\n                if random.random() < self.goal_sample_rate:\n                    return goal_pos\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                        return p\n            else:\n                c_min = heuristic(start_pos, goal_pos)\n                c_best = max(cost_best, c_min * 1.0001)  # safeguard\n\n                center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(len(start_pos)))\n                vec = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(len(start_pos)))\n\n                import numpy as np\n\n                dim = len(start_pos)\n                # Ellipse axes lengths\n                L_diag = [c_best / 2] + [math.sqrt(c_best ** 2 - c_min ** 2) / 2] * (dim - 1)\n                L = np.diag(L_diag)\n\n                e1 = np.array(vec)\n                # Orthonormal basis matrix C:\n                if dim == 2:\n                    e2 = np.array([-e1[1], e1[0]])\n                    C = np.column_stack((e1, e2))\n                else:\n                    # Gram-Schmidt for 3D basis\n                    a = np.array([1., 0., 0.])\n                    if abs(np.dot(a, e1)) > 0.9:\n                        a = np.array([0., 1., 0.])\n                    v2 = a - np.dot(a, e1) * e1\n                    v2 /= np.linalg.norm(v2)\n                    v3 = np.cross(e1, v2)\n                    C = np.column_stack((e1, v2, v3))\n\n                while True:\n                    sample_in_unit_ball = np.random.uniform(-1, 1, dim)\n                    if np.linalg.norm(sample_in_unit_ball) > 1.0:\n                        continue\n                    sample = C @ (L @ sample_in_unit_ball) + np.array(center)\n                    sample_t = tuple(float(x) for x in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n\n        # Lazy edge collision cache\n        lazy_checked_edges = set()\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            if not (in_bounds(p1) and in_bounds(p2)):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def try_extend(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = dynamic_radius(n_nodes)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + heuristic(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            # Lazy collision checking for selecting parent\n            for node in near:\n                tentative_cost = node.cost + heuristic(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    edge_check_key = (node, new_pos)\n                    if edge_check_key not in lazy_checked_edges:\n                        if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                            lazy_checked_edges.add(edge_check_key)\n                        else:\n                            continue\n                    else:\n                        # Already verified free\n                        pass\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            # Final edge check before adding new node and edge\n            if self._is_edge_in_obstacle(best_parent.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if cheaper path found via new_node\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + heuristic(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + heuristic(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                dist_to_goal = heuristic(new_pos, node.position)\n                if dist_to_goal <= self.step_size:\n                    if not self._is_in_obstacle(node.position, obstacles, is_3d) and \\\n                       not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + dist_to_goal)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_branches():\n            removed = []\n            for node in nodes[:]:\n                # prune leaf nodes except roots\n                if node.is_leaf() and node is not start_root and node is not goal_root:\n                    # Also prune nodes with no potential: heuristic + cost > current best path cost\n                    if hasattr(self, 'best_path_cost') and node.cost + heuristic(node.position, goal_pos) >= getattr(self, 'best_path_cost', float('inf')):\n                        try:\n                            if node.parent:\n                                node.parent.children.remove(node)\n                            nodes.remove(node)\n                            edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                            removed.append(node)\n                        except Exception:\n                            pass\n            return removed\n\n        def shortcut_path(raw_path):\n            if len(raw_path) < 3:\n                return raw_path\n            smoothed = raw_path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                p_i = smoothed[i]\n                p_j = smoothed[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    smoothed = smoothed[:i + 1] + smoothed[j:]\n            return smoothed\n\n        best_path_cost = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n\n        tree_turn = 0  # 0:start tree grows, 1:goal tree grows\n\n        for itr in range(self.max_iter):\n            sample_pt = informed_sample(best_path_cost)\n\n            # Grow the smaller tree to balance exploration\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n                tree_turn = 1 - tree_turn  # flip turn accordingly\n\n            if tree_turn == 0:\n                new_node = try_extend(tree_start, sample_pt)\n                if new_node:\n                    connect_node = try_connect(tree_goal, new_node)\n                    if connect_node:\n                        success = True\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n                        candidate_path = path_start + path_goal[::-1][1:]\n                        candidate_cost = sum(heuristic(candidate_path[i], candidate_path[i + 1]) for i in range(len(candidate_path) - 1))\n                        if candidate_cost < best_path_cost:\n                            best_path_cost = candidate_cost\n                            best_path = candidate_path\n                            self.best_path_cost = best_path_cost\n                            # Improve path by shortcutting after each improvement\n                            best_path = shortcut_path(best_path)\n                            extracted_path = best_path\n                        break\n                tree_turn = 1\n            else:\n                new_node = try_extend(tree_goal, sample_pt)\n                if new_node:\n                    connect_node = try_connect(tree_start, new_node)\n                    if connect_node:\n                        success = True\n                        path_goal = new_node.path_from_root()\n                        path_start = connect_node.path_from_root()\n                        candidate_path = path_start + path_goal[::-1][1:]\n                        candidate_cost = sum(heuristic(candidate_path[i], candidate_path[i + 1]) for i in range(len(candidate_path) - 1))\n                        if candidate_cost < best_path_cost:\n                            best_path_cost = candidate_cost\n                            best_path = candidate_path\n                            self.best_path_cost = best_path_cost\n                            best_path = shortcut_path(best_path)\n                            extracted_path = best_path\n                        break\n                tree_turn = 0\n\n            # Periodic pruning to limit tree size and focus on promising branches\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_branches()\n\n        # Final smoothing on path if found\n        if success and extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 41.03117,
    "time_improvement": -150.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.010256791114807129,
            "num_nodes_avg": 71.2,
            "path_length_avg": 160.07642757461787,
            "success_improvement": 0.0,
            "time_improvement": -1.664870638724253,
            "length_improvement": 19.995340072277386,
            "objective_score": 3.4996068228382016
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.038149333000183104,
            "num_nodes_avg": 300.2,
            "path_length_avg": 246.08398367861372,
            "success_improvement": 0.0,
            "time_improvement": -166.70316940437198,
            "length_improvement": 18.341008823744055,
            "objective_score": -46.34274905656278
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.10965025424957275,
            "num_nodes_avg": 448.0,
            "path_length_avg": 127.02817943359605,
            "success_improvement": 0.0,
            "time_improvement": -282.16592530793463,
            "length_improvement": 21.997045521496815,
            "objective_score": -80.25036848808102
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This implementation is an optimized bidirectional informed RRT* planner that accelerates convergence by adaptive ellipsoidal sampling focused on the current best path, efficient nearest neighbor and radius searches via KD-tree, collision caching with fast lookup to avoid redundant checks, incremental rewiring for path cost improvements, periodic pruning of nodes unlikely to improve the best solution, and shortcut smoothing to refine the final path for reduced length and improved smoothness. These enhancements collectively minimize planning time while maximizing path quality, robustness, and success rate in both 2D and 3D environments.",
    "planning_mechanism": "The planner builds two trees rooted at the start and goal positions, grows them alternately, and biases sampling within a dynamically adapting ellipsoid enclosing the current shortest path estimate. Connections between nodes are made only after collision and obstacle intersection checks. A KD-tree accelerates neighbor queries for rewiring and extension steps. Pruning removes nodes that cannot improve the known best cost, and shortcut smoothing refines the final path. Collision checks are cached to avoid redundant expensive computations, further speeding up the search.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision status\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            # Householder reflection matrix to rotate unit vector a1 to x-axis\n            v = a1_np - np.array([1] + [0]*(dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + np.array(center)\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors for cost improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -2.91188,
    "time_improvement": -5.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009558582305908203,
            "num_nodes_avg": 72.5,
            "path_length_avg": 157.12652174772785,
            "success_improvement": 0.0,
            "time_improvement": 5.2557449262210625,
            "length_improvement": 21.4696746515466,
            "objective_score": 5.870658408175639
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.020438408851623534,
            "num_nodes_avg": 202.2,
            "path_length_avg": 233.96171182835747,
            "success_improvement": 0.0,
            "time_improvement": -42.88554974956454,
            "length_improvement": 22.36358873836805,
            "objective_score": -8.392947177195751
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.022094321250915528,
            "num_nodes_avg": 176.4,
            "path_length_avg": 127.3519737102936,
            "success_improvement": 0.0,
            "time_improvement": 22.994280472087492,
            "length_improvement": 21.798216329909117,
            "objective_score": 11.257927407608072
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved planner implements a bidirectional anytime RRT* algorithm with adaptive heuristic-biased sampling focusing on rapid convergence to minimal-length paths. It enhances neighbor radius adaptation, incorporates a refined incremental rewiring scheme prioritizing cost-effective parent selection, and integrates an enhanced multi-resolution shortcut smoothing with adaptive node pruning based on cost improvements and heuristic guidance. Collision caching optimizes repeated obstacle checks. The tree growth balances exploration and exploitation by always expanding the smaller tree, with symmetric incremental connections and pruning to maintain computational efficiency. Overall, these improvements reduce path length, smoothness cost, and planning time, while preserving robustness and higher success rates in both 2D and 3D environments.",
    "planning_mechanism": "The planner alternately grows two trees rooted at start and goal using heuristic-informed samples concentrated within informed subsets shaped by the current best costs. It adaptively calculates neighbor radii for rewiring and node connections, performs incremental connection attempts with collision checks, and rewires nodes to minimize path costs. Node pruning removes states unlikely to yield better solutions periodically. Upon connecting trees, a multi-pass shortcut smoothing refines the path, promoting shorter and smoother routes. This dynamic balance between exploration and exploitation ensures rapid discovery and continuous improvement of feasible, high-quality paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from root\n        self.children = []\n        self.valid = True                 # For collision checking if needed\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = 3.5\n        self.max_neighbor_radius = 25.0\n        self.prune_interval = 150\n        self.prune_threshold = 250\n        self.smoothing_passes = 4\n        self.shortcut_iterations_per_pass = 100\n        self.collision_check_resolution = 1.0\n        self.goal_sample_rate = 0.18\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                candidate = to_pos\n            else:\n                ratio = self.step_size / d\n                candidate = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp inside bounds\n            return tuple(max(0.0, min(candidate[d], bounds[d])) for d in range(dim))\n\n        def heuristic(p):\n            return dist(p, goal_pos)\n\n        def adaptive_neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            decay = 1.0 - (iteration / self.max_iter) ** 1.05\n            r_iter = self.max_neighbor_radius * decay\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def informed_sample(c_best, c_min, start, goal):\n            # Goal biased or uniform random if no solution yet\n            if c_best == float('inf') or random.random() < self.goal_sample_rate:\n                attempts = 0\n                while attempts < 20:\n                    sample_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample_pt, obstacles, is_3d):\n                        return sample_pt\n                    attempts += 1\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center_np = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            vec = a1 - id_mat[:, 0]\n            norm_vec = np.linalg.norm(vec)\n            if norm_vec > 1e-10:\n                u = vec / norm_vec\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_orth = math.sqrt(max(r1 ** 2 - (c_min / 2.0) ** 2, 0))\n            radii = np.array([r1] + [r_orth] * (dim - 1))\n\n            for _ in range(150):\n                x_ball = np.random.uniform(-1, 1, size=dim)\n                norm_x = np.linalg.norm(x_ball)\n                if 1e-15 < norm_x <= 1.0:\n                    radius_scale = np.random.uniform() ** (1 / dim)\n                    x_scaled = (x_ball / norm_x) * radius_scale\n                    sample_ellipse = x_scaled * radii\n                    sample_np = rot @ sample_ellipse + center_np\n                    sample = tuple(float(v) for v in sample_np)\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            # fallback uniform\n            for _ in range(20):\n                sample_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample_pt, obstacles, is_3d):\n                    return sample_pt\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        class KDTree:\n            def __init__(self, nodes_list):\n                self.dim = dim\n                self.points = [node.position for node in nodes_list]\n                self.nodes = nodes_list\n\n            def nearest(self, point):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, point)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, point, radius):\n                r2 = radius * radius\n                result = []\n                for p, n in zip(self.points, self.nodes):\n                    diff_sq = 0.0\n                    for d_ in range(self.dim):\n                        diff = p[d_] - point[d_]\n                        diff_sq += diff * diff\n                        if diff_sq > r2:\n                            break\n                    else:\n                        result.append(n)\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def shortcut_path(path):\n            # Multi-pass shortcut smoothing with adaptive pruning\n            path = list(path)\n            if len(path) < 3:\n                return path\n\n            for _ in range(self.smoothing_passes):\n                iterations = self.shortcut_iterations_per_pass\n                tries = 0\n                while tries < iterations and len(path) >= 3:\n                    i = random.randint(0, len(path) - 3)\n                    j = random.randint(i + 2, len(path) - 1)\n                    if can_connect(path[i], path[j]):\n                        path = path[: i + 1] + path[j:]\n                    tries += 1\n            return path\n\n        def prune_nodes(nodes_list, tree_s, tree_g, best_cost):\n            # Prune nodes that cannot beat best_cost by cost + heuristic\n            h = lambda p: dist(p, goal_pos)\n            to_remove = []\n            upper_thres = best_cost * 1.005\n            lower_thres = best_cost * 0.99\n\n            for node in nodes_list:\n                if node is root_start or node is root_goal:\n                    continue\n                est_cost = node.cost + h(node.position)\n                # Prune nodes unlikely to improve solution\n                if est_cost > upper_thres or (not node.children and est_cost >= lower_thres):\n                    to_remove.append(node)\n\n            for node in to_remove:\n                # Disconnect from parent & children\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                for child in node.children:\n                    child.parent = None\n                node.children.clear()\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_s:\n                    try:\n                        tree_s.remove(node)\n                    except ValueError:\n                        pass\n                if node in tree_g:\n                    try:\n                        tree_g.remove(node)\n                    except ValueError:\n                        pass\n\n        # Initialization\n        root_start = Node(start_pos, None, 0.0)\n        root_goal = Node(goal_pos, None, 0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Expand smaller tree first for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree(tree_a)\n            nearest_a = kdtree_a.nearest(q_rand)\n\n            new_pos = steer(nearest_a.position, q_rand)\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = adaptive_neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            # Choose best parent minimizing cost + edge cost with valid connection\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for near in near_nodes:\n                cost_candidate = near.cost + dist(near.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(near.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = near\n\n            new_node = Node(new_pos, best_parent, min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near neighbors if cheaper path through new_node and valid edge\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, near.position)\n                if cost_via_new + 1e-12 < near.cost and can_connect(new_node.position, near.position):\n                    try:\n                        edges.remove((near.parent, near))\n                    except ValueError:\n                        pass\n                    near.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, near))\n\n            # Attempt incremental connection from opposite tree towards new_node\n            kdtree_b = KDTree(tree_b)\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, last_b, cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                # Rewire neighbors around new_node_b if improved path\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connect_node = Node(new_node.position, new_node_b, final_cost)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = merged_path\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                extracted_path = shortcut_path(best_path)\n                # Continue searching to improve path: do not break immediately.\n                # But prune periodically now since a solution exists.\n            else:\n                # If no connection, continue\n\n                pass\n\n            # Prune to maintain tree sizes and focus search on promising areas\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = shortcut_path(best_path) if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 1608.60877,
    "time_improvement": -5377.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.0623547792434693,
            "num_nodes_avg": 103.6,
            "path_length_avg": 160.42548416927866,
            "success_improvement": 0.0,
            "time_improvement": -10430.014699070794,
            "length_improvement": 19.820884941222268,
            "objective_score": -3125.0402327329934
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.5747358083724976,
            "num_nodes_avg": 742.4,
            "path_length_avg": 231.75567822993725,
            "success_improvement": 0.0,
            "time_improvement": -3917.9958496887266,
            "length_improvement": 23.0956253197621,
            "objective_score": -1170.7796298426656
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.5404867649078369,
            "num_nodes_avg": 543.6,
            "path_length_avg": 121.12880368717022,
            "success_improvement": 0.0,
            "time_improvement": -1783.7678584634969,
            "length_improvement": 25.619617614176406,
            "objective_score": -530.0064340162137
        }
    ],
    "success_rate": 1.0
}
