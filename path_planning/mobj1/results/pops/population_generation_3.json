[
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and            not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if not self._is_in_obstacle(new_pos, obstacles, is_3d) and                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -14.547310392594369,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0033696174621582033,
                    "num_nodes_avg": 59.1,
                    "path_length_avg": 170.9770888905735,
                    "success_improvement": 0.0,
                    "time_improvement": 66.60049721615668,
                    "length_improvement": 14.547294318234119,
                    "objective_score": 22.889608028493825
               },
               {
                    "map_id": 1,
                    "success_rate": 0.7,
                    "time_avg": 0.008120989799499512,
                    "num_nodes_avg": 195.7,
                    "path_length_avg": 276.36470377614694,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": 43.2259086098124,
                    "length_improvement": 8.292841453028517,
                    "objective_score": -0.3736591264505782
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.004628038406372071,
                    "num_nodes_avg": 134.2,
                    "path_length_avg": 154.99263582978188,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 83.8698177944377,
                    "length_improvement": 4.825184687042764,
                    "objective_score": 21.125982275739858
               }
          ]
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -6.05410676996533,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009668374061584472,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "success_improvement": 0.0,
                    "time_improvement": 4.167493784798042,
                    "length_improvement": 12.401486536989607,
                    "objective_score": 3.730545442837334
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019790220260620116,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "success_improvement": 0.0,
                    "time_improvement": -38.35404321990816,
                    "length_improvement": 14.190408824541839,
                    "objective_score": -8.668131201064078
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.00882866382598877,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "success_improvement": 0.0,
                    "time_improvement": 69.22930545503195,
                    "length_improvement": 11.655572158065754,
                    "objective_score": 23.099906068122735
               }
          ]
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for iter_num in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or            self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, new_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            connect_node.parent = best_parent\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n\n            nearest = connect_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -4.22512875357786,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007775163650512696,
                    "num_nodes_avg": 63.6,
                    "path_length_avg": 157.74844317172378,
                    "success_improvement": 0.0,
                    "time_improvement": 22.932913629961522,
                    "length_improvement": 21.158844301429212,
                    "objective_score": 11.111642949274298
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.019913077354431152,
                    "num_nodes_avg": 236.6,
                    "path_length_avg": 218.9843001436935,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -39.21294097057279,
                    "length_improvement": 27.333600643728058,
                    "objective_score": -16.29716216242622
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.008108234405517578,
                    "num_nodes_avg": 131.2,
                    "path_length_avg": 111.23634768618506,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 71.74023055938031,
                    "length_improvement": 31.694181530357035,
                    "objective_score": 17.860905473885502
               }
          ]
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements an anytime informed bidirectional RRT* variant with fast heuristic-informed sampling focusing search within an evolving ellipsoidal domain defined by currently best solution. It adaptively refines path quality by rewiring, employs KD-tree for nearest neighbor search, caches collision checks, prunes suboptimal branches, and applies iterative path smoothing. The bidirectional approach grows trees from start and goal asynchronously, prioritizing the smaller for extension, and connects them efficiently through incremental extension steps. Focused sampling and aggressive pruning reduce search space and improve convergence, producing shorter, smoother paths rapidly and robustly.",
          "planning_mechanism": "The planner initializes two trees from start and goal positions and iteratively samples points biased inside an informed ellipsoid that shrinks as better paths are found. The smaller tree is extended towards sampled points using RRT* style rewiring and cost optimization, with nearest neighbor queries accelerated by KD-tree. Connection attempts between trees are done incrementally with collision checking and caching. Periodic pruning removes unnecessary nodes, and the final path undergoes shortcut smoothing to improve quality and smoothness. This strategy improves planning efficiency, success rate, and path optimality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent: \n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def is_descendant_of(self, node):\n        \"\"\"Check if this node is descendant of given node.\"\"\"\n        cur = self.parent\n        while cur:\n            if cur == node:\n                return True\n            cur = cur.parent\n        return False\nclass Planner:\n    def __init__(self, max_iter: int =5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval:int=200, prune_threshold:int=300, smoothing_iterations:int=100,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clip to bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes,1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration/self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c+1)/c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1,p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree helper class for fast queries\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p,n in points_nodes]\n                self.nodes = [n for p,n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i,p in enumerate(self.points):\n                    d = dist(pt,p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i,p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d]-pt[d]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Sampling inside ellipsoid informed by current best path cost\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf'):\n                # No solution yet - uniform sample\n                for _ in range(10):\n                    p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Ellipsoidal sampling between start and goal (informed RRT*)\n            center = tuple((start[d] + goal[d])/2 for d in range(dim))\n            a1 = tuple((goal[d]-start[d])/c_min for d in range(dim))  # unit vector from start to goal\n\n            # Rotation matrix from unit vector to x-axis using Householder transform approximation for dim=2 or 3\n            import numpy as np\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d==0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u,u)\n            else:\n                rot = id_mat  # Already aligned\n\n            # Ellipsoid radii\n            r1 = c_best / 2.0\n            r_others = math.sqrt(r1**2 - (c_min/2)**2)\n            radii = [r1] + [r_others]*(dim-1)\n\n            # Sample a random point in unit ball\n            while True:\n                x = np.random.uniform(-1,1,dim)\n                if np.linalg.norm(x) <= 1:\n                    break\n            x = np.array(x)\n            # Scale with radii\n            x = x * radii\n            # Rotate to original coordinate system\n            p = rot @ x\n            # Translate back to center\n            p = p + np.array(center)\n\n            p_tuple = tuple(float(coord) for coord in p)\n            if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                return p_tuple\n            else:\n                # fallback uniform sampling if outside or collision\n                for _ in range(10):\n                    fallback_p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(fallback_p):\n                        return fallback_p\n                return fallback_p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1,p2):\n            if (p1,p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1,p2)]\n            if (p2,p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2,p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1,p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1,p2)\n            edge_collision_cache[(p1,p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        # Initialize trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal  = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        # Best path cost and path\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        def rebuild_kdtree():\n            return KDTree([(node.position, node) for node in nodes])\n\n        kd_tree = rebuild_kdtree()\n\n        def prune_useless_nodes():\n            # Prune nodes that cannot improve best path to reduce complexity\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                # Don't prune roots\n                if node in (root_start, root_goal):\n                    continue\n                # Prune if cost + heuristic > best path cost\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= c_best:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                # Remove from trees if present\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed +=1\n            return removed\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1,p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n            # Alternate, always extend smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Build KD-tree for tree_a subset\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest.position, new_pos):\n                continue\n\n            # Neighbor search radius\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for node in near:\n                c_p = node.cost + dist(node.position, new_pos)\n                if c_p + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = c_p\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cost improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try to connect tree_b to new_node incrementally\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_extend_steps = int(dist(last_node_b.position, new_node.position)/self.step_size) + 1\n\n            for _ in range(max_extend_steps):\n                new_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(new_pos_b) or not can_connect(last_node_b.position, new_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, new_pos_b)\n                new_node_b = Node(new_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(new_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_b_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_b_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_b_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Update best path cost and path\n                    c_best = final_cost\n                    best_path = merged_path\n\n                    # Shortcut smoothing\n                    best_path = shortcut_path(best_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_useless_nodes()\n                kd_tree = rebuild_kdtree()\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            # fallback if improved path not assigned\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -1.99103,
          "time_improvement": -7.0,
          "length_improvement": 21.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013820695877075195,
                    "num_nodes_avg": 90.8,
                    "path_length_avg": 165.68594819008476,
                    "success_improvement": 0.0,
                    "time_improvement": -36.99014075187401,
                    "length_improvement": 17.191755584556482,
                    "objective_score": -7.658691108650905
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.018435454368591307,
                    "num_nodes_avg": 189.5,
                    "path_length_avg": 235.2552560057235,
                    "success_improvement": 0.0,
                    "time_improvement": -28.882832879132593,
                    "length_improvement": 21.934347017770815,
                    "objective_score": -4.2779804601856135
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016191697120666503,
                    "num_nodes_avg": 153.5,
                    "path_length_avg": 123.44301109039233,
                    "success_improvement": 0.0,
                    "time_improvement": 43.56679831912523,
                    "length_improvement": 24.19855485839855,
                    "objective_score": 17.90975046741728
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a streamlined bidirectional RRT* with adaptive informed sampling and efficient rewiring in both 2D and 3D. It incorporates essential collision and bounds checks, incremental tree growth from start and goal, periodic pruning, and shortcut path smoothing to balance exploration, path quality, and computational efficiency. The approach uses dynamic neighbor radius based on iteration and node count to optimize rewiring and refines paths progressively while maintaining robustness against obstacles and reducing search time.",
          "planning_mechanism": "The planning mechanism simultaneously grows two RRT* trees from start and goal, alternating expansions focused on samples drawn adaptively within an informed ellipsoid when a path is found to guide search in promising areas. Each extension uses steering with collision and bounds checks. Nearby nodes within a dynamic radius are rewired to minimize path cost while pruning removes non-promising nodes to maintain manageable complexity. Upon connection of the two trees, the path is extracted and shortcut-smoothed to enhance smoothness and shorten length, delivering an efficient and robust solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = 5.0\n        self.max_radius = 30.0\n        self.prune_interval = 200\n        self.prune_threshold = 300\n        self.smoothing_iterations = 50\n        self.collision_resolution = 1.0\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        import math\n        import random\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            n = max(n_nodes, 1)\n            r_iter = self.max_radius * (1 - (iteration / self.max_iter) ** 0.9)\n            r_log = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.min_radius, min(r_iter, r_log))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance_edge = dist(p1, p2)\n            steps = max(1, int(distance_edge / self.collision_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        # Ellipsoidal informed sampling to bias towards promising areas\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            I = np.eye(dim)\n            u = direction - I[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = I - 2 * np.outer(u, u)\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback\n\n        # KD-tree substitute: linear search for neighbors and nearest node (simplify for clarity)\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            result = [node for node in tree if sum((a - b) ** 2 for a, b in zip(node.position, point)) <= r2]\n            return result\n\n        # Prune nodes that cannot improve the best path\n        def prune_nodes(nodes, tree_start, tree_goal, best_cost):\n            to_remove = []\n            for node in nodes:\n                if node is root_start or node is root_goal:\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n\n        # Shortcut smoothing to improve path quality\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate expanding smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            nearest_a = nearest_node(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if (not in_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            neighbors = near_nodes(tree_a, new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in neighbors:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improvements\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt incremental connection from other tree\n            nearest_b = nearest_node(tree_b, new_node.position)\n            last_b = nearest_b\n            max_connect_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            connected = False\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if (not in_bounds(next_pos_b)) or is_in_obstacle(next_pos_b) or is_edge_in_obstacle(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                # Rewire neighbors around new_node_b\n                neighbors_b = near_nodes(tree_b, next_pos_b, r)\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is last_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and not is_edge_in_obstacle(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and not is_edge_in_obstacle(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Extract and merge path\n                    if tree_a is tree_start:\n                        path_from_start = connection_node.path_from_root()\n                        path_from_goal = new_node.path_from_root()\n                    else:\n                        path_from_start = new_node.path_from_root()\n                        path_from_goal = connection_node.path_from_root()\n\n                    merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic pruning to remove nodes that cannot improve path\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )",
          "objective": -1.08481,
          "time_improvement": -10.0,
          "length_improvement": 21.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.00862126350402832,
                    "num_nodes_avg": 59.7,
                    "path_length_avg": 160.531158757098,
                    "success_improvement": 0.0,
                    "time_improvement": 14.546408416754108,
                    "length_improvement": 19.768069797921118,
                    "objective_score": 8.317536484610455
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026832151412963866,
                    "num_nodes_avg": 241.5,
                    "path_length_avg": 244.1143260176625,
                    "success_improvement": 0.0,
                    "time_improvement": -87.58440216349558,
                    "length_improvement": 18.994607872132015,
                    "objective_score": -22.47639907462227
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016585564613342284,
                    "num_nodes_avg": 163.0,
                    "path_length_avg": 124.13203186042806,
                    "success_improvement": 0.0,
                    "time_improvement": 42.19404514297159,
                    "length_improvement": 23.775454598287087,
                    "objective_score": 17.413304462548894
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm integrating adaptive goal biasing, dynamic neighborhood radius, and adaptive step sizing. It optimizes node connections with efficient rewiring and carefully balanced tree growth. Heuristic goal-biased sampling accelerates convergence, and rigorous collision checks ensure path feasibility. Post-processing with shortcut smoothing further refines the path quality, achieving reduced planning time and higher success rates.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal with biased sampling towards both ends, adapting the step length based on obstacle proximity for efficient exploration. It rewires nodes within a shrinking radius proportional to the tree size to locally optimize costs. The connection attempts between trees are incremental and maintain collision safety. The extracted path undergoes iterative shortcut smoothing to improve smoothness and minimize length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.25,\n                 radius_const: float=25.0,\n                 radius_min: float=5.0,\n                 smoothing_iter: int=60,\n                 collision_resolution: float=0.5,\n                 adaptive_step_min: float=1.5,\n                 adaptive_step_max: float=7.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.smoothing_iter = smoothing_iter\n        self.collision_resolution = collision_resolution\n        self.adaptive_step_min = adaptive_step_min\n        self.adaptive_step_max = adaptive_step_max\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(point):\n            for i, val in enumerate(point):\n                if val < 0 or val > bounds[i]:\n                    return False\n            return True\n\n        def sample_point():\n            # Adaptive goal biasing with occasional start bias to diversify\n            if random.random() < self.goal_sample_rate:\n                if random.random() < 0.85:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest(tree, point):\n            # Cached distance computation for speed\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                dist = distance(node.position, point)\n                if dist < best_dist:\n                    best_dist = dist\n                    best_node = node\n            return best_node\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_const\n            r = self.radius_const * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, r)\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius*radius\n            near = []\n            for node in tree:\n                dx = node.position[0] - pos[0]\n                dy = node.position[1] - pos[1]\n                dz = node.position[2] - pos[2] if is_3d else 0.0\n                dist_sq = dx*dx + dy*dy + dz*dz\n                if dist_sq <= r_sq:\n                    near.append(node)\n            return near\n\n        def adaptive_step(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            # Adaptive step based on minimum distance, clipped by min/max step\n            step = min(self.adaptive_step_max, max(self.adaptive_step_min, dist))\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def collision_free(node_pos):\n            return (in_bounds(node_pos) and not self._is_in_obstacle(node_pos, obstacles, is_3d))\n\n        def edge_collision_free(pos1, pos2):\n            if not in_bounds(pos2):\n                return False\n            return not self._is_edge_in_obstacle(pos1, pos2, obstacles, is_3d, self.collision_resolution)\n\n        def add_node(tree, new_node, parent_node):\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = adaptive_step(nearest_node.position, point)\n\n            if not collision_free(new_pos) or not edge_collision_free(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + distance(node.position, new_pos)\n                if temp_cost < min_cost and edge_collision_free(node.position, new_pos):\n                    min_cost = temp_cost\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-12 < neighbor.cost and edge_collision_free(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            max_iters = 5  # Limit incremental connection steps to reduce search time\n            for _ in range(max_iters):\n                new_pos = adaptive_step(last_node.position, node.position)\n                if not collision_free(new_pos) or not edge_collision_free(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                dist_to_goal = distance(new_pos, node.position)\n                if dist_to_goal <= self.step_size:\n                    if edge_collision_free(new_pos, node.position):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + dist_to_goal\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if edge_collision_free(p_i, p_j):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            rand_point = sample_point()\n\n            # Balance tree growth: extend smaller tree first for efficiency\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                extracted_path = extract_path(new_node_start, new_node_goal)\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -0.56941,
          "time_improvement": -4.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.011932563781738282,
                    "num_nodes_avg": 84.8,
                    "path_length_avg": 179.4556821069735,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -18.275056952991342,
                    "length_improvement": 10.309774920648962,
                    "objective_score": -8.42056210176761
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.021422696113586426,
                    "num_nodes_avg": 263.1,
                    "path_length_avg": 246.43185249463258,
                    "success_improvement": 0.0,
                    "time_improvement": -49.76673250493788,
                    "length_improvement": 18.22557418166317,
                    "objective_score": -11.284904915148728
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.012469840049743653,
                    "num_nodes_avg": 155.3,
                    "path_length_avg": 126.59919358120321,
                    "success_improvement": 0.0,
                    "time_improvement": 56.538651062263334,
                    "length_improvement": 22.260468677408557,
                    "objective_score": 21.41368905416071
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -0.2556317858417804,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.00937027931213379,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "success_improvement": 0.0,
                    "time_improvement": 7.122196069534629,
                    "length_improvement": 5.9265718433081265,
                    "objective_score": 3.321973189522014
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017043161392211913,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "success_improvement": 0.0,
                    "time_improvement": -19.14926952854797,
                    "length_improvement": 0.3867603104208941,
                    "objective_score": -5.667428796480212
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026260972023010254,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "success_improvement": 0.0,
                    "time_improvement": 8.472180558590889,
                    "length_improvement": 2.8534839845313615,
                    "objective_score": 3.112350964483539
               }
          ]
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid algorithm combines the efficient incremental bidirectional RRT* tree growth from Algorithm #1 with the heuristic-informed sampling, KD-tree accelerated nearest neighbor searches, collision caching, and pruning strategies from Algorithm #2. It interleaves adaptive ellipsoidal sampling focused on promising regions with balanced tree expansions. Periodic pruning of suboptimal nodes reduces search complexity, while incremental rewiring improves path cost. Final path smoothing ensures a high-quality, smooth path. This approach enhances planning efficiency, robustness, success rates, and path optimality, producing shorter and smoother paths faster in both 2D and 3D spaces.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternating extension of the smaller tree towards informed ellipsoid-biased samples. KD-tree structures accelerate neighbor queries for rewiring and nearest node search. Edge collision caching speeds collision checks. Nodes and edges are only added if both node placement and connecting edges are collision-free and within bounds. The best path cost updates the ellipsoid sampling region dynamically, progressively shrinking the search space. Periodic pruning removes nodes that cannot beat the current best path, lowering computational overhead. After successful connection, the final path is shortcut-smoothed for better smoothness and path length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checks etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_iterations: int = 100,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Helpers\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c+1)/c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree helper for nearest and radius search\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Ellipsoidal informed sampling as in Algorithm #2\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # No solution yet or marginal improvement: uniform sample\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Calculate ellipsoid parameters\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))  # unit vector from start to goal\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1**2 - (c_min / 2)**2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    x = x * radii\n                    p = rot @ x + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n            # fallback uniform sampling\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback last sample\n\n        # Caches for collision checks\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        # Shortcut smoothing (similar to both algorithms)\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Prune nodes that cannot improve the best path\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialize\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cost improvements\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try connect other tree incrementally to new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Update best cost and path\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to reduce complexity\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 2.55304,
          "time_improvement": -22.0,
          "length_improvement": 20.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.00791943073272705,
                    "num_nodes_avg": 61.8,
                    "path_length_avg": 158.4027803367249,
                    "success_improvement": 0.0,
                    "time_improvement": 21.50294454054769,
                    "length_improvement": 20.83181287552122,
                    "objective_score": 10.617245937268551
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027858495712280273,
                    "num_nodes_avg": 228.4,
                    "path_length_avg": 240.8903836814004,
                    "success_improvement": 0.0,
                    "time_improvement": -94.7596069705228,
                    "length_improvement": 20.06442101012724,
                    "objective_score": -24.414997889131392
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026755642890930176,
                    "num_nodes_avg": 178.9,
                    "path_length_avg": 129.35039218762472,
                    "success_improvement": 0.0,
                    "time_improvement": 6.748095637353845,
                    "length_improvement": 20.57106699807329,
                    "objective_score": 6.138642090820811
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an improved bidirectional RRT* variant with adaptive step size, informed sampling around an ellipse for faster convergence, and enhanced rewiring to optimize path quality and reduce search time. It incorporates aggressive rewiring, goal bias sampling, and path smoothing for robust and high-quality paths.",
          "planning_mechanism": "The planner grows two trees from start and goal positions, alternating expansions with adaptive step sizes. Sampling is biased towards an ellipsoidal region defined by current best path cost to focus exploration. After each extension, it attempts connection and performs rewiring with a dynamically adjusted radius to optimize the path. On successful connection, the path is extracted and smoothed.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def rewire(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        new_parent.children.append(self)\n        self.cost = new_cost\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 6.0, goal_sample_rate: float = 0.2,\n                 search_radius_factor: float = 20.0, smoothing_iterations: int = 5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # probability of sampling goal bias\n        self.search_radius_factor = search_radius_factor  # factor multiplier for neighbor search radius\n        self.smoothing_iterations = smoothing_iterations  # iterations for path smoothing\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n\n        nodes = []\n        edges = []\n\n        best_path_cost = float(\"inf\")\n        success_state = False\n        extracted_path = []\n\n        dimension = len(bounds)\n        diag_dist = math.dist((0,) * dimension, bounds)\n        # Dynamic radius for near neighbors will depend on sample count and dimension\n        def calc_radius(n_nodes):\n            gamma = self.search_radius_factor\n            unit_ball_volume = math.pi if dimension == 2 else (4/3)*math.pi\n            r = min(\n                self.step_size * 5,\n                gamma * ((math.log(max(n_nodes,1)) / max(n_nodes,1)) ** (1/dimension))\n            )\n            return r if r > self.step_size else self.step_size * 1.5\n\n        def ellipse_sample(c_best, start, goal):\n            # If no solution yet, sample uniformly\n            if c_best == float(\"inf\"):\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[i]) for i in range(3))\n                    else:\n                        p = tuple(random.uniform(0, bounds[i]) for i in range(2))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            # Ellipsoidal sampling focused between start and goal according to c_best path cost\n            center = tuple([(s + g) / 2 for s, g in zip(start, goal)])\n            a1 = [g - s for s, g in zip(start, goal)]\n            a1_len = math.dist(start, goal) / 2\n            if a1_len < 1e-6:\n                return start  # start == goal\n\n            # Rotation matrix to align ellipse along start-goal vector (assume 2D or 3D)\n            def unit_vector(v):\n                l = math.dist((0,) * len(v), v)\n                return tuple(x / l for x in v)\n\n            e_r1 = unit_vector(a1)\n            dim = len(start)\n\n            # Create an orthonormal basis with e_r1\n            import numpy as np\n            e1 = np.array(e_r1)\n            if dim == 2:\n                e2 = np.array([-e1[1], e1[0]])\n                basis = np.stack([e1, e2], axis=1)  # dim x dim\n            else:\n                # Gram-Schmidt for 3D, pick arbitrary vector not colinear\n                if abs(e1[0]) < abs(e1[1]):\n                    v = np.array([1,0,0])\n                else:\n                    v = np.array([0,1,0])\n                e2 = v - (np.dot(v,e1))*e1\n                e2 /= np.linalg.norm(e2)\n                e3 = np.cross(e1, e2)\n                basis = np.stack([e1, e2, e3], axis=1)\n\n            # Define ellipse axes lengths\n            r1 = c_best / 2\n            r2 = math.sqrt(max(c_best**2 - math.dist(start, goal)**2, 0)) / 2\n            if r2 < 1e-6:\n                r2 = self.step_size*2\n\n            while True:\n                # Sample point in unit ball scaled to ellipse\n                if dim == 2:\n                    sample_ball = np.random.normal(size=2)\n                else:\n                    sample_ball = np.random.normal(size=3)\n                sample_ball /= np.linalg.norm(sample_ball)\n                uniform_radius = random.uniform(0,1) ** (1/dim)\n                sample_ball = sample_ball * uniform_radius\n                scale = np.array([r1, r2] + ([r2] if dim==3 else []))\n                offset = center + basis @ (sample_ball * scale)\n                p = tuple(offset.tolist())\n                if all(0 <= p[i] <= bounds[i] for i in range(dim)) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def find_path_cost_back(node):\n            return node.cost if node else float(\"inf\")\n\n        for iteration in range(self.max_iter):\n            # With goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = ellipse_sample(best_path_cost, start_position, goal_position)\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size, bounds)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                radius = calc_radius(len(tree_a)+1)\n                near_nodes = self._near(tree_a, new_pos, radius)\n\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    cost = near.cost + math.dist(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node = Node(new_pos)\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewiring near nodes to new_node if improves cost and collision-free\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.rewire(new_node, new_cost)\n                        # Update edges list accordingly\n                        # Remove old edge:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        edges.append((new_node, near))\n\n                # Try connecting tree_b to this new_node\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    # Path found: Extract full path\n                    success_state = True\n                    path_a = []\n                    node_iter = new_node\n                    while node_iter:\n                        path_a.append(node_iter.position)\n                        node_iter = node_iter.parent\n                    path_a.reverse()\n                    path_b = []\n                    node_iter = connect_node\n                    while node_iter:\n                        path_b.append(node_iter.position)\n                        node_iter = node_iter.parent\n                    extracted_path = path_a + path_b\n\n                    new_path_cost = min_cost + connect_node.cost\n                    if new_path_cost < best_path_cost:\n                        best_path_cost = new_path_cost\n\n                    # Smooth path before return\n                    extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n\n    def _steer(self, from_pos, to_pos, step_size, bounds):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            new_pos = to_pos\n        else:\n            ratio = step_size / dist\n            new_pos = tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        # Enforce boundary limits\n        new_pos_clamped = tuple(\n            max(0, min(new_pos[i], bounds[i])) for i in range(len(new_pos))\n        )\n        return new_pos_clamped\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if math.dist(node.position, point) <= radius]\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import random\n        if len(path) < 3:\n            return path\n\n        smoothed = path[:]\n        for _ in range(self.smoothing_iterations):\n            if len(smoothed) < 3:\n                break\n            # Pick two random vertices i, j with j > i+1\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                # shortcut path segment by directly connecting i to j\n                smoothed = smoothed[:i + 1] + smoothed[j:]\n        return smoothed",
          "objective": 3.37674,
          "time_improvement": -21.0,
          "length_improvement": 14.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014727044105529784,
                    "num_nodes_avg": 160.9,
                    "path_length_avg": 174.3077033815884,
                    "success_improvement": 0.0,
                    "time_improvement": -45.97382525593398,
                    "length_improvement": 12.882685207815397,
                    "objective_score": -11.215610535217113
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022585201263427734,
                    "num_nodes_avg": 296.1,
                    "path_length_avg": 265.9289031898334,
                    "success_improvement": 0.0,
                    "time_improvement": -57.893842038152854,
                    "length_improvement": 11.755793146414167,
                    "objective_score": -15.01699398216302
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016541576385498045,
                    "num_nodes_avg": 209.4,
                    "path_length_avg": 135.1807269228711,
                    "success_improvement": 0.0,
                    "time_improvement": 42.3473580733592,
                    "length_improvement": 16.990890245358386,
                    "objective_score": 16.102385471079437
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a streamlined bidirectional RRT* planner with balanced tree growth, adaptive sampling biased towards start and goal, collision-free node and edge verification, and incremental rewiring within a dynamic neighborhood radius. It prioritizes computational efficiency and robust pathfinding through straightforward tree extensions, rewiring for cost improvements, and final path smoothing.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately extending towards sampled free points. For each new node, it rewires neighbors to reduce path cost if collision-free. It attempts to connect the opposite tree incrementally to the new node. Upon successful connection, the planner reconstructs and smooths the path before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 smoothing_iterations: int = 100,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / distance_between\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(len(bounds)))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - position[d])**2 for d in range(len(position))) <= r2]\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        tree_a, tree_b = [start_root], [goal_root]\n\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            sample = sample_free()\n            r = neighbor_radius(iteration, len(nodes))\n\n            # Extend tree_a towards sample\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            neighbors = near_nodes(tree_a, new_pos, r)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                cost_out = node.cost + dist(node.position, new_pos)\n                if cost_out + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_out\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper and collision-free\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try to connect tree_b to new_node incrementally\n            connect_node = nearest(tree_b, new_node.position)\n            curr_pos = connect_node.position\n            connected = False\n\n            while True:\n                next_pos = steer(curr_pos, new_node.position)\n                if not can_add_node(next_pos) or not can_connect(curr_pos, next_pos):\n                    break\n\n                neighbors_b = near_nodes(tree_b, next_pos, r)\n                min_cost_b = connect_node.cost + dist(curr_pos, next_pos)\n                best_parent_b = connect_node\n                for node_b in neighbors_b:\n                    if not can_connect(node_b.position, next_pos):\n                        continue\n                    cost_b = node_b.cost + dist(node_b.position, next_pos)\n                    if cost_b < min_cost_b:\n                        min_cost_b = cost_b\n                        best_parent_b = node_b\n\n                new_node_b = Node(next_pos, parent=best_parent_b, cost=min_cost_b)\n                best_parent_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((best_parent_b, new_node_b))\n\n                # Rewire neighbors of new_node_b\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is best_parent_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    path_start = new_node.path_from_root()\n                    path_goal = connection_node.path_from_root()\n                    extracted_path = path_start + path_goal[::-1][1:]\n                    extracted_path = shortcut_smoothing(extracted_path)\n                    connected = True\n                    break\n\n                curr_pos = new_node_b.position\n                connect_node = new_node_b\n\n            if connected:\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 5.05134,
          "time_improvement": -32.0,
          "length_improvement": 23.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011016368865966797,
                    "num_nodes_avg": 70.8,
                    "path_length_avg": 155.16720304344847,
                    "success_improvement": 0.0,
                    "time_improvement": -9.19377250942915,
                    "length_improvement": 22.44892330795998,
                    "objective_score": 1.7316529087632513
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025777411460876466,
                    "num_nodes_avg": 229.0,
                    "path_length_avg": 236.87693357543202,
                    "success_improvement": 0.0,
                    "time_improvement": -80.21068246785175,
                    "length_improvement": 21.396219536347616,
                    "objective_score": -19.783960833086002
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03083500862121582,
                    "num_nodes_avg": 252.3,
                    "path_length_avg": 121.00421879728697,
                    "success_improvement": 0.0,
                    "time_improvement": -7.469788212105313,
                    "length_improvement": 25.696120241684756,
                    "objective_score": 2.8982875847053577
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This planner combines the strengths of bidirectional RRT* with adaptive informed sampling towards start and goal, dynamic neighbor radius rewiring, balanced tree expansion by always extending the smaller tree, aggressive pruning of dead-ends for efficiency, lazy collision checking, and robust path smoothing using iterative randomized shortcutting. It prioritizes path cost optimization during tree growth, reduces computational overhead by pruning unnecessary nodes, and maintains path feasibility and smoothness to minimize both planning time and path length.",
          "planning_mechanism": "The planner initializes two trees from start and goal and iteratively extends the smaller tree towards adaptively biased samples within map bounds. Each new node is connected by rewiring neighbors within a dynamically computed radius to optimize path cost. After each successful connection of the two trees, the planner extracts and smooths the resultant path. Periodic pruning removes dead-end nodes to maintain tree efficiency and reduce search complexity. Careful collision checks on nodes and edges ensure feasibility while alternating tree expansions and adaptive sampling improve exploration balance and convergence speed.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2, radius_constant: float = 27.0,\n                 radius_min: float = 5.0, prune_interval: int = 150,\n                 prune_threshold: int = 120, smoothing_iterations: int = 80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        import math\n        import random\n\n        is_3d = len(bounds) == 3\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        success_state = False\n        extracted_path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            bias_to_goal = self.goal_sample_rate\n            if random.random() < bias_to_goal:\n                # Alternate bias between goal and start to avoid biasing only goal\n                return goal_position if random.random() < 0.6 else start_position\n            else:\n                attempts = 0\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if (not self._is_in_obstacle(p, obstacles, is_3d)) and in_bounds(p):\n                        return p\n                    attempts += 1\n                    if attempts > 30:\n                        return goal_position if random.random() < 0.6 else start_position\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d_] + (to_pos[d_] - from_pos[d_]) * ratio for d_ in range(len(from_pos)))\n            # Clamp to bounds\n            clamped = tuple(max(0, min(new_pos[d_], bounds[d_])) for d_ in range(len(bounds)))\n            return clamped\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def can_connect(p1, p2):\n            if dist(p1, p2) < 1e-9:\n                return True\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos): \n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            # Prune leaf nodes except roots\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            total = 0.0\n            for i in range(len(path) - 1):\n                total += dist(path[i], path[i + 1])\n            return total\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            path = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend smaller tree for balanced search\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                # Fail fast to next iteration\n                if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                    prune_dead_nodes()\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 6.58919,
          "time_improvement": -35.0,
          "length_improvement": 20.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009231066703796387,
                    "num_nodes_avg": 82.1,
                    "path_length_avg": 162.4624183556212,
                    "success_improvement": 0.0,
                    "time_improvement": 8.502065432133769,
                    "length_improvement": 18.80284481287468,
                    "objective_score": 6.311188592215067
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03338677883148193,
                    "num_nodes_avg": 124.3,
                    "path_length_avg": 239.9674241601271,
                    "success_improvement": 0.0,
                    "time_improvement": -133.40800560042,
                    "length_improvement": 20.37069020439601,
                    "objective_score": -35.948263639246804
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02317764759063721,
                    "num_nodes_avg": 115.5,
                    "path_length_avg": 129.43392433655305,
                    "success_improvement": 0.0,
                    "time_improvement": 19.21854446615108,
                    "length_improvement": 20.51977322656999,
                    "objective_score": 9.869517985159321
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a streamlined bidirectional RRT* algorithm with balanced tree growth, adaptive goal-biased sampling, dynamic neighborhood radius for rewiring, and iterative shortcut smoothing. It maintains rigorous collision checks for nodes and edges, and adapts exploration efficiently to improve planning speed and path quality while preserving robustness across 2D and 3D maps.",
          "planning_mechanism": "The planner grows two trees from start and goal, always extending the smaller tree for balanced exploration. Sampling is biased towards the goal to guide search efficiently. Nodes and edges are added only after confirming collision-free states and paths. Rewiring is performed within a dynamically calculated radius to optimize path cost. Upon successful tree connection, the path is extracted and refined via iterative shortcut smoothing to improve smoothness and shorten the path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2, radius_const: float = 30.0,\n                 radius_min: float = 5.0, smoothing_iter: int = 60):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.smoothing_iter = smoothing_iter\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d) and in_bounds(sample):\n                        break\n            return sample\n\n        def steer(from_p, to_p):\n            distance = dist(from_p, to_p)\n            if distance <= self.step_size:\n                return to_p\n            ratio = self.step_size / distance\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(len(from_p)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def radius_dynamic(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_const\n            r = self.radius_const * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(r, self.radius_min)\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            near = []\n            for node in tree:\n                dx = node.position[0] - pos[0]\n                dy = node.position[1] - pos[1]\n                dz = (node.position[2] - pos[2]) if is_3d else 0.0\n                dist_sq = dx*dx + dy*dy + dz*dz\n                if dist_sq <= r_sq:\n                    near.append(node)\n            return near\n\n        def can_add_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def can_connect(p1, p2):\n            if not in_bounds(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def try_extend(tree, sample):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                return None\n\n            r = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                cost_thru = node.cost + dist(node.position, new_pos)\n                if cost_thru + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_thru\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_thru_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_thru_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos) or not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size and can_connect(new_pos, node.position):\n                    final_cost = new_node.cost + dist(new_pos, node.position)\n                    final_node = Node(node.position, parent=new_node, cost=final_cost)\n                    new_node.children.append(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n\n                last_node = new_node\n\n        def extract_path(n_start, n_goal):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            sample = sample_free()\n\n            # Balance tree expansion by extending the smaller tree\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                raw_path = extract_path(new_node_start, new_node_goal)\n                smoothed_path = shortcut_smoothing(raw_path)\n                extracted_path = smoothed_path if len(smoothed_path) < len(raw_path) else raw_path\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 6.77202,
          "time_improvement": -37.0,
          "length_improvement": 22.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007858896255493164,
                    "num_nodes_avg": 72.4,
                    "path_length_avg": 158.97044898668418,
                    "success_improvement": 0.0,
                    "time_improvement": 22.102959664993527,
                    "length_improvement": 20.548097540416986,
                    "objective_score": 10.740507407581454
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03225698471069336,
                    "num_nodes_avg": 337.6,
                    "path_length_avg": 241.2652125430845,
                    "success_improvement": 0.0,
                    "time_improvement": -125.50957988515808,
                    "length_improvement": 19.9400401127957,
                    "objective_score": -33.66486594298828
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03081839084625244,
                    "num_nodes_avg": 269.0,
                    "path_length_avg": 123.50683756551288,
                    "success_improvement": 0.0,
                    "time_improvement": -7.411869993958881,
                    "length_improvement": 24.159361557702983,
                    "objective_score": 2.6083113133529325
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid algorithm integrates the bidirectional tree growth of the dual-tree RRT with the rewiring and path cost optimization from RRT*, combining efficient exploration and asymptotic optimality. It grows two trees from start and goal, extends them alternately toward random samples, uses a rewiring step to optimize local paths dynamically, and attempts connection when proximity allows. This approach improves path quality and success rate while maintaining computational efficiency and robust collision checking.",
          "planning_mechanism": "The planner alternates expansion between start and goal trees by sampling collision-free random points and steering nodes toward them. For each extension, a neighborhood rewiring step optimizes path costs locally. The algorithm attempts to connect the two trees by incremental steering with rewiring until a collision-free path uniting start and goal is found or maximum iterations are reached. Validity checks for nodes and edges are enforced strictly at every step.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        def _sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _distance(a, b):\n            return math.dist(a, b)\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: _distance(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            dist = _distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _near_nodes(tree, position, radius):\n            return [node for node in tree if _distance(node.position, position) <= radius]\n\n        def _can_connect(p1, p2):\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def _add_node(tree, new_node, parent_node):\n            parent_node.add_child(new_node)\n            new_node.cost = parent_node.cost + _distance(parent_node.position, new_node.position)\n            new_node.parent = parent_node\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n\n        def _rewire(tree, new_node):\n            neighbors = _near_nodes(tree, new_node.position, self.rewire_radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                new_cost = new_node.cost + _distance(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and _can_connect(new_node.position, neighbor.position):\n                    # Remove old edge\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n\n                    # Add new edge\n                    new_node.add_child(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    edges.append((new_node, neighbor))\n\n        def _extend(tree, point):\n            nearest = _nearest(tree, point)\n            new_pos = _steer(nearest.position, point)\n            if not _can_connect(nearest.position, new_pos):\n                return None\n            new_node = Node(new_pos)\n            min_cost = nearest.cost + _distance(nearest.position, new_pos)\n            best_parent = nearest\n\n            neighbors = _near_nodes(tree, new_pos, self.rewire_radius)\n\n            # Choose best parent from neighbors to minimize cost\n            for neighbor in neighbors:\n                c = neighbor.cost + _distance(neighbor.position, new_pos)\n                if c < min_cost and _can_connect(neighbor.position, new_pos):\n                    min_cost = c\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire around new node\n            _rewire(tree, new_node)\n            return new_node\n\n        def _connect(tree, new_node_other):\n            nearest = _nearest(tree, new_node_other.position)\n            curr_node = nearest\n\n            while True:\n                new_pos = _steer(curr_node.position, new_node_other.position)\n                if not _can_connect(curr_node.position, new_pos):\n                    return None\n\n                connect_node = Node(new_pos)\n                neighbors = _near_nodes(tree, new_pos, self.rewire_radius)\n\n                min_cost = curr_node.cost + _distance(curr_node.position, new_pos)\n                best_parent = curr_node\n\n                for neighbor in neighbors:\n                    c = neighbor.cost + _distance(neighbor.position, new_pos)\n                    if c < min_cost and _can_connect(neighbor.position, new_pos):\n                        min_cost = c\n                        best_parent = neighbor\n\n                best_parent.add_child(connect_node)\n                connect_node.parent = best_parent\n                connect_node.cost = min_cost\n                tree.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((best_parent, connect_node))\n\n                _rewire(tree, connect_node)\n\n                if _distance(connect_node.position, new_node_other.position) <= self.step_size:\n                    return connect_node\n\n                curr_node = connect_node\n\n        for iter_num in range(self.max_iter):\n            rand_point = _sample_free()\n\n            # Alternate expanding start and goal trees\n            if iter_num % 2 == 0:\n                new_node_start = _extend(tree_start, rand_point)\n                if new_node_start is None:\n                    continue\n                connect_node_goal = _connect(tree_goal, new_node_start)\n                if connect_node_goal:\n                    success_state = True\n                    path_start = new_node_start.path_from_root()\n                    path_goal = connect_node_goal.path_from_root()\n                    extracted_path = path_start + path_goal[::-1]\n                    break\n            else:\n                new_node_goal = _extend(tree_goal, rand_point)\n                if new_node_goal is None:\n                    continue\n                connect_node_start = _connect(tree_start, new_node_goal)\n                if connect_node_start:\n                    success_state = True\n                    path_goal = new_node_goal.path_from_root()\n                    path_start = connect_node_start.path_from_root()\n                    extracted_path = path_start + path_goal[::-1]\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 8.43218,
          "time_improvement": -22.0,
          "length_improvement": 25.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01331765651702881,
                    "num_nodes_avg": 100.9,
                    "path_length_avg": 160.7913922442542,
                    "success_improvement": 0.0,
                    "time_improvement": -32.004036336481114,
                    "length_improvement": 19.638007602273778,
                    "objective_score": -5.673609380489578
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.02202715873718262,
                    "num_nodes_avg": 209.4,
                    "path_length_avg": 217.93141644497078,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -53.992549441208105,
                    "length_improvement": 27.68298307560509,
                    "objective_score": -20.66116821724141
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.023168563842773438,
                    "num_nodes_avg": 214.7,
                    "path_length_avg": 119.99487511069171,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 19.250204209499422,
                    "length_improvement": 26.31591806914092,
                    "objective_score": 1.0382448766780126
               }
          ],
          "success_rate": 0.8666666666666667
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid algorithm combines the asymptotic optimality and rewiring principles from RRT* and the fast convergence benefits of a bidirectional approach inspired by RRT-Connect. It grows two trees simultaneously from start and goal with goal biasing, samples from free space, connects the trees when close enough, and performs rewiring in both trees to improve path quality incrementally. Additionally, it performs path shortcutting to smooth the final path for better quality.",
          "planning_mechanism": "The planner alternates tree expansions by sampling points with goal biasing, steering nearest nodes toward sampled points, rewires neighbors for cost improvements, tries connecting the two trees to form a full path, and upon success, extracts and smooths the path. Collision checks are applied for nodes and edges throughout, ensuring valid paths that respect obstacles and boundaries.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D position\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Accumulated path cost\n        self.children = []\n        self.valid = True               # For collision validity\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, neighbor_radius: float=12.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        import random\n        import math\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def _distance(a, b):\n            return math.dist(a, b)\n\n        def _steer(from_pos, to_pos, step_size):\n            dist = _distance(from_pos, to_pos)\n            if dist <= step_size:\n                return to_pos\n            ratio = step_size / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def _near(tree, point, radius):\n            return [node for node in tree if _distance(node.position, point) <= radius]\n\n        def _extract_path_meet(node_from_start, node_from_goal):\n            path_start = []\n            current = node_from_start\n            while current:\n                path_start.append(current.position)\n                current = current.parent\n            path_goal = []\n            cur = node_from_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def _path_shortcut(path):\n            # Attempt to smooth path by shortcutting between non-adjacent nodes if direct connection is collision-free\n            if len(path) < 3:\n                return path\n            smooth_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smooth_path.append(path[j])\n                i = j\n            return smooth_path\n\n        def _check_in_bounds(pos):\n            for i, val in enumerate(pos):\n                if val < 0 or val > bounds[i]:\n                    return False\n            return True\n\n        success = False\n        final_path = []\n\n        for iter in range(self.max_iter):\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Alternate between start_tree and goal_tree expansions\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Find nearest node in tree_a to sample\n                nearest = min(tree_a, key=lambda n: _distance(n.position, sample))\n                new_pos = _steer(nearest.position, sample, self.step_size)\n\n                # Check bounds\n                if not _check_in_bounds(new_pos):\n                    continue\n                # Collision checks\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Create new node, find near neighbors for rewiring\n                new_node = Node(new_pos)\n                near_nodes = _near(tree_a, new_pos, self.neighbor_radius)\n\n                min_cost = nearest.cost + _distance(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    temp_cost = near.cost + _distance(near.position, new_pos)\n                    if temp_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        min_parent = near\n\n                new_node.update_parent(min_parent, min_cost)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors in tree_a\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + _distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                        near.update_parent(new_node, new_cost)\n                        edges.append((new_node, near))\n\n                # Try connect tree_b to new_node in tree_a to form path\n                connect_node = min(tree_b, key=lambda n: _distance(n.position, new_node.position))\n                dist_connect = _distance(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size:\n                    if (not self._is_in_obstacle(connect_node.position, obstacles, is_3d) and\n                        not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d)):\n                        # Path connected, extract full path\n                        success = True\n                        final_path = _extract_path_meet(new_node, connect_node)\n                        # Smooth path with shortcutting\n                        final_path = _path_shortcut(final_path)\n                        break\n            if success:\n                break\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 11.21486,
          "time_improvement": -51.0,
          "length_improvement": 21.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013281702995300293,
                    "num_nodes_avg": 128.5,
                    "path_length_avg": 174.34981020638165,
                    "success_improvement": 0.0,
                    "time_improvement": -31.647666581591665,
                    "length_improvement": 12.861640621493342,
                    "objective_score": -6.921971850178831
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02387359142303467,
                    "num_nodes_avg": 287.3,
                    "path_length_avg": 230.3975784226972,
                    "success_improvement": 0.0,
                    "time_improvement": -66.90101757631824,
                    "length_improvement": 23.546288782365693,
                    "objective_score": -15.361047516422332
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.044390535354614256,
                    "num_nodes_avg": 367.1,
                    "path_length_avg": 121.70644892216498,
                    "success_improvement": 0.0,
                    "time_improvement": -54.7150997032626,
                    "length_improvement": 25.26490864195521,
                    "objective_score": -11.361548182587736
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements an efficient bidirectional RRT* planner combining balanced tree growth, adaptive neighbor radius for rewiring, incremental connection attempts, and path shortcut smoothing. It ensures collision-free node and edge validation, bounds adherence, and aims to improve path quality, success rate, and planning speed by dynamically rewiring nodes towards lower-cost paths.",
          "planning_mechanism": "The planner alternately extends two trees from the start and goal towards randomly sampled free points, chooses optimal parents in a dynamic neighborhood for each new node, rewires neighboring nodes if a cheaper path is found, and attempts incremental connections between trees. Upon successful connection, it reconstructs and smooths the path before returning.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position      # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent          # Node or None\n        self.cost = cost              # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True             # For potential future use\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 smoothing_iterations: int = 100, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback sample even if in obstacle\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / distance_between\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(len(bounds)))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes,1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + \\\n                      (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - position[d])**2 for d in range(len(position))) <= r2]\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n        tree_a, tree_b = [start_root], [goal_root]\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for iteration in range(self.max_iter):\n            sample = sample_free()\n            radius = neighbor_radius(iteration, len(nodes))\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            neighbors = near_nodes(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                cost_thru_node = node.cost + dist(node.position, new_pos)\n                if cost_thru_node + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_thru_node\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper path found via new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt incremental connection from tree_b towards new_node\n            connect_node = nearest(tree_b, new_node.position)\n            curr_pos = connect_node.position\n            connected = False\n\n            while True:\n                next_pos = steer(curr_pos, new_node.position)\n                if not can_add_node(next_pos) or not can_connect(curr_pos, next_pos):\n                    break\n\n                neighbors_b = near_nodes(tree_b, next_pos, radius)\n\n                min_cost_b = connect_node.cost + dist(curr_pos, next_pos)\n                best_parent_b = connect_node\n                for node_b in neighbors_b:\n                    cost_b = node_b.cost + dist(node_b.position, next_pos)\n                    if cost_b + 1e-12 < min_cost_b and can_connect(node_b.position, next_pos):\n                        min_cost_b = cost_b\n                        best_parent_b = node_b\n\n                new_node_b = Node(next_pos, parent=best_parent_b, cost=min_cost_b)\n                best_parent_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((best_parent_b, new_node_b))\n\n                # Rewire neighbors of new_node_b\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is best_parent_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    path_start = new_node.path_from_root()\n                    path_goal = connection_node.path_from_root()\n                    extracted_path = path_start + path_goal[::-1][1:]\n                    extracted_path = shortcut_smoothing(extracted_path)\n                    connected = True\n                    break\n\n                curr_pos = new_node_b.position\n                connect_node = new_node_b\n\n            if connected:\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 11.36172,
          "time_improvement": -53.0,
          "length_improvement": 22.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009463739395141602,
                    "num_nodes_avg": 65.6,
                    "path_length_avg": 156.78522789428558,
                    "success_improvement": 0.0,
                    "time_improvement": 6.195823762394946,
                    "length_improvement": 21.640250039152267,
                    "objective_score": 6.186797136548938
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023795652389526366,
                    "num_nodes_avg": 218.4,
                    "path_length_avg": 241.46927916424852,
                    "success_improvement": 0.0,
                    "time_improvement": -66.35614337741997,
                    "length_improvement": 19.872323904012422,
                    "objective_score": -15.932378232423506
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05674192905426025,
                    "num_nodes_avg": 304.6,
                    "path_length_avg": 122.22337727974164,
                    "success_improvement": 0.0,
                    "time_improvement": -97.76362553088236,
                    "length_improvement": 24.94748349011496,
                    "objective_score": -24.339590961241715
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This improved planner implements a bidirectional RRT* algorithm with heuristic-informed adaptive sampling biased towards the goal region to direct exploration. It uses a dynamic neighborhood radius for rewiring to optimize path costs continuously. Additionally, it incorporates intelligent periodic pruning of dead-end nodes to reduce computational overhead and an enhanced shortcut smoothing technique that attempts multiple path refinements to minimize path length and improve smoothness. Rigorous collision checks ensure validity of nodes and edges, while balanced tree expansions promote efficient bidirectional search and early path convergence leading to a robust, high-quality, and computationally efficient path planning solution.",
          "planning_mechanism": "The planner grows two trees from start and goal, always extending the smaller tree to maintain balanced exploration. Sampling is adaptively biased towards the goal area to guide the search effectively. Nodes are only added if collision-free, and rewiring within a dynamically calculated neighborhood improves path cost continually. Dead-end nodes are periodically pruned to keep the tree manageable. Once a connection between the trees is found, iterative shortcut smoothing refines the path, producing a shorter and smoother trajectory.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2, radius_constant: float=30.0,\n                 radius_min: float=5.0, prune_interval: int=150,\n                 prune_threshold: int=150, smoothing_iterations: int=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d in range(len(pos)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            p_bias = 0.85\n            if random.random() < self.goal_sample_rate:\n                # Adaptive informed sampling: biased around goal with small Gaussian noise\n                if random.random() < p_bias:\n                    dim = len(bounds)\n                    noise_scale = self.step_size * 1.5\n                    if dim == 2:\n                        sample = (random.gauss(goal_position[0], noise_scale),\n                                  random.gauss(goal_position[1], noise_scale))\n                    else:\n                        sample = tuple(random.gauss(goal_position[d], noise_scale) for d in range(dim))\n                    # Check bounds and collisions\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                # fallback to pure uniform random sample\n                # sample uniformly until valid\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d) and in_bounds(sample):\n                        return sample\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d) and in_bounds(sample):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            # Use list copy to avoid modifying list while iterating\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                # Dead-end nodes have no children and are not start/goal\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Extend smaller tree for balanced exploration\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 11.40345,
          "time_improvement": -47.0,
          "length_improvement": 21.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.016108107566833497,
                    "num_nodes_avg": 86.3,
                    "path_length_avg": 161.6470753664288,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -59.66286664965168,
                    "length_improvement": 19.21034540220651,
                    "objective_score": -19.0567909144542
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027827692031860352,
                    "num_nodes_avg": 173.6,
                    "path_length_avg": 238.82154154739888,
                    "success_improvement": 0.0,
                    "time_improvement": -94.54425748597812,
                    "length_improvement": 20.750932822233363,
                    "objective_score": -24.213090681346763
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024597597122192384,
                    "num_nodes_avg": 154.9,
                    "path_length_avg": 123.94005355805423,
                    "success_improvement": 0.0,
                    "time_improvement": 14.269569834663018,
                    "length_improvement": 23.893340840912128,
                    "objective_score": 9.05953911858133
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner with adaptive step sizing, dynamic radius rewiring, and goal-biased sampling to improve exploration efficiency and path quality. The planner incrementally grows two trees from start and goal, attempts connections between them, and uses shortcut smoothing on the final combined path to deliver shorter and smoother trajectories with robustness in collision avoidance and bounded node placement.",
          "planning_mechanism": "The planner alternately extends two trees by sampling points mostly in free space but biased towards the goal to accelerate convergence. Each extension uses adaptive step size and dynamically computed radii to find near neighbors for rewiring, improving path optimality. After connecting the trees, the path is extracted and refined using shortcut smoothing, assuring collision and bound checks throughout the process to guarantee feasible, high-quality paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost\n        self.children = []\n        self.valid = True               # Node validity flag\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_and_propagate(self, new_cost):\n        self.cost = new_cost\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_cost_and_propagate(new_cost + dist)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 6.0, goal_sample_rate: float = 0.12, radius_constant: float = 24.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Probability to sample goal point\n        self.radius_constant = radius_constant      # Coefficient for dynamic radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            # Goal-biased sampling with slight randomness to increase exploration\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        break\n\n            # Alternate tree growth: (start -> goal) and (goal -> start)\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                # 1. Find nearest node in tree_a\n                nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n                dist_near_to_sample = math.dist(nearest.position, sample)\n                if dist_near_to_sample == 0:\n                    continue\n\n                # 2. Adaptive step sizing to avoid overshoot\n                step = min(self.step_size, dist_near_to_sample)\n                new_pos = tuple(nearest.position[d] + (sample[d] - nearest.position[d]) * (step / dist_near_to_sample) for d in range(dim))\n\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # 3. Create new node with cost from nearest\n                new_node = Node(new_pos)\n                # Compute dynamic radius for rewiring (RRT* style)\n                radius = min(\n                    self.radius_constant * ((math.log(len(tree_a) + 1) / (len(tree_a) + 1)) ** (1 / dim)),\n                    self.step_size * 5\n                )\n\n                # 4. Find neighbors within radius for potential better parent connection\n                near_nodes = [node for node in tree_a if math.dist(node.position, new_pos) <= radius]\n\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near in near_nodes:\n                    if near == nearest:\n                        continue\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = near\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                new_node.parent = best_parent\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # 5. Rewire neighbors to improve paths where beneficial\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                            try:\n                                near.parent.children.remove(near)\n                            except ValueError:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        near.update_cost_and_propagate(new_cost)\n\n                # 6. Attempt to connect the other tree\n                nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n                dist_to_connect = math.dist(nearest_other.position, new_node.position)\n                if dist_to_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    # Connect trees and extract path\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = new_node.path_from_root()\n                        path_goal = nearest_other.path_from_root()\n                        path_goal.reverse()\n                        full_path = path_start + path_goal\n                    else:\n                        path_start = nearest_other.path_from_root()\n                        path_goal = new_node.path_from_root()\n                        path_goal.reverse()\n                        full_path = path_start + path_goal\n\n                    # Smooth final path with shortcutting\n                    smoothed_path = self._smooth_path(full_path, obstacles, is_3d, max_iterations=150, map_bounds=bounds)\n\n                    extracted_path = smoothed_path\n                    return PlannerResult(True, extracted_path, nodes, edges)\n\n        # If no path found\n        return PlannerResult(False, extracted_path, nodes, edges)\n\n\n    def _smooth_path(self, path, obstacles, is_3d, max_iterations=150, map_bounds=None):\n        import random\n\n        def valid_edge(p1, p2):\n            if map_bounds:\n                for d in range(len(p1)):\n                    if p1[d] < 0 or p1[d] > map_bounds[d]:\n                        return False\n                    if p2[d] < 0 or p2[d] > map_bounds[d]:\n                        return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        if len(path) < 3:\n            return path[:]\n\n        path = path[:]\n        for _ in range(max_iterations):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if valid_edge(path[i], path[j]):\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 11.8182,
          "time_improvement": -51.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023647093772888185,
                    "num_nodes_avg": 132.8,
                    "path_length_avg": 171.6632933428514,
                    "success_improvement": 0.0,
                    "time_improvement": -134.3889723884336,
                    "length_improvement": 14.20433592843752,
                    "objective_score": -37.47582453084257
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.020715737342834474,
                    "num_nodes_avg": 206.8,
                    "path_length_avg": 243.57773464966635,
                    "success_improvement": 0.0,
                    "time_improvement": -44.82436182713705,
                    "length_improvement": 19.172667041727053,
                    "objective_score": -9.612775139795703
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02119474411010742,
                    "num_nodes_avg": 255.5,
                    "path_length_avg": 131.94851844751196,
                    "success_improvement": 0.0,
                    "time_improvement": 26.12959222084375,
                    "length_improvement": 18.975660960743372,
                    "objective_score": 11.6340098584018
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm with adaptive sampling towards the goal and start to improve exploration efficiency. It employs a KD-tree to accelerate nearest and near neighbor searches, dynamically adjusts the neighborhood radius based on the growing tree sizes, and performs incremental rewiring to minimize path cost and improve smoothness. Early connection attempts between the two trees enable faster convergence. Post path extraction, an optimization-based shortcutting smooths the path while ensuring collision-free transitions. Overall, this approach balances fast search, path quality, robustness, and planning efficiency.",
          "planning_mechanism": "The planner grows two trees bidirectionally from start and goal, alternately extending them by sampling points biased toward both ends. Using KD-trees, it quickly finds nearest and nearby nodes for efficient rewiring to locally optimize path costs. The rewiring radius shrinks adaptively with the tree size, focusing on refining the solution as exploring proceeds. When trees connect, the shortest cost path is extracted and post-processed by shortcutting to smooth the trajectory. Collision checks prevent invalid nodes or edges, and out-of-bound checks ensure safety.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 radius_constant: float=40.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        class KDTree:\n            def __init__(self):\n                self.points = []\n                self.nodes = []\n\n            def insert(self, node):\n                self.points.append(node.position)\n                self.nodes.append(node)\n\n            def nearest(self, point):\n                best_node = None\n                best_dist = float('inf')\n                for node in self.nodes:\n                    dist = math.dist(node.position, point)\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_node = node\n                return best_node\n\n            def near(self, point, radius):\n                r_sq = radius * radius\n                neighbors = []\n                for node in self.nodes:\n                    dx = 0\n                    for d in range(dim):\n                        diff = node.position[d] - point[d]\n                        dx += diff * diff\n                        if dx > r_sq:\n                            break\n                    if dx <= r_sq:\n                        neighbors.append(node)\n                return neighbors\n\n        def sample_free():\n            # Adaptive goal/start biasing to balance exploration\n            r = random.random()\n            if r < self.goal_sample_rate:\n                return goal_position\n            elif r < self.goal_sample_rate * 2:\n                return start_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def out_of_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return True\n            return False\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_constant\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        # Initialize trees and kd-trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        kd_start = KDTree()\n        kd_goal = KDTree()\n        kd_start.insert(start_root)\n        kd_goal.insert(goal_root)\n\n        tree_flag = True  # True: extend start tree; False: extend goal tree\n\n        def try_extend(tree, kd_tree, point):\n            if not tree:\n                return None\n            nearest_node = kd_tree.nearest(point)\n            if nearest_node is None:\n                return None\n            new_pos = steer(nearest_node.position, point)\n            if out_of_bounds(new_pos): \n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = kd_tree.near(new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + math.dist(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            kd_tree.insert(new_node)\n\n            # Rewire neighbors for incremental optimization\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, kd_tree, node):\n            if not tree:\n                return None\n            nearest_node = kd_tree.nearest(node.position)\n            if nearest_node is None:\n                return None\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if out_of_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + math.dist(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n                kd_tree.insert(new_node)\n\n                if math.dist(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + math.dist(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        kd_tree.insert(final_node)\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def combine_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            path_goal.reverse()\n            return path_start + path_goal[1:]\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Alternate tree extension with balancing sizes for faster convergence\n            if len(tree_start) > len(tree_goal):\n                tree_extend, kd_extend = tree_goal, kd_goal\n                tree_connect, kd_connect = tree_start, kd_start\n                start_tree_flag = False\n            else:\n                tree_extend, kd_extend = tree_start, kd_start\n                tree_connect, kd_connect = tree_goal, kd_goal\n                start_tree_flag = True\n\n            new_node = try_extend(tree_extend, kd_extend, rand_point)\n            if new_node is None:\n                continue\n\n            connect_node = try_connect(tree_connect, kd_connect, new_node)\n            if connect_node is not None:\n                success_state = True\n                if start_tree_flag:\n                    extracted_path = combine_path(new_node, connect_node)\n                else:\n                    extracted_path = combine_path(connect_node, new_node)\n\n                # Post-process smoothing\n                extracted_path = smooth_path(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 12.53989,
          "time_improvement": -56.0,
          "length_improvement": 22.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012874317169189454,
                    "num_nodes_avg": 112.4,
                    "path_length_avg": 158.54806002330182,
                    "success_improvement": 0.0,
                    "time_improvement": -27.6096758642203,
                    "length_improvement": 20.759203484525322,
                    "objective_score": -4.131062062361026
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03498883247375488,
                    "num_nodes_avg": 396.1,
                    "path_length_avg": 235.32768417519816,
                    "success_improvement": 0.0,
                    "time_improvement": -144.6080122675867,
                    "length_improvement": 21.910312900785097,
                    "objective_score": -39.00034110011899
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.027908682823181152,
                    "num_nodes_avg": 266.9,
                    "path_length_avg": 124.63820597220362,
                    "success_improvement": 0.0,
                    "time_improvement": 2.7293856430958123,
                    "length_improvement": 23.464633201215378,
                    "objective_score": 5.511742333171819
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT* variant that merges adaptive rewiring, informed sampling inside an ellipsoidal subset, and dynamic neighborhood radius to accelerate convergence, improve path quality, and increase success rates. It integrates incremental connection attempts and extensive shortcut smoothing to yield shorter, smoother, and collision-free paths efficiently.",
          "planning_mechanism": "The planner grows two trees from start and goal simultaneously using informed samples biased towards promising regions. Each extension selects the best parent from a dynamically computed neighborhood for minimal path cost, followed by rewiring neighbors to optimize path costs. Incremental connection attempts are made between trees after each extension. Successful connection triggers path extraction and iterative shortcut smoothing, producing a high-quality feasible solution while respecting collision and boundary constraints.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 min_neighbor_radius: float = 4.0,\n                 max_neighbor_radius: float = 20.0,\n                 smoothing_iterations: int = 100,\n                 collision_check_resolution: float = 0.5,\n                 informed_sampling_rate: float = 0.7):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.informed_sampling_rate = informed_sampling_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_a, tree_b = [start_root], [goal_root]\n\n        success_state = False\n        extracted_path = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float(\"inf\")\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            # Clamp inside bounds\n            return tuple(max(0.0, min(new_pos[d], bounds[d])) for d in range(len(bounds)))\n\n        def is_collision_free_point(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_collision_free_edge(p1, p2):\n            return in_bounds(p1) and in_bounds(p2) and not self._is_edge_in_obstacle(\n                p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        def uniform_sample():\n            attempts = 0\n            while attempts < 40:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n                attempts += 1\n            # fallback sample even if in obstacle after attempts\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def informed_sample():\n            # Sample inside prolate hyperspheroid (ellipsoid) between start and goal\n            d = len(bounds)\n            if c_best == float(\"inf\"):\n                # No solution found yet - uniform sample\n                return uniform_sample()\n            c = c_best\n            c_min_ = c_min\n            x_center = tuple((start_position[d] + goal_position[d]) / 2.0 for d in range(d))\n            a1 = tuple((goal_position[i] - start_position[i]) / c_min_ for i in range(d))  # unit vector\n\n            # Sampling in unit ball\n            while True:\n                sample = [random.gauss(0, 1) for _ in range(d)]\n                norm = math.sqrt(sum(s ** 2 for s in sample))\n                unit_ball_sample = [s / norm for s in sample]\n\n                r = random.uniform(0,1) ** (1/d)\n                unit_ball_scale = [r * s for s in unit_ball_sample]\n\n                # Define scaling matrix L\n                L = [c / 2.0] + [math.sqrt(c * c - c_min_ * c_min_) / 2.0] * (d - 1)\n\n                # Transform sample\n                scaled = [L[0] * unit_ball_scale[0]] + [L[i] * unit_ball_scale[i] for i in range(1, d)]\n\n                # Rotation matrix that aligns x-axis with a1\n                R = self._rotation_matrix_to_align(a1)\n\n                sample_pos = [0.0] * d\n                for i in range(d):\n                    for j in range(d):\n                        sample_pos[i] += R[i][j] * scaled[j]\n                pos = tuple(sample_pos[i] + x_center[i] for i in range(d))\n\n                if is_collision_free_point(pos):\n                    return pos\n\n        def sample():\n            if c_best < float(\"inf\") and random.random() < self.informed_sampling_rate:\n                return informed_sample()\n            else:\n                return uniform_sample()\n\n        def neighbor_radius(iteration, n_nodes):\n            n_nodes = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + \\\n                      (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - position[d]) ** 2 for d in range(len(position))) <= r2]\n\n        def shortcut_smoothing(path: list):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if is_collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for iteration in range(self.max_iter):\n            rand_point = sample()\n            radius = neighbor_radius(iteration, len(nodes))\n\n            for extend_trees in [(tree_a, tree_b), (tree_b, tree_a)]:\n                tree_src, tree_tgt = extend_trees\n                nearest_node = nearest(tree_src, rand_point)\n                new_pos = steer(nearest_node.position, rand_point)\n\n                if not is_collision_free_point(new_pos) or not is_collision_free_edge(nearest_node.position, new_pos):\n                    continue\n\n                neighbors = near_nodes(tree_src, new_pos, radius)\n\n                # Find best parent minimizing cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for node in neighbors:\n                    cost_thru_node = node.cost + dist(node.position, new_pos)\n                    if cost_thru_node + 1e-12 < min_cost and is_collision_free_edge(node.position, new_pos):\n                        min_cost = cost_thru_node\n                        best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree_src.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors for better paths\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-12 < neighbor.cost and is_collision_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n                # Incremental connection attempt from target tree to new_node\n                connect_node = nearest(tree_tgt, new_node.position)\n                curr_pos = connect_node.position\n                connected = False\n\n                while True:\n                    next_pos = steer(curr_pos, new_node.position)\n                    if not is_collision_free_point(next_pos) or not is_collision_free_edge(curr_pos, next_pos):\n                        break\n\n                    neighbors_b = near_nodes(tree_tgt, next_pos, radius)\n\n                    min_cost_b = connect_node.cost + dist(curr_pos, next_pos)\n                    best_parent_b = connect_node\n                    for node_b in neighbors_b:\n                        cost_b = node_b.cost + dist(node_b.position, next_pos)\n                        if cost_b + 1e-12 < min_cost_b and is_collision_free_edge(node_b.position, next_pos):\n                            min_cost_b = cost_b\n                            best_parent_b = node_b\n\n                    new_node_b = Node(next_pos, parent=best_parent_b, cost=min_cost_b)\n                    best_parent_b.children.append(new_node_b)\n                    tree_tgt.append(new_node_b)\n                    nodes.append(new_node_b)\n                    edges.append((best_parent_b, new_node_b))\n\n                    # Rewire neighbors around new_node_b\n                    for neighbor_b in neighbors_b:\n                        if neighbor_b is best_parent_b:\n                            continue\n                        cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                        if cost_via_new_b + 1e-12 < neighbor_b.cost and is_collision_free_edge(new_node_b.position, neighbor_b.position):\n                            try:\n                                edges.remove((neighbor_b.parent, neighbor_b))\n                            except ValueError:\n                                pass\n                            neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                            edges.append((new_node_b, neighbor_b))\n\n                    # Check direct connection to new_node\n                    if dist(new_node_b.position, new_node.position) <= self.step_size and is_collision_free_edge(new_node_b.position, new_node.position):\n                        final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                        connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                        new_node_b.children.append(connection_node)\n                        tree_tgt.append(connection_node)\n                        nodes.append(connection_node)\n                        edges.append((new_node_b, connection_node))\n\n                        success_state = True\n                        c_best = min(c_best, final_cost + new_node.cost)\n\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n                        extracted_path = path_start + path_goal[::-1][1:]\n                        extracted_path = shortcut_smoothing(extracted_path)\n                        connected = True\n                        break\n\n                    curr_pos = new_node_b.position\n                    connect_node = new_node_b\n\n                if connected:\n                    break\n\n            if success_state:\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return self._finish_result(success_state, extracted_path, nodes, edges)\n\n    def _finish_result(self, success_state, extracted_path, nodes, edges):\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _rotation_matrix_to_align(self, a1):\n        \"\"\"\n        Compute the rotation matrix R that aligns the x-axis unit vector (1,0,...)\n        to the vector a1 (unit vector) in d-dimensional space.\n        This implementation supports 2D and 3D only; higher dims returns identity.\n        \"\"\"\n        d = len(a1)\n        if d == 2:\n            # 2D rotation matrix\n            angle = math.atan2(a1[1], a1[0])\n            cos_t = math.cos(angle)\n            sin_t = math.sin(angle)\n            return [[cos_t, -sin_t],\n                    [sin_t,  cos_t]]\n        elif d == 3:\n            v = (1.0, 0.0, 0.0)  # x-axis\n            b = a1\n            dot = sum(v[i]*b[i] for i in range(3))\n            if abs(dot - 1.0) < 1e-10:\n                # vectors are the same\n                return [[1,0,0],[0,1,0],[0,0,1]]\n            if abs(dot + 1.0) < 1e-10:\n                # vectors are opposite\n                return [[-1,0,0],[0,-1,0],[0,0,1]]\n            cross = (v[1]*b[2] - v[2]*b[1],\n                     v[2]*b[0] - v[0]*b[2],\n                     v[0]*b[1] - v[1]*b[0])\n            cross_norm = math.sqrt(sum(x*x for x in cross))\n            if cross_norm < 1e-10:\n                return [[1,0,0],[0,1,0],[0,0,1]]\n            k = tuple(x / cross_norm for x in cross)\n            K = [[0, -k[2], k[1]],\n                 [k[2], 0, -k[0]],\n                 [-k[1], k[0], 0]]\n            I = [[1,0,0],[0,1,0],[0,0,1]]\n\n            def mat_add(A,B):\n                return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n            def mat_scalar_mul(A, s):\n                return [[A[i][j] * s for j in range(3)] for i in range(3)]\n            def mat_mul(A,B):\n                return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n            K2 = mat_mul(K,K)\n            R = mat_add(mat_add(I, mat_scalar_mul(K, math.sin(math.acos(dot)))), mat_scalar_mul(K2, 1 - dot))\n            return R\n        else:\n            # For dimensions != 2 or 3, return identity matrix\n            return [[1 if i == j else 0 for j in range(d)] for i in range(d)]\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 19.6595,
          "time_improvement": -74.0,
          "length_improvement": 21.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.016077089309692382,
                    "num_nodes_avg": 89.7,
                    "path_length_avg": 161.0362629793951,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -59.35541502424637,
                    "length_improvement": 19.515623562424647,
                    "objective_score": -18.903499794788978
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04176735877990723,
                    "num_nodes_avg": 287.1,
                    "path_length_avg": 239.56231900136723,
                    "success_improvement": 0.0,
                    "time_improvement": -191.99689976748255,
                    "length_improvement": 20.505117801390018,
                    "objective_score": -53.49804636996676
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.020148921012878417,
                    "num_nodes_avg": 182.6,
                    "path_length_avg": 126.28510850985008,
                    "success_improvement": 0.0,
                    "time_improvement": 29.774617527864315,
                    "length_improvement": 22.453335832022415,
                    "objective_score": 13.423052424763778
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm with adaptive informed sampling biased towards both the start and goal positions. It alternately extends the smaller of the two trees, employing a dynamically shrinking rewiring radius proportional to the logarithm of explored nodes to optimize local costs continuously. The sampling strategy leverages heuristic goal and start biasing for efficient exploration and exploitation balance. After each successful extension, it attempts to connect the opposite tree directly to form a complete path. Dead-end nodes are pruned periodically to maintain efficiency. Upon path discovery, a shortcut smoothing procedure is applied iteratively to minimize path length while ensuring collision-free transitions. Together, these improvements lead to faster planning times, higher success rates, more optimal and smoother paths, and elevated robustness in cluttered environments.",
          "planning_mechanism": "The planning mechanism grows two RRT* trees simultaneously from start and goal points, alternating growth on the smaller tree to keep balance. Samples are drawn with bias toward the start and goal to focus search in promising regions. New nodes are generated via steering, validated by collision checks on nodes and edges, and inserted using rewiring with a shrinking radius to refine path costs effectively. After extension, direct connection attempts between trees attempt path completion. Periodic pruning removes dead branches, reducing computation. Once connected, the extracted path undergoes shortcut smoothing to reduce unnecessary waypoints and path length, improving smoothness and efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=25.0,\n                 radius_min: float=5.0, prune_interval: int=250, prune_threshold: int=100,\n                 smoothing_iterations: int=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if self._squared_distance(node.position, pos) <= r_sq]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Check node validity and edge collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            # Choose best parent minimizing cost among neighbors\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring for lower cost paths locally\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-10 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            last_node = nearest(tree, node.position)\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                # Check for collision at node position and edge\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            for node in nodes[:]:\n                if (not node.children) and node is not start_root and node is not goal_root:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed_nodes.append(node)\n                    except Exception:\n                        continue\n            return removed_nodes\n\n        def path_length(path):\n            if len(path) < 2:\n                return 0.0\n            total = 0.0\n            for i in range(len(path) - 1):\n                total += distance(path[i], path[i + 1])\n            return total\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def informed_sample(c_best, c_min, x_center):\n            # Adaptive informed sampling within ellipse defined by start and goal\n            while True:\n                if is_3d:\n                    # sample in unit ball 3D\n                    from random import uniform\n                    import numpy as np\n                    import math\n\n                    # Create rotation matrix aligning ellipse axis\n                    a1 = [(goal_position[d] - start_position[d]) / c_min for d in range(len(start_position))]\n                    I = np.eye(3)\n                    M = np.outer(a1, I[:, 0])\n                    U, _, Vt = np.linalg.svd(M)\n                    C = np.dot(U, Vt)\n                    # sample random point in unit ball\n                    while True:\n                        x_ball = np.random.normal(0, 1, 3)\n                        norm = np.linalg.norm(x_ball)\n                        if 0 < norm <= 1:\n                            break\n                    x_ball = (x_ball / norm) * (random.random() ** (1.0/3.0))\n                    L = np.diag([c_best / 2.0, math.sqrt(c_best ** 2 - c_min ** 2) / 2.0, math.sqrt(c_best ** 2 - c_min ** 2) / 2.0])\n                    rnd = np.dot(np.dot(C, L), x_ball) + np.array(x_center)\n                    sample_pt = tuple(rnd)\n                else:\n                    import math\n                    # 2D ellipse sampling\n                    while True:\n                        r1 = random.random()\n                        r2 = random.random()\n                        theta = 2 * math.pi * r2\n                        radius = r1 ** 0.5\n                        x_ball = (radius * math.cos(theta), radius * math.sin(theta))\n\n                        a = c_best / 2.0\n                        b = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n                        rot = math.atan2(goal_position[1] - start_position[1], goal_position[0] - start_position[0])\n                        x = x_ball[0] * a\n                        y = x_ball[1] * b\n\n                        # Rotate and translate\n                        cos_r = math.cos(rot)\n                        sin_r = math.sin(rot)\n                        sample_x = cos_r * x - sin_r * y + x_center[0]\n                        sample_y = sin_r * x + cos_r * y + x_center[1]\n                        sample_pt = (sample_x, sample_y)\n\n                        if 0 <= sample_x <= bounds[0] and 0 <= sample_y <= bounds[1]:\n                            if not self._is_in_obstacle(sample_pt, obstacles, is_3d):\n                                return sample_pt\n                    continue\n\n                # Verify sample within bounds and not in obstacle\n                if all(0 <= sample_pt[d] <= bounds[d] for d in range(len(bounds))) and not self._is_in_obstacle(sample_pt, obstacles, is_3d):\n                    return sample_pt\n\n        def sample_adaptive(c_best):\n            c_min = distance(start_position, goal_position)\n            x_center = tuple((start_position[d] + goal_position[d]) / 2.0 for d in range(len(start_position)))\n            if c_best < float('inf'):\n                return informed_sample(c_best, c_min, x_center)\n            else:\n                return sample_free()\n\n        # Keep track of best path cost found so far\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        for itr in range(self.max_iter):\n            # Sample state with adaptive informed sampling if path found else biased random\n            sample_pt = sample_adaptive(best_cost)\n\n            # Alternate growth on smaller tree for balanced progress\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                candidate_cost = new_node_start.cost + new_node_goal.cost\n                if candidate_cost + 1e-10 < best_cost:\n                    best_cost = candidate_cost\n                    best_start_node = new_node_start\n                    best_goal_node = new_node_goal\n\n                # Immediately extract path if desired or keep searching for improvements (can break early or keep going)\n                # For better path quality, continue search but here break for efficiency and as per previous code\n                success_state = True\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n                smoothed_path = path_smoothing(raw_path)\n                if path_length(smoothed_path) + 1e-8 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    @staticmethod\n    def _squared_distance(p1, p2):\n        return sum((a - b) ** 2 for a, b in zip(p1, p2))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 22.94459,
          "time_improvement": -89.0,
          "length_improvement": 19.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.006510114669799805,
                    "num_nodes_avg": 74.9,
                    "path_length_avg": 163.0264082947292,
                    "success_improvement": 0.0,
                    "time_improvement": 35.47202450160224,
                    "length_improvement": 18.520968062095992,
                    "objective_score": 14.34580096289987
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.030130410194396974,
                    "num_nodes_avg": 194.7,
                    "path_length_avg": 252.37764071734563,
                    "success_improvement": 0.0,
                    "time_improvement": -110.64263153069815,
                    "length_improvement": 16.252560494398942,
                    "objective_score": -29.942277360329655
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08396587371826172,
                    "num_nodes_avg": 173.5,
                    "path_length_avg": 125.7449422235135,
                    "success_improvement": 0.0,
                    "time_improvement": -192.64771015297225,
                    "length_improvement": 22.78503047199763,
                    "objective_score": -53.237306951492144
               }
          ],
          "success_rate": 1.0
     }
]