[
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and            not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if not self._is_in_obstacle(new_pos, obstacles, is_3d) and                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -14.547310392594369,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0033696174621582033,
                    "num_nodes_avg": 59.1,
                    "path_length_avg": 170.9770888905735,
                    "success_improvement": 0.0,
                    "time_improvement": 66.60049721615668,
                    "length_improvement": 14.547294318234119,
                    "objective_score": 22.889608028493825
               },
               {
                    "map_id": 1,
                    "success_rate": 0.7,
                    "time_avg": 0.008120989799499512,
                    "num_nodes_avg": 195.7,
                    "path_length_avg": 276.36470377614694,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": 43.2259086098124,
                    "length_improvement": 8.292841453028517,
                    "objective_score": -0.3736591264505782
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.004628038406372071,
                    "num_nodes_avg": 134.2,
                    "path_length_avg": 154.99263582978188,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 83.8698177944377,
                    "length_improvement": 4.825184687042764,
                    "objective_score": 21.125982275739858
               }
          ]
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -6.05410676996533,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009668374061584472,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "success_improvement": 0.0,
                    "time_improvement": 4.167493784798042,
                    "length_improvement": 12.401486536989607,
                    "objective_score": 3.730545442837334
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019790220260620116,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "success_improvement": 0.0,
                    "time_improvement": -38.35404321990816,
                    "length_improvement": 14.190408824541839,
                    "objective_score": -8.668131201064078
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.00882866382598877,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "success_improvement": 0.0,
                    "time_improvement": 69.22930545503195,
                    "length_improvement": 11.655572158065754,
                    "objective_score": 23.099906068122735
               }
          ]
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for iter_num in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or            self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, new_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            connect_node.parent = best_parent\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n\n            nearest = connect_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -4.22512875357786,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007775163650512696,
                    "num_nodes_avg": 63.6,
                    "path_length_avg": 157.74844317172378,
                    "success_improvement": 0.0,
                    "time_improvement": 22.932913629961522,
                    "length_improvement": 21.158844301429212,
                    "objective_score": 11.111642949274298
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.019913077354431152,
                    "num_nodes_avg": 236.6,
                    "path_length_avg": 218.9843001436935,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -39.21294097057279,
                    "length_improvement": 27.333600643728058,
                    "objective_score": -16.29716216242622
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.008108234405517578,
                    "num_nodes_avg": 131.2,
                    "path_length_avg": 111.23634768618506,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 71.74023055938031,
                    "length_improvement": 31.694181530357035,
                    "objective_score": 17.860905473885502
               }
          ]
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements an anytime informed bidirectional RRT* variant with fast heuristic-informed sampling focusing search within an evolving ellipsoidal domain defined by currently best solution. It adaptively refines path quality by rewiring, employs KD-tree for nearest neighbor search, caches collision checks, prunes suboptimal branches, and applies iterative path smoothing. The bidirectional approach grows trees from start and goal asynchronously, prioritizing the smaller for extension, and connects them efficiently through incremental extension steps. Focused sampling and aggressive pruning reduce search space and improve convergence, producing shorter, smoother paths rapidly and robustly.",
          "planning_mechanism": "The planner initializes two trees from start and goal positions and iteratively samples points biased inside an informed ellipsoid that shrinks as better paths are found. The smaller tree is extended towards sampled points using RRT* style rewiring and cost optimization, with nearest neighbor queries accelerated by KD-tree. Connection attempts between trees are done incrementally with collision checking and caching. Periodic pruning removes unnecessary nodes, and the final path undergoes shortcut smoothing to improve quality and smoothness. This strategy improves planning efficiency, success rate, and path optimality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent: \n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def is_descendant_of(self, node):\n        \"\"\"Check if this node is descendant of given node.\"\"\"\n        cur = self.parent\n        while cur:\n            if cur == node:\n                return True\n            cur = cur.parent\n        return False\nclass Planner:\n    def __init__(self, max_iter: int =5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval:int=200, prune_threshold:int=300, smoothing_iterations:int=100,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clip to bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes,1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration/self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c+1)/c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1,p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree helper class for fast queries\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p,n in points_nodes]\n                self.nodes = [n for p,n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i,p in enumerate(self.points):\n                    d = dist(pt,p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i,p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d]-pt[d]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Sampling inside ellipsoid informed by current best path cost\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf'):\n                # No solution yet - uniform sample\n                for _ in range(10):\n                    p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Ellipsoidal sampling between start and goal (informed RRT*)\n            center = tuple((start[d] + goal[d])/2 for d in range(dim))\n            a1 = tuple((goal[d]-start[d])/c_min for d in range(dim))  # unit vector from start to goal\n\n            # Rotation matrix from unit vector to x-axis using Householder transform approximation for dim=2 or 3\n            import numpy as np\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d==0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u,u)\n            else:\n                rot = id_mat  # Already aligned\n\n            # Ellipsoid radii\n            r1 = c_best / 2.0\n            r_others = math.sqrt(r1**2 - (c_min/2)**2)\n            radii = [r1] + [r_others]*(dim-1)\n\n            # Sample a random point in unit ball\n            while True:\n                x = np.random.uniform(-1,1,dim)\n                if np.linalg.norm(x) <= 1:\n                    break\n            x = np.array(x)\n            # Scale with radii\n            x = x * radii\n            # Rotate to original coordinate system\n            p = rot @ x\n            # Translate back to center\n            p = p + np.array(center)\n\n            p_tuple = tuple(float(coord) for coord in p)\n            if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                return p_tuple\n            else:\n                # fallback uniform sampling if outside or collision\n                for _ in range(10):\n                    fallback_p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(fallback_p):\n                        return fallback_p\n                return fallback_p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1,p2):\n            if (p1,p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1,p2)]\n            if (p2,p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2,p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1,p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1,p2)\n            edge_collision_cache[(p1,p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        # Initialize trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal  = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        # Best path cost and path\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        def rebuild_kdtree():\n            return KDTree([(node.position, node) for node in nodes])\n\n        kd_tree = rebuild_kdtree()\n\n        def prune_useless_nodes():\n            # Prune nodes that cannot improve best path to reduce complexity\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                # Don't prune roots\n                if node in (root_start, root_goal):\n                    continue\n                # Prune if cost + heuristic > best path cost\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= c_best:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                # Remove from trees if present\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed +=1\n            return removed\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1,p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n            # Alternate, always extend smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Build KD-tree for tree_a subset\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest.position, new_pos):\n                continue\n\n            # Neighbor search radius\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for node in near:\n                c_p = node.cost + dist(node.position, new_pos)\n                if c_p + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = c_p\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cost improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try to connect tree_b to new_node incrementally\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_extend_steps = int(dist(last_node_b.position, new_node.position)/self.step_size) + 1\n\n            for _ in range(max_extend_steps):\n                new_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(new_pos_b) or not can_connect(last_node_b.position, new_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, new_pos_b)\n                new_node_b = Node(new_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(new_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_b_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_b_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_b_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Update best path cost and path\n                    c_best = final_cost\n                    best_path = merged_path\n\n                    # Shortcut smoothing\n                    best_path = shortcut_path(best_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_useless_nodes()\n                kd_tree = rebuild_kdtree()\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            # fallback if improved path not assigned\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -1.99103,
          "time_improvement": -7.0,
          "length_improvement": 21.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013820695877075195,
                    "num_nodes_avg": 90.8,
                    "path_length_avg": 165.68594819008476,
                    "success_improvement": 0.0,
                    "time_improvement": -36.99014075187401,
                    "length_improvement": 17.191755584556482,
                    "objective_score": -7.658691108650905
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.018435454368591307,
                    "num_nodes_avg": 189.5,
                    "path_length_avg": 235.2552560057235,
                    "success_improvement": 0.0,
                    "time_improvement": -28.882832879132593,
                    "length_improvement": 21.934347017770815,
                    "objective_score": -4.2779804601856135
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016191697120666503,
                    "num_nodes_avg": 153.5,
                    "path_length_avg": 123.44301109039233,
                    "success_improvement": 0.0,
                    "time_improvement": 43.56679831912523,
                    "length_improvement": 24.19855485839855,
                    "objective_score": 17.90975046741728
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm integrating adaptive goal biasing, dynamic neighborhood radius, and adaptive step sizing. It optimizes node connections with efficient rewiring and carefully balanced tree growth. Heuristic goal-biased sampling accelerates convergence, and rigorous collision checks ensure path feasibility. Post-processing with shortcut smoothing further refines the path quality, achieving reduced planning time and higher success rates.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal with biased sampling towards both ends, adapting the step length based on obstacle proximity for efficient exploration. It rewires nodes within a shrinking radius proportional to the tree size to locally optimize costs. The connection attempts between trees are incremental and maintain collision safety. The extracted path undergoes iterative shortcut smoothing to improve smoothness and minimize length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.25,\n                 radius_const: float=25.0,\n                 radius_min: float=5.0,\n                 smoothing_iter: int=60,\n                 collision_resolution: float=0.5,\n                 adaptive_step_min: float=1.5,\n                 adaptive_step_max: float=7.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.smoothing_iter = smoothing_iter\n        self.collision_resolution = collision_resolution\n        self.adaptive_step_min = adaptive_step_min\n        self.adaptive_step_max = adaptive_step_max\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(point):\n            for i, val in enumerate(point):\n                if val < 0 or val > bounds[i]:\n                    return False\n            return True\n\n        def sample_point():\n            # Adaptive goal biasing with occasional start bias to diversify\n            if random.random() < self.goal_sample_rate:\n                if random.random() < 0.85:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest(tree, point):\n            # Cached distance computation for speed\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                dist = distance(node.position, point)\n                if dist < best_dist:\n                    best_dist = dist\n                    best_node = node\n            return best_node\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_const\n            r = self.radius_const * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, r)\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius*radius\n            near = []\n            for node in tree:\n                dx = node.position[0] - pos[0]\n                dy = node.position[1] - pos[1]\n                dz = node.position[2] - pos[2] if is_3d else 0.0\n                dist_sq = dx*dx + dy*dy + dz*dz\n                if dist_sq <= r_sq:\n                    near.append(node)\n            return near\n\n        def adaptive_step(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            # Adaptive step based on minimum distance, clipped by min/max step\n            step = min(self.adaptive_step_max, max(self.adaptive_step_min, dist))\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def collision_free(node_pos):\n            return (in_bounds(node_pos) and not self._is_in_obstacle(node_pos, obstacles, is_3d))\n\n        def edge_collision_free(pos1, pos2):\n            if not in_bounds(pos2):\n                return False\n            return not self._is_edge_in_obstacle(pos1, pos2, obstacles, is_3d, self.collision_resolution)\n\n        def add_node(tree, new_node, parent_node):\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = adaptive_step(nearest_node.position, point)\n\n            if not collision_free(new_pos) or not edge_collision_free(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + distance(node.position, new_pos)\n                if temp_cost < min_cost and edge_collision_free(node.position, new_pos):\n                    min_cost = temp_cost\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-12 < neighbor.cost and edge_collision_free(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            max_iters = 5  # Limit incremental connection steps to reduce search time\n            for _ in range(max_iters):\n                new_pos = adaptive_step(last_node.position, node.position)\n                if not collision_free(new_pos) or not edge_collision_free(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                dist_to_goal = distance(new_pos, node.position)\n                if dist_to_goal <= self.step_size:\n                    if edge_collision_free(new_pos, node.position):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + dist_to_goal\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if edge_collision_free(p_i, p_j):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            rand_point = sample_point()\n\n            # Balance tree growth: extend smaller tree first for efficiency\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                extracted_path = extract_path(new_node_start, new_node_goal)\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -0.56941,
          "time_improvement": -4.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.011932563781738282,
                    "num_nodes_avg": 84.8,
                    "path_length_avg": 179.4556821069735,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -18.275056952991342,
                    "length_improvement": 10.309774920648962,
                    "objective_score": -8.42056210176761
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.021422696113586426,
                    "num_nodes_avg": 263.1,
                    "path_length_avg": 246.43185249463258,
                    "success_improvement": 0.0,
                    "time_improvement": -49.76673250493788,
                    "length_improvement": 18.22557418166317,
                    "objective_score": -11.284904915148728
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.012469840049743653,
                    "num_nodes_avg": 155.3,
                    "path_length_avg": 126.59919358120321,
                    "success_improvement": 0.0,
                    "time_improvement": 56.538651062263334,
                    "length_improvement": 22.260468677408557,
                    "objective_score": 21.41368905416071
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -0.2556317858417804,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.00937027931213379,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "success_improvement": 0.0,
                    "time_improvement": 7.122196069534629,
                    "length_improvement": 5.9265718433081265,
                    "objective_score": 3.321973189522014
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017043161392211913,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "success_improvement": 0.0,
                    "time_improvement": -19.14926952854797,
                    "length_improvement": 0.3867603104208941,
                    "objective_score": -5.667428796480212
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026260972023010254,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "success_improvement": 0.0,
                    "time_improvement": 8.472180558590889,
                    "length_improvement": 2.8534839845313615,
                    "objective_score": 3.112350964483539
               }
          ]
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid algorithm combines the efficient incremental bidirectional RRT* tree growth from Algorithm #1 with the heuristic-informed sampling, KD-tree accelerated nearest neighbor searches, collision caching, and pruning strategies from Algorithm #2. It interleaves adaptive ellipsoidal sampling focused on promising regions with balanced tree expansions. Periodic pruning of suboptimal nodes reduces search complexity, while incremental rewiring improves path cost. Final path smoothing ensures a high-quality, smooth path. This approach enhances planning efficiency, robustness, success rates, and path optimality, producing shorter and smoother paths faster in both 2D and 3D spaces.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternating extension of the smaller tree towards informed ellipsoid-biased samples. KD-tree structures accelerate neighbor queries for rewiring and nearest node search. Edge collision caching speeds collision checks. Nodes and edges are only added if both node placement and connecting edges are collision-free and within bounds. The best path cost updates the ellipsoid sampling region dynamically, progressively shrinking the search space. Periodic pruning removes nodes that cannot beat the current best path, lowering computational overhead. After successful connection, the final path is shortcut-smoothed for better smoothness and path length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checks etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_iterations: int = 100,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Helpers\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c+1)/c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree helper for nearest and radius search\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Ellipsoidal informed sampling as in Algorithm #2\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # No solution yet or marginal improvement: uniform sample\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Calculate ellipsoid parameters\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))  # unit vector from start to goal\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1**2 - (c_min / 2)**2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    x = x * radii\n                    p = rot @ x + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n            # fallback uniform sampling\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback last sample\n\n        # Caches for collision checks\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        # Shortcut smoothing (similar to both algorithms)\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Prune nodes that cannot improve the best path\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialize\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cost improvements\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try connect other tree incrementally to new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Update best cost and path\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to reduce complexity\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 2.55304,
          "time_improvement": -22.0,
          "length_improvement": 20.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.00791943073272705,
                    "num_nodes_avg": 61.8,
                    "path_length_avg": 158.4027803367249,
                    "success_improvement": 0.0,
                    "time_improvement": 21.50294454054769,
                    "length_improvement": 20.83181287552122,
                    "objective_score": 10.617245937268551
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027858495712280273,
                    "num_nodes_avg": 228.4,
                    "path_length_avg": 240.8903836814004,
                    "success_improvement": 0.0,
                    "time_improvement": -94.7596069705228,
                    "length_improvement": 20.06442101012724,
                    "objective_score": -24.414997889131392
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026755642890930176,
                    "num_nodes_avg": 178.9,
                    "path_length_avg": 129.35039218762472,
                    "success_improvement": 0.0,
                    "time_improvement": 6.748095637353845,
                    "length_improvement": 20.57106699807329,
                    "objective_score": 6.138642090820811
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an improved bidirectional RRT* variant with adaptive step size, informed sampling around an ellipse for faster convergence, and enhanced rewiring to optimize path quality and reduce search time. It incorporates aggressive rewiring, goal bias sampling, and path smoothing for robust and high-quality paths.",
          "planning_mechanism": "The planner grows two trees from start and goal positions, alternating expansions with adaptive step sizes. Sampling is biased towards an ellipsoidal region defined by current best path cost to focus exploration. After each extension, it attempts connection and performs rewiring with a dynamically adjusted radius to optimize the path. On successful connection, the path is extracted and smoothed.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def rewire(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        new_parent.children.append(self)\n        self.cost = new_cost\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 6.0, goal_sample_rate: float = 0.2,\n                 search_radius_factor: float = 20.0, smoothing_iterations: int = 5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # probability of sampling goal bias\n        self.search_radius_factor = search_radius_factor  # factor multiplier for neighbor search radius\n        self.smoothing_iterations = smoothing_iterations  # iterations for path smoothing\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n\n        nodes = []\n        edges = []\n\n        best_path_cost = float(\"inf\")\n        success_state = False\n        extracted_path = []\n\n        dimension = len(bounds)\n        diag_dist = math.dist((0,) * dimension, bounds)\n        # Dynamic radius for near neighbors will depend on sample count and dimension\n        def calc_radius(n_nodes):\n            gamma = self.search_radius_factor\n            unit_ball_volume = math.pi if dimension == 2 else (4/3)*math.pi\n            r = min(\n                self.step_size * 5,\n                gamma * ((math.log(max(n_nodes,1)) / max(n_nodes,1)) ** (1/dimension))\n            )\n            return r if r > self.step_size else self.step_size * 1.5\n\n        def ellipse_sample(c_best, start, goal):\n            # If no solution yet, sample uniformly\n            if c_best == float(\"inf\"):\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[i]) for i in range(3))\n                    else:\n                        p = tuple(random.uniform(0, bounds[i]) for i in range(2))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            # Ellipsoidal sampling focused between start and goal according to c_best path cost\n            center = tuple([(s + g) / 2 for s, g in zip(start, goal)])\n            a1 = [g - s for s, g in zip(start, goal)]\n            a1_len = math.dist(start, goal) / 2\n            if a1_len < 1e-6:\n                return start  # start == goal\n\n            # Rotation matrix to align ellipse along start-goal vector (assume 2D or 3D)\n            def unit_vector(v):\n                l = math.dist((0,) * len(v), v)\n                return tuple(x / l for x in v)\n\n            e_r1 = unit_vector(a1)\n            dim = len(start)\n\n            # Create an orthonormal basis with e_r1\n            import numpy as np\n            e1 = np.array(e_r1)\n            if dim == 2:\n                e2 = np.array([-e1[1], e1[0]])\n                basis = np.stack([e1, e2], axis=1)  # dim x dim\n            else:\n                # Gram-Schmidt for 3D, pick arbitrary vector not colinear\n                if abs(e1[0]) < abs(e1[1]):\n                    v = np.array([1,0,0])\n                else:\n                    v = np.array([0,1,0])\n                e2 = v - (np.dot(v,e1))*e1\n                e2 /= np.linalg.norm(e2)\n                e3 = np.cross(e1, e2)\n                basis = np.stack([e1, e2, e3], axis=1)\n\n            # Define ellipse axes lengths\n            r1 = c_best / 2\n            r2 = math.sqrt(max(c_best**2 - math.dist(start, goal)**2, 0)) / 2\n            if r2 < 1e-6:\n                r2 = self.step_size*2\n\n            while True:\n                # Sample point in unit ball scaled to ellipse\n                if dim == 2:\n                    sample_ball = np.random.normal(size=2)\n                else:\n                    sample_ball = np.random.normal(size=3)\n                sample_ball /= np.linalg.norm(sample_ball)\n                uniform_radius = random.uniform(0,1) ** (1/dim)\n                sample_ball = sample_ball * uniform_radius\n                scale = np.array([r1, r2] + ([r2] if dim==3 else []))\n                offset = center + basis @ (sample_ball * scale)\n                p = tuple(offset.tolist())\n                if all(0 <= p[i] <= bounds[i] for i in range(dim)) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def find_path_cost_back(node):\n            return node.cost if node else float(\"inf\")\n\n        for iteration in range(self.max_iter):\n            # With goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = ellipse_sample(best_path_cost, start_position, goal_position)\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size, bounds)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                radius = calc_radius(len(tree_a)+1)\n                near_nodes = self._near(tree_a, new_pos, radius)\n\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    cost = near.cost + math.dist(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node = Node(new_pos)\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewiring near nodes to new_node if improves cost and collision-free\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.rewire(new_node, new_cost)\n                        # Update edges list accordingly\n                        # Remove old edge:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        edges.append((new_node, near))\n\n                # Try connecting tree_b to this new_node\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    # Path found: Extract full path\n                    success_state = True\n                    path_a = []\n                    node_iter = new_node\n                    while node_iter:\n                        path_a.append(node_iter.position)\n                        node_iter = node_iter.parent\n                    path_a.reverse()\n                    path_b = []\n                    node_iter = connect_node\n                    while node_iter:\n                        path_b.append(node_iter.position)\n                        node_iter = node_iter.parent\n                    extracted_path = path_a + path_b\n\n                    new_path_cost = min_cost + connect_node.cost\n                    if new_path_cost < best_path_cost:\n                        best_path_cost = new_path_cost\n\n                    # Smooth path before return\n                    extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n\n    def _steer(self, from_pos, to_pos, step_size, bounds):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            new_pos = to_pos\n        else:\n            ratio = step_size / dist\n            new_pos = tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        # Enforce boundary limits\n        new_pos_clamped = tuple(\n            max(0, min(new_pos[i], bounds[i])) for i in range(len(new_pos))\n        )\n        return new_pos_clamped\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if math.dist(node.position, point) <= radius]\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import random\n        if len(path) < 3:\n            return path\n\n        smoothed = path[:]\n        for _ in range(self.smoothing_iterations):\n            if len(smoothed) < 3:\n                break\n            # Pick two random vertices i, j with j > i+1\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                # shortcut path segment by directly connecting i to j\n                smoothed = smoothed[:i + 1] + smoothed[j:]\n        return smoothed",
          "objective": 3.37674,
          "time_improvement": -21.0,
          "length_improvement": 14.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014727044105529784,
                    "num_nodes_avg": 160.9,
                    "path_length_avg": 174.3077033815884,
                    "success_improvement": 0.0,
                    "time_improvement": -45.97382525593398,
                    "length_improvement": 12.882685207815397,
                    "objective_score": -11.215610535217113
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022585201263427734,
                    "num_nodes_avg": 296.1,
                    "path_length_avg": 265.9289031898334,
                    "success_improvement": 0.0,
                    "time_improvement": -57.893842038152854,
                    "length_improvement": 11.755793146414167,
                    "objective_score": -15.01699398216302
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016541576385498045,
                    "num_nodes_avg": 209.4,
                    "path_length_avg": 135.1807269228711,
                    "success_improvement": 0.0,
                    "time_improvement": 42.3473580733592,
                    "length_improvement": 16.990890245358386,
                    "objective_score": 16.102385471079437
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a streamlined bidirectional RRT* planner with balanced tree growth, adaptive sampling biased towards start and goal, collision-free node and edge verification, and incremental rewiring within a dynamic neighborhood radius. It prioritizes computational efficiency and robust pathfinding through straightforward tree extensions, rewiring for cost improvements, and final path smoothing.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately extending towards sampled free points. For each new node, it rewires neighbors to reduce path cost if collision-free. It attempts to connect the opposite tree incrementally to the new node. Upon successful connection, the planner reconstructs and smooths the path before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 smoothing_iterations: int = 100,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / distance_between\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(len(bounds)))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - position[d])**2 for d in range(len(position))) <= r2]\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        tree_a, tree_b = [start_root], [goal_root]\n\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            sample = sample_free()\n            r = neighbor_radius(iteration, len(nodes))\n\n            # Extend tree_a towards sample\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            neighbors = near_nodes(tree_a, new_pos, r)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                cost_out = node.cost + dist(node.position, new_pos)\n                if cost_out + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_out\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper and collision-free\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try to connect tree_b to new_node incrementally\n            connect_node = nearest(tree_b, new_node.position)\n            curr_pos = connect_node.position\n            connected = False\n\n            while True:\n                next_pos = steer(curr_pos, new_node.position)\n                if not can_add_node(next_pos) or not can_connect(curr_pos, next_pos):\n                    break\n\n                neighbors_b = near_nodes(tree_b, next_pos, r)\n                min_cost_b = connect_node.cost + dist(curr_pos, next_pos)\n                best_parent_b = connect_node\n                for node_b in neighbors_b:\n                    if not can_connect(node_b.position, next_pos):\n                        continue\n                    cost_b = node_b.cost + dist(node_b.position, next_pos)\n                    if cost_b < min_cost_b:\n                        min_cost_b = cost_b\n                        best_parent_b = node_b\n\n                new_node_b = Node(next_pos, parent=best_parent_b, cost=min_cost_b)\n                best_parent_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((best_parent_b, new_node_b))\n\n                # Rewire neighbors of new_node_b\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is best_parent_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    path_start = new_node.path_from_root()\n                    path_goal = connection_node.path_from_root()\n                    extracted_path = path_start + path_goal[::-1][1:]\n                    extracted_path = shortcut_smoothing(extracted_path)\n                    connected = True\n                    break\n\n                curr_pos = new_node_b.position\n                connect_node = new_node_b\n\n            if connected:\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 5.05134,
          "time_improvement": -32.0,
          "length_improvement": 23.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011016368865966797,
                    "num_nodes_avg": 70.8,
                    "path_length_avg": 155.16720304344847,
                    "success_improvement": 0.0,
                    "time_improvement": -9.19377250942915,
                    "length_improvement": 22.44892330795998,
                    "objective_score": 1.7316529087632513
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025777411460876466,
                    "num_nodes_avg": 229.0,
                    "path_length_avg": 236.87693357543202,
                    "success_improvement": 0.0,
                    "time_improvement": -80.21068246785175,
                    "length_improvement": 21.396219536347616,
                    "objective_score": -19.783960833086002
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03083500862121582,
                    "num_nodes_avg": 252.3,
                    "path_length_avg": 121.00421879728697,
                    "success_improvement": 0.0,
                    "time_improvement": -7.469788212105313,
                    "length_improvement": 25.696120241684756,
                    "objective_score": 2.8982875847053577
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid algorithm integrates the bidirectional tree growth of the dual-tree RRT with the rewiring and path cost optimization from RRT*, combining efficient exploration and asymptotic optimality. It grows two trees from start and goal, extends them alternately toward random samples, uses a rewiring step to optimize local paths dynamically, and attempts connection when proximity allows. This approach improves path quality and success rate while maintaining computational efficiency and robust collision checking.",
          "planning_mechanism": "The planner alternates expansion between start and goal trees by sampling collision-free random points and steering nodes toward them. For each extension, a neighborhood rewiring step optimizes path costs locally. The algorithm attempts to connect the two trees by incremental steering with rewiring until a collision-free path uniting start and goal is found or maximum iterations are reached. Validity checks for nodes and edges are enforced strictly at every step.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        def _sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _distance(a, b):\n            return math.dist(a, b)\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: _distance(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            dist = _distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _near_nodes(tree, position, radius):\n            return [node for node in tree if _distance(node.position, position) <= radius]\n\n        def _can_connect(p1, p2):\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def _add_node(tree, new_node, parent_node):\n            parent_node.add_child(new_node)\n            new_node.cost = parent_node.cost + _distance(parent_node.position, new_node.position)\n            new_node.parent = parent_node\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n\n        def _rewire(tree, new_node):\n            neighbors = _near_nodes(tree, new_node.position, self.rewire_radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                new_cost = new_node.cost + _distance(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and _can_connect(new_node.position, neighbor.position):\n                    # Remove old edge\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n\n                    # Add new edge\n                    new_node.add_child(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    edges.append((new_node, neighbor))\n\n        def _extend(tree, point):\n            nearest = _nearest(tree, point)\n            new_pos = _steer(nearest.position, point)\n            if not _can_connect(nearest.position, new_pos):\n                return None\n            new_node = Node(new_pos)\n            min_cost = nearest.cost + _distance(nearest.position, new_pos)\n            best_parent = nearest\n\n            neighbors = _near_nodes(tree, new_pos, self.rewire_radius)\n\n            # Choose best parent from neighbors to minimize cost\n            for neighbor in neighbors:\n                c = neighbor.cost + _distance(neighbor.position, new_pos)\n                if c < min_cost and _can_connect(neighbor.position, new_pos):\n                    min_cost = c\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire around new node\n            _rewire(tree, new_node)\n            return new_node\n\n        def _connect(tree, new_node_other):\n            nearest = _nearest(tree, new_node_other.position)\n            curr_node = nearest\n\n            while True:\n                new_pos = _steer(curr_node.position, new_node_other.position)\n                if not _can_connect(curr_node.position, new_pos):\n                    return None\n\n                connect_node = Node(new_pos)\n                neighbors = _near_nodes(tree, new_pos, self.rewire_radius)\n\n                min_cost = curr_node.cost + _distance(curr_node.position, new_pos)\n                best_parent = curr_node\n\n                for neighbor in neighbors:\n                    c = neighbor.cost + _distance(neighbor.position, new_pos)\n                    if c < min_cost and _can_connect(neighbor.position, new_pos):\n                        min_cost = c\n                        best_parent = neighbor\n\n                best_parent.add_child(connect_node)\n                connect_node.parent = best_parent\n                connect_node.cost = min_cost\n                tree.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((best_parent, connect_node))\n\n                _rewire(tree, connect_node)\n\n                if _distance(connect_node.position, new_node_other.position) <= self.step_size:\n                    return connect_node\n\n                curr_node = connect_node\n\n        for iter_num in range(self.max_iter):\n            rand_point = _sample_free()\n\n            # Alternate expanding start and goal trees\n            if iter_num % 2 == 0:\n                new_node_start = _extend(tree_start, rand_point)\n                if new_node_start is None:\n                    continue\n                connect_node_goal = _connect(tree_goal, new_node_start)\n                if connect_node_goal:\n                    success_state = True\n                    path_start = new_node_start.path_from_root()\n                    path_goal = connect_node_goal.path_from_root()\n                    extracted_path = path_start + path_goal[::-1]\n                    break\n            else:\n                new_node_goal = _extend(tree_goal, rand_point)\n                if new_node_goal is None:\n                    continue\n                connect_node_start = _connect(tree_start, new_node_goal)\n                if connect_node_start:\n                    success_state = True\n                    path_goal = new_node_goal.path_from_root()\n                    path_start = connect_node_start.path_from_root()\n                    extracted_path = path_start + path_goal[::-1]\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 8.43218,
          "time_improvement": -22.0,
          "length_improvement": 25.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01331765651702881,
                    "num_nodes_avg": 100.9,
                    "path_length_avg": 160.7913922442542,
                    "success_improvement": 0.0,
                    "time_improvement": -32.004036336481114,
                    "length_improvement": 19.638007602273778,
                    "objective_score": -5.673609380489578
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.02202715873718262,
                    "num_nodes_avg": 209.4,
                    "path_length_avg": 217.93141644497078,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -53.992549441208105,
                    "length_improvement": 27.68298307560509,
                    "objective_score": -20.66116821724141
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.023168563842773438,
                    "num_nodes_avg": 214.7,
                    "path_length_avg": 119.99487511069171,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 19.250204209499422,
                    "length_improvement": 26.31591806914092,
                    "objective_score": 1.0382448766780126
               }
          ],
          "success_rate": 0.8666666666666667
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid algorithm combines the asymptotic optimality and rewiring principles from RRT* and the fast convergence benefits of a bidirectional approach inspired by RRT-Connect. It grows two trees simultaneously from start and goal with goal biasing, samples from free space, connects the trees when close enough, and performs rewiring in both trees to improve path quality incrementally. Additionally, it performs path shortcutting to smooth the final path for better quality.",
          "planning_mechanism": "The planner alternates tree expansions by sampling points with goal biasing, steering nearest nodes toward sampled points, rewires neighbors for cost improvements, tries connecting the two trees to form a full path, and upon success, extracts and smooths the path. Collision checks are applied for nodes and edges throughout, ensuring valid paths that respect obstacles and boundaries.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D position\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Accumulated path cost\n        self.children = []\n        self.valid = True               # For collision validity\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, neighbor_radius: float=12.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        import random\n        import math\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def _distance(a, b):\n            return math.dist(a, b)\n\n        def _steer(from_pos, to_pos, step_size):\n            dist = _distance(from_pos, to_pos)\n            if dist <= step_size:\n                return to_pos\n            ratio = step_size / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def _near(tree, point, radius):\n            return [node for node in tree if _distance(node.position, point) <= radius]\n\n        def _extract_path_meet(node_from_start, node_from_goal):\n            path_start = []\n            current = node_from_start\n            while current:\n                path_start.append(current.position)\n                current = current.parent\n            path_goal = []\n            cur = node_from_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def _path_shortcut(path):\n            # Attempt to smooth path by shortcutting between non-adjacent nodes if direct connection is collision-free\n            if len(path) < 3:\n                return path\n            smooth_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smooth_path.append(path[j])\n                i = j\n            return smooth_path\n\n        def _check_in_bounds(pos):\n            for i, val in enumerate(pos):\n                if val < 0 or val > bounds[i]:\n                    return False\n            return True\n\n        success = False\n        final_path = []\n\n        for iter in range(self.max_iter):\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Alternate between start_tree and goal_tree expansions\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Find nearest node in tree_a to sample\n                nearest = min(tree_a, key=lambda n: _distance(n.position, sample))\n                new_pos = _steer(nearest.position, sample, self.step_size)\n\n                # Check bounds\n                if not _check_in_bounds(new_pos):\n                    continue\n                # Collision checks\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Create new node, find near neighbors for rewiring\n                new_node = Node(new_pos)\n                near_nodes = _near(tree_a, new_pos, self.neighbor_radius)\n\n                min_cost = nearest.cost + _distance(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    temp_cost = near.cost + _distance(near.position, new_pos)\n                    if temp_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        min_parent = near\n\n                new_node.update_parent(min_parent, min_cost)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors in tree_a\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + _distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                        near.update_parent(new_node, new_cost)\n                        edges.append((new_node, near))\n\n                # Try connect tree_b to new_node in tree_a to form path\n                connect_node = min(tree_b, key=lambda n: _distance(n.position, new_node.position))\n                dist_connect = _distance(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size:\n                    if (not self._is_in_obstacle(connect_node.position, obstacles, is_3d) and\n                        not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d)):\n                        # Path connected, extract full path\n                        success = True\n                        final_path = _extract_path_meet(new_node, connect_node)\n                        # Smooth path with shortcutting\n                        final_path = _path_shortcut(final_path)\n                        break\n            if success:\n                break\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 11.21486,
          "time_improvement": -51.0,
          "length_improvement": 21.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013281702995300293,
                    "num_nodes_avg": 128.5,
                    "path_length_avg": 174.34981020638165,
                    "success_improvement": 0.0,
                    "time_improvement": -31.647666581591665,
                    "length_improvement": 12.861640621493342,
                    "objective_score": -6.921971850178831
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02387359142303467,
                    "num_nodes_avg": 287.3,
                    "path_length_avg": 230.3975784226972,
                    "success_improvement": 0.0,
                    "time_improvement": -66.90101757631824,
                    "length_improvement": 23.546288782365693,
                    "objective_score": -15.361047516422332
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.044390535354614256,
                    "num_nodes_avg": 367.1,
                    "path_length_avg": 121.70644892216498,
                    "success_improvement": 0.0,
                    "time_improvement": -54.7150997032626,
                    "length_improvement": 25.26490864195521,
                    "objective_score": -11.361548182587736
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements an efficient bidirectional RRT* planner combining balanced tree growth, adaptive neighbor radius for rewiring, incremental connection attempts, and path shortcut smoothing. It ensures collision-free node and edge validation, bounds adherence, and aims to improve path quality, success rate, and planning speed by dynamically rewiring nodes towards lower-cost paths.",
          "planning_mechanism": "The planner alternately extends two trees from the start and goal towards randomly sampled free points, chooses optimal parents in a dynamic neighborhood for each new node, rewires neighboring nodes if a cheaper path is found, and attempts incremental connections between trees. Upon successful connection, it reconstructs and smooths the path before returning.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position      # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent          # Node or None\n        self.cost = cost              # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True             # For potential future use\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 smoothing_iterations: int = 100, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback sample even if in obstacle\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / distance_between\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(len(bounds)))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes,1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + \\\n                      (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - position[d])**2 for d in range(len(position))) <= r2]\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n        tree_a, tree_b = [start_root], [goal_root]\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for iteration in range(self.max_iter):\n            sample = sample_free()\n            radius = neighbor_radius(iteration, len(nodes))\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            neighbors = near_nodes(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                cost_thru_node = node.cost + dist(node.position, new_pos)\n                if cost_thru_node + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_thru_node\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper path found via new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt incremental connection from tree_b towards new_node\n            connect_node = nearest(tree_b, new_node.position)\n            curr_pos = connect_node.position\n            connected = False\n\n            while True:\n                next_pos = steer(curr_pos, new_node.position)\n                if not can_add_node(next_pos) or not can_connect(curr_pos, next_pos):\n                    break\n\n                neighbors_b = near_nodes(tree_b, next_pos, radius)\n\n                min_cost_b = connect_node.cost + dist(curr_pos, next_pos)\n                best_parent_b = connect_node\n                for node_b in neighbors_b:\n                    cost_b = node_b.cost + dist(node_b.position, next_pos)\n                    if cost_b + 1e-12 < min_cost_b and can_connect(node_b.position, next_pos):\n                        min_cost_b = cost_b\n                        best_parent_b = node_b\n\n                new_node_b = Node(next_pos, parent=best_parent_b, cost=min_cost_b)\n                best_parent_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((best_parent_b, new_node_b))\n\n                # Rewire neighbors of new_node_b\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is best_parent_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    path_start = new_node.path_from_root()\n                    path_goal = connection_node.path_from_root()\n                    extracted_path = path_start + path_goal[::-1][1:]\n                    extracted_path = shortcut_smoothing(extracted_path)\n                    connected = True\n                    break\n\n                curr_pos = new_node_b.position\n                connect_node = new_node_b\n\n            if connected:\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 11.36172,
          "time_improvement": -53.0,
          "length_improvement": 22.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009463739395141602,
                    "num_nodes_avg": 65.6,
                    "path_length_avg": 156.78522789428558,
                    "success_improvement": 0.0,
                    "time_improvement": 6.195823762394946,
                    "length_improvement": 21.640250039152267,
                    "objective_score": 6.186797136548938
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023795652389526366,
                    "num_nodes_avg": 218.4,
                    "path_length_avg": 241.46927916424852,
                    "success_improvement": 0.0,
                    "time_improvement": -66.35614337741997,
                    "length_improvement": 19.872323904012422,
                    "objective_score": -15.932378232423506
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05674192905426025,
                    "num_nodes_avg": 304.6,
                    "path_length_avg": 122.22337727974164,
                    "success_improvement": 0.0,
                    "time_improvement": -97.76362553088236,
                    "length_improvement": 24.94748349011496,
                    "objective_score": -24.339590961241715
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This improved planner implements a bidirectional RRT* algorithm with heuristic-informed adaptive sampling biased towards the goal region to direct exploration. It uses a dynamic neighborhood radius for rewiring to optimize path costs continuously. Additionally, it incorporates intelligent periodic pruning of dead-end nodes to reduce computational overhead and an enhanced shortcut smoothing technique that attempts multiple path refinements to minimize path length and improve smoothness. Rigorous collision checks ensure validity of nodes and edges, while balanced tree expansions promote efficient bidirectional search and early path convergence leading to a robust, high-quality, and computationally efficient path planning solution.",
          "planning_mechanism": "The planner grows two trees from start and goal, always extending the smaller tree to maintain balanced exploration. Sampling is adaptively biased towards the goal area to guide the search effectively. Nodes are only added if collision-free, and rewiring within a dynamically calculated neighborhood improves path cost continually. Dead-end nodes are periodically pruned to keep the tree manageable. Once a connection between the trees is found, iterative shortcut smoothing refines the path, producing a shorter and smoother trajectory.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2, radius_constant: float=30.0,\n                 radius_min: float=5.0, prune_interval: int=150,\n                 prune_threshold: int=150, smoothing_iterations: int=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d in range(len(pos)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            p_bias = 0.85\n            if random.random() < self.goal_sample_rate:\n                # Adaptive informed sampling: biased around goal with small Gaussian noise\n                if random.random() < p_bias:\n                    dim = len(bounds)\n                    noise_scale = self.step_size * 1.5\n                    if dim == 2:\n                        sample = (random.gauss(goal_position[0], noise_scale),\n                                  random.gauss(goal_position[1], noise_scale))\n                    else:\n                        sample = tuple(random.gauss(goal_position[d], noise_scale) for d in range(dim))\n                    # Check bounds and collisions\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                # fallback to pure uniform random sample\n                # sample uniformly until valid\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d) and in_bounds(sample):\n                        return sample\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d) and in_bounds(sample):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            # Use list copy to avoid modifying list while iterating\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                # Dead-end nodes have no children and are not start/goal\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Extend smaller tree for balanced exploration\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 11.40345,
          "time_improvement": -47.0,
          "length_improvement": 21.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.016108107566833497,
                    "num_nodes_avg": 86.3,
                    "path_length_avg": 161.6470753664288,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -59.66286664965168,
                    "length_improvement": 19.21034540220651,
                    "objective_score": -19.0567909144542
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027827692031860352,
                    "num_nodes_avg": 173.6,
                    "path_length_avg": 238.82154154739888,
                    "success_improvement": 0.0,
                    "time_improvement": -94.54425748597812,
                    "length_improvement": 20.750932822233363,
                    "objective_score": -24.213090681346763
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024597597122192384,
                    "num_nodes_avg": 154.9,
                    "path_length_avg": 123.94005355805423,
                    "success_improvement": 0.0,
                    "time_improvement": 14.269569834663018,
                    "length_improvement": 23.893340840912128,
                    "objective_score": 9.05953911858133
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner with adaptive step sizing, dynamic radius rewiring, and goal-biased sampling to improve exploration efficiency and path quality. The planner incrementally grows two trees from start and goal, attempts connections between them, and uses shortcut smoothing on the final combined path to deliver shorter and smoother trajectories with robustness in collision avoidance and bounded node placement.",
          "planning_mechanism": "The planner alternately extends two trees by sampling points mostly in free space but biased towards the goal to accelerate convergence. Each extension uses adaptive step size and dynamically computed radii to find near neighbors for rewiring, improving path optimality. After connecting the trees, the path is extracted and refined using shortcut smoothing, assuring collision and bound checks throughout the process to guarantee feasible, high-quality paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost\n        self.children = []\n        self.valid = True               # Node validity flag\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_and_propagate(self, new_cost):\n        self.cost = new_cost\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_cost_and_propagate(new_cost + dist)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 6.0, goal_sample_rate: float = 0.12, radius_constant: float = 24.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Probability to sample goal point\n        self.radius_constant = radius_constant      # Coefficient for dynamic radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            # Goal-biased sampling with slight randomness to increase exploration\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        break\n\n            # Alternate tree growth: (start -> goal) and (goal -> start)\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                # 1. Find nearest node in tree_a\n                nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n                dist_near_to_sample = math.dist(nearest.position, sample)\n                if dist_near_to_sample == 0:\n                    continue\n\n                # 2. Adaptive step sizing to avoid overshoot\n                step = min(self.step_size, dist_near_to_sample)\n                new_pos = tuple(nearest.position[d] + (sample[d] - nearest.position[d]) * (step / dist_near_to_sample) for d in range(dim))\n\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # 3. Create new node with cost from nearest\n                new_node = Node(new_pos)\n                # Compute dynamic radius for rewiring (RRT* style)\n                radius = min(\n                    self.radius_constant * ((math.log(len(tree_a) + 1) / (len(tree_a) + 1)) ** (1 / dim)),\n                    self.step_size * 5\n                )\n\n                # 4. Find neighbors within radius for potential better parent connection\n                near_nodes = [node for node in tree_a if math.dist(node.position, new_pos) <= radius]\n\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near in near_nodes:\n                    if near == nearest:\n                        continue\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = near\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                new_node.parent = best_parent\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # 5. Rewire neighbors to improve paths where beneficial\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                            try:\n                                near.parent.children.remove(near)\n                            except ValueError:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        near.update_cost_and_propagate(new_cost)\n\n                # 6. Attempt to connect the other tree\n                nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n                dist_to_connect = math.dist(nearest_other.position, new_node.position)\n                if dist_to_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    # Connect trees and extract path\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = new_node.path_from_root()\n                        path_goal = nearest_other.path_from_root()\n                        path_goal.reverse()\n                        full_path = path_start + path_goal\n                    else:\n                        path_start = nearest_other.path_from_root()\n                        path_goal = new_node.path_from_root()\n                        path_goal.reverse()\n                        full_path = path_start + path_goal\n\n                    # Smooth final path with shortcutting\n                    smoothed_path = self._smooth_path(full_path, obstacles, is_3d, max_iterations=150, map_bounds=bounds)\n\n                    extracted_path = smoothed_path\n                    return PlannerResult(True, extracted_path, nodes, edges)\n\n        # If no path found\n        return PlannerResult(False, extracted_path, nodes, edges)\n\n\n    def _smooth_path(self, path, obstacles, is_3d, max_iterations=150, map_bounds=None):\n        import random\n\n        def valid_edge(p1, p2):\n            if map_bounds:\n                for d in range(len(p1)):\n                    if p1[d] < 0 or p1[d] > map_bounds[d]:\n                        return False\n                    if p2[d] < 0 or p2[d] > map_bounds[d]:\n                        return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        if len(path) < 3:\n            return path[:]\n\n        path = path[:]\n        for _ in range(max_iterations):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if valid_edge(path[i], path[j]):\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 11.8182,
          "time_improvement": -51.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023647093772888185,
                    "num_nodes_avg": 132.8,
                    "path_length_avg": 171.6632933428514,
                    "success_improvement": 0.0,
                    "time_improvement": -134.3889723884336,
                    "length_improvement": 14.20433592843752,
                    "objective_score": -37.47582453084257
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.020715737342834474,
                    "num_nodes_avg": 206.8,
                    "path_length_avg": 243.57773464966635,
                    "success_improvement": 0.0,
                    "time_improvement": -44.82436182713705,
                    "length_improvement": 19.172667041727053,
                    "objective_score": -9.612775139795703
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02119474411010742,
                    "num_nodes_avg": 255.5,
                    "path_length_avg": 131.94851844751196,
                    "success_improvement": 0.0,
                    "time_improvement": 26.12959222084375,
                    "length_improvement": 18.975660960743372,
                    "objective_score": 11.6340098584018
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm with adaptive sampling towards the goal and start to improve exploration efficiency. It employs a KD-tree to accelerate nearest and near neighbor searches, dynamically adjusts the neighborhood radius based on the growing tree sizes, and performs incremental rewiring to minimize path cost and improve smoothness. Early connection attempts between the two trees enable faster convergence. Post path extraction, an optimization-based shortcutting smooths the path while ensuring collision-free transitions. Overall, this approach balances fast search, path quality, robustness, and planning efficiency.",
          "planning_mechanism": "The planner grows two trees bidirectionally from start and goal, alternately extending them by sampling points biased toward both ends. Using KD-trees, it quickly finds nearest and nearby nodes for efficient rewiring to locally optimize path costs. The rewiring radius shrinks adaptively with the tree size, focusing on refining the solution as exploring proceeds. When trees connect, the shortest cost path is extracted and post-processed by shortcutting to smooth the trajectory. Collision checks prevent invalid nodes or edges, and out-of-bound checks ensure safety.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 radius_constant: float=40.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        class KDTree:\n            def __init__(self):\n                self.points = []\n                self.nodes = []\n\n            def insert(self, node):\n                self.points.append(node.position)\n                self.nodes.append(node)\n\n            def nearest(self, point):\n                best_node = None\n                best_dist = float('inf')\n                for node in self.nodes:\n                    dist = math.dist(node.position, point)\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_node = node\n                return best_node\n\n            def near(self, point, radius):\n                r_sq = radius * radius\n                neighbors = []\n                for node in self.nodes:\n                    dx = 0\n                    for d in range(dim):\n                        diff = node.position[d] - point[d]\n                        dx += diff * diff\n                        if dx > r_sq:\n                            break\n                    if dx <= r_sq:\n                        neighbors.append(node)\n                return neighbors\n\n        def sample_free():\n            # Adaptive goal/start biasing to balance exploration\n            r = random.random()\n            if r < self.goal_sample_rate:\n                return goal_position\n            elif r < self.goal_sample_rate * 2:\n                return start_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def out_of_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return True\n            return False\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_constant\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        # Initialize trees and kd-trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        kd_start = KDTree()\n        kd_goal = KDTree()\n        kd_start.insert(start_root)\n        kd_goal.insert(goal_root)\n\n        tree_flag = True  # True: extend start tree; False: extend goal tree\n\n        def try_extend(tree, kd_tree, point):\n            if not tree:\n                return None\n            nearest_node = kd_tree.nearest(point)\n            if nearest_node is None:\n                return None\n            new_pos = steer(nearest_node.position, point)\n            if out_of_bounds(new_pos): \n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = kd_tree.near(new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + math.dist(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            kd_tree.insert(new_node)\n\n            # Rewire neighbors for incremental optimization\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, kd_tree, node):\n            if not tree:\n                return None\n            nearest_node = kd_tree.nearest(node.position)\n            if nearest_node is None:\n                return None\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if out_of_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + math.dist(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n                kd_tree.insert(new_node)\n\n                if math.dist(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + math.dist(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        kd_tree.insert(final_node)\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def combine_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            path_goal.reverse()\n            return path_start + path_goal[1:]\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Alternate tree extension with balancing sizes for faster convergence\n            if len(tree_start) > len(tree_goal):\n                tree_extend, kd_extend = tree_goal, kd_goal\n                tree_connect, kd_connect = tree_start, kd_start\n                start_tree_flag = False\n            else:\n                tree_extend, kd_extend = tree_start, kd_start\n                tree_connect, kd_connect = tree_goal, kd_goal\n                start_tree_flag = True\n\n            new_node = try_extend(tree_extend, kd_extend, rand_point)\n            if new_node is None:\n                continue\n\n            connect_node = try_connect(tree_connect, kd_connect, new_node)\n            if connect_node is not None:\n                success_state = True\n                if start_tree_flag:\n                    extracted_path = combine_path(new_node, connect_node)\n                else:\n                    extracted_path = combine_path(connect_node, new_node)\n\n                # Post-process smoothing\n                extracted_path = smooth_path(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 12.53989,
          "time_improvement": -56.0,
          "length_improvement": 22.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012874317169189454,
                    "num_nodes_avg": 112.4,
                    "path_length_avg": 158.54806002330182,
                    "success_improvement": 0.0,
                    "time_improvement": -27.6096758642203,
                    "length_improvement": 20.759203484525322,
                    "objective_score": -4.131062062361026
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03498883247375488,
                    "num_nodes_avg": 396.1,
                    "path_length_avg": 235.32768417519816,
                    "success_improvement": 0.0,
                    "time_improvement": -144.6080122675867,
                    "length_improvement": 21.910312900785097,
                    "objective_score": -39.00034110011899
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.027908682823181152,
                    "num_nodes_avg": 266.9,
                    "path_length_avg": 124.63820597220362,
                    "success_improvement": 0.0,
                    "time_improvement": 2.7293856430958123,
                    "length_improvement": 23.464633201215378,
                    "objective_score": 5.511742333171819
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT* variant that integrates adaptive step sizing and dynamic radius rewiring for improved efficiency and path quality. It grows two trees from start and goal, samples points biased towards the path for faster convergence, and employs smoothing on the resultant path to increase smoothness and robustness. It enforces strict collision and edge checks and limits node placement within map bounds.",
          "planning_mechanism": "The planner alternately grows two trees by sampling points biased via a goal-biased probability. Each extension employs adaptive step sizing based on distance to the sample, then rewires nodes in a dynamically calculated radius to optimize cost. Connection attempts between the two trees are made after each extension. The final combined path is smoothed using shortcutting to reduce unnecessary waypoints and produce a shorter, smoother trajectory.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated cost from root\n        self.children = []\n        self.valid = True               # Node validity flag\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_and_propagate(self, new_cost):\n        self.cost = new_cost\n        for child in self.children:\n            child.update_cost_and_propagate(new_cost + self._distance(self.position, child.position))\n\n    @staticmethod\n    def _distance(a, b):\n        import math\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float=7.0, goal_sample_rate: float = 0.1, radius_constant: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal point\n        self.radius_constant = radius_constant    # Used for dynamic radius calculation\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        dim = len(bounds)\n        unit_ball_volume = {2: math.pi, 3: 4 / 3 * math.pi}[dim]\n\n        for iter in range(self.max_iter):\n            # Goal-biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        break\n\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                # Find nearest in tree_a\n                nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n                direction_distance = math.dist(nearest.position, sample)\n                if direction_distance == 0.0:\n                    continue\n\n                # Adaptive step size: don't overshoot closer samples\n                step = min(self.step_size, direction_distance)\n                new_pos = tuple(\n                    nearest.position[d] + (sample[d] - nearest.position[d]) * (step / direction_distance) for d in range(dim)\n                )\n\n                if not in_bounds(new_pos) or self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                # Compute dynamic radius (RRT* style)\n                radius = min(\n                    self.radius_constant * ((math.log(len(tree_a) + 1) / (len(tree_a) + 1)) ** (1 / dim)),\n                    self.step_size * 5\n                )\n\n                near_nodes = [node for node in tree_a if math.dist(node.position, new_pos) <= radius]\n\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                best_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + math.dist(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = near\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                new_node.parent = best_parent\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            # Remove old edge\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                            try:\n                                near.parent.children.remove(near)\n                            except ValueError:\n                                pass\n\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        # Propagate cost update downwards\n                        near.update_cost_and_propagate(new_cost)\n\n                # Attempt connection to the other tree\n                nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n                dist_connect = math.dist(nearest_other.position, new_node.position)\n\n                if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    # Connect the trees\n                    success_state = True\n                    # Form path from start_root to new_node\n                    if tree_a is tree_start:\n                        path_start = new_node.path_from_root()\n                        path_goal = nearest_other.path_from_root()\n                        path_goal.reverse()\n                        full_path = path_start + path_goal\n                    else:\n                        path_start = nearest_other.path_from_root()\n                        path_goal = new_node.path_from_root()\n                        path_goal.reverse()\n                        full_path = path_start + path_goal\n\n                    # Smooth the path via shortcutting method\n                    smoothed_path = self._smooth_path(full_path, obstacles, is_3d, max_iterations=150, map_bounds=bounds)\n\n                    extracted_path = smoothed_path\n                    return PlannerResult(True, extracted_path, nodes, edges)\n\n        return PlannerResult(False, extracted_path, nodes, edges)\n\n\n    def _smooth_path(self, path, obstacles, is_3d, max_iterations=100, map_bounds=None):\n        import random\n        import math\n\n        def valid_edge(p1, p2):\n            if map_bounds:\n                for d in range(len(p1)):\n                    if p1[d] < 0 or p1[d] > map_bounds[d]:\n                        return False\n                    if p2[d] < 0 or p2[d] > map_bounds[d]:\n                        return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        if len(path) < 3:\n            return path[:]\n\n        path = path[:]\n        for _ in range(max_iterations):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n\n            if valid_edge(path[i], path[j]):\n                # Remove intermediate nodes and connect directly\n                path = path[:i+1] + path[j:]\n\n        return path\n\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 25.54824,
          "time_improvement": -98.0,
          "length_improvement": 20.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02762300968170166,
                    "num_nodes_avg": 99.9,
                    "path_length_avg": 167.97260652957092,
                    "success_improvement": 0.0,
                    "time_improvement": -173.7980791953795,
                    "length_improvement": 16.048905724690606,
                    "objective_score": -48.92964261367573
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023543739318847658,
                    "num_nodes_avg": 192.1,
                    "path_length_avg": 243.82630931447866,
                    "success_improvement": 0.0,
                    "time_improvement": -64.59501129251362,
                    "length_improvement": 19.090181558287142,
                    "objective_score": -15.560467076096655
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.044884872436523435,
                    "num_nodes_avg": 404.1,
                    "path_length_avg": 123.9554182240814,
                    "success_improvement": 0.0,
                    "time_improvement": -56.43802127435036,
                    "length_improvement": 23.883906010388394,
                    "objective_score": -12.15462518022743
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is a bidirectional RRT* variant integrating informed sampling and adaptive rewiring to boost planning efficiency, path optimality, and success rate. It uses heuristic guiding from the start towards the goal with dynamic radius-based rewiring and path smoothing to achieve shorter and smoother paths.",
          "planning_mechanism": "The planner simultaneously grows two trees from start and goal within the map. Sampling focuses within an ellipsoidal informed subset to bias towards promising regions. New nodes are added after collision checks, then nearby nodes within an adaptive radius are rewired for lower-cost connections. Trees attempt connection after each extension, resulting in a high-quality solution. Finally, path extraction and smoothing refine the solution for shorter, smoother trajectories.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost(self, new_cost):\n        self.cost = new_cost\n        for c in self.children:\n            c.update_cost(c.parent.cost + self._distance(c.parent.position, c.position))\n\n    @staticmethod\n    def _distance(a, b):\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        c_best = math.dist(start_position, goal_position) * 2  # Initial cost upper bound\n        c_min = math.dist(start_position, goal_position)\n\n        def informed_sample():\n            # Sample inside an ellipsoid around start-goal to improve efficiency\n            x_start = start_position\n            x_goal = goal_position\n            while True:\n                # Sample uniformly in unit ball in dimension d\n                d = 3 if is_3d else 2\n                while True:\n                    sample = tuple(random.uniform(-1,1) for _ in range(d))\n                    radius = math.sqrt(sum(s*s for s in sample))\n                    if radius <= 1:\n                        break\n                # Scale to ellipsoid\n                L = [0]*d\n                for i in range(d):\n                    L[i] = (c_best/2 if i==0 else math.sqrt(c_best**2 - c_min**2)/2)\n                # Rotation matrix aligning x-axis with vector from start to goal\n                def rotation_vector_angle(theta):\n                    if d==2:\n                        # 2D rotate by angle theta\n                        cos_t = math.cos(theta)\n                        sin_t = math.sin(theta)\n                        return [[cos_t, -sin_t],\n                                [sin_t,  cos_t]]\n                    else:\n                        # For 3D, compute rotation matrix by Rodrigues' formula\n                        vec1 = (1,0,0)\n                        vec2 = tuple(x_goal[i]-x_start[i] for i in range(3))\n                        norm_vec2 = math.dist((0,0,0), vec2)\n                        if norm_vec2 == 0:\n                            return [[1,0,0],[0,1,0],[0,0,1]]\n                        axis = (vec1[1]*vec2[2]-vec1[2]*vec2[1],\n                                vec1[2]*vec2[0]-vec1[0]*vec2[2],\n                                vec1[0]*vec2[1]-vec1[1]*vec2[0])\n                        axis_norm = math.dist((0,0,0), axis)\n                        if axis_norm == 0:\n                            return [[1,0,0],[0,1,0],[0,0,1]]\n                        axis = tuple(a/axis_norm for a in axis)\n                        angle = math.acos((vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2])/norm_vec2)\n                        K = [[0,-axis[2],axis[1]],\n                             [axis[2],0,-axis[0]],\n                             [-axis[1],axis[0],0]]\n                        I = [[1,0,0],[0,1,0],[0,0,1]]\n                        # Rodrigues rotation matrix R = I + sin\u03b8*K + (1-cos\u03b8)*K^2\n                        R = [[0]*3 for _ in range(3)]\n                        # Matrix addition helper\n                        def mat_add(A,B):\n                            return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                        # Matrix scalar mult helper\n                        def mat_scalar_mul(A, s):\n                            return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                        # Matrix multiplication helper\n                        def mat_mul(A,B):\n                            return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        K2 = mat_mul(K,K)\n                        R = mat_add(mat_add(I, mat_scalar_mul(K, math.sin(angle))), mat_scalar_mul(K2, 1 - math.cos(angle)))\n                        return R\n                d_vec = tuple(x_goal[i] - x_start[i] for i in range(d))\n                norm_d = math.dist((0,)*d, d_vec)\n                # To avoid complexity, use identity matrix if direction vector is axis-aligned\n                if d == 2:\n                    angle = math.atan2(d_vec[1], d_vec[0]) if norm_d > 1e-8 else 0\n                    R = rotation_vector_angle(angle)\n                    scaled = tuple(L[i]*sample[i] for i in range(d))\n                    rotated = (R[0][0]*scaled[0] + R[0][1]*scaled[1],\n                               R[1][0]*scaled[0] + R[1][1]*scaled[1])\n                    pos = tuple(rotated[i] + (x_start[i] + x_goal[i]) / 2 for i in range(d))\n                else:\n                    R = rotation_vector_angle(0)  # Identity for now for simplification\n                    scaled = tuple(L[i]*sample[i] for i in range(d))\n                    pos = tuple(scaled[i] + (x_start[i] + x_goal[i]) / 2 for i in range(d))\n                if self._inside_bounds(pos, bounds) and not self._is_in_obstacle(pos, obstacles, is_3d):\n                    return pos\n\n        def improved_sample():\n            # With probability p, sample informed; else, uniform\n            p = 0.7\n            if c_best < float(\"inf\") and random.random() < p:\n                return informed_sample()\n            else:\n                return self._uniform_sample(bounds, obstacles, is_3d)\n\n        # Main loop\n        for iteration in range(self.max_iter):\n            rand_point = improved_sample()\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = self._nearest(tree_a, rand_point)\n                new_pos = self._steer(nearest_node.position, rand_point, self.step_size)\n                if not self._inside_bounds(new_pos, bounds):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.parent = nearest_node\n                new_node.cost = new_cost\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Rewire nearby nodes within rewire_radius to improve path costs\n                near_nodes = self._near(tree_a, new_pos, self.rewire_radius)\n                for near_node in near_nodes:\n                    if near_node == nearest_node:\n                        continue\n                    potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                    if potential_cost < near_node.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                            # Rewire near_node\n                            if near_node.parent is not None:\n                                # Remove old edge\n                                try:\n                                    edges.remove((near_node.parent, near_node))\n                                    near_node.parent.children.remove(near_node)\n                                except (ValueError, AttributeError):\n                                    pass\n                            near_node.parent = new_node\n                            near_node.cost = potential_cost\n                            new_node.add_child(near_node)\n                            edges.append((new_node, near_node))\n                            # Update costs of subtree rooted at near_node\n                            self._update_subtree_costs(near_node, obstacles, is_3d)\n\n                # Try connecting to other tree\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size and \\\n                   not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    # Merge trees, extract path\n                    success_state = True\n                    c_best = min(c_best, new_node.cost + connect_node.cost + dist_connect)\n\n                    path_start = self._path_to_root(new_node)\n                    path_goal = self._path_to_root(connect_node)\n                    path_goal.reverse()\n                    extracted_path = path_start + path_goal\n\n                    # Optional smoothing\n                    extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n                    return PlannerResult(success_state, extracted_path, nodes, edges)\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _uniform_sample(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _inside_bounds(self, pos, bounds):\n        return all(0 <= pos[i] <= bounds[i] for i in range(len(bounds)))\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if math.dist(node.position, point) <= radius]\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], step_size: float) -> Tuple[float, ...]:\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _path_to_root(self, node: Node) -> List[Tuple[float, ...]]:\n        path = []\n        current = node\n        while current is not None:\n            path.append(current.position)\n            current = current.parent\n        return path[::-1]\n\n    def _update_subtree_costs(self, node: Node, obstacles, is_3d):\n        # DFS update cost of children recursively\n        for child in node.children:\n            if not self._is_edge_in_obstacle(node.position, child.position, obstacles, is_3d):\n                child.cost = node.cost + math.dist(node.position, child.position)\n                self._update_subtree_costs(child, obstacles, is_3d)\n\n    def _smooth_path(self, path: List[Tuple[float, ...]], obstacles, is_3d, iterations=20) -> List[Tuple[float, ...]]:\n        # Shortcut smoothing attempts to remove unnecessary waypoints\n        if len(path) < 3:\n            return path\n\n        for _ in range(iterations):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 32.39026,
          "time_improvement": -120.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018288540840148925,
                    "num_nodes_avg": 136.6,
                    "path_length_avg": 176.17728495855667,
                    "success_improvement": 0.0,
                    "time_improvement": -81.27522710300693,
                    "length_improvement": 11.948286305123998,
                    "objective_score": -21.992910869877278
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0203230619430542,
                    "num_nodes_avg": 275.6,
                    "path_length_avg": 251.47819612943417,
                    "success_improvement": 0.0,
                    "time_improvement": -42.07915593669526,
                    "length_improvement": 16.551026638232653,
                    "objective_score": -9.313541453362047
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09636964797973632,
                    "num_nodes_avg": 629.7,
                    "path_length_avg": 122.9577397894858,
                    "success_improvement": 0.0,
                    "time_improvement": -235.87879885759014,
                    "length_improvement": 24.496540670390164,
                    "objective_score": -65.86433152319901
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This implementation enhances the bidirectional RRT* by introducing adaptive goal bias with a faster ramp-up for better early convergence, employs a k-d tree for efficient nearest neighbor and radius searches reducing computational complexity, introduces lazy collision checks caching edge validity to avoid redundant computations, and implements more aggressive pruning of unproductive nodes. It prioritizes incremental extension of the smaller tree towards adaptively sampled points, dynamic neighbor radius based on iteration and node count, heuristic sampling weighted by distance to goal/start, and iterative shortcut smoothing to produce shorter, smoother, and near-optimal collision-free paths rapidly and robustly.",
          "planning_mechanism": "The planner grows two trees from start and goal, always extending the smaller tree towards adaptively sampled points biased towards start/goal or randomly sampled. It uses k-d trees for fast neighborhood queries, dynamically adjusts neighbor radius based on iteration and tree size for efficient rewiring. Each new node picks the best parent minimizing cost, rewires neighbors, and attempts incremental connections to the opposing tree with cached lazy collision checks. Periodic pruning removes dead-end nodes, and final solution paths undergo iterative shortcut smoothing for path quality improvement.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.25,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=150,\n                 prune_threshold: int=200,\n                 smoothing_iterations: int=120,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        # ---- Helper functions ----\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # KD-Tree for fast nearest and radius search\n        # Simple 2D/3D KD-tree for nodes positions with rebuilding every prune_interval\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = len(points_nodes[0][0]) if points_nodes else 2\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, point):\n                best = None\n                best_dist = float('inf')\n                stack = [(0, len(self.points))]\n                for i in range(len(self.points)):\n                    d = dist(point, self.points[i])\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, point, radius):\n                result = []\n                r2 = radius * radius\n                for i, p in enumerate(self.points):\n                    # squred dist for perf\n                    sqd = sum((p[d] - point[d])**2 for d in range(len(point)))\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def sample_free(iteration):\n            # Adaptive goal bias ramping faster early, capped at 0.4\n            bias = min(self.goal_sample_rate + (iteration/self.max_iter)*0.2, 0.4)\n            r = random.random()\n            if r < bias:\n                # 75% towards the main goal, 25% towards start (balanced growth)\n                if random.random() < 0.75:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # fallback if repeated hits inside obstacles, return random without checking\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / distance_between\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            if in_bounds(new_pos):\n                return new_pos\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(len(bounds)))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        # Cache collision checks for edges to avoid redundant computations\n        edge_collision_cache = {}\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def prune_dead_nodes():\n            # Remove leaf nodes with no children except roots\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (start_root, goal_root):\n                    continue\n                if not node.children:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(node)\n                except ValueError:\n                    pass\n                # Clean edges containing this node\n                while True:\n                    try:\n                        edges.remove(next(e for e in edges if e[0] == node or e[1] == node))\n                    except StopIteration:\n                        break\n                removed += 1\n            return removed\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Initialize roots and trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        # KD-trees to speed up near/nearest queries, rebuilt periodically\n        def rebuild_kdtree():\n            return KDTree([(node.position, node) for node in nodes])\n\n        kd_tree = rebuild_kdtree()\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for iteration in range(self.max_iter):\n            q_rand = sample_free(iteration)\n\n            # Always extend smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_a, tree_b = tree_goal, tree_start\n            else:\n                tree_a, tree_b = tree_start, tree_goal\n\n            r = neighbor_radius(iteration, len(nodes))\n\n            # Extend tree_a towards q_rand using RRT* logic\n            # Use kd_tree for nearest neighbor search within that tree subset\n            # Extract subset nodes of tree_a for nearest and neighbors\n            sub_nodes = [(node.position, node) for node in tree_a]\n            sub_kdtree = KDTree(sub_nodes)\n            nearest_node = sub_kdtree.nearest(q_rand)\n            new_pos = steer(nearest_node.position, q_rand)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                # Failed extension, skip iteration\n                continue\n\n            near = sub_kdtree.radius_search(new_pos, r)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            # Select best parent with minimal cost & valid connection\n            for node in near:\n                potential_cost = node.cost + dist(node.position, new_pos)\n                if potential_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = potential_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to optimize cost if possible\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try to connect tree_b to new_node incrementally\n            sub_nodes_b = [(node.position, node) for node in tree_b]\n            sub_kdtree_b = KDTree(sub_nodes_b)\n            nearest_b = sub_kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n\n            connected = False\n            max_extend_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_extend_steps):\n                new_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(new_pos_b) or not can_connect(last_node_b.position, new_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, new_pos_b)\n                new_node_b = Node(new_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                # Rewire neighbors of new_node_b in tree_b\n                near_b = sub_kdtree_b.radius_search(new_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_b_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_b_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_b_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                # Check if connection to new_node is possible\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Smooth path with iterative shortcutting\n                    merged_path = shortcut_smoothing(merged_path)\n\n                    extracted_path = merged_path\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic pruning of dead-end nodes for efficiency\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n                # Rebuild kd_tree after pruning for up-to-date efficient queries\n                kd_tree = rebuild_kdtree()\n                # Clear edge cache to avoid memory bloat, but keep minimal\n                edge_collision_cache.clear()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 35.05465,
          "time_improvement": -132.0,
          "length_improvement": 23.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015506649017333984,
                    "num_nodes_avg": 99.3,
                    "path_length_avg": 156.99622385581873,
                    "success_improvement": 0.0,
                    "time_improvement": -53.701235478168805,
                    "length_improvement": 21.53479628556501,
                    "objective_score": -11.803411386337636
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.062104415893554685,
                    "num_nodes_avg": 252.7,
                    "path_length_avg": 232.9376796934483,
                    "success_improvement": 0.0,
                    "time_improvement": -334.17389637556147,
                    "length_improvement": 22.703397245279902,
                    "objective_score": -95.71148946361245
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.030992841720581053,
                    "num_nodes_avg": 170.8,
                    "path_length_avg": 124.11726748792546,
                    "success_improvement": 0.0,
                    "time_improvement": -8.019886639837587,
                    "length_improvement": 23.784520812424446,
                    "objective_score": 2.350938170533613
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the bidirectional tree growth approach of algorithm #1 with goal biasing and incremental single-tree expansion strategies inspired by algorithm #2. It integrates an adaptive heuristic to prioritize samples nearer the goal and enhances connection attempts between trees to improve success rates and path quality. Collision and edge-obstacle checks are strictly enforced to ensure safety. Additionally, it attempts local rewiring akin to RRT* for path smoothing and cost improvement.",
          "planning_mechanism": "The planner grows two trees from start and goal alternatively, sampling points with goal biasing to guide exploration. Each tree extends towards these samples via fixed step sizes, performing collision and edge checks. After adding new nodes, the algorithm tries to connect the two trees by extending one toward the other's new node in multiple smaller steps. A local rewiring step updates parents and costs within neighbors to optimize paths. The process repeats until the trees meet or max iterations are hit, then the path is reconstructed, providing improved efficiency, robustness, and smoother paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        # Initialize two trees: start and goal\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes.extend([start_root, goal_root])\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                # Sample inside bounds but avoid obstacles\n                for _ in range(100):\n                    if is_3d:\n                        p = (random.uniform(0, bounds[0]),\n                             random.uniform(0, bounds[1]),\n                             random.uniform(0, bounds[2]))\n                    else:\n                        p = (random.uniform(0, bounds[0]),\n                             random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # fallback, just return goal if no free sample found\n                return goal_position\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos, extend_length=None):\n            dist = math.dist(from_pos, to_pos)\n            step = self.step_size if extend_length is None else min(self.step_size, extend_length)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near(tree, new_node):\n            # Return nodes within rewire radius\n            r = self.rewire_radius\n            return [node for node in tree if math.dist(node.position, new_node.position) <= r]\n\n        def try_add_node(tree, point, all_nodes, all_edges):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            all_edges.append((nearest_node, new_node))\n\n            # Rewire nearby nodes for cost improvement (like RRT*)\n            neighbors = near(tree, new_node)\n            for neighbor in neighbors:\n                if neighbor == new_node or neighbor == nearest_node:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost:\n                    if (not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d) and\n                        not self._is_in_obstacle(neighbor.position, obstacles, is_3d)):\n                        neighbor.update_parent(new_node, potential_cost)\n                        # edges list update - remove old edge, add new edge\n                        try:\n                            all_edges.remove((neighbor.parent, neighbor))\n                        except (ValueError, AttributeError):\n                            pass\n                        all_edges.append((new_node, neighbor))\n            return new_node\n\n        def connect_trees(tree_a, tree_b, obstacles, is_3d, all_nodes, all_edges):\n            # Attempt to connect tree_b toward last node in tree_a by incremental steering,\n            # returns connecting node from tree_b if success else None\n            import math\n            new_node = tree_a[-1]\n            nearest_node = nearest(tree_b, new_node.position)\n            current_node = nearest_node\n            while True:\n                new_pos = steer(current_node.position, new_node.position)\n                if new_pos == current_node.position:\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d):\n                    return None\n                candidate = Node(new_pos, parent=current_node,\n                                 cost=current_node.cost + math.dist(current_node.position, new_pos))\n                current_node.add_child(candidate)\n                tree_b.append(candidate)\n                all_nodes.append(candidate)\n                all_edges.append((current_node, candidate))\n                dist_to_target = math.dist(candidate.position, new_node.position)\n                if dist_to_target <= self.step_size:\n                    # Final direct connection check\n                    if (not self._is_in_obstacle(new_node.position, obstacles, is_3d) and\n                        not self._is_edge_in_obstacle(candidate.position, new_node.position, obstacles, is_3d)):\n                        goal_connect = Node(new_node.position, parent=candidate,\n                                           cost=candidate.cost + dist_to_target)\n                        candidate.add_child(goal_connect)\n                        tree_b.append(goal_connect)\n                        all_nodes.append(goal_connect)\n                        all_edges.append((candidate, goal_connect))\n                        return goal_connect\n                    else:\n                        return None\n                current_node = candidate\n\n        # Begin main loop\n        for iteration in range(self.max_iter):\n            # Alternate sampling bias to improve coverage and goal proximity\n            if iteration % 2 == 0:\n                sample = sample_point()\n            else:\n                # Try goal direct sample half the times to speed connection\n                sample = goal_position if random.random() < 0.5 else sample_point()\n\n            # Extend start tree towards sample\n            new_node_start = try_add_node(tree_start, sample, nodes, edges)\n            if new_node_start is None:\n                # swap and continue next iteration\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            # Try to connect goal tree towards new node in start tree\n            new_node_goal = connect_trees(tree_start, tree_goal, obstacles, is_3d, nodes, edges)\n            if new_node_goal:\n                success_state = True\n                # Reconstruct path: start_root -> new_node_start + reversed(new_node_goal -> goal_root)\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                # Remove duplicated connecting node at join\n                if path_start[-1] == path_goal[-1]:\n                    path_goal.pop()\n                extracted_path = path_start + path_goal[::-1]\n                break\n\n            # Swap trees for next iteration to keep bidirectional balance\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 36.90791,
          "time_improvement": -128.0,
          "length_improvement": 7.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007505941390991211,
                    "num_nodes_avg": 147.2,
                    "path_length_avg": 181.13967146690692,
                    "success_improvement": 0.0,
                    "time_improvement": 25.601433041242466,
                    "length_improvement": 9.46813322421259,
                    "objective_score": 9.574056557215258
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0628847360610962,
                    "num_nodes_avg": 651.3,
                    "path_length_avg": 290.76659208493203,
                    "success_improvement": 0.0,
                    "time_improvement": -339.6291388520806,
                    "length_improvement": 3.5138076746074822,
                    "objective_score": -101.18598012070268
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04845216274261475,
                    "num_nodes_avg": 500.9,
                    "path_length_avg": 150.23335018440193,
                    "success_improvement": 0.0,
                    "time_improvement": -68.87115980193133,
                    "length_improvement": 7.747672777496979,
                    "objective_score": -19.11181338508
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This improved planner retains the bidirectional RRT* framework while enhancing path quality and planning efficiency through an adaptive goal-biased sampling focused on progressive connection attempts, a tightened dynamic neighborhood radius for rewiring based on tree size and cost-aware heuristics, and an enhanced shortcut smoothing with bidirectional checking and adaptive iterations. Dead-end pruning is stabilized and performed more frequently to reduce computational load and maintain robustness. The algorithm aggressively rewires nodes to paths of lower cost and emphasizes extending the smaller tree for balanced exploration, improving success rate and path optimality.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternately sampling in free space with a bias toward start and goal points to expedite connection. On each iteration, it extends the smaller tree by steering toward the sample, rewires nearby nodes for optimality within a dynamically computed radius, and then tries to connect the other tree to the newly added node. It rigorously checks collisions for nodes and edges, prunes dead ends periodically, and applies enhanced iterative shortcut smoothing to minimize path length and improve smoothness before returning the final path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...] (2D or 3D)\n        self.parent = parent              # Parent Node or None\n        self.cost = cost                  # Cost from root to this node\n        self.children = []\n        self.valid = True                 # For collision flag etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 20.0,\n                 radius_min: float = 5.0, prune_interval: int = 100,\n                 smoothing_iterations: int = 60):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        import random\n        import math\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def sample_free():\n            # Adaptive bias sampling toward start or goal with more focus on unexplored regions\n            bias_prob = 0.85\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < bias_prob else start_position\n            else:\n                attempts = 0\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                    attempts += 1\n                    if attempts > 100:\n                        # fallback to goal if stuck sampling\n                        return goal_position\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree, pos, radius):\n            radsq = radius * radius\n            result = []\n            for node in tree:\n                d_sq = sum((node.position[d] - pos[d])**2 for d in range(len(pos)))\n                if d_sq <= radsq:\n                    result.append(node)\n            return result\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(val, self.radius_min)\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                if not can_connect(node.position, new_pos):\n                    continue\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                # Improved cost comparison allowing negligible float tolerance\n                if tentative_cost + 1e-12 < min_cost:\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Improved rewiring: rewire neighbors for better cost paths if possible\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                if not can_connect(new_node.position, neighbor.position):\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            # Prune nodes that have no children and are not root nodes\n            for node in nodes[:]:\n                if node in (start_root, goal_root):\n                    continue\n                if not node.children and node.parent is not None:\n                    try:\n                        node.parent.children.remove(node)\n                    except Exception:\n                        pass\n                    # Remove node from main data structures\n                    try:\n                        nodes.remove(node)\n                    except Exception:\n                        pass\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    removed.append(node)\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            max_iter = self.smoothing_iterations\n            count = 0\n            while count < max_iter and len(path) >= 3:\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n                    # After successful shortcut, restart smoothing more aggressively\n                    count = 0\n                    continue\n                count += 1\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always grow smaller tree for better balance & efficiency\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal:\n                # Successful connection: extract full path\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed_path = shortcut_smoothing(raw_path)\n                # Choose path with minimal length between raw and smoothed\n                if path_length(smoothed_path) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            # Prune dead nodes periodically for efficiency and robustness\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > 150:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.7):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 47.34171,
          "time_improvement": -159.0,
          "length_improvement": 19.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.03282475471496582,
                    "num_nodes_avg": 101.0,
                    "path_length_avg": 174.22720544091052,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -225.35755135221999,
                    "length_improvement": 12.922917304860498,
                    "objective_score": -70.0226819446939
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03972630500793457,
                    "num_nodes_avg": 170.6,
                    "path_length_avg": 245.22545494316165,
                    "success_improvement": 0.0,
                    "time_improvement": -177.72782958721908,
                    "length_improvement": 18.625897703486842,
                    "objective_score": -49.59316933546835
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.05017263889312744,
                    "num_nodes_avg": 137.3,
                    "path_length_avg": 121.72262325370605,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -74.86756504997003,
                    "length_improvement": 25.254976628030867,
                    "objective_score": -22.409274189384835
               }
          ],
          "success_rate": 0.9333333333333332
     }
]