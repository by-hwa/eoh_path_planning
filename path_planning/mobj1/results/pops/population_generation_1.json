[
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and            not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if not self._is_in_obstacle(new_pos, obstacles, is_3d) and                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -14.547310392594369,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0033696174621582033,
                    "num_nodes_avg": 59.1,
                    "path_length_avg": 170.9770888905735,
                    "success_improvement": 0.0,
                    "time_improvement": 66.60049721615668,
                    "length_improvement": 14.547294318234119,
                    "objective_score": 22.889608028493825
               },
               {
                    "map_id": 1,
                    "success_rate": 0.7,
                    "time_avg": 0.008120989799499512,
                    "num_nodes_avg": 195.7,
                    "path_length_avg": 276.36470377614694,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": 43.2259086098124,
                    "length_improvement": 8.292841453028517,
                    "objective_score": -0.3736591264505782
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.004628038406372071,
                    "num_nodes_avg": 134.2,
                    "path_length_avg": 154.99263582978188,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 83.8698177944377,
                    "length_improvement": 4.825184687042764,
                    "objective_score": 21.125982275739858
               }
          ]
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -6.05410676996533,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009668374061584472,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "success_improvement": 0.0,
                    "time_improvement": 4.167493784798042,
                    "length_improvement": 12.401486536989607,
                    "objective_score": 3.730545442837334
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019790220260620116,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "success_improvement": 0.0,
                    "time_improvement": -38.35404321990816,
                    "length_improvement": 14.190408824541839,
                    "objective_score": -8.668131201064078
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.00882866382598877,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "success_improvement": 0.0,
                    "time_improvement": 69.22930545503195,
                    "length_improvement": 11.655572158065754,
                    "objective_score": 23.099906068122735
               }
          ]
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for iter_num in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or            self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, new_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            connect_node.parent = best_parent\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n\n            nearest = connect_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -4.22512875357786,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007775163650512696,
                    "num_nodes_avg": 63.6,
                    "path_length_avg": 157.74844317172378,
                    "success_improvement": 0.0,
                    "time_improvement": 22.932913629961522,
                    "length_improvement": 21.158844301429212,
                    "objective_score": 11.111642949274298
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.019913077354431152,
                    "num_nodes_avg": 236.6,
                    "path_length_avg": 218.9843001436935,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -39.21294097057279,
                    "length_improvement": 27.333600643728058,
                    "objective_score": -16.29716216242622
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.008108234405517578,
                    "num_nodes_avg": 131.2,
                    "path_length_avg": 111.23634768618506,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 71.74023055938031,
                    "length_improvement": 31.694181530357035,
                    "objective_score": 17.860905473885502
               }
          ]
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm integrating adaptive goal biasing, dynamic neighborhood radius, and adaptive step sizing. It optimizes node connections with efficient rewiring and carefully balanced tree growth. Heuristic goal-biased sampling accelerates convergence, and rigorous collision checks ensure path feasibility. Post-processing with shortcut smoothing further refines the path quality, achieving reduced planning time and higher success rates.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal with biased sampling towards both ends, adapting the step length based on obstacle proximity for efficient exploration. It rewires nodes within a shrinking radius proportional to the tree size to locally optimize costs. The connection attempts between trees are incremental and maintain collision safety. The extracted path undergoes iterative shortcut smoothing to improve smoothness and minimize length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.25,\n                 radius_const: float=25.0,\n                 radius_min: float=5.0,\n                 smoothing_iter: int=60,\n                 collision_resolution: float=0.5,\n                 adaptive_step_min: float=1.5,\n                 adaptive_step_max: float=7.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.smoothing_iter = smoothing_iter\n        self.collision_resolution = collision_resolution\n        self.adaptive_step_min = adaptive_step_min\n        self.adaptive_step_max = adaptive_step_max\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(point):\n            for i, val in enumerate(point):\n                if val < 0 or val > bounds[i]:\n                    return False\n            return True\n\n        def sample_point():\n            # Adaptive goal biasing with occasional start bias to diversify\n            if random.random() < self.goal_sample_rate:\n                if random.random() < 0.85:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest(tree, point):\n            # Cached distance computation for speed\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                dist = distance(node.position, point)\n                if dist < best_dist:\n                    best_dist = dist\n                    best_node = node\n            return best_node\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_const\n            r = self.radius_const * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, r)\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius*radius\n            near = []\n            for node in tree:\n                dx = node.position[0] - pos[0]\n                dy = node.position[1] - pos[1]\n                dz = node.position[2] - pos[2] if is_3d else 0.0\n                dist_sq = dx*dx + dy*dy + dz*dz\n                if dist_sq <= r_sq:\n                    near.append(node)\n            return near\n\n        def adaptive_step(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            # Adaptive step based on minimum distance, clipped by min/max step\n            step = min(self.adaptive_step_max, max(self.adaptive_step_min, dist))\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def collision_free(node_pos):\n            return (in_bounds(node_pos) and not self._is_in_obstacle(node_pos, obstacles, is_3d))\n\n        def edge_collision_free(pos1, pos2):\n            if not in_bounds(pos2):\n                return False\n            return not self._is_edge_in_obstacle(pos1, pos2, obstacles, is_3d, self.collision_resolution)\n\n        def add_node(tree, new_node, parent_node):\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = adaptive_step(nearest_node.position, point)\n\n            if not collision_free(new_pos) or not edge_collision_free(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + distance(node.position, new_pos)\n                if temp_cost < min_cost and edge_collision_free(node.position, new_pos):\n                    min_cost = temp_cost\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-12 < neighbor.cost and edge_collision_free(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            max_iters = 5  # Limit incremental connection steps to reduce search time\n            for _ in range(max_iters):\n                new_pos = adaptive_step(last_node.position, node.position)\n                if not collision_free(new_pos) or not edge_collision_free(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                dist_to_goal = distance(new_pos, node.position)\n                if dist_to_goal <= self.step_size:\n                    if edge_collision_free(new_pos, node.position):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + dist_to_goal\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if edge_collision_free(p_i, p_j):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            rand_point = sample_point()\n\n            # Balance tree growth: extend smaller tree first for efficiency\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                extracted_path = extract_path(new_node_start, new_node_goal)\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -0.56941,
          "time_improvement": -4.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.011932563781738282,
                    "num_nodes_avg": 84.8,
                    "path_length_avg": 179.4556821069735,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -18.275056952991342,
                    "length_improvement": 10.309774920648962,
                    "objective_score": -8.42056210176761
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.021422696113586426,
                    "num_nodes_avg": 263.1,
                    "path_length_avg": 246.43185249463258,
                    "success_improvement": 0.0,
                    "time_improvement": -49.76673250493788,
                    "length_improvement": 18.22557418166317,
                    "objective_score": -11.284904915148728
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.012469840049743653,
                    "num_nodes_avg": 155.3,
                    "path_length_avg": 126.59919358120321,
                    "success_improvement": 0.0,
                    "time_improvement": 56.538651062263334,
                    "length_improvement": 22.260468677408557,
                    "objective_score": 21.41368905416071
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -0.2556317858417804,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.00937027931213379,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "success_improvement": 0.0,
                    "time_improvement": 7.122196069534629,
                    "length_improvement": 5.9265718433081265,
                    "objective_score": 3.321973189522014
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017043161392211913,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "success_improvement": 0.0,
                    "time_improvement": -19.14926952854797,
                    "length_improvement": 0.3867603104208941,
                    "objective_score": -5.667428796480212
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026260972023010254,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "success_improvement": 0.0,
                    "time_improvement": 8.472180558590889,
                    "length_improvement": 2.8534839845313615,
                    "objective_score": 3.112350964483539
               }
          ]
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an improved bidirectional RRT* variant with adaptive step size, informed sampling around an ellipse for faster convergence, and enhanced rewiring to optimize path quality and reduce search time. It incorporates aggressive rewiring, goal bias sampling, and path smoothing for robust and high-quality paths.",
          "planning_mechanism": "The planner grows two trees from start and goal positions, alternating expansions with adaptive step sizes. Sampling is biased towards an ellipsoidal region defined by current best path cost to focus exploration. After each extension, it attempts connection and performs rewiring with a dynamically adjusted radius to optimize the path. On successful connection, the path is extracted and smoothed.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def rewire(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        new_parent.children.append(self)\n        self.cost = new_cost\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 6.0, goal_sample_rate: float = 0.2,\n                 search_radius_factor: float = 20.0, smoothing_iterations: int = 5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # probability of sampling goal bias\n        self.search_radius_factor = search_radius_factor  # factor multiplier for neighbor search radius\n        self.smoothing_iterations = smoothing_iterations  # iterations for path smoothing\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n\n        nodes = []\n        edges = []\n\n        best_path_cost = float(\"inf\")\n        success_state = False\n        extracted_path = []\n\n        dimension = len(bounds)\n        diag_dist = math.dist((0,) * dimension, bounds)\n        # Dynamic radius for near neighbors will depend on sample count and dimension\n        def calc_radius(n_nodes):\n            gamma = self.search_radius_factor\n            unit_ball_volume = math.pi if dimension == 2 else (4/3)*math.pi\n            r = min(\n                self.step_size * 5,\n                gamma * ((math.log(max(n_nodes,1)) / max(n_nodes,1)) ** (1/dimension))\n            )\n            return r if r > self.step_size else self.step_size * 1.5\n\n        def ellipse_sample(c_best, start, goal):\n            # If no solution yet, sample uniformly\n            if c_best == float(\"inf\"):\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[i]) for i in range(3))\n                    else:\n                        p = tuple(random.uniform(0, bounds[i]) for i in range(2))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            # Ellipsoidal sampling focused between start and goal according to c_best path cost\n            center = tuple([(s + g) / 2 for s, g in zip(start, goal)])\n            a1 = [g - s for s, g in zip(start, goal)]\n            a1_len = math.dist(start, goal) / 2\n            if a1_len < 1e-6:\n                return start  # start == goal\n\n            # Rotation matrix to align ellipse along start-goal vector (assume 2D or 3D)\n            def unit_vector(v):\n                l = math.dist((0,) * len(v), v)\n                return tuple(x / l for x in v)\n\n            e_r1 = unit_vector(a1)\n            dim = len(start)\n\n            # Create an orthonormal basis with e_r1\n            import numpy as np\n            e1 = np.array(e_r1)\n            if dim == 2:\n                e2 = np.array([-e1[1], e1[0]])\n                basis = np.stack([e1, e2], axis=1)  # dim x dim\n            else:\n                # Gram-Schmidt for 3D, pick arbitrary vector not colinear\n                if abs(e1[0]) < abs(e1[1]):\n                    v = np.array([1,0,0])\n                else:\n                    v = np.array([0,1,0])\n                e2 = v - (np.dot(v,e1))*e1\n                e2 /= np.linalg.norm(e2)\n                e3 = np.cross(e1, e2)\n                basis = np.stack([e1, e2, e3], axis=1)\n\n            # Define ellipse axes lengths\n            r1 = c_best / 2\n            r2 = math.sqrt(max(c_best**2 - math.dist(start, goal)**2, 0)) / 2\n            if r2 < 1e-6:\n                r2 = self.step_size*2\n\n            while True:\n                # Sample point in unit ball scaled to ellipse\n                if dim == 2:\n                    sample_ball = np.random.normal(size=2)\n                else:\n                    sample_ball = np.random.normal(size=3)\n                sample_ball /= np.linalg.norm(sample_ball)\n                uniform_radius = random.uniform(0,1) ** (1/dim)\n                sample_ball = sample_ball * uniform_radius\n                scale = np.array([r1, r2] + ([r2] if dim==3 else []))\n                offset = center + basis @ (sample_ball * scale)\n                p = tuple(offset.tolist())\n                if all(0 <= p[i] <= bounds[i] for i in range(dim)) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def find_path_cost_back(node):\n            return node.cost if node else float(\"inf\")\n\n        for iteration in range(self.max_iter):\n            # With goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = ellipse_sample(best_path_cost, start_position, goal_position)\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size, bounds)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                radius = calc_radius(len(tree_a)+1)\n                near_nodes = self._near(tree_a, new_pos, radius)\n\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    cost = near.cost + math.dist(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node = Node(new_pos)\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewiring near nodes to new_node if improves cost and collision-free\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.rewire(new_node, new_cost)\n                        # Update edges list accordingly\n                        # Remove old edge:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        edges.append((new_node, near))\n\n                # Try connecting tree_b to this new_node\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    # Path found: Extract full path\n                    success_state = True\n                    path_a = []\n                    node_iter = new_node\n                    while node_iter:\n                        path_a.append(node_iter.position)\n                        node_iter = node_iter.parent\n                    path_a.reverse()\n                    path_b = []\n                    node_iter = connect_node\n                    while node_iter:\n                        path_b.append(node_iter.position)\n                        node_iter = node_iter.parent\n                    extracted_path = path_a + path_b\n\n                    new_path_cost = min_cost + connect_node.cost\n                    if new_path_cost < best_path_cost:\n                        best_path_cost = new_path_cost\n\n                    # Smooth path before return\n                    extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n\n    def _steer(self, from_pos, to_pos, step_size, bounds):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            new_pos = to_pos\n        else:\n            ratio = step_size / dist\n            new_pos = tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        # Enforce boundary limits\n        new_pos_clamped = tuple(\n            max(0, min(new_pos[i], bounds[i])) for i in range(len(new_pos))\n        )\n        return new_pos_clamped\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if math.dist(node.position, point) <= radius]\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import random\n        if len(path) < 3:\n            return path\n\n        smoothed = path[:]\n        for _ in range(self.smoothing_iterations):\n            if len(smoothed) < 3:\n                break\n            # Pick two random vertices i, j with j > i+1\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                # shortcut path segment by directly connecting i to j\n                smoothed = smoothed[:i + 1] + smoothed[j:]\n        return smoothed",
          "objective": 3.37674,
          "time_improvement": -21.0,
          "length_improvement": 14.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014727044105529784,
                    "num_nodes_avg": 160.9,
                    "path_length_avg": 174.3077033815884,
                    "success_improvement": 0.0,
                    "time_improvement": -45.97382525593398,
                    "length_improvement": 12.882685207815397,
                    "objective_score": -11.215610535217113
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022585201263427734,
                    "num_nodes_avg": 296.1,
                    "path_length_avg": 265.9289031898334,
                    "success_improvement": 0.0,
                    "time_improvement": -57.893842038152854,
                    "length_improvement": 11.755793146414167,
                    "objective_score": -15.01699398216302
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016541576385498045,
                    "num_nodes_avg": 209.4,
                    "path_length_avg": 135.1807269228711,
                    "success_improvement": 0.0,
                    "time_improvement": 42.3473580733592,
                    "length_improvement": 16.990890245358386,
                    "objective_score": 16.102385471079437
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a streamlined bidirectional RRT* planner with balanced tree growth, adaptive sampling biased towards start and goal, collision-free node and edge verification, and incremental rewiring within a dynamic neighborhood radius. It prioritizes computational efficiency and robust pathfinding through straightforward tree extensions, rewiring for cost improvements, and final path smoothing.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately extending towards sampled free points. For each new node, it rewires neighbors to reduce path cost if collision-free. It attempts to connect the opposite tree incrementally to the new node. Upon successful connection, the planner reconstructs and smooths the path before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 smoothing_iterations: int = 100,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / distance_between\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(len(bounds)))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - position[d])**2 for d in range(len(position))) <= r2]\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        tree_a, tree_b = [start_root], [goal_root]\n\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            sample = sample_free()\n            r = neighbor_radius(iteration, len(nodes))\n\n            # Extend tree_a towards sample\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            neighbors = near_nodes(tree_a, new_pos, r)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                cost_out = node.cost + dist(node.position, new_pos)\n                if cost_out + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_out\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper and collision-free\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try to connect tree_b to new_node incrementally\n            connect_node = nearest(tree_b, new_node.position)\n            curr_pos = connect_node.position\n            connected = False\n\n            while True:\n                next_pos = steer(curr_pos, new_node.position)\n                if not can_add_node(next_pos) or not can_connect(curr_pos, next_pos):\n                    break\n\n                neighbors_b = near_nodes(tree_b, next_pos, r)\n                min_cost_b = connect_node.cost + dist(curr_pos, next_pos)\n                best_parent_b = connect_node\n                for node_b in neighbors_b:\n                    if not can_connect(node_b.position, next_pos):\n                        continue\n                    cost_b = node_b.cost + dist(node_b.position, next_pos)\n                    if cost_b < min_cost_b:\n                        min_cost_b = cost_b\n                        best_parent_b = node_b\n\n                new_node_b = Node(next_pos, parent=best_parent_b, cost=min_cost_b)\n                best_parent_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((best_parent_b, new_node_b))\n\n                # Rewire neighbors of new_node_b\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is best_parent_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    path_start = new_node.path_from_root()\n                    path_goal = connection_node.path_from_root()\n                    extracted_path = path_start + path_goal[::-1][1:]\n                    extracted_path = shortcut_smoothing(extracted_path)\n                    connected = True\n                    break\n\n                curr_pos = new_node_b.position\n                connect_node = new_node_b\n\n            if connected:\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 5.05134,
          "time_improvement": -32.0,
          "length_improvement": 23.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011016368865966797,
                    "num_nodes_avg": 70.8,
                    "path_length_avg": 155.16720304344847,
                    "success_improvement": 0.0,
                    "time_improvement": -9.19377250942915,
                    "length_improvement": 22.44892330795998,
                    "objective_score": 1.7316529087632513
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025777411460876466,
                    "num_nodes_avg": 229.0,
                    "path_length_avg": 236.87693357543202,
                    "success_improvement": 0.0,
                    "time_improvement": -80.21068246785175,
                    "length_improvement": 21.396219536347616,
                    "objective_score": -19.783960833086002
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03083500862121582,
                    "num_nodes_avg": 252.3,
                    "path_length_avg": 121.00421879728697,
                    "success_improvement": 0.0,
                    "time_improvement": -7.469788212105313,
                    "length_improvement": 25.696120241684756,
                    "objective_score": 2.8982875847053577
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid algorithm integrates the bidirectional tree growth of the dual-tree RRT with the rewiring and path cost optimization from RRT*, combining efficient exploration and asymptotic optimality. It grows two trees from start and goal, extends them alternately toward random samples, uses a rewiring step to optimize local paths dynamically, and attempts connection when proximity allows. This approach improves path quality and success rate while maintaining computational efficiency and robust collision checking.",
          "planning_mechanism": "The planner alternates expansion between start and goal trees by sampling collision-free random points and steering nodes toward them. For each extension, a neighborhood rewiring step optimizes path costs locally. The algorithm attempts to connect the two trees by incremental steering with rewiring until a collision-free path uniting start and goal is found or maximum iterations are reached. Validity checks for nodes and edges are enforced strictly at every step.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        def _sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _distance(a, b):\n            return math.dist(a, b)\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: _distance(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            dist = _distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _near_nodes(tree, position, radius):\n            return [node for node in tree if _distance(node.position, position) <= radius]\n\n        def _can_connect(p1, p2):\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def _add_node(tree, new_node, parent_node):\n            parent_node.add_child(new_node)\n            new_node.cost = parent_node.cost + _distance(parent_node.position, new_node.position)\n            new_node.parent = parent_node\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n\n        def _rewire(tree, new_node):\n            neighbors = _near_nodes(tree, new_node.position, self.rewire_radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                new_cost = new_node.cost + _distance(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and _can_connect(new_node.position, neighbor.position):\n                    # Remove old edge\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n\n                    # Add new edge\n                    new_node.add_child(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    edges.append((new_node, neighbor))\n\n        def _extend(tree, point):\n            nearest = _nearest(tree, point)\n            new_pos = _steer(nearest.position, point)\n            if not _can_connect(nearest.position, new_pos):\n                return None\n            new_node = Node(new_pos)\n            min_cost = nearest.cost + _distance(nearest.position, new_pos)\n            best_parent = nearest\n\n            neighbors = _near_nodes(tree, new_pos, self.rewire_radius)\n\n            # Choose best parent from neighbors to minimize cost\n            for neighbor in neighbors:\n                c = neighbor.cost + _distance(neighbor.position, new_pos)\n                if c < min_cost and _can_connect(neighbor.position, new_pos):\n                    min_cost = c\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire around new node\n            _rewire(tree, new_node)\n            return new_node\n\n        def _connect(tree, new_node_other):\n            nearest = _nearest(tree, new_node_other.position)\n            curr_node = nearest\n\n            while True:\n                new_pos = _steer(curr_node.position, new_node_other.position)\n                if not _can_connect(curr_node.position, new_pos):\n                    return None\n\n                connect_node = Node(new_pos)\n                neighbors = _near_nodes(tree, new_pos, self.rewire_radius)\n\n                min_cost = curr_node.cost + _distance(curr_node.position, new_pos)\n                best_parent = curr_node\n\n                for neighbor in neighbors:\n                    c = neighbor.cost + _distance(neighbor.position, new_pos)\n                    if c < min_cost and _can_connect(neighbor.position, new_pos):\n                        min_cost = c\n                        best_parent = neighbor\n\n                best_parent.add_child(connect_node)\n                connect_node.parent = best_parent\n                connect_node.cost = min_cost\n                tree.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((best_parent, connect_node))\n\n                _rewire(tree, connect_node)\n\n                if _distance(connect_node.position, new_node_other.position) <= self.step_size:\n                    return connect_node\n\n                curr_node = connect_node\n\n        for iter_num in range(self.max_iter):\n            rand_point = _sample_free()\n\n            # Alternate expanding start and goal trees\n            if iter_num % 2 == 0:\n                new_node_start = _extend(tree_start, rand_point)\n                if new_node_start is None:\n                    continue\n                connect_node_goal = _connect(tree_goal, new_node_start)\n                if connect_node_goal:\n                    success_state = True\n                    path_start = new_node_start.path_from_root()\n                    path_goal = connect_node_goal.path_from_root()\n                    extracted_path = path_start + path_goal[::-1]\n                    break\n            else:\n                new_node_goal = _extend(tree_goal, rand_point)\n                if new_node_goal is None:\n                    continue\n                connect_node_start = _connect(tree_start, new_node_goal)\n                if connect_node_start:\n                    success_state = True\n                    path_goal = new_node_goal.path_from_root()\n                    path_start = connect_node_start.path_from_root()\n                    extracted_path = path_start + path_goal[::-1]\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 8.43218,
          "time_improvement": -22.0,
          "length_improvement": 25.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01331765651702881,
                    "num_nodes_avg": 100.9,
                    "path_length_avg": 160.7913922442542,
                    "success_improvement": 0.0,
                    "time_improvement": -32.004036336481114,
                    "length_improvement": 19.638007602273778,
                    "objective_score": -5.673609380489578
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.02202715873718262,
                    "num_nodes_avg": 209.4,
                    "path_length_avg": 217.93141644497078,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -53.992549441208105,
                    "length_improvement": 27.68298307560509,
                    "objective_score": -20.66116821724141
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.023168563842773438,
                    "num_nodes_avg": 214.7,
                    "path_length_avg": 119.99487511069171,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 19.250204209499422,
                    "length_improvement": 26.31591806914092,
                    "objective_score": 1.0382448766780126
               }
          ],
          "success_rate": 0.8666666666666667
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid algorithm combines the asymptotic optimality and rewiring principles from RRT* and the fast convergence benefits of a bidirectional approach inspired by RRT-Connect. It grows two trees simultaneously from start and goal with goal biasing, samples from free space, connects the trees when close enough, and performs rewiring in both trees to improve path quality incrementally. Additionally, it performs path shortcutting to smooth the final path for better quality.",
          "planning_mechanism": "The planner alternates tree expansions by sampling points with goal biasing, steering nearest nodes toward sampled points, rewires neighbors for cost improvements, tries connecting the two trees to form a full path, and upon success, extracts and smooths the path. Collision checks are applied for nodes and edges throughout, ensuring valid paths that respect obstacles and boundaries.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D position\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Accumulated path cost\n        self.children = []\n        self.valid = True               # For collision validity\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, neighbor_radius: float=12.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        import random\n        import math\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def _distance(a, b):\n            return math.dist(a, b)\n\n        def _steer(from_pos, to_pos, step_size):\n            dist = _distance(from_pos, to_pos)\n            if dist <= step_size:\n                return to_pos\n            ratio = step_size / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def _near(tree, point, radius):\n            return [node for node in tree if _distance(node.position, point) <= radius]\n\n        def _extract_path_meet(node_from_start, node_from_goal):\n            path_start = []\n            current = node_from_start\n            while current:\n                path_start.append(current.position)\n                current = current.parent\n            path_goal = []\n            cur = node_from_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def _path_shortcut(path):\n            # Attempt to smooth path by shortcutting between non-adjacent nodes if direct connection is collision-free\n            if len(path) < 3:\n                return path\n            smooth_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smooth_path.append(path[j])\n                i = j\n            return smooth_path\n\n        def _check_in_bounds(pos):\n            for i, val in enumerate(pos):\n                if val < 0 or val > bounds[i]:\n                    return False\n            return True\n\n        success = False\n        final_path = []\n\n        for iter in range(self.max_iter):\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Alternate between start_tree and goal_tree expansions\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Find nearest node in tree_a to sample\n                nearest = min(tree_a, key=lambda n: _distance(n.position, sample))\n                new_pos = _steer(nearest.position, sample, self.step_size)\n\n                # Check bounds\n                if not _check_in_bounds(new_pos):\n                    continue\n                # Collision checks\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Create new node, find near neighbors for rewiring\n                new_node = Node(new_pos)\n                near_nodes = _near(tree_a, new_pos, self.neighbor_radius)\n\n                min_cost = nearest.cost + _distance(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    temp_cost = near.cost + _distance(near.position, new_pos)\n                    if temp_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        min_parent = near\n\n                new_node.update_parent(min_parent, min_cost)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors in tree_a\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + _distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                        near.update_parent(new_node, new_cost)\n                        edges.append((new_node, near))\n\n                # Try connect tree_b to new_node in tree_a to form path\n                connect_node = min(tree_b, key=lambda n: _distance(n.position, new_node.position))\n                dist_connect = _distance(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size:\n                    if (not self._is_in_obstacle(connect_node.position, obstacles, is_3d) and\n                        not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d)):\n                        # Path connected, extract full path\n                        success = True\n                        final_path = _extract_path_meet(new_node, connect_node)\n                        # Smooth path with shortcutting\n                        final_path = _path_shortcut(final_path)\n                        break\n            if success:\n                break\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 11.21486,
          "time_improvement": -51.0,
          "length_improvement": 21.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013281702995300293,
                    "num_nodes_avg": 128.5,
                    "path_length_avg": 174.34981020638165,
                    "success_improvement": 0.0,
                    "time_improvement": -31.647666581591665,
                    "length_improvement": 12.861640621493342,
                    "objective_score": -6.921971850178831
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02387359142303467,
                    "num_nodes_avg": 287.3,
                    "path_length_avg": 230.3975784226972,
                    "success_improvement": 0.0,
                    "time_improvement": -66.90101757631824,
                    "length_improvement": 23.546288782365693,
                    "objective_score": -15.361047516422332
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.044390535354614256,
                    "num_nodes_avg": 367.1,
                    "path_length_avg": 121.70644892216498,
                    "success_improvement": 0.0,
                    "time_improvement": -54.7150997032626,
                    "length_improvement": 25.26490864195521,
                    "objective_score": -11.361548182587736
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT* variant that integrates adaptive step sizing and dynamic radius rewiring for improved efficiency and path quality. It grows two trees from start and goal, samples points biased towards the path for faster convergence, and employs smoothing on the resultant path to increase smoothness and robustness. It enforces strict collision and edge checks and limits node placement within map bounds.",
          "planning_mechanism": "The planner alternately grows two trees by sampling points biased via a goal-biased probability. Each extension employs adaptive step sizing based on distance to the sample, then rewires nodes in a dynamically calculated radius to optimize cost. Connection attempts between the two trees are made after each extension. The final combined path is smoothed using shortcutting to reduce unnecessary waypoints and produce a shorter, smoother trajectory.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated cost from root\n        self.children = []\n        self.valid = True               # Node validity flag\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_and_propagate(self, new_cost):\n        self.cost = new_cost\n        for child in self.children:\n            child.update_cost_and_propagate(new_cost + self._distance(self.position, child.position))\n\n    @staticmethod\n    def _distance(a, b):\n        import math\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float=7.0, goal_sample_rate: float = 0.1, radius_constant: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal point\n        self.radius_constant = radius_constant    # Used for dynamic radius calculation\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        dim = len(bounds)\n        unit_ball_volume = {2: math.pi, 3: 4 / 3 * math.pi}[dim]\n\n        for iter in range(self.max_iter):\n            # Goal-biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        break\n\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                # Find nearest in tree_a\n                nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n                direction_distance = math.dist(nearest.position, sample)\n                if direction_distance == 0.0:\n                    continue\n\n                # Adaptive step size: don't overshoot closer samples\n                step = min(self.step_size, direction_distance)\n                new_pos = tuple(\n                    nearest.position[d] + (sample[d] - nearest.position[d]) * (step / direction_distance) for d in range(dim)\n                )\n\n                if not in_bounds(new_pos) or self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                # Compute dynamic radius (RRT* style)\n                radius = min(\n                    self.radius_constant * ((math.log(len(tree_a) + 1) / (len(tree_a) + 1)) ** (1 / dim)),\n                    self.step_size * 5\n                )\n\n                near_nodes = [node for node in tree_a if math.dist(node.position, new_pos) <= radius]\n\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                best_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + math.dist(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = near\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                new_node.parent = best_parent\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            # Remove old edge\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                            try:\n                                near.parent.children.remove(near)\n                            except ValueError:\n                                pass\n\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        # Propagate cost update downwards\n                        near.update_cost_and_propagate(new_cost)\n\n                # Attempt connection to the other tree\n                nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n                dist_connect = math.dist(nearest_other.position, new_node.position)\n\n                if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    # Connect the trees\n                    success_state = True\n                    # Form path from start_root to new_node\n                    if tree_a is tree_start:\n                        path_start = new_node.path_from_root()\n                        path_goal = nearest_other.path_from_root()\n                        path_goal.reverse()\n                        full_path = path_start + path_goal\n                    else:\n                        path_start = nearest_other.path_from_root()\n                        path_goal = new_node.path_from_root()\n                        path_goal.reverse()\n                        full_path = path_start + path_goal\n\n                    # Smooth the path via shortcutting method\n                    smoothed_path = self._smooth_path(full_path, obstacles, is_3d, max_iterations=150, map_bounds=bounds)\n\n                    extracted_path = smoothed_path\n                    return PlannerResult(True, extracted_path, nodes, edges)\n\n        return PlannerResult(False, extracted_path, nodes, edges)\n\n\n    def _smooth_path(self, path, obstacles, is_3d, max_iterations=100, map_bounds=None):\n        import random\n        import math\n\n        def valid_edge(p1, p2):\n            if map_bounds:\n                for d in range(len(p1)):\n                    if p1[d] < 0 or p1[d] > map_bounds[d]:\n                        return False\n                    if p2[d] < 0 or p2[d] > map_bounds[d]:\n                        return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        if len(path) < 3:\n            return path[:]\n\n        path = path[:]\n        for _ in range(max_iterations):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n\n            if valid_edge(path[i], path[j]):\n                # Remove intermediate nodes and connect directly\n                path = path[:i+1] + path[j:]\n\n        return path\n\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 25.54824,
          "time_improvement": -98.0,
          "length_improvement": 20.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02762300968170166,
                    "num_nodes_avg": 99.9,
                    "path_length_avg": 167.97260652957092,
                    "success_improvement": 0.0,
                    "time_improvement": -173.7980791953795,
                    "length_improvement": 16.048905724690606,
                    "objective_score": -48.92964261367573
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023543739318847658,
                    "num_nodes_avg": 192.1,
                    "path_length_avg": 243.82630931447866,
                    "success_improvement": 0.0,
                    "time_improvement": -64.59501129251362,
                    "length_improvement": 19.090181558287142,
                    "objective_score": -15.560467076096655
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.044884872436523435,
                    "num_nodes_avg": 404.1,
                    "path_length_avg": 123.9554182240814,
                    "success_improvement": 0.0,
                    "time_improvement": -56.43802127435036,
                    "length_improvement": 23.883906010388394,
                    "objective_score": -12.15462518022743
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is a bidirectional RRT* variant integrating informed sampling and adaptive rewiring to boost planning efficiency, path optimality, and success rate. It uses heuristic guiding from the start towards the goal with dynamic radius-based rewiring and path smoothing to achieve shorter and smoother paths.",
          "planning_mechanism": "The planner simultaneously grows two trees from start and goal within the map. Sampling focuses within an ellipsoidal informed subset to bias towards promising regions. New nodes are added after collision checks, then nearby nodes within an adaptive radius are rewired for lower-cost connections. Trees attempt connection after each extension, resulting in a high-quality solution. Finally, path extraction and smoothing refine the solution for shorter, smoother trajectories.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost(self, new_cost):\n        self.cost = new_cost\n        for c in self.children:\n            c.update_cost(c.parent.cost + self._distance(c.parent.position, c.position))\n\n    @staticmethod\n    def _distance(a, b):\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        c_best = math.dist(start_position, goal_position) * 2  # Initial cost upper bound\n        c_min = math.dist(start_position, goal_position)\n\n        def informed_sample():\n            # Sample inside an ellipsoid around start-goal to improve efficiency\n            x_start = start_position\n            x_goal = goal_position\n            while True:\n                # Sample uniformly in unit ball in dimension d\n                d = 3 if is_3d else 2\n                while True:\n                    sample = tuple(random.uniform(-1,1) for _ in range(d))\n                    radius = math.sqrt(sum(s*s for s in sample))\n                    if radius <= 1:\n                        break\n                # Scale to ellipsoid\n                L = [0]*d\n                for i in range(d):\n                    L[i] = (c_best/2 if i==0 else math.sqrt(c_best**2 - c_min**2)/2)\n                # Rotation matrix aligning x-axis with vector from start to goal\n                def rotation_vector_angle(theta):\n                    if d==2:\n                        # 2D rotate by angle theta\n                        cos_t = math.cos(theta)\n                        sin_t = math.sin(theta)\n                        return [[cos_t, -sin_t],\n                                [sin_t,  cos_t]]\n                    else:\n                        # For 3D, compute rotation matrix by Rodrigues' formula\n                        vec1 = (1,0,0)\n                        vec2 = tuple(x_goal[i]-x_start[i] for i in range(3))\n                        norm_vec2 = math.dist((0,0,0), vec2)\n                        if norm_vec2 == 0:\n                            return [[1,0,0],[0,1,0],[0,0,1]]\n                        axis = (vec1[1]*vec2[2]-vec1[2]*vec2[1],\n                                vec1[2]*vec2[0]-vec1[0]*vec2[2],\n                                vec1[0]*vec2[1]-vec1[1]*vec2[0])\n                        axis_norm = math.dist((0,0,0), axis)\n                        if axis_norm == 0:\n                            return [[1,0,0],[0,1,0],[0,0,1]]\n                        axis = tuple(a/axis_norm for a in axis)\n                        angle = math.acos((vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2])/norm_vec2)\n                        K = [[0,-axis[2],axis[1]],\n                             [axis[2],0,-axis[0]],\n                             [-axis[1],axis[0],0]]\n                        I = [[1,0,0],[0,1,0],[0,0,1]]\n                        # Rodrigues rotation matrix R = I + sin\u03b8*K + (1-cos\u03b8)*K^2\n                        R = [[0]*3 for _ in range(3)]\n                        # Matrix addition helper\n                        def mat_add(A,B):\n                            return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                        # Matrix scalar mult helper\n                        def mat_scalar_mul(A, s):\n                            return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                        # Matrix multiplication helper\n                        def mat_mul(A,B):\n                            return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        K2 = mat_mul(K,K)\n                        R = mat_add(mat_add(I, mat_scalar_mul(K, math.sin(angle))), mat_scalar_mul(K2, 1 - math.cos(angle)))\n                        return R\n                d_vec = tuple(x_goal[i] - x_start[i] for i in range(d))\n                norm_d = math.dist((0,)*d, d_vec)\n                # To avoid complexity, use identity matrix if direction vector is axis-aligned\n                if d == 2:\n                    angle = math.atan2(d_vec[1], d_vec[0]) if norm_d > 1e-8 else 0\n                    R = rotation_vector_angle(angle)\n                    scaled = tuple(L[i]*sample[i] for i in range(d))\n                    rotated = (R[0][0]*scaled[0] + R[0][1]*scaled[1],\n                               R[1][0]*scaled[0] + R[1][1]*scaled[1])\n                    pos = tuple(rotated[i] + (x_start[i] + x_goal[i]) / 2 for i in range(d))\n                else:\n                    R = rotation_vector_angle(0)  # Identity for now for simplification\n                    scaled = tuple(L[i]*sample[i] for i in range(d))\n                    pos = tuple(scaled[i] + (x_start[i] + x_goal[i]) / 2 for i in range(d))\n                if self._inside_bounds(pos, bounds) and not self._is_in_obstacle(pos, obstacles, is_3d):\n                    return pos\n\n        def improved_sample():\n            # With probability p, sample informed; else, uniform\n            p = 0.7\n            if c_best < float(\"inf\") and random.random() < p:\n                return informed_sample()\n            else:\n                return self._uniform_sample(bounds, obstacles, is_3d)\n\n        # Main loop\n        for iteration in range(self.max_iter):\n            rand_point = improved_sample()\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = self._nearest(tree_a, rand_point)\n                new_pos = self._steer(nearest_node.position, rand_point, self.step_size)\n                if not self._inside_bounds(new_pos, bounds):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.parent = nearest_node\n                new_node.cost = new_cost\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Rewire nearby nodes within rewire_radius to improve path costs\n                near_nodes = self._near(tree_a, new_pos, self.rewire_radius)\n                for near_node in near_nodes:\n                    if near_node == nearest_node:\n                        continue\n                    potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                    if potential_cost < near_node.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                            # Rewire near_node\n                            if near_node.parent is not None:\n                                # Remove old edge\n                                try:\n                                    edges.remove((near_node.parent, near_node))\n                                    near_node.parent.children.remove(near_node)\n                                except (ValueError, AttributeError):\n                                    pass\n                            near_node.parent = new_node\n                            near_node.cost = potential_cost\n                            new_node.add_child(near_node)\n                            edges.append((new_node, near_node))\n                            # Update costs of subtree rooted at near_node\n                            self._update_subtree_costs(near_node, obstacles, is_3d)\n\n                # Try connecting to other tree\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size and \\\n                   not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    # Merge trees, extract path\n                    success_state = True\n                    c_best = min(c_best, new_node.cost + connect_node.cost + dist_connect)\n\n                    path_start = self._path_to_root(new_node)\n                    path_goal = self._path_to_root(connect_node)\n                    path_goal.reverse()\n                    extracted_path = path_start + path_goal\n\n                    # Optional smoothing\n                    extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n                    return PlannerResult(success_state, extracted_path, nodes, edges)\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _uniform_sample(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _inside_bounds(self, pos, bounds):\n        return all(0 <= pos[i] <= bounds[i] for i in range(len(bounds)))\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if math.dist(node.position, point) <= radius]\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], step_size: float) -> Tuple[float, ...]:\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _path_to_root(self, node: Node) -> List[Tuple[float, ...]]:\n        path = []\n        current = node\n        while current is not None:\n            path.append(current.position)\n            current = current.parent\n        return path[::-1]\n\n    def _update_subtree_costs(self, node: Node, obstacles, is_3d):\n        # DFS update cost of children recursively\n        for child in node.children:\n            if not self._is_edge_in_obstacle(node.position, child.position, obstacles, is_3d):\n                child.cost = node.cost + math.dist(node.position, child.position)\n                self._update_subtree_costs(child, obstacles, is_3d)\n\n    def _smooth_path(self, path: List[Tuple[float, ...]], obstacles, is_3d, iterations=20) -> List[Tuple[float, ...]]:\n        # Shortcut smoothing attempts to remove unnecessary waypoints\n        if len(path) < 3:\n            return path\n\n        for _ in range(iterations):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 32.39026,
          "time_improvement": -120.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018288540840148925,
                    "num_nodes_avg": 136.6,
                    "path_length_avg": 176.17728495855667,
                    "success_improvement": 0.0,
                    "time_improvement": -81.27522710300693,
                    "length_improvement": 11.948286305123998,
                    "objective_score": -21.992910869877278
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0203230619430542,
                    "num_nodes_avg": 275.6,
                    "path_length_avg": 251.47819612943417,
                    "success_improvement": 0.0,
                    "time_improvement": -42.07915593669526,
                    "length_improvement": 16.551026638232653,
                    "objective_score": -9.313541453362047
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09636964797973632,
                    "num_nodes_avg": 629.7,
                    "path_length_avg": 122.9577397894858,
                    "success_improvement": 0.0,
                    "time_improvement": -235.87879885759014,
                    "length_improvement": 24.496540670390164,
                    "objective_score": -65.86433152319901
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This implementation enhances the bidirectional RRT* by introducing adaptive goal bias with a faster ramp-up for better early convergence, employs a k-d tree for efficient nearest neighbor and radius searches reducing computational complexity, introduces lazy collision checks caching edge validity to avoid redundant computations, and implements more aggressive pruning of unproductive nodes. It prioritizes incremental extension of the smaller tree towards adaptively sampled points, dynamic neighbor radius based on iteration and node count, heuristic sampling weighted by distance to goal/start, and iterative shortcut smoothing to produce shorter, smoother, and near-optimal collision-free paths rapidly and robustly.",
          "planning_mechanism": "The planner grows two trees from start and goal, always extending the smaller tree towards adaptively sampled points biased towards start/goal or randomly sampled. It uses k-d trees for fast neighborhood queries, dynamically adjusts neighbor radius based on iteration and tree size for efficient rewiring. Each new node picks the best parent minimizing cost, rewires neighbors, and attempts incremental connections to the opposing tree with cached lazy collision checks. Periodic pruning removes dead-end nodes, and final solution paths undergo iterative shortcut smoothing for path quality improvement.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.25,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=150,\n                 prune_threshold: int=200,\n                 smoothing_iterations: int=120,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        # ---- Helper functions ----\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # KD-Tree for fast nearest and radius search\n        # Simple 2D/3D KD-tree for nodes positions with rebuilding every prune_interval\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = len(points_nodes[0][0]) if points_nodes else 2\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, point):\n                best = None\n                best_dist = float('inf')\n                stack = [(0, len(self.points))]\n                for i in range(len(self.points)):\n                    d = dist(point, self.points[i])\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, point, radius):\n                result = []\n                r2 = radius * radius\n                for i, p in enumerate(self.points):\n                    # squred dist for perf\n                    sqd = sum((p[d] - point[d])**2 for d in range(len(point)))\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def sample_free(iteration):\n            # Adaptive goal bias ramping faster early, capped at 0.4\n            bias = min(self.goal_sample_rate + (iteration/self.max_iter)*0.2, 0.4)\n            r = random.random()\n            if r < bias:\n                # 75% towards the main goal, 25% towards start (balanced growth)\n                if random.random() < 0.75:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # fallback if repeated hits inside obstacles, return random without checking\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / distance_between\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            if in_bounds(new_pos):\n                return new_pos\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(len(bounds)))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        # Cache collision checks for edges to avoid redundant computations\n        edge_collision_cache = {}\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def prune_dead_nodes():\n            # Remove leaf nodes with no children except roots\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (start_root, goal_root):\n                    continue\n                if not node.children:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(node)\n                except ValueError:\n                    pass\n                # Clean edges containing this node\n                while True:\n                    try:\n                        edges.remove(next(e for e in edges if e[0] == node or e[1] == node))\n                    except StopIteration:\n                        break\n                removed += 1\n            return removed\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Initialize roots and trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        # KD-trees to speed up near/nearest queries, rebuilt periodically\n        def rebuild_kdtree():\n            return KDTree([(node.position, node) for node in nodes])\n\n        kd_tree = rebuild_kdtree()\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for iteration in range(self.max_iter):\n            q_rand = sample_free(iteration)\n\n            # Always extend smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_a, tree_b = tree_goal, tree_start\n            else:\n                tree_a, tree_b = tree_start, tree_goal\n\n            r = neighbor_radius(iteration, len(nodes))\n\n            # Extend tree_a towards q_rand using RRT* logic\n            # Use kd_tree for nearest neighbor search within that tree subset\n            # Extract subset nodes of tree_a for nearest and neighbors\n            sub_nodes = [(node.position, node) for node in tree_a]\n            sub_kdtree = KDTree(sub_nodes)\n            nearest_node = sub_kdtree.nearest(q_rand)\n            new_pos = steer(nearest_node.position, q_rand)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                # Failed extension, skip iteration\n                continue\n\n            near = sub_kdtree.radius_search(new_pos, r)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            # Select best parent with minimal cost & valid connection\n            for node in near:\n                potential_cost = node.cost + dist(node.position, new_pos)\n                if potential_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = potential_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to optimize cost if possible\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try to connect tree_b to new_node incrementally\n            sub_nodes_b = [(node.position, node) for node in tree_b]\n            sub_kdtree_b = KDTree(sub_nodes_b)\n            nearest_b = sub_kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n\n            connected = False\n            max_extend_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_extend_steps):\n                new_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(new_pos_b) or not can_connect(last_node_b.position, new_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, new_pos_b)\n                new_node_b = Node(new_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                # Rewire neighbors of new_node_b in tree_b\n                near_b = sub_kdtree_b.radius_search(new_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_b_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_b_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_b_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                # Check if connection to new_node is possible\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Smooth path with iterative shortcutting\n                    merged_path = shortcut_smoothing(merged_path)\n\n                    extracted_path = merged_path\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic pruning of dead-end nodes for efficiency\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n                # Rebuild kd_tree after pruning for up-to-date efficient queries\n                kd_tree = rebuild_kdtree()\n                # Clear edge cache to avoid memory bloat, but keep minimal\n                edge_collision_cache.clear()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 35.05465,
          "time_improvement": -132.0,
          "length_improvement": 23.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015506649017333984,
                    "num_nodes_avg": 99.3,
                    "path_length_avg": 156.99622385581873,
                    "success_improvement": 0.0,
                    "time_improvement": -53.701235478168805,
                    "length_improvement": 21.53479628556501,
                    "objective_score": -11.803411386337636
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.062104415893554685,
                    "num_nodes_avg": 252.7,
                    "path_length_avg": 232.9376796934483,
                    "success_improvement": 0.0,
                    "time_improvement": -334.17389637556147,
                    "length_improvement": 22.703397245279902,
                    "objective_score": -95.71148946361245
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.030992841720581053,
                    "num_nodes_avg": 170.8,
                    "path_length_avg": 124.11726748792546,
                    "success_improvement": 0.0,
                    "time_improvement": -8.019886639837587,
                    "length_improvement": 23.784520812424446,
                    "objective_score": 2.350938170533613
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is a simplified optimized Bidirectional RRT (BI-RRT*) that grows two trees from start and goal, progressively extending them toward sampled free points. It rewires nodes within a radius to improve path cost while ensuring collision-free nodes and edges. The method balances exploration and exploitation to find high-quality, smooth, and feasible paths efficiently.",
          "planning_mechanism": "The planning mechanism iteratively samples random free points within bounds, extends one tree toward the sample, then attempts to connect the other tree to the new node. Nodes and edges undergo strict collision checks. Rewiring nearby nodes optimizes paths incrementally. Trees alternate roles each iteration until a connecting path is found or iteration limit is reached.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position       # Coordinates (2D or 3D)\n        self.parent = parent           # Parent Node or None\n        self.cost = cost               # Cost from root\n        self.children = []\n        self.valid = True              # Validity flag (collision-free)\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        final_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        for _ in range(self.max_iter):\n            sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if not new_node_a:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._connect_and_rewire(tree_b, new_node_a, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                success = True\n                path_from_start = new_node_a.path_from_root()\n                path_from_goal = new_node_b.path_from_root()\n                final_path = path_from_start + path_from_goal[::-1][1:]  # avoid duplicate node\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success, final_path, nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d) -> Tuple[float, ...]:\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree: List[Node], point: Tuple[float, ...], obstacles, is_3d,\n                           nodes: List[Node], edges: List[Tuple[Node, Node]]) -> Node or None:\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            if self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                continue\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            if self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost:\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree: List[Node], new_node: Node, obstacles, is_3d,\n                            nodes: List[Node], edges: List[Tuple[Node, Node]]) -> Node or None:\n        nearest = self._nearest(tree, new_node.position)\n        current_pos = nearest.position\n\n        while True:\n            new_pos = self._steer(current_pos, new_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current_pos, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                if self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    continue\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            connect_node.parent = best_parent\n\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                if self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    continue\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.children.remove(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n\n            current_pos = connect_node.position\n            nearest = connect_node\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...],\n                             obstacles: List[Tuple], is_3d: bool, resolution: float=1.0) -> bool:\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 94.93936,
          "time_improvement": -304.0,
          "length_improvement": 23.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.037035250663757326,
                    "num_nodes_avg": 75.5,
                    "path_length_avg": 175.81824683755517,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -267.09180538619324,
                    "length_improvement": 12.1277301071068,
                    "objective_score": -82.70199559443661
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.07646899223327637,
                    "num_nodes_avg": 204.9,
                    "path_length_avg": 230.3093546583982,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -434.5970947821087,
                    "length_improvement": 23.57556441210288,
                    "objective_score": -130.66401555221202
               },
               {
                    "map_id": 2,
                    "success_rate": 0.7,
                    "time_avg": 0.08894786834716797,
                    "num_nodes_avg": 184.0,
                    "path_length_avg": 109.50564099824196,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": -210.01154209540965,
                    "length_improvement": 32.75693969627909,
                    "objective_score": -71.45207468936708
               }
          ],
          "success_rate": 0.8333333333333334
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm with adaptive goal biasing, an exponentially decaying neighbor radius for local rewiring, and heuristic cost-guided rewiring to aggressively optimize path length while reducing planning time. The planner also applies shortcut smoothing on the extracted path to improve smoothness and robustness. It carefully alternates between trees, performs strict collision and edge feasibility checks before node and edge additions, and uses early termination upon connection to minimize runtime.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions by sampling points with an adaptive double goal bias. It extends trees towards samples using a fixed step size, rewires neighbors within a dynamically shrinking radius to improve costs locally, and attempts incremental connections between trees. When connection occurs, the shortest path is extracted, and a path smoothing step prunes unnecessary waypoints, resulting in high-quality, shorter, and smoother paths efficiently.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance(self, other_pos):\n        from math import dist\n        return dist(self.position, other_pos)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 initial_neighbor_radius: float=15.0,\n                 min_neighbor_radius: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.initial_neighbor_radius = initial_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        def sample_free():\n            # Adaptive double goal biasing: goal twice as likely as start\n            r = random.random()\n            if r < self.goal_sample_rate:\n                return goal_position\n            elif r < 2 * self.goal_sample_rate:\n                return start_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if self._dist_sq(node.position, pos) <= r_sq]\n\n        def can_connect(p1, p2):\n            if not in_bounds(p2):\n                return False\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def rewire(new_node, near, tree, edges):\n            for neighbor in near:\n                if neighbor == new_node.parent:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, potential_cost)\n                        edges.append((new_node, neighbor))\n\n        def neighbor_radius(iteration):\n            decay = iteration / self.max_iter\n            r = self.initial_neighbor_radius * (0.95 ** (decay * self.max_iter))  # exponential decay to focus rewiring\n            r = max(r, self.min_neighbor_radius)\n            return r\n\n        def try_extend(tree, sample_point, radius):\n            nearest_node = nearest(tree, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                if node == nearest_node:\n                    continue\n                if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    cost_through_node = node.cost + math.dist(node.position, new_pos)\n                    # Heuristic aggressive rewiring: allow slight epsilon to choose better cost nodes\n                    if cost_through_node + 1e-9 < min_cost:\n                        min_cost = cost_through_node\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(new_node, near, tree, edges)\n            return new_node\n\n        def try_connect(to_tree, from_node, radius):\n            curr_node = nearest(to_tree, from_node.position)\n            last_added_node = None\n            while True:\n                new_pos = steer(curr_node.position, from_node.position)\n                if not can_connect(curr_node.position, new_pos):\n                    break\n\n                new_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = curr_node\n                curr_node.children.append(new_node)\n\n                to_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr_node, new_node))\n\n                curr_node = new_node\n                last_added_node = new_node\n\n                if math.dist(new_pos, from_node.position) <= self.step_size:\n                    if can_connect(new_pos, from_node.position):\n                        final_cost = new_node.cost + math.dist(new_pos, from_node.position)\n                        final_node = Node(from_node.position)\n                        final_node.cost = final_cost\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n\n                        to_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    break\n\n            # Local rewiring around last added node to improve path quality\n            if last_added_node:\n                near = near_nodes(to_tree, last_added_node.position, radius)\n                rewire(last_added_node, near, to_tree, edges)\n\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Join without duplicating connection node\n            return path_start + path_goal[::-1][1:]\n\n        def smooth_path(path, max_attempts=75):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    continue\n                path = path[:i+1] + path[j:]\n            return path\n\n        nodes = []\n        edges = []\n        tree_start = [Node(start_position, cost=0.0)]\n        tree_goal = [Node(goal_position, cost=0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            radius = neighbor_radius(it)\n            sample = sample_free()\n\n            # Attempt grow start tree towards sample\n            new_node_start = try_extend(tree_start, sample, radius)\n            if new_node_start is None:\n                # Swap trees if extension failed (bidirectional alternating)\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            # Try connect goal tree towards newly added node\n            new_node_goal = try_connect(tree_goal, new_node_start, radius)\n            if new_node_goal is not None:\n                success_state = True\n                extracted_path = extract_path(new_node_start, new_node_goal)\n                extracted_path = smooth_path(extracted_path, max_attempts=100)\n                break\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _dist_sq(self, p1, p2):\n        return sum((p1[d] - p2[d]) ** 2 for d in range(len(p1)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 94.94693,
          "time_improvement": -318.0,
          "length_improvement": 19.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04654185771942139,
                    "num_nodes_avg": 164.6,
                    "path_length_avg": 165.83538010353692,
                    "success_improvement": 0.0,
                    "time_improvement": -361.3208840238588,
                    "length_improvement": 17.117070950477448,
                    "objective_score": -104.97285101706215
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.06950955390930176,
                    "num_nodes_avg": 373.5,
                    "path_length_avg": 243.98074684955972,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -385.9434457584319,
                    "length_improvement": 19.0389339592929,
                    "objective_score": -116.97524693567098
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.08783087730407715,
                    "num_nodes_avg": 340.8,
                    "path_length_avg": 130.74563020704176,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -206.11847391727417,
                    "length_improvement": 19.714306803598834,
                    "objective_score": -62.89268081446247
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a sampling-based path planning algorithm that incrementally builds a space-filling tree rooted at the start position by randomly sampling the configuration space and extending the nearest existing node toward the sample. It continues this process until the goal is reached or a maximum number of iterations is exceeded.",
          "planning_mechanism": "The planner randomly samples free configurations, finds the nearest node in the current tree, attempts to extend toward the sample by a fixed step size, and adds the new node if the move is valid. This repeats until the goal is reached or iteration limit is hit.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, length) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_position))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 194.9429043992882,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03392350673675537,
                    "num_nodes_avg": 461.3,
                    "path_length_avg": 182.79849371656624,
                    "success_improvement": 0.0,
                    "time_improvement": -236.24833394776394,
                    "length_improvement": 8.639069807597604,
                    "objective_score": -69.14668622280966
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2315977096557617,
                    "num_nodes_avg": 1743.3,
                    "path_length_avg": 304.8791467783907,
                    "success_improvement": 0.0,
                    "time_improvement": -1519.1067663408087,
                    "length_improvement": -1.1692154216563917,
                    "objective_score": -455.96587298657386
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08732478618621826,
                    "num_nodes_avg": 962.7,
                    "path_length_avg": 149.90205372686268,
                    "success_improvement": 0.0,
                    "time_improvement": -204.35458580164382,
                    "length_improvement": 7.95110876006046,
                    "objective_score": -59.716153988481054
               }
          ]
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This improved planner implements a bidirectional RRT* algorithm with enhanced heuristic-informed sampling biased toward the corridor between start and goal, dynamic adaptive radius rewiring optimized for minimizing path length, and periodic aggressive pruning of nodes that have higher costs or are dead ends. It maintains balanced growth between the two trees growing from start and goal, while aggressively rewiring to reduce overall path cost. To refine path quality and smoothness, an additional shortcutting smoothing phase is applied after path extraction to reduce unnecessary waypoints. Collision checking for nodes and edges is strictly enforced to guarantee safety. This approach improves planning efficiency, solution optimality, success rate, and path smoothness while controlling computational cost.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal points. Sampling is biased using an adaptive heuristic that favors points along the direct line between start and goal but still allows exploration to avoid local minima. Extensions grow the smaller tree first to maintain balanced tree sizes. For each new node, rewiring considers neighbors within a dynamically shrinking radius to minimize path cost. Attempts are made after each extension to connect the opposite tree. Periodically, nodes that are dead ends or have significantly worse costs than alternate nearby nodes are pruned to boost efficiency. On success, the path is extracted and then post-processed by shortcut smoothing to reduce path length and improve smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2, radius_constant: float = 30.0,\n                 radius_min: float = 5.0, prune_interval: int = 200, prune_threshold: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        direct_dist = math.dist(start_position, goal_position)\n\n        def sample_free():\n            # Heuristic-informed sampling biased towards corridor between start-goal segment with Gaussian noise\n            p_goal_bias = self.goal_sample_rate\n            if random.random() < p_goal_bias:\n                # Alternate bias to goal and start with probability weighted by distance\n                if random.random() < 0.7:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                w = 0.8  # corridor width fraction of max bound dimension\n                max_dim = max(bounds) if not is_3d else max(bounds[0], bounds[1], bounds[2])\n                corridor_width = w * max_dim\n\n                # Sample along line between start and goal plus perpendicular noise inside corridor_width\n                alpha = random.uniform(0.0, 1.0)\n                base_point = tuple(start_position[d] + alpha * (goal_position[d] - start_position[d]) for d in range(len(bounds)))\n\n                # Generate perpendicular noise vector\n                if is_3d:\n                    # sample random perpendicular vector in 3D using Gram-Schmidt\n                    import numpy as np\n                    dir_vec = np.array([goal_position[d] - start_position[d] for d in range(3)])\n                    dir_vec /= np.linalg.norm(dir_vec)\n                    # create arbitrary vector not parallel to dir_vec\n                    if abs(dir_vec[0]) < 0.9:\n                        temp_vec = np.array([1,0,0])\n                    else:\n                        temp_vec = np.array([0,1,0])\n                    perp_vec1 = temp_vec - dir_vec * np.dot(temp_vec, dir_vec)\n                    perp_vec1 /= np.linalg.norm(perp_vec1)\n                    perp_vec2 = np.cross(dir_vec, perp_vec1)\n                    perp_vec2 /= np.linalg.norm(perp_vec2)\n                    noise_radius = random.uniform(-corridor_width/2, corridor_width/2)\n                    noise_vec = perp_vec1 * noise_radius * random.gauss(0,0.5) + perp_vec2 * noise_radius * random.gauss(0,0.5)\n                    sample_np = np.array(base_point) + noise_vec\n                    sample = tuple(max(0, min(bounds[d], sample_np[d])) for d in range(3))\n                else:\n                    # 2D: noise perpendicular to line between start-goal\n                    dx = goal_position[0] - start_position[0]\n                    dy = goal_position[1] - start_position[1]\n                    length = math.hypot(dx, dy)\n                    if length == 0:\n                        perp = (0.0, 0.0)\n                    else:\n                        perp = (-dy/length, dx/length)\n                    offset = random.gauss(0, corridor_width/4)\n                    x = base_point[0] + perp[0]*offset\n                    y = base_point[1] + perp[1]*offset\n                    x = min(max(x, 0), bounds[0])\n                    y = min(max(y, 0), bounds[1])\n                    sample = (x, y)\n\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n                # fallback random sampling if corridor sample is invalid\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            # Choose parent that yields minimum cost and valid edge\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if improves cost and edge is free\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            # Remove dead-end nodes with no children except roots\n            removed_nodes = []\n            cost_threshold_factor = 1.5  # prune if cost significantly worse than neighbor best\n            for node in nodes[:]:\n                if (not node.children) and node is not start_root and node is not goal_root:\n                    # Check if nearby better paths exist: prune high cost dead ends\n                    radius = radius_by_nodes(len(nodes))\n                    near = near_nodes(nodes, node.position, radius)\n                    better_found = False\n                    for n in near:\n                        if n is node:\n                            continue\n                        if n.cost + distance(n.position, node.position) * 0.5 < node.cost * cost_threshold_factor:\n                            better_found = True\n                            break\n                    if better_found:\n                        try:\n                            if node.parent:\n                                node.parent.children.remove(node)\n                            nodes.remove(node)\n                            edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                            removed_nodes.append(node)\n                        except Exception:\n                            continue\n            return removed_nodes\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]\n\n        def shortcut_smooth(path):\n            # Attempt shortcutting by connecting non-adjacent waypoints directly if edge collision free\n            # Improves path length and smoothness\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(smoothed[-1], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always grow smaller tree first to keep balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                raw_path = extract_path(new_node_start, new_node_goal)\n                # Apply shortcut smoothing post extraction\n                extracted_path = shortcut_smooth(raw_path)\n                break\n\n            # Prune dead or costly nodes periodically to improve efficiency\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 246.94059,
          "time_improvement": -823.0,
          "length_improvement": 25.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010161566734313964,
                    "num_nodes_avg": 85.4,
                    "path_length_avg": 151.13846741624656,
                    "success_improvement": 0.0,
                    "time_improvement": -0.7210106910926433,
                    "length_improvement": 24.46244665225591,
                    "objective_score": 4.676186123123389
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.10125017166137695,
                    "num_nodes_avg": 385.5,
                    "path_length_avg": 229.07856327082519,
                    "success_improvement": 0.0,
                    "time_improvement": -607.8430882316173,
                    "length_improvement": 23.98398263402543,
                    "objective_score": -177.55612994268012
               },
               {
                    "map_id": 2,
                    "success_rate": 0.7,
                    "time_avg": 0.5628214597702026,
                    "num_nodes_avg": 659.0,
                    "path_length_avg": 117.72808715504519,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": -1861.611356291771,
                    "length_improvement": 27.707862427511778,
                    "objective_score": -567.9418344020289
               }
          ],
          "success_rate": 0.9
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This improved bidirectional RRT planner enhances path planning performance by integrating informed sampling biased towards frontiers, adaptive step sizing near obstacles, and efficient rewiring to minimize path costs dynamically during tree growth. After connecting the start and goal trees, an aggressive shortcut smoothing process is applied using randomized edge-skipping to produce shorter, smoother paths. The planner maintains strict collision and edge validations, pruning longer paths in favor of lower-cost connections, thereby improving success rates and reducing total planning time while providing higher quality paths.",
          "planning_mechanism": "The planner alternates growth between forward and reverse trees, sampling points with a frontier bias to promote exploration near unknown boundaries. It adaptively reduces step size near obstacles for safer expansion. Upon adding new nodes, it rewires nearby nodes to reduce overall path cost, akin to RRT*. When the trees connect, the concatenated path is shortcut-smoothed iteratively to remove unnecessary waypoints and improve smoothness. This process results in efficient, collision-free, and cost-optimized trajectories.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        # Remove self from old parent's children\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, frontier_sample_rate: float = 0.3, rewire_radius: float = 10.0, smoothing_iters: int = 100):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.frontier_sample_rate = frontier_sample_rate\n        self.rewire_radius = rewire_radius\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start + tree_goal)\n\n        frontiers = self._identify_frontiers(bounds, obstacles, is_3d)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        for i in range(self.max_iter):\n            # Alternate tree order\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Sampling with frontier bias\n            if frontiers and random.random() < self.frontier_sample_rate:\n                rand_point = self._sample_near_frontier(frontiers, bounds, is_3d)\n            else:\n                rand_point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest_a = nearest_node(tree_a, rand_point)\n            step_size_a = self._adaptive_step_size(nearest_a.position, obstacles, is_3d)\n            new_pos_a = self._steer(nearest_a.position, rand_point, step_size_a)\n\n            if not self._in_bounds(new_pos_a, bounds):\n                continue\n            if self._is_in_obstacle(new_pos_a, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_a.position, new_pos_a, obstacles, is_3d):\n                continue\n\n            # Choose parent with minimum cost among near nodes in tree_a for new_pos_a (rewiring)\n            near_a = near_nodes(tree_a, new_pos_a, self.rewire_radius)\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos_a)\n            min_parent = nearest_a\n            for node in near_a:\n                if not self._is_edge_in_obstacle(node.position, new_pos_a, obstacles, is_3d):\n                    cost_through_node = node.cost + dist(node.position, new_pos_a)\n                    if cost_through_node < min_cost:\n                        min_cost = cost_through_node\n                        min_parent = node\n\n            new_node_a = Node(new_pos_a, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node_a)\n            tree_a.append(new_node_a)\n            nodes.append(new_node_a)\n            edges.append((min_parent, new_node_a))\n\n            # Rewiring: Try to connect other near nodes to new_node_a if cheaper\n            for node in near_a:\n                if node is min_parent:\n                    continue\n                if not self._is_edge_in_obstacle(new_node_a.position, node.position, obstacles, is_3d):\n                    potential_cost = new_node_a.cost + dist(new_node_a.position, node.position)\n                    if potential_cost < node.cost:\n                        node.update_parent(new_node_a, potential_cost)\n                        edges.append((new_node_a, node))  # Track rewired edge (optional)\n\n            # Connect tree_b towards new_node_a\n            nearest_b = nearest_node(tree_b, new_pos_a)\n            connected = False\n            current_node_b = nearest_b\n            while True:\n                step_size_b = self._adaptive_step_size(current_node_b.position, obstacles, is_3d)\n                next_pos_b = self._steer(current_node_b.position, new_pos_a, step_size_b)\n\n                if not self._in_bounds(next_pos_b, bounds):\n                    break\n                if self._is_in_obstacle(next_pos_b, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(current_node_b.position, next_pos_b, obstacles, is_3d):\n                    break\n\n                # Rewiring in tree_b as well\n                near_b = near_nodes(tree_b, next_pos_b, self.rewire_radius)\n                min_cost_b = current_node_b.cost + dist(current_node_b.position, next_pos_b)\n                min_parent_b = current_node_b\n                for node in near_b:\n                    if not self._is_edge_in_obstacle(node.position, next_pos_b, obstacles, is_3d):\n                        cost_through_node = node.cost + dist(node.position, next_pos_b)\n                        if cost_through_node < min_cost_b:\n                            min_cost_b = cost_through_node\n                            min_parent_b = node\n\n                new_node_b = Node(next_pos_b, parent=min_parent_b, cost=min_cost_b)\n                min_parent_b.add_child(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((min_parent_b, new_node_b))\n\n                # Rewiring in tree_b\n                for node in near_b:\n                    if node is min_parent_b:\n                        continue\n                    if not self._is_edge_in_obstacle(new_node_b.position, node.position, obstacles, is_3d):\n                        potential_cost = new_node_b.cost + dist(new_node_b.position, node.position)\n                        if potential_cost < node.cost:\n                            node.update_parent(new_node_b, potential_cost)\n                            edges.append((new_node_b, node))\n\n                current_node_b = new_node_b\n\n                if dist(next_pos_b, new_pos_a) <= step_size_b:\n                    path_a = new_node_a.path_from_root()\n                    path_b = current_node_b.path_from_root()\n                    if tree_a is tree_goal and tree_b is tree_start:\n                        # swap to maintain start->goal order\n                        path_a, path_b = path_b, path_a\n                    path = path_a + path_b[::-1]\n                    success = True\n                    connected = True\n                    break\n\n            if connected:\n                break\n\n        if success and len(path) > 2:\n            path = self._shortcut_smooth(path, obstacles, is_3d, bounds)\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _adaptive_step_size(self, position, obstacles, is_3d):\n        query_radius = self.base_step_size * 2\n        min_dist = float('inf')\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                px, py, pz = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dz = max(oz - pz, 0, pz - (oz + d))\n                dist = (dx*dx + dy*dy + dz*dz) ** 0.5\n            else:\n                ox, oy, w, h = obs\n                px, py = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dist = (dx*dx + dy*dy) ** 0.5\n            if dist < min_dist:\n                min_dist = dist\n        if min_dist <= query_radius:\n            factor = max(0.2, min_dist / query_radius)  # Scale step size with distance but don't go below 20%\n            return self.base_step_size * factor\n        return self.base_step_size\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        import random\n        dim = len(bounds)\n        frontier = random.choice(frontiers)\n        radius = self.base_step_size * 3\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                yield nbr\n\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                min_c = [int(ox // resolution), int(oy // resolution), int(oz // resolution)]\n                max_c = [int((ox + w) // resolution), int((oy + h) // resolution), int((oz + d) // resolution)]\n                ranges = [range(min_c[i], max_c[i] + 1) for i in range(3)]\n                for x in ranges[0]:\n                    for y in ranges[1]:\n                        for z in ranges[2]:\n                            occupied.add((x, y, z))\n            else:\n                ox, oy, w, h = obs\n                min_c = [int(ox // resolution), int(oy // resolution)]\n                max_c = [int((ox + w) // resolution), int((oy + h) // resolution)]\n                for x in range(min_c[0], max_c[0] + 1):\n                    for y in range(min_c[1], max_c[1] + 1):\n                        occupied.add((x, y))\n\n        if is_3d:\n            for ix in range(steps[0] + 1):\n                for iy in range(steps[1] + 1):\n                    for iz in range(steps[2] + 1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontiers.append(tuple((pos_grid[d] + 0.5) * resolution for d in range(dims)))\n        else:\n            for ix in range(steps[0] + 1):\n                for iy in range(steps[1] + 1):\n                    pos_grid = (ix, iy)\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontiers.append(((ix + 0.5) * resolution, (iy + 0.5) * resolution))\n\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n            return\n        for item in arrays[0]:\n            for rest in self._cartesian_product(arrays[1:]):\n                yield (item,) + rest\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, bounds):\n        import random\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            p_i, p_j = new_path[i], new_path[j]\n            if self._in_bounds(p_i, bounds) and self._in_bounds(p_j, bounds):\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    new_path = new_path[:i + 1] + new_path[j:]\n        return new_path",
          "objective": 317.11977,
          "time_improvement": -1074.0,
          "length_improvement": 25.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.09651689529418946,
                    "num_nodes_avg": 207.9,
                    "path_length_avg": 152.38497676196295,
                    "success_improvement": 0.0,
                    "time_improvement": -856.6712985282026,
                    "length_improvement": 23.839453262087442,
                    "objective_score": -252.23349890604325
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.19585566520690917,
                    "num_nodes_avg": 657.9,
                    "path_length_avg": 226.874162371368,
                    "success_improvement": 0.0,
                    "time_improvement": -1269.233025810269,
                    "length_improvement": 24.715477430666883,
                    "objective_score": -375.82681225694733
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.3428631782531738,
                    "num_nodes_avg": 738.6,
                    "path_length_avg": 120.53298597760006,
                    "success_improvement": 0.0,
                    "time_improvement": -1094.986958013862,
                    "length_improvement": 25.985485580515178,
                    "objective_score": -323.29899028805556
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
          "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 365.07898281774106,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.048356366157531736,
                    "num_nodes_avg": 379.9,
                    "path_length_avg": 157.7438779343973,
                    "success_improvement": 0.0,
                    "time_improvement": -379.30621331140287,
                    "length_improvement": 21.16112596316623,
                    "objective_score": -109.55963880078761
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.42775466442108157,
                    "num_nodes_avg": 1647.6,
                    "path_length_avg": 225.42614332098805,
                    "success_improvement": 0.0,
                    "time_improvement": -2890.4461167920927,
                    "length_improvement": 25.195979140247676,
                    "objective_score": -862.0946392095783
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.15208303928375244,
                    "num_nodes_avg": 897.6,
                    "path_length_avg": 118.59892784173539,
                    "success_improvement": 0.0,
                    "time_improvement": -430.0576439998969,
                    "length_improvement": 27.173113785558407,
                    "objective_score": -123.58267044285738
               }
          ]
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional, asymptotically optimal planner that enhances RRT*-Connect by incorporating informed heuristic sampling, adaptive step size, node rejection, and pruning. It accelerates convergence and improves success rate in narrow, obstacle-rich environments.",
          "planning_mechanism": "The planner grows two trees from start and goal using informed sampling. During expansion, it adaptively adjusts the step size near obstacles, rejects inefficient new nodes, and prunes branches that cannot contribute to an improved solution. The planner rewires nearby nodes only if doing so reduces path cost, and updates the current best path whenever a successful connection is found.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map):\n        import math, random, numpy as np\n\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_a, tree_b = [Node(start)], [Node(goal)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n        success, c_best, best_path = False, float(\"inf\"), []\n        c_min = math.dist(start, goal)\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_a, tree_b) if i % 2 == 0 else (tree_b, tree_a)\n\n            sample = self._informed_sample(start, goal, c_best, c_min, bounds, dim)\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            cost = nearest.cost + math.dist(nearest.position, new_pos)\n            if cost + math.dist(new_pos, goal) >= c_best:\n                continue  # pruning\n\n            new_node = Node(new_pos, nearest, cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            near_nodes = [n for n in tree_a if math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        near.parent.children.remove(near)\n                        edges.remove((near.parent, near))\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            # Try to connect to the other tree\n            other_nearest = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            connect_cost = new_node.cost + math.dist(new_node.position, other_nearest.position) + other_nearest.cost\n            if connect_cost < c_best and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                c_best = connect_cost\n                path_a = new_node.path_from_root()\n                path_b = other_nearest.path_from_root()\n                best_path = path_a + path_b[::-1]\n                success = True\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np, math, random\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n        x_center = [(s + g) / 2 for s, g in zip(start, goal)]\n        a1 = np.array(goal) - np.array(start)\n        a1 = a1 / np.linalg.norm(a1)\n        M = np.outer(a1, np.eye(dim)[0])\n        U, _, Vt = np.linalg.svd(M)\n        C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n        r1 = c_best / 2\n        r2 = math.sqrt(c_best**2 - c_min**2) / 2\n        L = np.diag([r1] + [r2] * (dim - 1))\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            x_ball /= np.linalg.norm(x_ball)\n            x_ball *= random.random() ** (1 / dim)\n            x_rand = C @ L @ x_ball + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return max(self.base_step * 0.3, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    ",
          "objective": 2785.2308249802863,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 1.137650489807129,
                    "num_nodes_avg": 1818.3,
                    "path_length_avg": 154.56558140968315,
                    "success_improvement": 0.0,
                    "time_improvement": -11176.342530886956,
                    "length_improvement": 22.74960801803148,
                    "objective_score": -3348.35283766248
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 1.7188157796859742,
                    "num_nodes_avg": 3093.7,
                    "path_length_avg": 229.59608695928765,
                    "success_improvement": 0.0,
                    "time_improvement": -11916.294388745822,
                    "length_improvement": 23.81225076558798,
                    "objective_score": -3570.125866470629
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 1.408572006225586,
                    "num_nodes_avg": 2839.3,
                    "path_length_avg": 117.39619397761064,
                    "success_improvement": 0.0,
                    "time_improvement": -4809.320345913857,
                    "length_improvement": 27.91166483203798,
                    "objective_score": -1437.2137708077494
               }
          ]
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm is a hybrid incremental sampling planner that combines informed sampling within an ellipsoidal heuristic region around the current best path with iterative path optimization via shortcut smoothing. It aims to accelerate convergence toward an optimal path by focusing samples where improvements are most likely and continuously refining the found path to improve smoothness and length.",
          "planning_mechanism": "The planner first builds a tree incrementally like RRT but after finding an initial solution, it restricts sampling to an ellipsoidal subset defined by start, goal, and current best path cost to guide exploration efficiently. Upon reaching the goal, it performs shortcut smoothing by attempting to connect random pairs of points on the path directly if collision-free, thus improving path quality and reducing length while maintaining robustness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def path_to_root(self):\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        def euclidean(p1, p2):\n            return math.dist(p1, p2)\n\n        def sample_in_bounds():\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def sample_in_ellipse(cbest, start, goal):\n            # Generate a uniformly random sample in the ellipsoid scaled by current best cost cbest\n            # Ellipsoid defined in the frame with foci start and goal\n            dim = len(bounds)\n            c_min = euclidean(start, goal)\n            if cbest == float('inf'):\n                return sample_in_bounds()\n\n            # Center and rotation\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            diff = tuple(goal[d] - start[d] for d in range(dim))\n            dist = max(c_min, 1e-6)\n\n            # Rotation matrix: only for 2D or 3D cases (orthonormal basis)\n            # Here we build an orthonormal frame with first axis along diff\n            import numpy as np\n\n            diff_np = np.array(diff)\n            e1 = diff_np / dist\n\n            # Create an orthonormal basis with e1 as first basis vector\n            if dim == 2:\n                e2 = np.array([-e1[1], e1[0]])\n                rotation = np.vstack((e1, e2)).T  # 2x2 matrix\n            elif dim == 3:\n                # Gram-Schmidt to find two perpendicular vectors\n                if abs(e1[0]) < abs(e1[1]):\n                    v = np.array([1,0,0])\n                else:\n                    v = np.array([0,1,0])\n                e2 = v - np.dot(v,e1)*e1\n                e2 /= np.linalg.norm(e2)\n                e3 = np.cross(e1,e2)\n                rotation = np.vstack((e1, e2, e3)).T  # 3x3 matrix\n            else:\n                # fallback to uniform sampling\n                return sample_in_bounds()\n\n            # Radii of the ellipsoid axes\n            a = cbest / 2   # major axis half length\n            r = math.sqrt(cbest**2 - c_min**2) / 2 if cbest > c_min else 0\n            radii = [a] + [r] * (dim -1)\n\n            # Sample unit ball point (random direction + radius^{1/dim} for uniform volumetric sampling)\n            while True:\n                # sample random vector in unit ball\n                vec = np.random.normal(0,1,dim)\n                norm = np.linalg.norm(vec)\n                if norm == 0: \n                    continue\n                unit_vec = vec / norm\n                # scale by uniform radius within unit ball (radius^(1/d))\n                radius_scale = random.uniform(0,1)**(1/dim)\n                sample_ball = unit_vec * radius_scale\n\n                # scale by radii\n                local_point = np.multiply(sample_ball, radii)\n                global_point = rotation @ local_point + np.array(center)\n\n                # Check in bounds\n                if all(0 <= global_point[d] <= bounds[d] for d in range(dim)):\n                    return tuple(global_point)\n\n        def steer(from_pos, to_pos):\n            dist = euclidean(from_pos, to_pos)\n            if dist == 0:\n                return from_pos\n            step = min(self.step_size, dist)\n            unit_vec = tuple((to_pos[d] - from_pos[d]) / dist for d in range(len(from_pos)))\n            new_pos = tuple(from_pos[d] + unit_vec[d]*step for d in range(len(from_pos)))\n            return new_pos\n\n        for iter_count in range(self.max_iter):\n            # After initial solution: informed sampling within ellipsoidal heuristic sampling\n            if best_goal_node:\n                sample = sample_in_ellipse(best_cost, start_position, goal_position)\n            else:\n                sample = sample_in_bounds()\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: euclidean(n.position, sample))\n\n            new_position = steer(nearest_node.position, sample)\n\n            # Check collisions and bounds\n            if any(not (0 <= new_position[d] <= bounds[d]) for d in range(len(bounds))):\n                continue\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + euclidean(nearest_node.position, new_position)\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check goal reach\n            dist_to_goal = euclidean(new_position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_cost = new_node.cost + dist_to_goal\n                    if goal_cost < best_cost:\n                        goal_node = Node(goal_position, parent=new_node, cost=goal_cost)\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success_state = True\n                        best_goal_node = goal_node\n                        best_cost = goal_cost\n\n            # Early stopping if max iterations reached and found solution\n            if iter_count >= self.max_iter - 1 and success_state:\n                break\n\n        # If success, extract and smooth path by shortcutting\n        if success_state:\n            path = best_goal_node.path_to_root()\n\n            def shortcut_smooth(path_, max_attempts=100):\n                path_smoothed = path_[:]\n                for _ in range(max_attempts):\n                    if len(path_smoothed) <= 2:\n                        break\n                    i = random.randint(0, len(path_smoothed) - 2)\n                    j = random.randint(i+1, len(path_smoothed) -1)\n                    if j == i +1:\n                        continue\n                    p1 = path_smoothed[i]\n                    p2 = path_smoothed[j]\n                    if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                        # Shortcut is possible: remove intermediate points\n                        path_smoothed = path_smoothed[:i+1] + path_smoothed[j:]\n                return path_smoothed\n\n            extracted_path = shortcut_smooth(path, max_attempts=200)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 2995.45002,
          "time_improvement": -9996.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 1.2528609752655029,
                    "num_nodes_avg": 3151.0,
                    "path_length_avg": 178.45351599762108,
                    "success_improvement": 0.0,
                    "time_improvement": -12318.303887927857,
                    "length_improvement": 10.810647909786953,
                    "objective_score": -3693.3290367963996
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 1.6598132610321046,
                    "num_nodes_avg": 4219.8,
                    "path_length_avg": 240.8545685239727,
                    "success_improvement": 0.0,
                    "time_improvement": -11503.805952113076,
                    "length_improvement": 20.076305691042464,
                    "objective_score": -3447.126524495714
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 1.7981833457946776,
                    "num_nodes_avg": 4588.2,
                    "path_length_avg": 128.02205757347767,
                    "success_improvement": 0.0,
                    "time_improvement": -6167.239478121122,
                    "length_improvement": 21.38674447138304,
                    "objective_score": -1845.8944945420599
               }
          ],
          "success_rate": 1.0
     }
]