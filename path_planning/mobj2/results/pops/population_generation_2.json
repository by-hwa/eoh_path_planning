[
     {
          "operator": "e1",
          "algorithm_description": "This algorithm introduces a Hybrid Adaptive Bidirectional RRT* with Sampling Bias and Localized Lazy Collision Checking to improve planning efficiency, path quality, robustness, and smoothness. It dynamically adjusts the sampling domain using heuristic-guided informed sampling biased towards promising regions, interleaves tree growth from start and goal, employs KD-tree for efficient neighbor queries, and performs lazy collision checks during rewiring to reduce expensive computations. Additionally, a post-processing shortcut smoothing using smart edge checking is applied to enhance path smoothness and shorten final path length.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately, samples points adaptively biased towards the current best path region, extends one tree toward sampled points, rewires neighbors using efficient KD-tree-based radius search with lazy collision checking, and attempts to connect the two trees. Upon connection, it extracts and shortcuts the combined path while validating collision-free edges. It leverages pruning of nodes not capable of improving current best path and maintains balanced tree growth for robustness and reduced search time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # For collision validity or lazy checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_radius: float = 5.0, max_radius: float = 30.0,\n                 shortcut_iter: int = 150, collision_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.shortcut_iter = shortcut_iter\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # clamp inside bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def radius(iteration, n_nodes):\n            if n_nodes == 0:\n                return self.max_radius\n            r_iter = self.max_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius)*math.sqrt(math.log(n_nodes + 1) / (n_nodes))\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        # Lazy collision cache for edges and nodes\n        node_collision_cache = {}\n        edge_collision_cache = {}\n\n        def is_in_obstacle_cached(pos):\n            if pos in node_collision_cache:\n                return node_collision_cache[pos]\n            val = self._is_in_obstacle(pos, obstacles, is_3d)\n            node_collision_cache[pos] = val\n            return val\n\n        def is_edge_colliding_cached(a, b):\n            key = (a, b)\n            key_rev = (b, a)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n            val = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n            edge_collision_cache[key] = val\n            return val\n\n        # KDTree for neighbor search (simple linear search)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius*radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d in range(dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        # Informed sampling biased towards best found path corridor with heuristic weights\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # Uniform sampling with retries for obstacle free\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_m = np.eye(dim)\n            v = a1 - np.array([1] + [0] * (dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_m - 2 * np.outer(v, v)\n            else:\n                rot = id_m\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r_others]*(dim-1))\n\n            for _ in range(150):\n                x_ball = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x <= 1.0 and norm_x > 1e-5:  # avoid zero vector\n                    x_ball = x_ball / norm_x * random.uniform(0,1) ** (1.0/dim)  # uniform in ball\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle_cached(p):\n                        return p\n\n            # fallback uniform sampling\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle_cached(p):\n                    return p\n            return p\n\n        # Shortcut smoothing on path using lazy collision checks\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(self.shortcut_iter):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if not is_edge_colliding_cached(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        root_start = Node(start_position, cost=0.0)\n        root_goal = Node(goal_position, cost=0.0)\n\n        nodes_start = [root_start]\n        nodes_goal = [root_goal]\n        nodes_all = [root_start, root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_position, goal_position)\n\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        # Balanced tree growth flag\n        grow_start_tree = True\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_position, goal_position)\n\n            # Select which tree to grow based on sizes for balance\n            if len(nodes_start) <= len(nodes_goal):\n                tree_a_nodes, tree_b_nodes = nodes_start, nodes_goal\n                root_a, root_b = root_start, root_goal\n                growing_from_start = True\n            else:\n                tree_a_nodes, tree_b_nodes = nodes_goal, nodes_start\n                root_a, root_b = root_goal, root_start\n                growing_from_start = False\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a_nodes])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if is_in_obstacle_cached(new_pos) or is_edge_colliding_cached(nearest_a.position, new_pos):\n                continue\n\n            r = radius(iteration, len(nodes_all))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n\n            # Lazy rewiring: first minimal cost parent selection (do edge check lazily)\n            for node in near_nodes:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost:\n                    # Check connectivity lazily now\n                    if not is_edge_colliding_cached(node.position, new_pos):\n                        min_cost = cost_candidate\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a_nodes.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cheaper cost paths if possible\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost:\n                    if not is_edge_colliding_cached(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, c_via_new)\n                        edges.append((new_node, neighbor))\n\n            # Attempt to connect new_node to other tree\n            kdtree_b = KDTree([(n.position, n) for n in tree_b_nodes])\n            nearest_b = kdtree_b.nearest(new_node.position)\n\n            if dist(new_node.position, nearest_b.position) <= self.step_size and \\\n               not is_edge_colliding_cached(new_node.position, nearest_b.position):\n                # Connect directly\n                cost_connection = new_node.cost + dist(new_node.position, nearest_b.position)\n                connect_node = Node(nearest_b.position, parent=new_node, cost=cost_connection)\n                new_node.children.append(connect_node)\n                tree_a_nodes.append(connect_node)\n                nodes_all.append(connect_node)\n                edges.append((new_node, connect_node))\n\n                # Extract full path\n                if growing_from_start:\n                    path_start = connect_node.path_from_root()\n                    path_goal = nearest_b.path_from_root()\n                else:\n                    path_start = nearest_b.path_from_root()\n                    path_goal = connect_node.path_from_root()\n\n                merged_path = path_start + path_goal[::-1][1:]  # avoid duplicate node\n\n                # Shortcut smoothing for improved path quality\n                smoothed_path = shortcut_path(merged_path)\n\n                c_candidate = connect_node.cost + (nearest_b.cost if growing_from_start else new_node.cost)\n                if c_candidate < c_best:\n                    c_best = c_candidate\n                    best_path = smoothed_path\n                    success_state = True\n\n                extracted_path = best_path\n                break\n\n            # Else do incremental connection attempt with limited steps from nearest_b toward new_node\n            dist_to_newnode = dist(nearest_b.position, new_node.position)\n            max_steps = max(1, int(dist_to_newnode / self.step_size))\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos = steer(last_node_b.position, new_node.position)\n                if is_in_obstacle_cached(next_pos) or is_edge_colliding_cached(last_node_b.position, next_pos):\n                    break\n                cost_next = last_node_b.cost + dist(last_node_b.position, next_pos)\n                new_node_b = Node(next_pos, parent=last_node_b, cost=cost_next)\n                last_node_b.children.append(new_node_b)\n                tree_b_nodes.append(new_node_b)\n                nodes_all.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                # Rewire neighbors in tree_b around new_node_b\n                near_b = kdtree_b.radius_search(next_pos, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost:\n                        if not is_edge_colliding_cached(new_node_b.position, neighbor_b.position):\n                            try:\n                                edges.remove((neighbor_b.parent, neighbor_b))\n                            except ValueError:\n                                pass\n                            neighbor_b.update_parent(new_node_b, c_via_new_b)\n                            edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and \\\n                   not is_edge_colliding_cached(new_node_b.position, new_node.position):\n                    # Connect finally\n                    cost_conn = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=cost_conn)\n                    new_node_b.children.append(connection_node)\n                    tree_b_nodes.append(connection_node)\n                    nodes_all.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    if growing_from_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    smoothed_path = shortcut_path(merged_path)\n\n                    if cost_conn < c_best:\n                        c_best = cost_conn\n                        best_path = smoothed_path\n                        success_state = True\n\n                    extracted_path = best_path\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if success_state:\n                break\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes_all,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.30002,
          "time_improvement": 43.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016922187805175782,
                    "num_nodes_avg": 73.5,
                    "path_length_avg": 154.23200362778806,
                    "smoothness_avg": 0.04002093790061885,
                    "success_improvement": 0.0,
                    "time_improvement": 32.784829785863906,
                    "length_improvement": 15.46299484911554,
                    "smoothness_improvement": 526.4145850023286,
                    "objective_score": 15.560120830593922
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.045720887184143064,
                    "num_nodes_avg": 212.9,
                    "path_length_avg": 237.2164084286152,
                    "smoothness_avg": 0.10522668171555331,
                    "success_improvement": 0.0,
                    "time_improvement": 72.29510884836787,
                    "length_improvement": 20.81033497079458,
                    "smoothness_improvement": 2607.558312256502,
                    "objective_score": 38.88839120995179
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03875234127044678,
                    "num_nodes_avg": 157.1,
                    "path_length_avg": 123.32472678199296,
                    "smoothness_avg": 0.1265137676603671,
                    "success_improvement": 0.0,
                    "time_improvement": 24.288718052866827,
                    "length_improvement": 18.093588563825442,
                    "smoothness_improvement": 1509.245786364919,
                    "objective_score": 18.45156206044973
               }
          ],
          "smoothness_improvement": 1548.0,
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This planner is an improved hybrid bidirectional RRT* algorithm integrating informed ellipsoidal sampling, KD-tree acceleration, adaptive neighbor radius, collision caching, incremental rewiring, periodic pruning, and aggressive shortcut smoothing for fast convergence to short and smooth paths. It employs balanced tree growth, enhanced nearest and radius search, and rigorous collision and boundary checks to improve path length, planning time, robustness, and success rate in both 2D and 3D environments.",
          "planning_mechanism": "The planner alternates growth between two trees rooted at start and goal, sampling points within an ellipsoid defined by the current best path cost for focused exploration. KD-trees accelerate nearest neighbor and radius queries for rewiring, collision results are cached to reduce redundant checks, and nodes are periodically pruned to remove suboptimal branches. Upon successful tree connection, the best path undergoes shortcut smoothing to improve path quality. This combination ensures efficient, reliable, and high-quality path planning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = 5.0\n        self.max_neighbor_radius = 30.0\n        self.prune_interval = 200\n        self.prune_threshold = 300\n        self.smoothing_iterations = 150\n        self.collision_check_resolution = 1.0\n        self.goal_sample_rate = 0.15\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) * (c_min / 2), 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    radius_factor = np.random.uniform(0, 1) ** (1 / dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new node\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connect opposite tree towards new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.44167,
          "time_improvement": 39.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02169802188873291,
                    "num_nodes_avg": 80.9,
                    "path_length_avg": 157.57814870223828,
                    "smoothness_avg": 0.04764540259502782,
                    "success_improvement": 0.0,
                    "time_improvement": 13.8151490012917,
                    "length_improvement": 13.628919710747569,
                    "smoothness_improvement": 645.7540142599136,
                    "objective_score": 10.099098713836593
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05104916095733643,
                    "num_nodes_avg": 217.4,
                    "path_length_avg": 235.39968977102907,
                    "smoothness_avg": 0.09157597560954919,
                    "success_improvement": 0.0,
                    "time_improvement": 69.0664041139677,
                    "length_improvement": 21.41680795004402,
                    "smoothness_improvement": 2256.3158119428285,
                    "objective_score": 36.284861883913266
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03416609764099121,
                    "num_nodes_avg": 154.4,
                    "path_length_avg": 124.42529858311859,
                    "smoothness_avg": 0.12568992365837842,
                    "success_improvement": 0.0,
                    "time_improvement": 33.24896079238765,
                    "length_improvement": 17.362641177115243,
                    "smoothness_improvement": 1498.7665514694615,
                    "objective_score": 20.94104923048665
               }
          ],
          "smoothness_improvement": 1467.0,
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This planner is an optimized bidirectional anytime informed RRT* variant that combines adaptive ellipsoidal sampling guided by the current best path, KD-tree accelerated neighbor searches, lazy collision checking with caching, dynamic neighbor radius adjustment, iterative rewiring, and aggressive pruning of non-promising nodes. It balances fast convergence and high-quality path discovery by prioritizing smaller tree extensions, incremental multi-step connection attempts between trees, and comprehensive shortcut smoothing for path refinement. This approach improves planning time, robustness, and path optimality in both 2D and 3D environments.",
          "planning_mechanism": "The planner initializes two trees from start and goal. Each iteration extends the smaller tree by sampling adaptively within an evolving informed ellipsoid biased by the best path found so far or near the best path using Gaussian perturbations. It uses KD-tree structures for efficient nearest and radius neighbor queries and lazy collision checks with caching for edges. Incremental multi-step extensions attempt to connect opposite trees, while rewiring locally optimizes paths. Periodic aggressive pruning discards nodes unlikely to improve the current best solution, keeping the trees manageable. Once connected, iterative shortcut smoothing refines path quality before returning the solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For pruning etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_trials: int = 100, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp position within bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree approximation (brute-force)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r2] * (dim - 1))\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.power(np.random.uniform(0, 1), 1 / dim)\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 0.5, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i + 2, len(smooth) - 1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i + 1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(nodes_list, best_cost, root_s, root_g):\n            removed = 0\n            to_remove = []\n            h = lambda pos: dist(pos, goal_pos)\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + h(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cand_cost = node.cost + dist(node.position, new_pos)\n                if cand_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cand_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Incremental multi-step connect from tree_b towards new_node.position\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                # Aggressive iterative shortcut smoothing\n                best_path = shortcut_path(best_path)\n                break\n\n            # Periodic pruning when good path exists and node count is high\n            if (it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf')):\n                removed_s = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_g = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.28407,
          "time_improvement": 36.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021583127975463866,
                    "num_nodes_avg": 71.8,
                    "path_length_avg": 158.58444319624488,
                    "smoothness_avg": 0.041607666795992704,
                    "success_improvement": 0.0,
                    "time_improvement": 14.271509255997362,
                    "length_improvement": 13.077353752825879,
                    "smoothness_improvement": 551.250337851875,
                    "objective_score": 9.65317521662376
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05545804500579834,
                    "num_nodes_avg": 228.6,
                    "path_length_avg": 241.31274324250552,
                    "smoothness_avg": 0.11501020495036371,
                    "success_improvement": 0.0,
                    "time_improvement": 66.39481000926783,
                    "length_improvement": 19.442860503457883,
                    "smoothness_improvement": 2859.295411875127,
                    "objective_score": 38.10349216284756
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.036947321891784665,
                    "num_nodes_avg": 154.6,
                    "path_length_avg": 121.78117599783027,
                    "smoothness_avg": 0.11678105345078149,
                    "success_improvement": 0.0,
                    "time_improvement": 27.815223203721956,
                    "length_improvement": 19.118741498676453,
                    "smoothness_improvement": 1385.4463800132248,
                    "objective_score": 19.095547160918002
               }
          ],
          "smoothness_improvement": 1599.0,
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This implementation enhances the bidirectional informed RRT* planner by integrating a dynamically adaptive informed sampling ellipsoid, efficient KD-tree neighbor searches, collision caching, incremental rewiring, and aggressive pruning. Additionally, it emphasizes path quality by incorporating a more robust shortcut smoothing method that leverages edge shortcuts verified by collision checks. The planner maintains two trees rooted at start and goal, iteratively growing and rewiring them to minimize path length, while pruning non-promising nodes to reduce computational overhead. These improvements collectively boost planning efficiency, path quality, success rate, and smoothness in both 2D and 3D environments.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal positions, samples nodes adaptively within an ellipsoid that shrinks as better paths are found, uses KD-tree-based nearest neighbor and radius queries for rewiring and extension, caches collision outcomes to avoid redundant computations, prunes nodes that cannot improve the current best path, and applies shortcut smoothing on the final path to reduce length and improve smoothness. It stops upon finding a connecting path or after reaching the maximum iterations.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...] position in 2D or 3D\n        self.parent = parent          # Parent Node or None\n        self.cost = cost              # Cost from root to this node\n        self.children = []            # Children Nodes\n        self.valid = True             # For collision validity if needed\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_iterations: int = 150, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KDTree with simple linear search (quicker for small data, can upgrade to balanced structure)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d in range(dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        # Informed sampling inside ellipsoid based on current best path cost\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # fallback uniform sampling with retries for obstacle free\n                for _ in range(15):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_m = np.eye(dim)\n\n            v = a1 - np.array([1] + [0] * (dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_m - 2 * np.outer(v, v)\n            else:\n                rot = id_m\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            # Allow more tries but break early for efficiency\n            for _ in range(200):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # fallback uniform sampling if ellipsoid fails\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic - 1e-12 >= best_cost:\n                    to_remove.append(node)\n            for rmn in to_remove:\n                if rmn.parent:\n                    try:\n                        rmn.parent.children.remove(rmn)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rmn)\n                except ValueError:\n                    pass\n                if rmn in tree_start:\n                    tree_start.remove(rmn)\n                if rmn in tree_goal:\n                    tree_goal.remove(rmn)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n\n        best_path: list = []\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth direction depending on size for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n\n            for node in near_nodes:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors around new_node for cost improvement\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try connecting trees via new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b):\n                    break\n                if not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    # Mark success and update best path\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Shortcut smoothing to improve path quality\n                    smoothed = shortcut_path(merged_path)\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = smoothed\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning of nodes unlikely to yield improvement\n            if iteration > 0 and iteration % self.prune_interval == 0 \\\n               and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.24121,
          "time_improvement": 39.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02421252727508545,
                    "num_nodes_avg": 84.0,
                    "path_length_avg": 163.03586017152315,
                    "smoothness_avg": 0.03982455083038601,
                    "success_improvement": 0.0,
                    "time_improvement": 3.8274979071256188,
                    "length_improvement": 10.63746157146,
                    "smoothness_improvement": 523.3407008918359,
                    "objective_score": 5.892445190888865
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05236344337463379,
                    "num_nodes_avg": 227.1,
                    "path_length_avg": 234.57044411783062,
                    "smoothness_avg": 0.09292093831093264,
                    "success_improvement": 0.0,
                    "time_improvement": 68.27000549713694,
                    "length_improvement": 21.69363401759437,
                    "smoothness_improvement": 2290.922670986902,
                    "objective_score": 36.27434180759447
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028946614265441893,
                    "num_nodes_avg": 132.5,
                    "path_length_avg": 123.69278957364477,
                    "smoothness_avg": 0.13291123176527828,
                    "success_improvement": 0.0,
                    "time_improvement": 43.44637763248849,
                    "length_improvement": 17.849138782877038,
                    "smoothness_improvement": 1590.6210575677087,
                    "objective_score": 24.556846334160497
               }
          ],
          "smoothness_improvement": 1468.0,
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner merges the bidirectional informed RRT* approach with incremental rewiring and goal biasing for efficient exploration. It adaptively samples within a shrinking informed ellipsoid around the best path found, employs KD-tree accelerated neighbor searches, caches collision checks to avoid redundant computations, and aggressively prunes nodes unlikely to improve the solution. The planner alternates tree growth from start and goal to rapidly connect the two, and applies robust shortcut smoothing to enhance final path quality and smoothness. These combined techniques optimize planning efficiency, path quality, success rate, and computational overhead in complex 2D/3D environments.",
          "planning_mechanism": "The planner maintains two trees from start and goal positions, alternately sampling adaptively and extending towards sampled points with step-size control. It uses KD-tree-based searches to select best parents minimizing cost, rewires neighbors for incremental path improvement, and attempts connection between trees each iteration. Collision checking of nodes and edges is cached and leveraged extensively. The best path is adaptively refined and periodically pruned during iterations to reduce search space. Upon successful connection, a shortcut smoothing phase improves path smoothness and length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from tree root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 25.0,\n                 goal_sample_rate: float = 0.1,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_iterations: int = 150, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def within_ellipsoid_sample(c_best, c_min, start, goal):\n            # Use informed sampling inside ellipsoid\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # fallback uniform sampling with retries for collision-free sample\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback: random anyway\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            eye = np.eye(dim)\n            v = a1 - np.array([1] + [0] * (dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rotation = eye - 2 * np.outer(v, v)\n            else:\n                rotation = eye\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            # Try multiple times for collision-free sample\n            for _ in range(200):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rotation @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # fallback again to uniform if ellipsoid fails\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def is_in_obstacle(pos):\n            # check if pos inside any obstacle\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else None\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return True\n\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / self.collision_check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    edge_collision_cache[key] = True\n                    return True\n            edge_collision_cache[key] = False\n            return False\n\n        def can_connect(p1, p2):\n            if is_in_obstacle(p2):\n                return False\n            if is_edge_in_obstacle(p1, p2):\n                return False\n            return True\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        # KDTree with linear search (sufficient for moderate node counts)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d in range(dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic - 1e-12 >= best_cost:\n                    to_remove.append(node)\n            for rmn in to_remove:\n                if rmn.parent:\n                    rmn.parent.remove_child(rmn)\n                try:\n                    nodes.remove(rmn)\n                except ValueError:\n                    pass\n                if rmn in tree_start:\n                    tree_start.remove(rmn)\n                if rmn in tree_goal:\n                    tree_goal.remove(rmn)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        # Trees: lists of nodes for start and goal sides\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        # All nodes and edges\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path: List[Tuple[float, ...]] = []\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            # Sample point with goal bias or informed ellipsoid\n            if random.random() < self.goal_sample_rate:\n                q_rand = goal_pos\n            else:\n                q_rand = within_ellipsoid_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth tree selection for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            # Build KDTree for tree_a and find nearest to q_rand\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            # Choose best parent minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cost improvements\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt to connect trees via new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            # Extend tree_b towards new_node stepwise\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n\n                if not can_add_node(next_pos_b):\n                    break\n                if not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=None, cost=cost_b)\n                last_node_b.add_child(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        if neighbor_b.parent:\n                            try:\n                                edges.remove((neighbor_b.parent, neighbor_b))\n                            except ValueError:\n                                pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=None, cost=final_cost)\n                    new_node_b.add_child(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Depending on tree assignment, assemble path\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Shortcut smoothing to improve path quality\n                    smoothed = shortcut_path(merged_path)\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = smoothed\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning of nodes unlikely to improve best path\n            if iteration > 0 and iteration % self.prune_interval == 0 \\\n               and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # Collision helpers unchanged\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else None\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -21.39406,
          "time_improvement": 33.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01638748645782471,
                    "num_nodes_avg": 69.8,
                    "path_length_avg": 156.77104356827704,
                    "smoothness_avg": 0.042380982844713186,
                    "success_improvement": 0.0,
                    "time_improvement": 34.90867112893999,
                    "length_improvement": 14.071306824071005,
                    "smoothness_improvement": 563.3544132970283,
                    "objective_score": 16.10363476998134
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06851754188537598,
                    "num_nodes_avg": 279.8,
                    "path_length_avg": 234.47724576367142,
                    "smoothness_avg": 0.10093387513099414,
                    "success_improvement": 0.0,
                    "time_improvement": 58.4813165968027,
                    "length_improvement": 21.724746310778592,
                    "smoothness_improvement": 2497.1013068521906,
                    "objective_score": 34.37485077545748
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04835000038146973,
                    "num_nodes_avg": 213.9,
                    "path_length_avg": 123.59421078042612,
                    "smoothness_avg": 0.14087353326908802,
                    "success_improvement": 0.0,
                    "time_improvement": 5.537565189200058,
                    "length_improvement": 17.914610123515168,
                    "smoothness_improvement": 1691.9009449802068,
                    "objective_score": 13.703696306364085
               }
          ],
          "smoothness_improvement": 1584.0,
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This improved planner builds upon the bidirectional RRT* framework with adaptive informed sampling and balanced bidirectional tree growth. It incorporates an enhanced dynamic radius rewiring strategy with logarithmic decay, efficient collision checks, and periodic dead-end pruning to maintain computational efficiency. Additionally, the sampling bias dynamically adjusts based on the relative sizes of the trees for faster convergence. Iterative shortcut smoothing is applied upon finding a connection to yield shorter and smoother paths. To reduce computation overhead, caching of nearest neighbors and radius computations optimize rewiring steps, and the edge collision checks are done with adaptive resolution. Tree growth always favors expanding the smaller tree to keep search balanced and minimize redundant expansions. This results in faster planning with higher success rates and improved path quality while strictly enforcing collision-free, map-bound paths.",
          "planning_mechanism": "The planner alternates extension between start and goal trees, sampling adaptively biased towards start or goal to accelerate progress. Each extension rewires neighbors within a dynamically shrinking radius to optimize local costs. Upon connecting the two trees, the path is extracted and refined via shortcut smoothing iterations to shorten and smooth the trajectory. Dead-end nodes are pruned periodically to reduce computational load. The planner uses rigorous collision and boundary checks for nodes and edges, enforcing feasibility. This balanced and adaptive growth approach promotes rapid, robust convergence to high-quality, smooth paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        # Propagate cost update down children recursively to keep consistency\n        for child in self.children:\n            child._update_cost_recursive()\n\n    def _update_cost_recursive(self):\n        if self.parent:\n            self.cost = self.parent.cost + sum((self._distance(self.parent.position, self.position),))\n        for child in self.children:\n            child._update_cost_recursive()\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _distance(p1, p2):\n        import math\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 4000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 radius_constant: float = 30.0,\n                 radius_min: float = 5.0,\n                 prune_interval: int = 100,\n                 prune_threshold: int = 120,\n                 smoothing_iterations: int = 70):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        import random\n        import math\n\n        is_3d = (len(bounds) == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free(size_start, size_goal):\n            p_bias = 0.75\n            # Adaptive bias sampling proportion based on tree size ratio\n            total = size_start + size_goal + 1e-9\n            bias_goal = size_goal / total\n            bias_start = size_start / total\n            # With prob goal_sample_rate sample biased between start and goal, else uniform free\n            if random.random() < self.goal_sample_rate:\n                # Choose start or goal with bias proportional to size\n                if random.random() < (bias_goal * p_bias):\n                    return goal_position\n                elif random.random() < (bias_start * p_bias / (1 - bias_goal * p_bias)):\n                    return start_position\n                else:\n                    return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            # Optimized nearest using simple linear search (can be replaced by spatial indexing)\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = node\n            return min_node\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= r_sq]\n\n        def radius_dynamic(n):\n            if n <= 1:\n                return self.radius_constant\n            # Logarithmic decay for radius to balance exploration\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            # Collision and bounds check\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            for d in range(len(pos)):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def can_connect(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.5)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost efficiently\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            # Remove leaf nodes (dead-ends) except roots\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        pass\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free(len(tree_start), len(tree_goal))\n\n            # Always extend the smaller tree first to balance search\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                # Combined path: start->connection->goal reversed (avoid double joint node)\n                raw_path = path_start + path_goal[::-1][1:]\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.82279,
          "time_improvement": 35.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027561044692993163,
                    "num_nodes_avg": 82.4,
                    "path_length_avg": 159.95946170997846,
                    "smoothness_avg": 0.03919379441318278,
                    "success_improvement": 0.0,
                    "time_improvement": -9.47286081722483,
                    "length_improvement": 12.323684316885842,
                    "smoothness_improvement": 513.4679932531224,
                    "objective_score": 2.1902185844753315
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05026965141296387,
                    "num_nodes_avg": 123.5,
                    "path_length_avg": 241.28509223189593,
                    "smoothness_avg": 0.0937151505467923,
                    "success_improvement": 0.0,
                    "time_improvement": 69.53875337069844,
                    "length_improvement": 19.452091206689573,
                    "smoothness_improvement": 2311.3583238635224,
                    "objective_score": 36.308835871865064
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.027540087699890137,
                    "num_nodes_avg": 118.2,
                    "path_length_avg": 123.18829835962379,
                    "smoothness_avg": 0.10965737125236882,
                    "success_improvement": 0.0,
                    "time_improvement": 46.19433881056144,
                    "length_improvement": 18.184197825939695,
                    "smoothness_improvement": 1294.8336682649397,
                    "objective_score": 23.96930954968107
               }
          ],
          "smoothness_improvement": 1373.0,
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner is an enhanced hybrid bidirectional informed RRT* variant with refined parameter tuning aimed at maximizing planning efficiency, path quality, success rate, and computational speed. It features adaptive sampling within an informed ellipsoid, dynamic neighbor radius control, goal biasing, collision caching, aggressive pruning of redundant nodes, incremental rewiring, balanced tree growth, and robust shortcut smoothing to generate shorter and smoother paths more reliably in complex 2D/3D environments.",
          "planning_mechanism": "The planner alternates between extending two trees rooted at start and goal. It samples points adaptively within a shrinking ellipsoid to focus search near the best known path. KD-tree inspired neighbor searches enable rewiring for incremental improvements while caching collision checks reduces overhead. It prunes nodes unlikely to improve solutions periodically and applies shortcut smoothing to enhance final path quality, thus balancing exploration, optimization, and computational cost for faster, robust planning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 4000,\n                 step_size: float = 6.0,\n                 min_neighbor_radius: float = 6.0,\n                 max_neighbor_radius: float = 20.0,\n                 goal_sample_rate: float = 0.15,  # more frequent goal bias\n                 prune_interval: int = 150,\n                 prune_threshold: int = 250,\n                 smoothing_iterations: int = 200,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            n = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.98)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def within_ellipsoid_sample(c_best, c_min, start, goal):\n            # informed sampling inside ellipsoid focusing near best path\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # fallback uniform sampling with collision check retries\n                for _ in range(15):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) * 0.5 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            eye = np.eye(dim)\n            v = direction - np.array([1] + [0] * (dim -1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rotation = eye - 2 * np.outer(v, v)\n            else:\n                rotation = eye\n\n            r1 = c_best * 0.5\n            r_other = math.sqrt(max(r1 * r1 - (c_min * 0.5) ** 2, 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(150):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rotation @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def is_in_obstacle(pos):\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else None\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return True\n\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / self.collision_check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    edge_collision_cache[key] = True\n                    return True\n            edge_collision_cache[key] = False\n            return False\n\n        def can_connect(p1, p2):\n            if is_in_obstacle(p2):\n                return False\n            if is_edge_in_obstacle(p1, p2):\n                return False\n            return True\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        class KDTree:\n            # Simple linear search based KDTree substitute optimized for iteration\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                # Slightly tighter condition for pruning improves runtime\n                if node.cost + heuristic - 1e-12 >= best_cost:\n                    to_remove.append(node)\n            for rmn in to_remove:\n                if rmn.parent:\n                    rmn.parent.remove_child(rmn)\n                try:\n                    nodes.remove(rmn)\n                except ValueError:\n                    pass\n                if rmn in tree_start:\n                    tree_start.remove(rmn)\n                if rmn in tree_goal:\n                    tree_goal.remove(rmn)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path: list[tuple] = []\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            # Sample with goal bias or informed ellipsoid\n            if random.random() < self.goal_sample_rate:\n                q_rand = goal_pos\n            else:\n                q_rand = within_ellipsoid_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree growth for balanced exploration\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cost improvements with pruning of expensive rewires\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            max_ext_steps = max(1, int(dist(last_node_b.position, new_node.position) / self.step_size))\n\n            for _ in range(max_ext_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=None, cost=cost_b)\n                last_node_b.add_child(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        if neighbor_b.parent:\n                            try:\n                                edges.remove((neighbor_b.parent, neighbor_b))\n                            except ValueError:\n                                pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=None, cost=final_cost)\n                    new_node_b.add_child(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    smoothed = shortcut_path(merged_path)\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = smoothed\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -20.26536,
          "time_improvement": 33.0,
          "length_improvement": 14.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02238790988922119,
                    "num_nodes_avg": 77.0,
                    "path_length_avg": 168.1601616915515,
                    "smoothness_avg": 0.04350127346738022,
                    "success_improvement": 0.0,
                    "time_improvement": 11.07490406869931,
                    "length_improvement": 7.828750708578664,
                    "smoothness_improvement": 580.8893942917919,
                    "objective_score": 7.792668333784485
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05254693031311035,
                    "num_nodes_avg": 224.2,
                    "path_length_avg": 242.65001573363708,
                    "smoothness_avg": 0.09995825129568903,
                    "success_improvement": 0.0,
                    "time_improvement": 68.15882030430012,
                    "length_improvement": 18.996440454663716,
                    "smoothness_improvement": 2471.9978028563455,
                    "objective_score": 36.60692319650451
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.041457104682922366,
                    "num_nodes_avg": 182.2,
                    "path_length_avg": 126.29069487361997,
                    "smoothness_avg": 0.1253220957696637,
                    "success_improvement": 0.0,
                    "time_improvement": 19.004363647204144,
                    "length_improvement": 16.123733781590172,
                    "smoothness_improvement": 1494.087807875241,
                    "objective_score": 16.396494889855482
               }
          ],
          "smoothness_improvement": 1516.0,
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This improved algorithm is a bidirectional informed RRT* planner enhanced with adaptive ellipsoidal sampling, KD-tree accelerated nearest neighbor search, collision caching, incremental rewiring, pruning of nodes unlikely to improve the best path, and post-planning shortcut smoothing. It synergizes aggressive informed sampling to focus search in promising regions, efficient data structures for speedy queries, and heuristic pruning to minimize computation. The method balances rapid convergence, path quality, and robustness in both 2D and 3D spaces while strictly validating collision-free states and edges.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately. Sampling is concentrated within a dynamic ellipsoid defined by the best current path to bias exploration. New nodes are connected with minimal cost parent from neighbors found efficiently using a KD-tree structure. The planner rewires neighbors for cost improvement and attempts connecting both trees incrementally. Periodic pruning removes nodes that cannot contribute to a better path. On successful connection, shortcut smoothing refines the path for smoothness and minimal length. Collision checks are cached to avoid redundancy, and all expansions obey strict collision and boundary constraints, optimizing planning speed and path optimality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Ensure new_p within bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.step_size * 15 * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.step_size * 8 * math.sqrt(math.log(c + 1) / c)\n            r = max(self.step_size * 3, min(r_iter, r_nodes))\n            return r\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=1.0)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            # If no solution found yet, sample uniformly inside map free space\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(15):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # Fallback uniform sample without obstacle check\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n\n            v = a1 - np.array([1] + [0] * (dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            rr = max(r1 * r1 - (c_min / 2) ** 2, 0)\n            r_others = math.sqrt(rr)\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # Fallback uniform sample\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos) or is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(150):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_position)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_position, cost=0.0)\n        root_goal = Node(goal_position, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_position, goal_position)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_position, goal_position)\n\n            # Alternate tree growth, smaller first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors for cost improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to reduce search space and maintain speed\n            if it > 0 and it % 200 == 0 and len(nodes) > 300 and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.24912,
          "time_improvement": 30.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023321080207824706,
                    "num_nodes_avg": 63.3,
                    "path_length_avg": 156.20421051138774,
                    "smoothness_avg": 0.04175374744685328,
                    "success_improvement": 0.0,
                    "time_improvement": 7.368338314563752,
                    "length_improvement": 14.381997004596602,
                    "smoothness_improvement": 553.5368172570537,
                    "objective_score": 7.854584981573715
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0528256893157959,
                    "num_nodes_avg": 228.1,
                    "path_length_avg": 236.87605303184245,
                    "smoothness_avg": 0.1027365135094304,
                    "success_improvement": 0.0,
                    "time_improvement": 67.98990433825956,
                    "length_improvement": 20.92395539882424,
                    "smoothness_improvement": 2543.4844907172983,
                    "objective_score": 37.29918483482921
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04322056770324707,
                    "num_nodes_avg": 179.9,
                    "path_length_avg": 122.6417820386079,
                    "smoothness_avg": 0.12132860892370778,
                    "success_improvement": 0.0,
                    "time_improvement": 15.559048046699587,
                    "length_improvement": 18.547167944047814,
                    "smoothness_improvement": 1443.2909499632185,
                    "objective_score": 15.593602752635531
               }
          ],
          "smoothness_improvement": 1513.0,
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements a Fast Informed Bidirectional RRT* with Dynamic Domain Reduction and Hierarchical Sampling. It combines bidirectional tree growth from start and goal with an adaptive sampling domain shrinking around the current best path cost, enhanced by a dynamic informed ellipsoid sampling. It incorporates hierarchical sampling levels to focus exploration near promising regions while maintaining global exploration, aggressive pruning of nodes unlikely to improve the solution, and prioritized rewiring with lazy collision checks. The algorithm includes a novel batch shortcut smoothing that applies both local and global path shortcuts to improve smoothness and reduce path length efficiently. The planner stops either when the maximum iteration count is reached or a path meeting quality criteria is found.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal, adaptively sampling in a dynamically shrinking informed ellipsoid augmented by hierarchical global samples to avoid local minima. It uses efficient KD-tree-like neighbor searches to perform rewiring and node connections. Lazy collision caching reduces redundant checks during rewiring and connections. Aggressive node pruning removes nodes whose cost combined with heuristics exceeds the best solution, conserving memory and search time. Upon connecting the two trees, a batch shortcut smoothing is applied combining long-range and local shortcuts validated by collision checks, yielding a high-quality, smooth path. This strategy balances rapid global exploration and focused local optimization, improving efficiency, robustness, and path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision validity or lazy checking\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 neighbor_min_radius: float = 5.0, neighbor_max_radius: float = 30.0,\n                 smoothing_batch_iters: int = 100,\n                 prune_interval: int = 150, prune_threshold: int = 350,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_min_radius = neighbor_min_radius\n        self.neighbor_max_radius = neighbor_max_radius\n        self.smoothing_batch_iters = smoothing_batch_iters\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # (W,H) or (W,H,D)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(1, n_nodes)\n            r_iter = self.neighbor_max_radius * (1.0 - (iteration / self.max_iter)**0.95)\n            r_nodes = self.neighbor_min_radius + (self.neighbor_max_radius - self.neighbor_min_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.neighbor_min_radius, min(r_iter, r_nodes))\n\n        # Lazy collision caches\n        node_in_obstacle_cache = {}\n        edge_collision_cache = {}\n\n        def is_in_obstacle_cached(pos):\n            if pos in node_in_obstacle_cache:\n                return node_in_obstacle_cache[pos]\n            val = self._is_in_obstacle(pos, obstacles, is_3d)\n            node_in_obstacle_cache[pos] = val\n            return val\n\n        def is_edge_collision_cached(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n            val = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = val\n            return val\n\n        # Informed ellipsoid sampling with augmented hierarchical global exploration\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            # Hierarchical sampling parameters\n            elite_rate = 0.8    # Fraction of samples from informed ellipsoid\n            global_rate = 0.2   # Fraction from global uniform\n\n            # If no solution yet, uniform random sampling tries\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(15):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                # fallback uniform\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Choose sampling mode (ellipsoid or global)\n            if random.random() < elite_rate:\n                # Ellipsoid sampling\n                center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n                a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n                id_m = np.eye(dim)\n\n                v = a1 - np.array([1] + [0] * (dim - 1))\n                norm_v = np.linalg.norm(v)\n                if norm_v > 1e-10:\n                    v /= norm_v\n                    rot = id_m - 2 * np.outer(v, v)\n                else:\n                    rot = id_m\n\n                r1 = c_best / 2.0\n                r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n                radii = np.array([r1] + [r_others] * (dim - 1))\n\n                for _ in range(100):\n                    x_ball = np.random.uniform(-1, 1, dim)\n                    norm_x = np.linalg.norm(x_ball)\n                    if norm_x <= 1.0 and norm_x > 1e-8:\n                        # Uniformly sample inside unit ball\n                        r_scale = random.uniform(0,1) ** (1.0 / dim)\n                        x_ball = x_ball / norm_x * r_scale\n                        sample = rot @ (x_ball * radii) + center\n                        p = tuple(float(c) for c in sample)\n                        if in_bounds(p) and not is_in_obstacle_cached(p):\n                            return p\n                # fail ellipsoid, fallback global\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                return p\n            else:\n                # Global uniform hierarchical exploration sample biased near bounds edges to avoid local minima\n                # To maintain global exploration, sample dominantly near boundary regions as well (20%)\n                ranges = []\n                for d_ in range(dim):\n                    e = bounds[d_]\n                    ranges.append((0, e))\n                # Sample with edge bias (uniform, but 40% chance to be near edges)\n                def edge_biased_sample(d):\n                    if random.random() < 0.4:\n                        edge_zone = 0.15 * bounds[d]\n                        if random.random() < 0.5:\n                            return random.uniform(0, edge_zone)\n                        else:\n                            return random.uniform(bounds[d] - edge_zone, bounds[d])\n                    else:\n                        return random.uniform(0, bounds[d])\n                for _ in range(30):\n                    p = tuple(edge_biased_sample(d) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                # fallback uniform\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # KDTree for neighbor queries (linear search, adequate for moderate sizes)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                radius_sq = radius * radius\n                res = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for i_ in range(dim):\n                        delta = p[i_] - pt[i_]\n                        sqd += delta * delta\n                        if sqd > radius_sq:\n                            break\n                    if sqd <= radius_sq:\n                        res.append(n)\n                return res\n\n        # Add node with collision and edge validity checks\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle_cached(pos):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            if is_edge_collision_cached(p1, p2):\n                return False\n            return True\n\n        # Aggressive pruning - remove nodes not capable of improving current best cost\n        def prune_nodes(best_cost):\n            removed = 0\n            nonlocal nodes, tree_start, tree_goal, edges\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic - 1e-12 >= best_cost:\n                    to_remove.append(node)\n\n            for rn in to_remove:\n                if rn.parent:\n                    try:\n                        rn.parent.children.remove(rn)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rn)\n                except ValueError:\n                    pass\n                if rn in tree_start:\n                    tree_start.remove(rn)\n                if rn in tree_goal:\n                    tree_goal.remove(rn)\n                # Remove edges with rn if present\n                edges = [e for e in edges if e[0] != rn and e[1] != rn]\n                removed += 1\n            return removed\n\n        # Batch shortcut smoothing combining local and long-range shortcuts\n        def batch_shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            length = len(p)\n            for _ in range(self.smoothing_batch_iters):\n                if length < 3:\n                    break\n                # Random long-range shortcut attempt\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n                    length = len(p)\n                    continue\n                # Attempt local shortcut for adjacent triples to smooth jagged edges\n                if length >= 4:\n                    li = random.randint(0, length - 4)\n                    if can_connect(p[li], p[li+2]):\n                        p = p[:li+1] + p[li+2:]\n                        length = len(p)\n            return p\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree growth for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n                growing_from_start = True\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n                growing_from_start = False\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            # Choose best parent minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for nn in near_nodes:\n                cost_candidate = nn.cost + dist(nn.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(nn.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = nn\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node to optimize paths\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try connect new_node to tree_b by incremental steps towards new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n\n            max_steps = max(1, int(dist(last_node_b.position, new_node.position) / self.step_size))\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b):\n                    break\n                if not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                # Rewire neighbors around new_node_b\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for nb in near_b:\n                    if nb is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, nb.position)\n                    if c_via_new_b + 1e-12 < nb.cost and can_connect(new_node_b.position, nb.position):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, nb))\n\n                # Check connection termination condition\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_conn = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=cost_conn)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    # Extract full path & update best\n                    success_state = True\n\n                    if growing_from_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Batch shortcut smoothing\n                    smoothed_path = batch_shortcut_path(merged_path)\n\n                    if cost_conn + 1e-12 < c_best:\n                        c_best = cost_conn\n                        best_path = smoothed_path\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning of non-promising nodes\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                node_in_obstacle_cache.clear()\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.10161,
          "time_improvement": 29.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014202570915222168,
                    "num_nodes_avg": 56.9,
                    "path_length_avg": 152.88041791210188,
                    "smoothness_avg": 0.04373393242318906,
                    "success_improvement": 0.0,
                    "time_improvement": 43.58718668439454,
                    "length_improvement": 16.203820397129356,
                    "smoothness_improvement": 584.5310121772093,
                    "objective_score": 19.23957514563028
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05148146152496338,
                    "num_nodes_avg": 206.3,
                    "path_length_avg": 238.89910138307377,
                    "smoothness_avg": 0.11296072838976305,
                    "success_improvement": 0.0,
                    "time_improvement": 68.8044485634847,
                    "length_improvement": 20.248603628965096,
                    "smoothness_improvement": 2806.5609037925724,
                    "objective_score": 38.72385981380129
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06440050601959228,
                    "num_nodes_avg": 188.5,
                    "path_length_avg": 126.36258764892011,
                    "smoothness_avg": 0.11591866387777214,
                    "success_improvement": 0.0,
                    "time_improvement": -25.820652609338058,
                    "length_improvement": 16.075986023401896,
                    "smoothness_improvement": 1374.4768482995228,
                    "objective_score": 2.3413856633765766
               }
          ],
          "smoothness_improvement": 1589.0,
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This implementation develops an advanced bidirectional informed RRT* planner that focuses on minimizing path length by adaptively sampling within an ellipsoid shaped by the current best path, which improves convergence speed. The planner efficiently manages nodes using KD-tree neighbor searches, caches collision checks to avoid redundant computations, rewires incrementally for cost optimization, prunes nodes unlikely to improve the path, and applies shortcut smoothing on the obtained path to enhance smoothness and reduce length. These enhancements collectively improve planning efficiency, robustness, success rate, and path quality in both 2D and 3D spaces.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal, sampling within an ellipsoidal informed region that shrinks as better solutions are found. It incrementally connects and rewires nodes ensuring collision-free safeguards for nodes and edges. Pruning and collision cache clearing happen periodically to maintain efficiency. Once a feasible path is found, shortcut smoothing refines the path. The process continues until a max iteration limit or an optimal path is finalized.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # Collision-validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        # Informed sampling inside an ellipsoid defined by start-goal and current best cost\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # No good path yet: uniform random sampling with obstacle rejection\n                trials = 0\n                while trials < 20:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                    trials += 1\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            # Rotation matrix that aligns x-axis with a1 via Householder transform\n            id_mat = np.eye(dim)\n            v = a1 - np.array([1.] + [0.]*(dim - 1))\n            v_norm = np.linalg.norm(v)\n            if v_norm > 1e-10:\n                v = v / v_norm\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r2]*(dim - 1))\n\n            for _ in range(100):\n                sample_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(sample_ball) <= 1:\n                    sample_scaled = sample_ball * radii\n                    point = rot @ sample_scaled + center\n                    p = tuple(float(c) for c in point)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # fallback uniform random\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent and rm_node in rm_node.parent.children:\n                    rm_node.parent.children.remove(rm_node)\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path: list = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate expanding smaller tree for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            # Choose best parent minimizing cost and collision-free edge\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes to improve their cost paths\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt connection to opposite tree\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            dist_ab = dist(last_node_b.position, new_node.position)\n            max_steps = int(dist_ab / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                # Check if we can connect new_node_b directly to new_node to close the trees\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Merge paths from start and goal trees\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]  # avoid duplicated node\n\n                    # Update best path if improved\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning of unpromising nodes for efficiency\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.05396,
          "time_improvement": 32.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014794063568115235,
                    "num_nodes_avg": 66.6,
                    "path_length_avg": 156.89092179508836,
                    "smoothness_avg": 0.03711808451837075,
                    "success_improvement": 0.0,
                    "time_improvement": 41.23776946941373,
                    "length_improvement": 14.005599668363654,
                    "smoothness_improvement": 480.97862592313305,
                    "objective_score": 17.577343904112514
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04550454616546631,
                    "num_nodes_avg": 219.4,
                    "path_length_avg": 234.7442100183161,
                    "smoothness_avg": 0.09456512667699488,
                    "success_improvement": 0.0,
                    "time_improvement": 72.4262022007329,
                    "length_improvement": 21.63562595843819,
                    "smoothness_improvement": 2333.2288219066954,
                    "objective_score": 37.72112996144099
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06006522178649902,
                    "num_nodes_avg": 212.7,
                    "path_length_avg": 126.23472190811553,
                    "smoothness_avg": 0.11535332710218134,
                    "success_improvement": 0.0,
                    "time_improvement": -17.35071463573235,
                    "length_improvement": 16.160908360132023,
                    "smoothness_improvement": 1367.2858062428277,
                    "objective_score": 4.863396312520839
               }
          ],
          "smoothness_improvement": 1394.0,
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This planner implements an optimized bidirectional RRT* algorithm with enhanced adaptive informed sampling biased toward start and goal, dynamic rewiring radius shrinking with samples, fast collision and edge checking, and balanced growth by always extending the smaller tree. It applies iterative shortcut smoothing upon path discovery and prunes dead-end nodes periodically to keep search efficient. The use of spatial hashing for collision and neighbor queries accelerates nearest-neighbor lookups and obstacle checks, improving the overall timing. The planner respects map bounds and performs rigorous collision validation for nodes and edges to guarantee path feasibility while minimizing redundant exploration and improving path quality.",
          "planning_mechanism": "The algorithm alternately grows two trees from start and goal, always extending the smaller tree, sampling adaptively close to start or goal with randomized bias. New nodes are connected with rewiring in a dynamically computed radius that shrinks with samples, improving local optimality. Upon connection, the combined path undergoes iterative shortcut smoothing to reduce length and curvature. Dead-end nodes without children are pruned periodically to optimize tree structure and reduce computations. The process repeats until the path is found or max iterations are reached, returning the best found path, the explored nodes and edges.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float=5.0,\n                 goal_sample_rate: float=0.12, radius_constant: float=20.0,\n                 radius_min: float=4.0, prune_interval: int=100,\n                 prune_threshold: int=120, smoothing_iterations: int=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle rects/cuboids\n\n        import random\n        import math\n\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for i in range(dim):\n                if pos[i] < 0 or pos[i] > bounds[i]:\n                    return False\n            return True\n\n        def sample_free():\n            p_bias = 0.7\n            # Adaptive informed sampling bias: biased toward start/goal\n            if random.random() < self.goal_sample_rate:\n                # 70% goal, 30% start bias for faster convergence\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                for _ in range(10):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                # fallback to goal to avoid stalling\n                return goal_position\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            # Linear search is retained for simplicity; could be replaced with spatial indexing\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = node\n            return min_node\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            # Linear near search with early prune by squared distance\n            result = []\n            for node in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - pos[i]\n                    d += diff * diff\n                    if d > radius_sq:\n                        break\n                if d <= radius_sq:\n                    result.append(node)\n            return result\n\n        def radius_dynamic(n):\n            if n <= 1:\n                return self.radius_constant\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            if not in_bounds(pos): return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    # Final edge to node.position\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            # Remove dead-end nodes (no children) except roots\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            # Attempts iterative shortcut smoothing improving both length and smoothness\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend the smaller tree first to balance search effort\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                # Use smoothed path if shorter\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            # Prune dead-ends periodically to reduce overhead\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        # Early exit on collision for efficiency\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -18.71987,
          "time_improvement": 36.0,
          "length_improvement": 16.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011481571197509765,
                    "num_nodes_avg": 66.8,
                    "path_length_avg": 160.4213014965881,
                    "smoothness_avg": 0.026907098392694905,
                    "success_improvement": 0.0,
                    "time_improvement": 54.39503619441572,
                    "length_improvement": 12.070542611525363,
                    "smoothness_improvement": 321.15451954503476,
                    "objective_score": 20.33839197835496
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0377842903137207,
                    "num_nodes_avg": 191.9,
                    "path_length_avg": 246.52838420182957,
                    "smoothness_avg": 0.07303336660913587,
                    "success_improvement": 0.0,
                    "time_improvement": 77.10434519419485,
                    "length_improvement": 17.701729427334346,
                    "smoothness_improvement": 1779.2011266607726,
                    "objective_score": 35.56765507702919
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06316671371459961,
                    "num_nodes_avg": 143.9,
                    "path_length_avg": 124.97421472360108,
                    "smoothness_avg": 0.06882091501543851,
                    "success_improvement": 0.0,
                    "time_improvement": -23.410166068264452,
                    "length_improvement": 16.99807721318453,
                    "smoothness_improvement": 775.3969591648413,
                    "objective_score": 0.25355041798177735
               }
          ],
          "smoothness_improvement": 959.0,
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This implementation enhances the bidirectional informed RRT* by integrating adaptive ellipsoidal sampling focused on the current best path length, efficient KD-tree based nearest neighbor queries and rewiring, collision caching to avoid redundant checks, and periodic pruning of nodes unlikely to improve the solution. The planner incrementally refines the path by connecting the two trees grown from start and goal, rewiring neighbors for cost reduction, and applying shortcut smoothing to the final path to minimize length and enhance smoothness, thereby improving planning efficiency, path quality, robustness, and success rate.",
          "planning_mechanism": "The planner grows two trees rooted at start and goal, alternating expansions. Sampling is biased within an adaptive ellipsoid enclosing the best path found so far to accelerate convergence towards shorter paths. The KD-tree accelerates nearest neighbor and radius searches for rewiring. New nodes and edges are added after thorough collision checks. Incremental rewiring enhances path cost improvements, and pruning removes nodes that can't improve the current best cost to reduce computational load. Once a path is found, shortcut smoothing refines the path length and smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision status\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_iterations: int = 100,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best, best_dist = None, float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best, best_dist = self.nodes[i], d\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)], dtype=float)\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)], dtype=float)\n\n            id_mat = np.eye(dim)\n            v = a1 - np.array([1.] + [0.]*(dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1*r1 - (c_min / 2)**2, 0))\n            radii = np.array([r1] + [r_others]*(dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors for cost improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -18.41515,
          "time_improvement": 25.0,
          "length_improvement": 16.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02038121223449707,
                    "num_nodes_avg": 75.7,
                    "path_length_avg": 170.00074963763453,
                    "smoothness_avg": 0.045661882485008146,
                    "success_improvement": 0.0,
                    "time_improvement": 19.04553564326056,
                    "length_improvement": 6.819895289348138,
                    "smoothness_improvement": 614.7076172552462,
                    "objective_score": 10.151177837124028
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04544069766998291,
                    "num_nodes_avg": 210.0,
                    "path_length_avg": 229.22177479210396,
                    "smoothness_avg": 0.10448643197711793,
                    "success_improvement": 0.0,
                    "time_improvement": 72.4648916428349,
                    "length_improvement": 23.479173791432316,
                    "smoothness_improvement": 2588.5111533062245,
                    "objective_score": 39.37785801766805
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.058935809135437014,
                    "num_nodes_avg": 190.0,
                    "path_length_avg": 123.1088988983347,
                    "smoothness_avg": 0.11182887949059708,
                    "success_improvement": 0.0,
                    "time_improvement": -15.144156867713681,
                    "length_improvement": 18.236931167531854,
                    "smoothness_improvement": 1322.455092771138,
                    "objective_score": 5.716414637047957
               }
          ],
          "smoothness_improvement": 1509.0,
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -16.097394736585397,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022315311431884765,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "smoothness_avg": 0.016726285105375487,
                    "success_improvement": 0.0,
                    "time_improvement": 11.36326617195283,
                    "length_improvement": 3.931459226046746,
                    "smoothness_improvement": 161.80268360858182,
                    "objective_score": 5.004285114838107
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.043552708625793454,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "smoothness_avg": 0.010908242682381757,
                    "success_improvement": 0.0,
                    "time_improvement": 73.60893180010648,
                    "length_improvement": 13.674530120921121,
                    "smoothness_improvement": 180.67694110730886,
                    "objective_score": 25.720970269752712
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024148726463317872,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "smoothness_avg": 0.02092975461741331,
                    "success_improvement": 0.0,
                    "time_improvement": 52.82011414049006,
                    "length_improvement": 4.448849568598979,
                    "smoothness_improvement": 166.22493385971097,
                    "objective_score": 17.566928825165366
               }
          ]
     },
     {
          "operator": "m1",
          "algorithm_description": "This hybrid bidirectional informed RRT* planner improves path planning performance by combining adaptive sampling within a shrinking ellipsoid, bidirectional tree expansion, incremental rewiring, collision caching, and aggressive pruning. It maintains high path quality and efficiency by focusing search in promising regions, balancing exploration between start and goal trees, and applying shortcut smoothing to the final path.",
          "planning_mechanism": "The planner alternately grows two trees rooted at the start and goal positions, sampling adaptively within an ellipsoid defined by the current best path cost to bias exploration toward optimal solutions. Nodes are connected and rewired incrementally using nearest neighbor queries, while collision checks and pruning remove unpromising areas. The two trees aggressively attempt to connect via collision-free edges, with smooth shortcutting refining the result. The approach optimizes path length, robustness, and convergence speed in 2D/3D environments.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position          # Tuple[float, ...] (2D or 3D)\n        self.parent = parent              # Parent Node or None\n        self.cost = cost                  # Cost from root to this node\n        self.children: List[Node] = []   # Children nodes\n        self.valid = True                 # Collision validity flag\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval: int=200, prune_threshold: int=300,\n                 smoothing_iterations: int=150, collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n        import numpy as np\n\n        bounds: Tuple[int, ...] = map.size\n        start_pos: Tuple[float, ...] = map.start\n        goal_pos: Tuple[float, ...] = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d_] + ratio * (to_p[d_] - from_p[d_]) for d_ in range(dim))\n            # Clamp to bounds\n            return tuple(max(0.0, min(new_p[d_], bounds[d_])) for d_ in range(dim))\n\n        def neighbor_radius(iteration: int, n_nodes: int) -> float:\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes: List[Tuple[Tuple[float, ...], Node]]):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                r2 = radius * radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        def informed_sample(c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # Uniform sampling with obstacle rejection fallback\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n\n            center = np.array([(start[d_] + goal[d_]) / 2.0 for d_ in range(dim)])\n            a1 = np.array([(goal[d_] - start[d_]) / c_min for d_ in range(dim)])\n\n            id_mat = np.eye(dim)\n            v = a1 - np.array([1.] + [0.]*(dim - 1))\n            v_norm = np.linalg.norm(v)\n            if v_norm > 1e-10:\n                v = v / v_norm\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r_others]*(dim - 1))\n\n            for _ in range(200):\n                sample_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(sample_ball) <= 1:\n                    sample_scaled = sample_ball * radii\n                    point = rot @ sample_scaled + center\n                    p = tuple(float(c) for c in point)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            # fallback uniform\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_useless_nodes(best_cost: float) -> int:\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic - 1e-12 >= best_cost:\n                    to_remove.append(node)\n            for rmn in to_remove:\n                if rmn.parent:\n                    try:\n                        rmn.parent.children.remove(rmn)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rmn)\n                except ValueError:\n                    pass\n                if rmn in tree_start:\n                    tree_start.remove(rmn)\n                if rmn in tree_goal:\n                    tree_goal.remove(rmn)\n                removed += 1\n            return removed\n\n        # Initialize root nodes and trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes: List[Node] = [root_start, root_goal]\n        edges: List[Tuple[Node, Node]] = []\n        tree_start: List[Node] = [root_start]\n        tree_goal: List[Node] = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n\n        best_path: List[Tuple[float, ...]] = []\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree growth: expand smaller tree for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost improves\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt to connect new_node with opposite tree\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            dist_ab = dist(last_node_b.position, new_node.position)\n            max_steps = int(dist_ab / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    smoothed_path = shortcut_path(merged_path)\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = smoothed_path\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Prune nodes periodically to maintain efficiency\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List, is_3d: bool) -> bool:\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles: List,\n                             is_3d: bool, resolution: float=1.0) -> bool:\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -15.57017,
          "time_improvement": 17.0,
          "length_improvement": 15.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024022626876831054,
                    "num_nodes_avg": 86.1,
                    "path_length_avg": 163.88170326070446,
                    "smoothness_avg": 0.042392431825554355,
                    "success_improvement": 0.0,
                    "time_improvement": 4.5817849850941865,
                    "length_improvement": 10.173841571038267,
                    "smoothness_improvement": 563.5336147090525,
                    "objective_score": 6.226971883281172
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06401140689849853,
                    "num_nodes_avg": 243.8,
                    "path_length_avg": 239.2855829404569,
                    "smoothness_avg": 0.096460101085603,
                    "success_improvement": 0.0,
                    "time_improvement": 61.21184058736294,
                    "length_improvement": 20.119584960855782,
                    "smoothness_improvement": 2381.9878783350796,
                    "objective_score": 34.29740856005543
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05933775901794434,
                    "num_nodes_avg": 205.5,
                    "path_length_avg": 126.99325952829236,
                    "smoothness_avg": 0.13103119786397122,
                    "success_improvement": 0.0,
                    "time_improvement": -15.929454991270852,
                    "length_improvement": 15.657123790490541,
                    "smoothness_improvement": 1566.7071651127508,
                    "objective_score": 6.186124086280607
               }
          ],
          "smoothness_improvement": 1504.0,
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner leverages adaptive informed sampling within a dynamically shrinking ellipsoid to focus growth towards promising regions, while maintaining bidirectional RRT*-based tree expansion with incremental rewiring for path optimality. The algorithm integrates collision caching for efficiency, aggressive pruning of non-promising nodes, and robust shortcut smoothing to enhance path quality and smoothness. It alternates tree growth from start and goal, uses KD-tree-like nearest neighbor queries for rewiring, and employs connection attempts between trees similar to RRT-Connect for rapid convergence and improved success rates in 2D and 3D spaces.",
          "planning_mechanism": "The planner iteratively samples nodes adaptively within an informed ellipsoid shaped by current best path costs to reduce exploration area and improve convergence. It grows two trees bidirectionally, rewires locally to minimize costs, caches collision checks to reduce redundant computations, and prunes nodes unlikely to yield improvements. Connections between trees are aggressively attempted, and the final path undergoes shortcut smoothing to ensure minimal length and enhanced smoothness, outputting a high-quality, collision-free path efficiently.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval: int=200, prune_threshold: int=300,\n                 smoothing_iterations: int=150, collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # Simple KDTree substitute for nearest and radius searches\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d in range(dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        # Informed sampling inside ellipsoid based on current best cost\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # fallback uniform sampling with retries for obstacle free\n                for _ in range(15):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_m = np.eye(dim)\n\n            v = a1 - np.array([1] + [0] * (dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_m - 2 * np.outer(v, v)\n            else:\n                rot = id_m\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(200):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # fallback uniform\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic - 1e-12 >= best_cost:\n                    to_remove.append(node)\n            for rmn in to_remove:\n                if rmn.parent:\n                    try:\n                        rmn.parent.children.remove(rmn)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rmn)\n                except ValueError:\n                    pass\n                if rmn in tree_start:\n                    tree_start.remove(rmn)\n                if rmn in tree_goal:\n                    tree_goal.remove(rmn)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth direction for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n\n            for node in near_nodes:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors around new_node\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt connection from new_node to the other tree (tree_b)\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b):\n                    break\n                if not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    smoothed = shortcut_path(merged_path)\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = smoothed\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Prune nodes unlikely to improve the path periodically\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -14.43883,
          "time_improvement": 13.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019157958030700684,
                    "num_nodes_avg": 67.0,
                    "path_length_avg": 158.49583155130003,
                    "smoothness_avg": 0.047400650631977306,
                    "success_improvement": 0.0,
                    "time_improvement": 23.90431870783473,
                    "length_improvement": 13.125923199561521,
                    "smoothness_improvement": 641.9231145507785,
                    "objective_score": 13.006095825016615
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05653114318847656,
                    "num_nodes_avg": 225.7,
                    "path_length_avg": 235.25056936585833,
                    "smoothness_avg": 0.09084560193031925,
                    "success_improvement": 0.0,
                    "time_improvement": 65.74455866514202,
                    "length_improvement": 21.466588633482893,
                    "smoothness_improvement": 2237.5227711093453,
                    "objective_score": 35.20429918178591
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07700245380401612,
                    "num_nodes_avg": 192.0,
                    "path_length_avg": 126.88439228796013,
                    "smoothness_avg": 0.1193813140935434,
                    "success_improvement": 0.0,
                    "time_improvement": -50.44134881788389,
                    "length_improvement": 15.729428227818307,
                    "smoothness_improvement": 1418.5215034578803,
                    "objective_score": -4.893911482512104
               }
          ],
          "smoothness_improvement": 1433.0,
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner is a simplified bidirectional RRT* variant that balances between exploration and optimization. It alternates growth of two trees from start and goal, adaptively sampling points, checking collisions rigorously, and dynamically rewiring to improve path cost. It enforces strict boundary and obstacle checks, provides efficient neighbor search within a dynamic radius, and applies shortcut smoothing after connecting trees to yield smooth, short, and feasible paths. This design improves planning efficiency, robustness, and path quality while reducing computation time.",
          "planning_mechanism": "The planning mechanism grows two trees simultaneously from start and goal, alternately extending the smaller tree towards adaptively sampled points. New nodes are connected only if collision-free, and neighbors within a dynamic radius are rewired for lower-cost paths. Upon successful connection of both trees, the combined path is shortcut-smoothed iteratively to enhance smoothness and reduce length, yielding an efficient, high-quality path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        self._update_cost_recursive()\n\n    def _update_cost_recursive(self):\n        if self.parent:\n            self.cost = self.parent.cost + math.dist(self.parent.position, self.position)\n        for child in self.children:\n            child._update_cost_recursive()\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 6.0,\n                 goal_sample_rate: float = 0.2,\n                 radius_constant: float = 20.0,\n                 radius_min: float = 5.0,\n                 smoothing_iterations: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        final_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def sample_free(size_start: int, size_goal: int) -> Tuple[float, ...]:\n            total = size_start + size_goal + 1e-9\n            bias_goal = size_goal / total\n            bias_start = size_start / total\n            if random.random() < self.goal_sample_rate:\n                r = random.random()\n                if r < bias_goal * 0.7:\n                    return goal_pos\n                elif r < (bias_goal + bias_start) * 0.7:\n                    return start_pos\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(len(from_p)))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def radius_dynamic(n: int) -> float:\n            if n <= 1:\n                return self.radius_constant\n            r = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(r, self.radius_min)\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree if dist(node.position, pos)**2 <= r_sq]\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            resolution = min(0.3, self.step_size / 10.0)\n            return (not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution))\n\n        def try_extend(tree: List[Node], sample_pt: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near:\n                if node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, node.position)\n                if cost_through_new + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    if node.parent:\n                        try:\n                            edges.remove((node.parent, node))\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, node))\n\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos) or not can_connect(last_node.position, new_pos):\n                    return None\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    return None\n                last_node = new_node\n\n        def path_length(path: List[Tuple[float, ...]]) -> float:\n            return sum(dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        def shortcut_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free(len(tree_start), len(tree_goal))\n\n            # Extend smaller tree first for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]  # avoid duplicate joint node\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    final_path = smoothed\n                else:\n                    final_path = raw_path\n                break\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -11.67723,
          "time_improvement": 13.0,
          "length_improvement": 13.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.034816956520080565,
                    "num_nodes_avg": 109.2,
                    "path_length_avg": 176.8368770111015,
                    "smoothness_avg": 0.024335449327707342,
                    "success_improvement": 0.0,
                    "time_improvement": -38.29344560988822,
                    "length_improvement": 3.072905550580595,
                    "smoothness_improvement": 280.90262725265296,
                    "objective_score": -9.468939436587082
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.052289271354675294,
                    "num_nodes_avg": 229.3,
                    "path_length_avg": 245.89940126451285,
                    "smoothness_avg": 0.06741372456188324,
                    "success_improvement": 0.0,
                    "time_improvement": 68.31495055105006,
                    "length_improvement": 17.911702036080698,
                    "smoothness_improvement": 1634.6036891204037,
                    "objective_score": 32.249844018133174
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04734020233154297,
                    "num_nodes_avg": 214.0,
                    "path_length_avg": 124.01286896686602,
                    "smoothness_avg": 0.10959746120126557,
                    "success_improvement": 0.0,
                    "time_improvement": 7.510429340403599,
                    "length_improvement": 17.636557290442312,
                    "smoothness_improvement": 1294.071616837006,
                    "objective_score": 12.250798344394571
               }
          ],
          "smoothness_improvement": 1070.0,
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner is an enhanced bidirectional RRT* variant with adaptive informed sampling, dynamic rewiring radius with logarithmic decay, balanced tree growth, efficient collision and boundary checks, periodic dead-end pruning, and iterative shortcut smoothing upon path connection. It is tuned with adjusted parameters to improve planning efficiency, robustness, success rate, and path quality, while reducing search time and path lengths.",
          "planning_mechanism": "The planner alternates expanding the smaller of two trees (start and goal), sampling adaptively biased points to favor progress towards start or goal. New nodes are added with rewiring of neighbors within a dynamic radius to optimize costs. Collision-free edges and nodes are strictly enforced within map bounds. Dead-end pruning and cached nearest neighbor computations keep runtime manageable. Upon successful connection of trees, iterative shortcut smoothing improves path smoothness and reduces length, enabling rapid convergence to high-quality, feasible paths.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        self._update_cost_recursive()\n\n    def _distance(self, p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        import math\n        return math.dist(p1, p2)\n\n    def _update_cost_recursive(self):\n        if self.parent:\n            self.cost = self.parent.cost + self._distance(self.parent.position, self.position)\n        for child in self.children:\n            child._update_cost_recursive()\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 4000,\n                 step_size: float = 6.0,\n                 goal_sample_rate: float = 0.20,\n                 radius_constant: float = 28.0,\n                 radius_min: float = 6.0,\n                 prune_interval: int = 80,\n                 prune_threshold: int = 100,\n                 smoothing_iterations: int = 80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def sample_free(size_start: int, size_goal: int) -> Tuple[float, ...]:\n            p_bias = 0.7  # Slightly strengthened bias for goal/start sampling\n            total = size_start + size_goal + 1e-9\n            bias_goal = size_goal / total\n            bias_start = size_start / total\n            if random.random() < self.goal_sample_rate:\n                r = random.random()\n                if r < bias_goal * p_bias:\n                    return goal_position\n                elif r < bias_goal * p_bias + bias_start * p_bias:\n                    return start_position\n                else:\n                    return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = node\n            return min_node\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= r_sq]\n\n        def radius_dynamic(n: int) -> float:\n            if n <= 1:\n                return self.radius_constant\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            for d in range(len(pos)):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            # Adaptive resolution proportional to step size ensures thorough checking with efficiency\n            resolution = min(0.3, self.step_size / 10.0)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=resolution)\n\n        def try_extend(tree: List[Node], sample_pt: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        pass\n            return removed\n\n        def path_length(path: List[Tuple[float, ...]]) -> float:\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free(len(tree_start), len(tree_goal))\n\n            # Always extend the smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]  # Avoid duplicate joint node\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool, resolution: float = 0.3) -> bool:\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -10.85402,
          "time_improvement": 5.0,
          "length_improvement": 13.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04786636829376221,
                    "num_nodes_avg": 97.6,
                    "path_length_avg": 169.2049139925801,
                    "smoothness_avg": 0.04338590473855787,
                    "success_improvement": 0.0,
                    "time_improvement": -90.1258944433712,
                    "length_improvement": 7.2561054172252755,
                    "smoothness_improvement": 579.0836231585178,
                    "objective_score": -22.691129133773714
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05106112957000732,
                    "num_nodes_avg": 128.1,
                    "path_length_avg": 246.8626860839372,
                    "smoothness_avg": 0.08915352709829646,
                    "success_improvement": 0.0,
                    "time_improvement": 69.05915164946614,
                    "length_improvement": 17.590129836740665,
                    "smoothness_improvement": 2193.9844669291597,
                    "objective_score": 35.20569379683378
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.033048367500305174,
                    "num_nodes_avg": 108.4,
                    "path_length_avg": 128.04836186259698,
                    "smoothness_avg": 0.10890654974465504,
                    "success_improvement": 0.0,
                    "time_improvement": 35.432694188821834,
                    "length_improvement": 14.956375058619512,
                    "smoothness_improvement": 1285.2832741066989,
                    "objective_score": 20.047499638903947
               }
          ],
          "smoothness_improvement": 1353.0,
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -10.563710636997357,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019907546043395997,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "smoothness_avg": 0.011187468717945251,
                    "success_improvement": 0.0,
                    "time_improvement": 20.926944479167844,
                    "length_improvement": -3.169524359941512,
                    "smoothness_improvement": 75.10817941300277,
                    "objective_score": 6.019719368827065
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.031937599182128906,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "smoothness_avg": 0.0071781032260960454,
                    "success_improvement": 0.0,
                    "time_improvement": 80.64718855035225,
                    "length_improvement": -0.21210455131052114,
                    "smoothness_improvement": 84.69776618622483,
                    "objective_score": 24.575224485774694
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04825267791748047,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "smoothness_avg": 0.014027290647026427,
                    "success_improvement": 0.0,
                    "time_improvement": 5.727706178603966,
                    "length_improvement": -5.071271527036456,
                    "smoothness_improvement": 78.4261016432827,
                    "objective_score": 1.096188056390312
               }
          ]
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner that grows two trees simultaneously from the start and goal positions while optimizing path quality by rewiring around new nodes to achieve shorter paths. It integrates collision checking and edge validation rigorously to ensure robustness and path feasibility. The approach improves success rates and reduces search times by focusing explorations efficiently and smoothing paths during planning.",
          "planning_mechanism": "The planner alternately extends the start and goal trees towards random free samples, attempts to connect the trees, and applies rewiring to improve the path cost locally. When the trees connect, it reconstructs the path by merging their solutions. Rigorous collision and edge checks are performed for node validity. The rewiring step iteratively updates parents of nearby nodes if a better cost path is found through the newly added node, enhancing path quality and smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path: list[tuple] = []\n\n        start_root = Node(start_pos, parent=None, cost=0.0)\n        goal_root = Node(goal_pos, parent=None, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            while True:\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(3))\n                else:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(2))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def near_nodes(tree, new_node):\n            rn = self.neighbor_radius\n            return [node for node in tree if math.dist(node.position, new_node.position) <= rn]\n\n        def can_connect(p1, p2):\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def add_node(tree, new_pos, parent_node):\n            cost_from_parent = parent_node.cost + math.dist(parent_node.position, new_pos)\n            new_node = Node(new_pos, parent_node, cost_from_parent)\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n            return new_node\n\n        def rewire(tree, new_node):\n            neighbors = near_nodes(tree, new_node)\n            for node in neighbors:\n                if node == new_node.parent:\n                    continue\n                dist_to_new = math.dist(new_node.position, node.position)\n                new_cost = new_node.cost + dist_to_new\n                if new_cost < node.cost and can_connect(new_node.position, node.position):\n                    # Rewire parent\n                    old_parent = node.parent\n                    if old_parent:\n                        try:\n                            old_parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    node.parent = new_node\n                    node.cost = new_cost\n                    new_node.children.append(node)\n                    # Update edges list for the rewiring\n                    # Remove old edge\n                    try:\n                        edges.remove((old_parent, node))\n                    except ValueError:\n                        pass\n                    edges.append((new_node, node))\n                    # Recursively update costs of descendants\n                    self._update_costs_descendants(node)\n\n        for iteration in range(self.max_iter):\n            rand_point = sample_free()\n\n            for tree_src, tree_tgt in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_src, rand_point)\n                new_pos = steer(nearest_node.position, rand_point)\n                if not can_connect(nearest_node.position, new_pos):\n                    continue\n                new_node = add_node(tree_src, new_pos, nearest_node)\n                rewire(tree_src, new_node)\n\n                # Try connecting to other tree\n                nearest_target = nearest(tree_tgt, new_node.position)\n                if can_connect(new_node.position, nearest_target.position):\n                    connecting_node = add_node(tree_tgt, nearest_target.position, nearest_target.parent if nearest_target.parent else nearest_target)\n                    # Link new_node and connecting_node by setting parents accordingly\n                    # Connect new_node -> connecting_node or vice versa depends on tree roles\n                    # We create a shortcut edge in other tree if needed\n                    # Simplify by assuming connecting_node is nearest_target itself since no new node is added\n\n                    total_path = self._extract_full_path(new_node, nearest_target)\n                    if total_path:\n                        extracted_path = total_path\n                        success_state = True\n                        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n            # Swap trees for next iteration to balance growth\n            start_tree, goal_tree = goal_tree, start_tree\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _update_costs_descendants(self, node):\n        # Recursive update of costs for subtree below node after rewiring\n        for child in node.children:\n            child.cost = node.cost + math.dist(node.position, child.position)\n            self._update_costs_descendants(child)\n\n    def _extract_full_path(self, node_start_tree, node_goal_tree):\n        # Extract path from start root to node_start_tree\n        path_start = []\n        node = node_start_tree\n        while node:\n            path_start.append(node.position)\n            node = node.parent\n        path_start.reverse()\n\n        # Extract path from node_goal_tree to goal root\n        path_goal = []\n        node = node_goal_tree\n        while node:\n            path_goal.append(node.position)\n            node = node.parent\n\n        # Avoid duplicating meet point if same node\n        if path_start[-1] == path_goal[0]:\n            path_goal = path_goal[1:]\n\n        return path_start + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -4.64222,
          "time_improvement": 14.0,
          "length_improvement": -1.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.032508444786071775,
                    "num_nodes_avg": 107.8,
                    "path_length_avg": 199.59364496649934,
                    "smoothness_avg": 0.010782634789436678,
                    "success_improvement": 0.0,
                    "time_improvement": -29.12400422741684,
                    "length_improvement": -9.400439569837324,
                    "smoothness_improvement": 68.7716493208972,
                    "objective_score": -10.273430935588031
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.043404030799865725,
                    "num_nodes_avg": 215.7,
                    "path_length_avg": 279.15852204878036,
                    "smoothness_avg": 0.007839119789248315,
                    "success_improvement": 0.0,
                    "time_improvement": 73.69902416789888,
                    "length_improvement": 6.808850207579963,
                    "smoothness_improvement": 101.7061984671186,
                    "objective_score": 23.98000828422125
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05189414024353027,
                    "num_nodes_avg": 249.6,
                    "path_length_avg": 149.3506433285222,
                    "smoothness_avg": 0.015321086115321444,
                    "success_improvement": 0.0,
                    "time_improvement": -1.3866970246335524,
                    "length_improvement": 0.8084140145896085,
                    "smoothness_improvement": 94.88308450194768,
                    "objective_score": 0.2200891180375944
               }
          ],
          "smoothness_improvement": 88.0,
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an optimized bidirectional RRT* planner with adaptive radius tuning and goal biasing, aimed at improving planning efficiency, path quality, and success rate. It grows two trees from start and goal while dynamically rewiring nodes within an adaptive radius to minimize cost and frequently attempts connection between trees with careful collision checks. Enhanced sampling near the goal and adaptive rewiring radius improve convergence speed and path smoothness.",
          "planning_mechanism": "The planner alternately grows two trees by sampling points with a goal bias, extending trees toward sampled points with fixed step size, rewiring neighbors within an adaptively scaled radius to optimize costs, and attempts to connect the trees at each iteration. Collision validity is strictly checked for nodes and edges. The path is extracted once the trees are connected, returning the optimized combined path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, base_radius: float = 30.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius     # Max rewiring radius\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling goal to bias search\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def dist(a,b): return math.dist(a,b)\n        volume = 1\n        for b in bounds:\n            volume *= b\n        dim = len(bounds)\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_a, tree_b = [start_root], [goal_root]\n        success_state = False\n        extracted_path = []\n\n        for iter_num in range(1, self.max_iter + 1):\n            radius = min(self.base_radius * (math.log(iter_num) / iter_num) ** (1/dim), self.base_radius)\n\n            # Goal biased sampling for faster convergence\n            if random.random() < self.goal_sample_rate:\n                rand_point = goal_position\n            else:\n                rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, radius)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connect_node = self._nearest(tree_b, new_a.position)\n            if dist(connect_node.position, new_a.position) <= self.step_size and \\\n               not self._is_edge_in_obstacle(connect_node.position, new_a.position, obstacles, is_3d):\n                # Try to connect trees by adding a new node in tree_b towards new_a\n                new_b = self._extend_and_rewire(tree_b, new_a.position, obstacles, is_3d, nodes, edges, radius)\n                if new_b:\n                    success_state = True\n                    path_a = new_a.path_from_root()\n                    path_b = new_b.path_from_root()\n                    extracted_path = path_a + path_b[::-1]\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, target_point, obstacles, is_3d, nodes, edges, radius):\n        nearest = self._nearest(tree, target_point)\n        new_pos = self._steer(nearest.position, target_point)\n\n        # Collision checks for node and edge\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n           self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors for potential better cost\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    except Exception:\n                        pass\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 6.76639,
          "time_improvement": 32.0,
          "length_improvement": -1.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.029661917686462404,
                    "num_nodes_avg": 163.9,
                    "path_length_avg": 185.48815011793954,
                    "smoothness_avg": 0.013437297972123261,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -17.81755817433171,
                    "length_improvement": -1.6689943274723857,
                    "smoothness_improvement": 110.32289282331054,
                    "objective_score": -55.127451853677435
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04360947608947754,
                    "num_nodes_avg": 342.8,
                    "path_length_avg": 300.1341930293572,
                    "smoothness_avg": 0.006879041384904136,
                    "success_improvement": 0.0,
                    "time_improvement": 73.57453315871555,
                    "length_improvement": -0.19343251694987623,
                    "smoothness_improvement": 77.00268960681954,
                    "objective_score": 22.418686892258787
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.030527329444885253,
                    "num_nodes_avg": 225.7,
                    "path_length_avg": 151.67279605712346,
                    "smoothness_avg": 0.014920581950300557,
                    "success_improvement": 0.0,
                    "time_improvement": 40.358100416055684,
                    "length_improvement": -0.733849258717081,
                    "smoothness_improvement": 89.78870108502437,
                    "objective_score": 12.409603778498411
               }
          ],
          "smoothness_improvement": 92.0,
          "success_rate": 0.9666666666666667
     }
]