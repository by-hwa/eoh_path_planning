[
     {
          "operator": "m1",
          "algorithm_description": "This planner is a refined hybrid bidirectional RRT* algorithm combining informed ellipsoidal sampling and adaptive neighbor radius with efficient KD-tree based nearest neighbor searches, incremental rewiring, collision caching, and periodic pruning. It emphasizes focused sampling within an ellipsoid shaped by the current best path, aggressively prunes suboptimal branches, and applies shortcut smoothing to quickly converge on short, smooth, and collision-free paths in both 2D and 3D environments.",
          "planning_mechanism": "The planner grows two balanced trees rooted at start and goal, alternately sampling points informed by the best found cost to constrain search space. Using KD-trees for accelerated neighbor queries, it rewires nodes for path cost improvement and caches collision checks to reduce redundant computations. The two trees are incrementally connected, and upon successful linking, aggressive shortcut smoothing refines the solution. Periodic pruning removes nodes that cannot yield better paths, enhancing efficiency, robustness, and path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = 5.0\n        self.max_neighbor_radius = 30.0\n        self.prune_interval = 200\n        self.prune_threshold = 300\n        self.smoothing_iterations = 150\n        self.collision_check_resolution = 1.0\n        self.goal_sample_rate = 0.15\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) * (c_min / 2), 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    radius_factor = np.random.uniform(0, 1) ** (1 / dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n            return len(to_remove)\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.17326,
          "time_improvement": 43.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017141342163085938,
                    "num_nodes_avg": 69.5,
                    "path_length_avg": 155.4151103601911,
                    "smoothness_avg": 0.047493421714181125,
                    "success_improvement": 0.0,
                    "time_improvement": 31.91434556481092,
                    "length_improvement": 14.814515301559547,
                    "smoothness_improvement": 643.3751834428977,
                    "objective_score": 15.754082646969671
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04740707874298096,
                    "num_nodes_avg": 222.9,
                    "path_length_avg": 244.34756808487708,
                    "smoothness_avg": 0.11688450983179502,
                    "success_improvement": 0.0,
                    "time_improvement": 71.27334928779209,
                    "length_improvement": 18.429748618484563,
                    "smoothness_improvement": 2907.5226264815924,
                    "objective_score": 39.6055676424425
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.037335777282714845,
                    "num_nodes_avg": 157.2,
                    "path_length_avg": 123.68673778420703,
                    "smoothness_avg": 0.14107973598461787,
                    "success_improvement": 0.0,
                    "time_improvement": 27.05628955836238,
                    "length_improvement": 17.853158093266345,
                    "smoothness_improvement": 1694.523828301445,
                    "objective_score": 20.160137627669208
               }
          ],
          "smoothness_improvement": 1748.0,
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This improved planner implements a hybrid bidirectional informed RRT* with enhanced adaptive ellipsoidal sampling, incorporates efficient KD-tree based nearest neighbor queries optimized via caching, and collision check memoization for nodes and edges. It aggressively prunes non-promising nodes based on heuristic cost bounds, uses incremental rewiring to improve path quality, and applies multiple shortcut smoothing iterations to yield smooth, shorter paths. The ellipsoidal sampling region shrinks dynamically as better paths are found, focusing the search and improving efficiency. The planner alternates tree growth between start and goal, ensures strict boundary and obstacle validation for nodes and edges, speeding up planning and increasing success rate and robustness in both 2D and 3D environments.",
          "planning_mechanism": "The planner alternates expansion between two trees starting from start and goal positions. It samples points within a progressively shrinking informed ellipsoid shaped by the current best path cost, improving sampling efficiency. KD-tree structures support fast nearest neighbor and radius queries needed for rewiring. Collision checks for nodes and edges are cached to avoid redundant computations. Non-promising nodes are pruned regularly. Upon connecting the trees, multiple shortcut smoothing attempts refine the path. The process iterates up to max iterations or until a satisfactory path is found, balancing exploration and exploitation to improve planning time, path quality, and robustness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]: 2D or 3D coords\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # Validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n        # Parameters for neighbor radius calculation\n        self.min_neighbor_radius = 5.0\n        self.max_neighbor_radius = 30.0\n\n        # Pruning parameters\n        self.prune_interval = 150\n        self.prune_threshold = 250\n\n        self.smoothing_iterations = 150\n        self.collision_check_resolution = 1.0\n        self.goal_sample_rate = 0.15\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int,...]\n        start_pos = map.start              # Tuple[float,...]\n        goal_pos = map.goal                # Tuple[float,...]\n        obstacles = map.obstacles          # List obstacles (boxes)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                # Construct a simple kd-tree for nearest neighbor and radius search with caching\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                # Linear search sufficient due to limited node count per iteration and for caching simplicity\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    squared_dist = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        squared_dist += delta * delta\n                        if squared_dist > r2:\n                            break\n                    if squared_dist <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Informed sampling within adaptive ellipsoid centered at midpoint of start and goal\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                # Uniform random sampling with retry to avoid obstacles\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # Fallback naive uniform sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if i == 0 else 0 for i in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) ** 2, 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    radius_factor = np.random.uniform(0, 1) ** (1 / dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    sample = rot @ (x_scaled * radii) + np.array(center)\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # Fallback uniform sample if ellipsoid sampling fails\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            coll = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = coll\n            return not coll\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                # Heuristic-based pruning: prune if cost + heuristic >= best found cost\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        # Precompute heuristic distances to goal for pruning efficiency\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth of trees biased to smaller tree for balanced expansion\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            # Choose best parent for new node among neighbors\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper and collision free\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try to connect the opposite tree incrementally\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                # Rewire neighbors in tree_b\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    # Merge path from both trees\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Smooth path with multiple shortcut calls\n                    smoothed_path = shortcut_path(merged_path)\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = smoothed_path\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Prune nodes periodically to improve efficiency\n            if iteration > 0 and iteration % self.prune_interval == 0 \\\n               and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.95329,
          "time_improvement": 48.0,
          "length_improvement": 16.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015650105476379395,
                    "num_nodes_avg": 67.5,
                    "path_length_avg": 162.98104746529913,
                    "smoothness_avg": 0.04185606495416218,
                    "success_improvement": 0.0,
                    "time_improvement": 37.83755885617312,
                    "length_improvement": 10.6675052843043,
                    "smoothness_improvement": 555.1383084324613,
                    "objective_score": 16.260460255875103
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.051227784156799315,
                    "num_nodes_avg": 219.8,
                    "path_length_avg": 239.2812421323719,
                    "smoothness_avg": 0.10209905014732215,
                    "success_improvement": 0.0,
                    "time_improvement": 68.95816613778094,
                    "length_improvement": 20.12103404753779,
                    "smoothness_improvement": 2527.0820992639524,
                    "objective_score": 37.3470671471616
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03288521766662598,
                    "num_nodes_avg": 157.8,
                    "path_length_avg": 123.92216613288151,
                    "smoothness_avg": 0.11772938731234146,
                    "success_improvement": 0.0,
                    "time_improvement": 35.75144352505184,
                    "length_improvement": 17.696797793970003,
                    "smoothness_improvement": 1397.5091167335431,
                    "objective_score": 21.252338199977267
               }
          ],
          "smoothness_improvement": 1493.0,
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm introduces a Hybrid Adaptive Bidirectional RRT* with Sampling Bias and Localized Lazy Collision Checking to improve planning efficiency, path quality, robustness, and smoothness. It dynamically adjusts the sampling domain using heuristic-guided informed sampling biased towards promising regions, interleaves tree growth from start and goal, employs KD-tree for efficient neighbor queries, and performs lazy collision checks during rewiring to reduce expensive computations. Additionally, a post-processing shortcut smoothing using smart edge checking is applied to enhance path smoothness and shorten final path length.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately, samples points adaptively biased towards the current best path region, extends one tree toward sampled points, rewires neighbors using efficient KD-tree-based radius search with lazy collision checking, and attempts to connect the two trees. Upon connection, it extracts and shortcuts the combined path while validating collision-free edges. It leverages pruning of nodes not capable of improving current best path and maintains balanced tree growth for robustness and reduced search time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # For collision validity or lazy checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_radius: float = 5.0, max_radius: float = 30.0,\n                 shortcut_iter: int = 150, collision_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.shortcut_iter = shortcut_iter\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # clamp inside bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def radius(iteration, n_nodes):\n            if n_nodes == 0:\n                return self.max_radius\n            r_iter = self.max_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius)*math.sqrt(math.log(n_nodes + 1) / (n_nodes))\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        # Lazy collision cache for edges and nodes\n        node_collision_cache = {}\n        edge_collision_cache = {}\n\n        def is_in_obstacle_cached(pos):\n            if pos in node_collision_cache:\n                return node_collision_cache[pos]\n            val = self._is_in_obstacle(pos, obstacles, is_3d)\n            node_collision_cache[pos] = val\n            return val\n\n        def is_edge_colliding_cached(a, b):\n            key = (a, b)\n            key_rev = (b, a)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n            val = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n            edge_collision_cache[key] = val\n            return val\n\n        # KDTree for neighbor search (simple linear search)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius*radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d in range(dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        # Informed sampling biased towards best found path corridor with heuristic weights\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # Uniform sampling with retries for obstacle free\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_m = np.eye(dim)\n            v = a1 - np.array([1] + [0] * (dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_m - 2 * np.outer(v, v)\n            else:\n                rot = id_m\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r_others]*(dim-1))\n\n            for _ in range(150):\n                x_ball = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x <= 1.0 and norm_x > 1e-5:  # avoid zero vector\n                    x_ball = x_ball / norm_x * random.uniform(0,1) ** (1.0/dim)  # uniform in ball\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle_cached(p):\n                        return p\n\n            # fallback uniform sampling\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle_cached(p):\n                    return p\n            return p\n\n        # Shortcut smoothing on path using lazy collision checks\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(self.shortcut_iter):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if not is_edge_colliding_cached(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        root_start = Node(start_position, cost=0.0)\n        root_goal = Node(goal_position, cost=0.0)\n\n        nodes_start = [root_start]\n        nodes_goal = [root_goal]\n        nodes_all = [root_start, root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_position, goal_position)\n\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        # Balanced tree growth flag\n        grow_start_tree = True\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_position, goal_position)\n\n            # Select which tree to grow based on sizes for balance\n            if len(nodes_start) <= len(nodes_goal):\n                tree_a_nodes, tree_b_nodes = nodes_start, nodes_goal\n                root_a, root_b = root_start, root_goal\n                growing_from_start = True\n            else:\n                tree_a_nodes, tree_b_nodes = nodes_goal, nodes_start\n                root_a, root_b = root_goal, root_start\n                growing_from_start = False\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a_nodes])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if is_in_obstacle_cached(new_pos) or is_edge_colliding_cached(nearest_a.position, new_pos):\n                continue\n\n            r = radius(iteration, len(nodes_all))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n\n            # Lazy rewiring: first minimal cost parent selection (do edge check lazily)\n            for node in near_nodes:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost:\n                    # Check connectivity lazily now\n                    if not is_edge_colliding_cached(node.position, new_pos):\n                        min_cost = cost_candidate\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a_nodes.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cheaper cost paths if possible\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost:\n                    if not is_edge_colliding_cached(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, c_via_new)\n                        edges.append((new_node, neighbor))\n\n            # Attempt to connect new_node to other tree\n            kdtree_b = KDTree([(n.position, n) for n in tree_b_nodes])\n            nearest_b = kdtree_b.nearest(new_node.position)\n\n            if dist(new_node.position, nearest_b.position) <= self.step_size and \\\n               not is_edge_colliding_cached(new_node.position, nearest_b.position):\n                # Connect directly\n                cost_connection = new_node.cost + dist(new_node.position, nearest_b.position)\n                connect_node = Node(nearest_b.position, parent=new_node, cost=cost_connection)\n                new_node.children.append(connect_node)\n                tree_a_nodes.append(connect_node)\n                nodes_all.append(connect_node)\n                edges.append((new_node, connect_node))\n\n                # Extract full path\n                if growing_from_start:\n                    path_start = connect_node.path_from_root()\n                    path_goal = nearest_b.path_from_root()\n                else:\n                    path_start = nearest_b.path_from_root()\n                    path_goal = connect_node.path_from_root()\n\n                merged_path = path_start + path_goal[::-1][1:]  # avoid duplicate node\n\n                # Shortcut smoothing for improved path quality\n                smoothed_path = shortcut_path(merged_path)\n\n                c_candidate = connect_node.cost + (nearest_b.cost if growing_from_start else new_node.cost)\n                if c_candidate < c_best:\n                    c_best = c_candidate\n                    best_path = smoothed_path\n                    success_state = True\n\n                extracted_path = best_path\n                break\n\n            # Else do incremental connection attempt with limited steps from nearest_b toward new_node\n            dist_to_newnode = dist(nearest_b.position, new_node.position)\n            max_steps = max(1, int(dist_to_newnode / self.step_size))\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos = steer(last_node_b.position, new_node.position)\n                if is_in_obstacle_cached(next_pos) or is_edge_colliding_cached(last_node_b.position, next_pos):\n                    break\n                cost_next = last_node_b.cost + dist(last_node_b.position, next_pos)\n                new_node_b = Node(next_pos, parent=last_node_b, cost=cost_next)\n                last_node_b.children.append(new_node_b)\n                tree_b_nodes.append(new_node_b)\n                nodes_all.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                # Rewire neighbors in tree_b around new_node_b\n                near_b = kdtree_b.radius_search(next_pos, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost:\n                        if not is_edge_colliding_cached(new_node_b.position, neighbor_b.position):\n                            try:\n                                edges.remove((neighbor_b.parent, neighbor_b))\n                            except ValueError:\n                                pass\n                            neighbor_b.update_parent(new_node_b, c_via_new_b)\n                            edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and \\\n                   not is_edge_colliding_cached(new_node_b.position, new_node.position):\n                    # Connect finally\n                    cost_conn = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=cost_conn)\n                    new_node_b.children.append(connection_node)\n                    tree_b_nodes.append(connection_node)\n                    nodes_all.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    if growing_from_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    smoothed_path = shortcut_path(merged_path)\n\n                    if cost_conn < c_best:\n                        c_best = cost_conn\n                        best_path = smoothed_path\n                        success_state = True\n\n                    extracted_path = best_path\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if success_state:\n                break\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes_all,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.30002,
          "time_improvement": 43.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016922187805175782,
                    "num_nodes_avg": 73.5,
                    "path_length_avg": 154.23200362778806,
                    "smoothness_avg": 0.04002093790061885,
                    "success_improvement": 0.0,
                    "time_improvement": 32.784829785863906,
                    "length_improvement": 15.46299484911554,
                    "smoothness_improvement": 526.4145850023286,
                    "objective_score": 15.560120830593922
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.045720887184143064,
                    "num_nodes_avg": 212.9,
                    "path_length_avg": 237.2164084286152,
                    "smoothness_avg": 0.10522668171555331,
                    "success_improvement": 0.0,
                    "time_improvement": 72.29510884836787,
                    "length_improvement": 20.81033497079458,
                    "smoothness_improvement": 2607.558312256502,
                    "objective_score": 38.88839120995179
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03875234127044678,
                    "num_nodes_avg": 157.1,
                    "path_length_avg": 123.32472678199296,
                    "smoothness_avg": 0.1265137676603671,
                    "success_improvement": 0.0,
                    "time_improvement": 24.288718052866827,
                    "length_improvement": 18.093588563825442,
                    "smoothness_improvement": 1509.245786364919,
                    "objective_score": 18.45156206044973
               }
          ],
          "smoothness_improvement": 1548.0,
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner is an enhanced bidirectional informed RRT* variant combining adaptive ellipsoidal and Gaussian sampling for focused exploration near the current best path, KD-tree accelerated nearest and radius searches, lazy collision checking with caching, dynamic neighbor radius adaptation, incremental multi-step connection attempts, aggressive pruning of non-promising nodes, and iterative shortcut smoothing for efficient convergence to short, smooth, and robust paths in both 2D and 3D environments.",
          "planning_mechanism": "The planner grows two balanced trees from start and goal by sampling mostly near the best known path and adaptively within an informed ellipsoid defined by the current best solution. It extends the smaller tree each iteration, connecting new nodes with rewiring for local optimization. Incremental multi-step attempts connect opposite trees efficiently, while collision caching reduces redundant checks. Periodic aggressive pruning eliminates costly suboptimal nodes. Once connected, the best path undergoes iterative shortcut smoothing to improve quality. This combination enhances planning efficiency, path quality, success rate, and robustness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For pruning or collision checks\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_trials: int = 150, collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def informed_sample(c_best, c_min, start, goal):\n            # With goal bias\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2.0) ** 2, 0)\n            r_others = math.sqrt(val)\n            radii = np.array([r1] + [r_others] * (dim - 1))\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x_norm = x / norm_x\n                radius_sample = np.power(np.random.uniform(0, 1), 1 / dim)\n                sample = rot @ (x_norm * radius_sample * radii) + center\n                p_tuple = tuple(float(coord) for coord in sample)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def adaptive_sample(best_path, c_best, c_min):\n            # 75% near best path with gaussian noise, else informed ellipsoid sampling\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 0.5, dim)\n                    sample_pt = tuple(base[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_pt) and not is_in_obstacle(sample_pt):\n                        return sample_pt\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth_path = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth_path) < 3:\n                    break\n                i = random.randint(0, len(smooth_path) - 3)\n                j = random.randint(i + 2, len(smooth_path) - 1)\n                p1, p2 = smooth_path[i], smooth_path[j]\n                if can_connect(p1, p2):\n                    smooth_path = smooth_path[:i + 1] + smooth_path[j:]\n            return smooth_path\n\n        def prune_nodes(node_list, best_cost, root_s, root_g):\n            removed_count = 0\n            heuristic = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in node_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                # Disconnect from parent\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    node_list.remove(node)\n                except ValueError:\n                    pass\n                removed_count += 1\n            return removed_count\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cand_cost = node.cost + dist(node.position, new_pos)\n                if cand_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cand_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Incremental multi-step connect from tree_b toward new_node.position\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                # Aggressive iterative smoothing\n                best_path = shortcut_path(best_path)\n                break\n\n            # Periodic aggressive pruning\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.44177,
          "time_improvement": 41.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01934525966644287,
                    "num_nodes_avg": 69.5,
                    "path_length_avg": 157.26922340812618,
                    "smoothness_avg": 0.04823528206544871,
                    "success_improvement": 0.0,
                    "time_improvement": 23.16035395146047,
                    "length_improvement": 13.798246559684957,
                    "smoothness_improvement": 654.9869089157728,
                    "objective_score": 12.982690041953996
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04646854400634766,
                    "num_nodes_avg": 212.7,
                    "path_length_avg": 236.15684812686385,
                    "smoothness_avg": 0.10129187144661571,
                    "success_improvement": 0.0,
                    "time_improvement": 71.8420609712668,
                    "length_improvement": 21.16404669727148,
                    "smoothness_improvement": 2506.312809907457,
                    "objective_score": 38.31699168037162
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.036221981048583984,
                    "num_nodes_avg": 155.2,
                    "path_length_avg": 123.94116138336044,
                    "smoothness_avg": 0.11350843290569693,
                    "success_improvement": 0.0,
                    "time_improvement": 29.23233719701811,
                    "length_improvement": 17.68418205305853,
                    "smoothness_improvement": 1343.8188882394704,
                    "objective_score": 19.025632010914492
               }
          ],
          "smoothness_improvement": 1502.0,
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This improved hybrid bidirectional informed RRT* planner integrates adaptive ellipse-based informed sampling, dynamic neighbor radius tuning, incremental rewiring, collision caching, aggressive pruning of non-promising nodes, and path shortcut smoothing. It balances exploration between start and goal trees, focuses sampling within a shrinking ellipsoid based on current best path cost, and applies efficient collision checks to enhance planning success, path quality, and convergence speed.",
          "planning_mechanism": "The planner alternately grows two bidirectional trees rooted at start and goal positions. It samples new nodes adaptively inside an ellipsoid defined by the best path cost to bias search towards the optimal path corridor. Nodes are steered with a step size limit, rewired within a dynamic radius, and connection attempts between trees happen frequently. Collision detection and pruning maintain efficiency. Final paths are smoothed with shortcutting for improved path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag for collision checks\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval: int=200, prune_threshold: int=300,\n                 smoothing_iterations: int=150, collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d_] + ratio * (to_p[d_] - from_p[d_]) for d_ in range(dim))\n            # Clamp to bounds\n            return tuple(max(0.0, min(new_p[d_], bounds[d_])) for d_ in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # Uniform sampling with obstacle rejection fallback\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n\n            center = np.array([(start[d_] + goal[d_]) / 2.0 for d_ in range(dim)])\n            a1 = np.array([(goal[d_] - start[d_]) / c_min for d_ in range(dim)])\n\n            id_mat = np.eye(dim)\n            v = a1 - np.array([1.] + [0.]*(dim - 1))\n            v_norm = np.linalg.norm(v)\n            if v_norm > 1e-10:\n                v = v / v_norm\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r_others]*(dim - 1))\n\n            for _ in range(200):\n                sample_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(sample_ball) <= 1:\n                    sample_scaled = sample_ball * radii\n                    point = rot @ sample_scaled + center\n                    p = tuple(float(c) for c in point)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            # fallback uniform\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic - 1e-12 >= best_cost:\n                    to_remove.append(node)\n            for rmn in to_remove:\n                if rmn.parent:\n                    try:\n                        rmn.parent.children.remove(rmn)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rmn)\n                except ValueError:\n                    pass\n                if rmn in tree_start:\n                    tree_start.remove(rmn)\n                if rmn in tree_goal:\n                    tree_goal.remove(rmn)\n                removed += 1\n            return removed\n\n        # Initialize roots and trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate expanding smaller tree for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve cost\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Connect new_node with opposite tree\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            dist_ab = dist(last_node_b.position, new_node.position)\n            max_steps = int(dist_ab / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    smoothed_path = shortcut_path(merged_path)\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = smoothed_path\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Prune unpromising nodes every prune_interval iterations\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.89619,
          "time_improvement": 41.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022204136848449706,
                    "num_nodes_avg": 69.3,
                    "path_length_avg": 156.81445324861423,
                    "smoothness_avg": 0.04280664090635528,
                    "success_improvement": 0.0,
                    "time_improvement": 11.804853195752885,
                    "length_improvement": 14.047513290407787,
                    "smoothness_improvement": 570.0168862930024,
                    "objective_score": 9.201043048272435
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.045001649856567384,
                    "num_nodes_avg": 208.5,
                    "path_length_avg": 238.47823771866751,
                    "smoothness_avg": 0.0945938032058756,
                    "success_improvement": 0.0,
                    "time_improvement": 72.73093573406283,
                    "length_improvement": 20.38910003403281,
                    "smoothness_improvement": 2333.966689649665,
                    "objective_score": 37.56693417527373
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03177974224090576,
                    "num_nodes_avg": 139.3,
                    "path_length_avg": 122.72318122172783,
                    "smoothness_avg": 0.11554479808121051,
                    "success_improvement": 0.0,
                    "time_improvement": 37.91123462149739,
                    "length_improvement": 18.493106482432133,
                    "smoothness_improvement": 1369.7213029631612,
                    "objective_score": 21.92059819775145
               }
          ],
          "smoothness_improvement": 1425.0,
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This improved path planner implements a hybrid anytime informed bidirectional RRT* combined with adaptive lazy-collision bidirectional PRM* principles to optimize path length, smoothness, and planning efficiency. It uses an evolving informed ellipsoidal sampling region biased by the current best path cost and adaptive neighbor radius to balance exploration and exploitation. KD-tree accelerated neighbor queries enable efficient rewiring to reduce path costs. Lazy collision checking with caching avoids redundant costly computations, and incremental multi-step tree connections improve robustness. The planner aggressively prunes nodes that cannot lead to better solutions to maintain manageable search complexity. Finally, the extracted path is iteratively shortcut-smoothed to produce a shorter and smoother trajectory.",
          "planning_mechanism": "The planner initializes two trees from start and goal, extending the smaller tree each iteration by sampling inside an informed ellipsoid or near the current best path. New nodes connect to the best cost parents found within an adaptive neighbor radius, rewiring neighbors for cost improvement. Trees connect incrementally with multiple step attempts ensuring collision-free bridging. Periodic pruning discards suboptimal nodes to accelerate convergence. When a successful connection occurs, the path is extracted and shortcut-smoothed before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []              # For rewiring and pruning\n        self.valid = True               # Node validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_trials: int = 100, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p,n in points_nodes]\n                self.nodes = [n for p,n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x /= norm_x\n                x *= np.power(np.random.uniform(0,1), 1/dim)\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 0.5, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i + 2, len(smooth) - 1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i + 1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(tree_nodes, best_cost, root_s, root_g):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in tree_nodes:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    tree_nodes.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Choose smaller tree to extend\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position,n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            # Parent selection minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve costs\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Attempt incremental multi-step connection from tree_b to new_node\n            kdtree_b = KDTree([(n.position,n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n\n                # Rewire neighbors in tree_b\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                # Check if connection to new_node is possible\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic pruning to remove nodes unlikely to improve solution\n            if (it > 0 and it % self.prune_interval == 0 and\n                len(nodes) > self.prune_threshold and c_best < float('inf')):\n                removed_s = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_g = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.76458,
          "time_improvement": 42.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015248799324035644,
                    "num_nodes_avg": 62.8,
                    "path_length_avg": 155.5745732200483,
                    "smoothness_avg": 0.037244017428828366,
                    "success_improvement": 0.0,
                    "time_improvement": 39.43155259080802,
                    "length_improvement": 14.727111181221101,
                    "smoothness_improvement": 482.9497494394867,
                    "objective_score": 17.189636760684056
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.054264283180236815,
                    "num_nodes_avg": 230.7,
                    "path_length_avg": 234.42186128394013,
                    "smoothness_avg": 0.09326487689474042,
                    "success_improvement": 0.0,
                    "time_improvement": 67.11817833116747,
                    "length_improvement": 21.743235244266756,
                    "smoothness_improvement": 2299.7724584772245,
                    "objective_score": 35.982962840589714
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04189918041229248,
                    "num_nodes_avg": 161.3,
                    "path_length_avg": 126.64389596936796,
                    "smoothness_avg": 0.11008114413305412,
                    "success_improvement": 0.0,
                    "time_improvement": 18.14067079430676,
                    "length_improvement": 15.889154431423172,
                    "smoothness_improvement": 1300.2240280275962,
                    "objective_score": 15.121152264714643
               }
          ],
          "smoothness_improvement": 1361.0,
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This improved planner combines strengths from enhanced bidirectional RRT* and adaptive lazy-collision informed sampling techniques. It employs bidirectional tree growth with adaptive sampling biased towards the informed ellipsoid around the best path found so far. KD-tree-accelerated neighbor searches and caching of collision checks optimize computational cost. Dynamic neighbor radius shrinking, iterative rewiring, and aggressive pruning discard unpromising nodes to maintain efficiency. Continuous incremental connection attempts between the two trees improve the success rate and path quality. The planner applies iterative shortcut smoothing on the final path to ensure reduced path length and increased smoothness, while strictly enforcing bounds and collision constraints at every step.",
          "planning_mechanism": "The planner initializes two trees from start and goal and alternates extending the smaller one using samples drawn from an evolving informed ellipsoidal domain biased by the current best path cost. Each extension rewires neighbors within a dynamically adjusted radius leveraging KD-tree acceleration and lazy collision checks with caching. Incremental multi-step connection attempts facilitate bridging the trees. Periodic pruning maintains manageable tree size by removing nodes that cannot improve the best solution. Upon success, the path is extracted, shortcut smoothed, and returned, achieving improved planning efficiency, path optimality, and robustness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_radius: float = 5.0, max_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_iterations: int = 100, collision_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp within map bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def is_in_obstacle(p):\n            return self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)\n\n        # Simple KD-tree for neighbor searching (brute-force)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_dist = float('inf')\n                best_node = None\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = self.nodes[i]\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        def can_connect(p1, p2):\n            # Cache key tuple sorted to avoid duplicates\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        # Informed ellipsoidal sampling inside evolving domain biased by current best cost c_best\n        def informed_sample(c_best, c_min, start, goal) -> tuple:\n            # If no path yet, sample random free points\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)   # Householder reflection matrix\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            # Try sampling points in the ellipsoid\n            for _ in range(150):\n                x = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * (np.random.uniform(0,1) ** (1/dim))  # Uniform in unit ball\n                sample = rot @ (x * radii) + center\n                sample_tuple = tuple(float(s) for s in sample)\n                if in_bounds(sample_tuple) and not is_in_obstacle(sample_tuple):\n                    return sample_tuple\n\n            # Fallback random samples if unable to find in ellipsoid\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        # Adaptive sampling: sample near best known path with Gaussian noise, fallback to informed_sample\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 0.5, dim)\n                    sample = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample) and not is_in_obstacle(sample):\n                        return sample\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.max_radius\n            r_iter = self.max_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(max(n_nodes,1) + 1) / max(n_nodes,1))\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i + 2, len(smooth) - 1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i+1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(node_list, best_cost, root_s, root_g):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for n in node_list:\n                if n in (root_s, root_g):\n                    continue\n                if n.cost + heuristic(n.position) >= best_cost - 1e-9:\n                    to_remove.append(n)\n            for n in to_remove:\n                if n.parent:\n                    try:\n                        n.parent.children.remove(n)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    node_list.remove(n)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialize roots and data structures\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success = False\n\n        edge_collision_cache = {}\n\n        for itr in range(self.max_iter):\n            # Alternate which tree to extend (extend smaller)\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n            kdt_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdt_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), itr)\n            near_nodes_a = kdt_a.radius_search(new_pos, radius_a)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                c_cand = node.cost + dist(node.position, new_pos)\n                if c_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = c_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_c = new_node.cost + dist(new_node.position, node.position)\n                if new_c + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_c)\n                    edges.append((new_node, node))\n\n            # Incrementally connect tree_b to new_node\n            kdt_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdt_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), itr)\n                near_nodes_b = kdt_b.radius_search(next_pos_b, radius_b)\n\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                # Connect check to new_node's position\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            # Prune nodes periodically for efficiency\n            if (itr > 0 and itr % self.prune_interval == 0 and\n                len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success else []\n\n        # Final smoothing for additional refinement\n        if success and len(extracted_path) > 2:\n            for _ in range(self.smoothing_iterations):\n                if len(extracted_path) < 3:\n                    break\n                i = random.randint(0, len(extracted_path) - 3)\n                j = random.randint(i + 2, len(extracted_path) - 1)\n                p1, p2 = extracted_path[i], extracted_path[j]\n                if can_connect(p1, p2):\n                    extracted_path = extracted_path[:i+1] + extracted_path[j:]\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.60429,
          "time_improvement": 40.0,
          "length_improvement": 16.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01983821392059326,
                    "num_nodes_avg": 71.6,
                    "path_length_avg": 162.40920970916468,
                    "smoothness_avg": 0.04670560436178761,
                    "success_improvement": 0.0,
                    "time_improvement": 21.20233265527991,
                    "length_improvement": 10.980938619790697,
                    "smoothness_improvement": 631.0441311051766,
                    "objective_score": 11.712108176067995
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05411078929901123,
                    "num_nodes_avg": 223.6,
                    "path_length_avg": 235.63868774199312,
                    "smoothness_avg": 0.09815916646431869,
                    "success_improvement": 0.0,
                    "time_improvement": 67.21118902132905,
                    "length_improvement": 21.337023548161053,
                    "smoothness_improvement": 2425.7060543167604,
                    "objective_score": 36.559291687614724
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.035620379447937014,
                    "num_nodes_avg": 145.6,
                    "path_length_avg": 125.56170039384592,
                    "smoothness_avg": 0.1194595465961014,
                    "success_improvement": 0.0,
                    "time_improvement": 30.407699172919294,
                    "length_improvement": 16.6078972040693,
                    "smoothness_improvement": 1419.5166151158953,
                    "objective_score": 19.541472268269125
               }
          ],
          "smoothness_improvement": 1492.0,
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This planner is an improved hybrid bidirectional RRT* algorithm integrating informed ellipsoidal sampling, KD-tree acceleration, adaptive neighbor radius, collision caching, incremental rewiring, periodic pruning, and aggressive shortcut smoothing for fast convergence to short and smooth paths. It employs balanced tree growth, enhanced nearest and radius search, and rigorous collision and boundary checks to improve path length, planning time, robustness, and success rate in both 2D and 3D environments.",
          "planning_mechanism": "The planner alternates growth between two trees rooted at start and goal, sampling points within an ellipsoid defined by the current best path cost for focused exploration. KD-trees accelerate nearest neighbor and radius queries for rewiring, collision results are cached to reduce redundant checks, and nodes are periodically pruned to remove suboptimal branches. Upon successful tree connection, the best path undergoes shortcut smoothing to improve path quality. This combination ensures efficient, reliable, and high-quality path planning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = 5.0\n        self.max_neighbor_radius = 30.0\n        self.prune_interval = 200\n        self.prune_threshold = 300\n        self.smoothing_iterations = 150\n        self.collision_check_resolution = 1.0\n        self.goal_sample_rate = 0.15\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) * (c_min / 2), 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    radius_factor = np.random.uniform(0, 1) ** (1 / dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new node\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connect opposite tree towards new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.44167,
          "time_improvement": 39.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02169802188873291,
                    "num_nodes_avg": 80.9,
                    "path_length_avg": 157.57814870223828,
                    "smoothness_avg": 0.04764540259502782,
                    "success_improvement": 0.0,
                    "time_improvement": 13.8151490012917,
                    "length_improvement": 13.628919710747569,
                    "smoothness_improvement": 645.7540142599136,
                    "objective_score": 10.099098713836593
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05104916095733643,
                    "num_nodes_avg": 217.4,
                    "path_length_avg": 235.39968977102907,
                    "smoothness_avg": 0.09157597560954919,
                    "success_improvement": 0.0,
                    "time_improvement": 69.0664041139677,
                    "length_improvement": 21.41680795004402,
                    "smoothness_improvement": 2256.3158119428285,
                    "objective_score": 36.284861883913266
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03416609764099121,
                    "num_nodes_avg": 154.4,
                    "path_length_avg": 124.42529858311859,
                    "smoothness_avg": 0.12568992365837842,
                    "success_improvement": 0.0,
                    "time_improvement": 33.24896079238765,
                    "length_improvement": 17.362641177115243,
                    "smoothness_improvement": 1498.7665514694615,
                    "objective_score": 20.94104923048665
               }
          ],
          "smoothness_improvement": 1467.0,
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This planner is an optimized bidirectional anytime informed RRT* variant that combines adaptive ellipsoidal sampling guided by the current best path, KD-tree accelerated neighbor searches, lazy collision checking with caching, dynamic neighbor radius adjustment, iterative rewiring, and aggressive pruning of non-promising nodes. It balances fast convergence and high-quality path discovery by prioritizing smaller tree extensions, incremental multi-step connection attempts between trees, and comprehensive shortcut smoothing for path refinement. This approach improves planning time, robustness, and path optimality in both 2D and 3D environments.",
          "planning_mechanism": "The planner initializes two trees from start and goal. Each iteration extends the smaller tree by sampling adaptively within an evolving informed ellipsoid biased by the best path found so far or near the best path using Gaussian perturbations. It uses KD-tree structures for efficient nearest and radius neighbor queries and lazy collision checks with caching for edges. Incremental multi-step extensions attempt to connect opposite trees, while rewiring locally optimizes paths. Periodic aggressive pruning discards nodes unlikely to improve the current best solution, keeping the trees manageable. Once connected, iterative shortcut smoothing refines path quality before returning the solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For pruning etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_trials: int = 100, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp position within bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree approximation (brute-force)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r2] * (dim - 1))\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.power(np.random.uniform(0, 1), 1 / dim)\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 0.5, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i + 2, len(smooth) - 1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i + 1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(nodes_list, best_cost, root_s, root_g):\n            removed = 0\n            to_remove = []\n            h = lambda pos: dist(pos, goal_pos)\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + h(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cand_cost = node.cost + dist(node.position, new_pos)\n                if cand_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cand_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Incremental multi-step connect from tree_b towards new_node.position\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                # Aggressive iterative shortcut smoothing\n                best_path = shortcut_path(best_path)\n                break\n\n            # Periodic pruning when good path exists and node count is high\n            if (it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf')):\n                removed_s = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_g = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.28407,
          "time_improvement": 36.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021583127975463866,
                    "num_nodes_avg": 71.8,
                    "path_length_avg": 158.58444319624488,
                    "smoothness_avg": 0.041607666795992704,
                    "success_improvement": 0.0,
                    "time_improvement": 14.271509255997362,
                    "length_improvement": 13.077353752825879,
                    "smoothness_improvement": 551.250337851875,
                    "objective_score": 9.65317521662376
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05545804500579834,
                    "num_nodes_avg": 228.6,
                    "path_length_avg": 241.31274324250552,
                    "smoothness_avg": 0.11501020495036371,
                    "success_improvement": 0.0,
                    "time_improvement": 66.39481000926783,
                    "length_improvement": 19.442860503457883,
                    "smoothness_improvement": 2859.295411875127,
                    "objective_score": 38.10349216284756
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.036947321891784665,
                    "num_nodes_avg": 154.6,
                    "path_length_avg": 121.78117599783027,
                    "smoothness_avg": 0.11678105345078149,
                    "success_improvement": 0.0,
                    "time_improvement": 27.815223203721956,
                    "length_improvement": 19.118741498676453,
                    "smoothness_improvement": 1385.4463800132248,
                    "objective_score": 19.095547160918002
               }
          ],
          "smoothness_improvement": 1599.0,
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This implementation enhances the bidirectional informed RRT* planner by integrating a dynamically adaptive informed sampling ellipsoid, efficient KD-tree neighbor searches, collision caching, incremental rewiring, and aggressive pruning. Additionally, it emphasizes path quality by incorporating a more robust shortcut smoothing method that leverages edge shortcuts verified by collision checks. The planner maintains two trees rooted at start and goal, iteratively growing and rewiring them to minimize path length, while pruning non-promising nodes to reduce computational overhead. These improvements collectively boost planning efficiency, path quality, success rate, and smoothness in both 2D and 3D environments.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal positions, samples nodes adaptively within an ellipsoid that shrinks as better paths are found, uses KD-tree-based nearest neighbor and radius queries for rewiring and extension, caches collision outcomes to avoid redundant computations, prunes nodes that cannot improve the current best path, and applies shortcut smoothing on the final path to reduce length and improve smoothness. It stops upon finding a connecting path or after reaching the maximum iterations.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...] position in 2D or 3D\n        self.parent = parent          # Parent Node or None\n        self.cost = cost              # Cost from root to this node\n        self.children = []            # Children Nodes\n        self.valid = True             # For collision validity if needed\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_iterations: int = 150, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KDTree with simple linear search (quicker for small data, can upgrade to balanced structure)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d in range(dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        # Informed sampling inside ellipsoid based on current best path cost\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # fallback uniform sampling with retries for obstacle free\n                for _ in range(15):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_m = np.eye(dim)\n\n            v = a1 - np.array([1] + [0] * (dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_m - 2 * np.outer(v, v)\n            else:\n                rot = id_m\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            # Allow more tries but break early for efficiency\n            for _ in range(200):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # fallback uniform sampling if ellipsoid fails\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic - 1e-12 >= best_cost:\n                    to_remove.append(node)\n            for rmn in to_remove:\n                if rmn.parent:\n                    try:\n                        rmn.parent.children.remove(rmn)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rmn)\n                except ValueError:\n                    pass\n                if rmn in tree_start:\n                    tree_start.remove(rmn)\n                if rmn in tree_goal:\n                    tree_goal.remove(rmn)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n\n        best_path: list = []\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth direction depending on size for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n\n            for node in near_nodes:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors around new_node for cost improvement\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try connecting trees via new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b):\n                    break\n                if not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    # Mark success and update best path\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Shortcut smoothing to improve path quality\n                    smoothed = shortcut_path(merged_path)\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = smoothed\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning of nodes unlikely to yield improvement\n            if iteration > 0 and iteration % self.prune_interval == 0 \\\n               and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.24121,
          "time_improvement": 39.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02421252727508545,
                    "num_nodes_avg": 84.0,
                    "path_length_avg": 163.03586017152315,
                    "smoothness_avg": 0.03982455083038601,
                    "success_improvement": 0.0,
                    "time_improvement": 3.8274979071256188,
                    "length_improvement": 10.63746157146,
                    "smoothness_improvement": 523.3407008918359,
                    "objective_score": 5.892445190888865
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05236344337463379,
                    "num_nodes_avg": 227.1,
                    "path_length_avg": 234.57044411783062,
                    "smoothness_avg": 0.09292093831093264,
                    "success_improvement": 0.0,
                    "time_improvement": 68.27000549713694,
                    "length_improvement": 21.69363401759437,
                    "smoothness_improvement": 2290.922670986902,
                    "objective_score": 36.27434180759447
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028946614265441893,
                    "num_nodes_avg": 132.5,
                    "path_length_avg": 123.69278957364477,
                    "smoothness_avg": 0.13291123176527828,
                    "success_improvement": 0.0,
                    "time_improvement": 43.44637763248849,
                    "length_improvement": 17.849138782877038,
                    "smoothness_improvement": 1590.6210575677087,
                    "objective_score": 24.556846334160497
               }
          ],
          "smoothness_improvement": 1468.0,
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner merges the bidirectional informed RRT* approach with incremental rewiring and goal biasing for efficient exploration. It adaptively samples within a shrinking informed ellipsoid around the best path found, employs KD-tree accelerated neighbor searches, caches collision checks to avoid redundant computations, and aggressively prunes nodes unlikely to improve the solution. The planner alternates tree growth from start and goal to rapidly connect the two, and applies robust shortcut smoothing to enhance final path quality and smoothness. These combined techniques optimize planning efficiency, path quality, success rate, and computational overhead in complex 2D/3D environments.",
          "planning_mechanism": "The planner maintains two trees from start and goal positions, alternately sampling adaptively and extending towards sampled points with step-size control. It uses KD-tree-based searches to select best parents minimizing cost, rewires neighbors for incremental path improvement, and attempts connection between trees each iteration. Collision checking of nodes and edges is cached and leveraged extensively. The best path is adaptively refined and periodically pruned during iterations to reduce search space. Upon successful connection, a shortcut smoothing phase improves path smoothness and length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from tree root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 25.0,\n                 goal_sample_rate: float = 0.1,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_iterations: int = 150, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def within_ellipsoid_sample(c_best, c_min, start, goal):\n            # Use informed sampling inside ellipsoid\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # fallback uniform sampling with retries for collision-free sample\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback: random anyway\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            eye = np.eye(dim)\n            v = a1 - np.array([1] + [0] * (dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rotation = eye - 2 * np.outer(v, v)\n            else:\n                rotation = eye\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            # Try multiple times for collision-free sample\n            for _ in range(200):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rotation @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # fallback again to uniform if ellipsoid fails\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def is_in_obstacle(pos):\n            # check if pos inside any obstacle\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else None\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return True\n\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / self.collision_check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    edge_collision_cache[key] = True\n                    return True\n            edge_collision_cache[key] = False\n            return False\n\n        def can_connect(p1, p2):\n            if is_in_obstacle(p2):\n                return False\n            if is_edge_in_obstacle(p1, p2):\n                return False\n            return True\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        # KDTree with linear search (sufficient for moderate node counts)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d in range(dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic - 1e-12 >= best_cost:\n                    to_remove.append(node)\n            for rmn in to_remove:\n                if rmn.parent:\n                    rmn.parent.remove_child(rmn)\n                try:\n                    nodes.remove(rmn)\n                except ValueError:\n                    pass\n                if rmn in tree_start:\n                    tree_start.remove(rmn)\n                if rmn in tree_goal:\n                    tree_goal.remove(rmn)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        # Trees: lists of nodes for start and goal sides\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        # All nodes and edges\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path: List[Tuple[float, ...]] = []\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            # Sample point with goal bias or informed ellipsoid\n            if random.random() < self.goal_sample_rate:\n                q_rand = goal_pos\n            else:\n                q_rand = within_ellipsoid_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth tree selection for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            # Build KDTree for tree_a and find nearest to q_rand\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            # Choose best parent minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cost improvements\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt to connect trees via new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            # Extend tree_b towards new_node stepwise\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n\n                if not can_add_node(next_pos_b):\n                    break\n                if not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=None, cost=cost_b)\n                last_node_b.add_child(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        if neighbor_b.parent:\n                            try:\n                                edges.remove((neighbor_b.parent, neighbor_b))\n                            except ValueError:\n                                pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=None, cost=final_cost)\n                    new_node_b.add_child(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Depending on tree assignment, assemble path\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Shortcut smoothing to improve path quality\n                    smoothed = shortcut_path(merged_path)\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = smoothed\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning of nodes unlikely to improve best path\n            if iteration > 0 and iteration % self.prune_interval == 0 \\\n               and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # Collision helpers unchanged\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else None\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -21.39406,
          "time_improvement": 33.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01638748645782471,
                    "num_nodes_avg": 69.8,
                    "path_length_avg": 156.77104356827704,
                    "smoothness_avg": 0.042380982844713186,
                    "success_improvement": 0.0,
                    "time_improvement": 34.90867112893999,
                    "length_improvement": 14.071306824071005,
                    "smoothness_improvement": 563.3544132970283,
                    "objective_score": 16.10363476998134
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06851754188537598,
                    "num_nodes_avg": 279.8,
                    "path_length_avg": 234.47724576367142,
                    "smoothness_avg": 0.10093387513099414,
                    "success_improvement": 0.0,
                    "time_improvement": 58.4813165968027,
                    "length_improvement": 21.724746310778592,
                    "smoothness_improvement": 2497.1013068521906,
                    "objective_score": 34.37485077545748
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04835000038146973,
                    "num_nodes_avg": 213.9,
                    "path_length_avg": 123.59421078042612,
                    "smoothness_avg": 0.14087353326908802,
                    "success_improvement": 0.0,
                    "time_improvement": 5.537565189200058,
                    "length_improvement": 17.914610123515168,
                    "smoothness_improvement": 1691.9009449802068,
                    "objective_score": 13.703696306364085
               }
          ],
          "smoothness_improvement": 1584.0,
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner combines the bidirectional adaptive informed sampling technique with dynamic neighbor radius rewiring and efficient collision caching. It balances growth by always extending the smaller tree, uses KD-tree accelerated nearest neighbor searches, caches collision checks to minimize redundant computations, and prunes dead-end and non-improving nodes periodically. Iterative shortcut smoothing is applied upon path connection to enhance path quality and smoothness. The approach focuses on improving planning efficiency, robustness, success rate, and producing shorter, smoother paths with reduced search time in complex 2D/3D environments.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal, always extending the smaller tree to balance exploration. Samples are generated with adaptive informed biasing near start and goal, avoiding obstacles efficiently. New nodes are connected using a dynamically shrinking neighbor radius to incrementally optimize costs via rewiring. Collision checks for nodes and edges are cached for efficiency. Dead-end and cost-ineffective nodes are pruned regularly to maintain a compact search space. Once a connection is found, iterative shortcut smoothing refines the path. The final output is the best feasible path found within max iterations.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n    \n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.12, radius_constant: float=20.0,\n                 radius_min: float=4.0, prune_interval: int=100,\n                 prune_threshold: int=120, smoothing_iterations: int=50,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle rects/cuboids\n\n        import math\n        import random\n\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        edge_collision_cache = {}\n        node_collision_cache = {}\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for i in range(dim):\n                if pos[i] < 0 or pos[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_in_obstacle_cached(pos):\n            if pos in node_collision_cache:\n                return node_collision_cache[pos]\n            res = self._is_in_obstacle(pos, obstacles, is_3d)\n            node_collision_cache[pos] = res\n            return res\n\n        def is_edge_in_obstacle_cached(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n            res = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = res\n            return res\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle_cached(pos):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if is_in_obstacle_cached(p2):\n                return False\n            if is_edge_in_obstacle_cached(p1, p2):\n                return False\n            return True\n\n        # Adaptive informed sampling biased near start and goal with fallback uniform sampling\n        def sample_free():\n            p_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                # Bias mixture toward goal and start\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                for _ in range(15):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(sample):\n                        return sample\n                return goal_position  # fallback\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            clamped = tuple(max(0.0, min(bounds[d], new_pos[d])) for d in range(dim))\n            return clamped\n\n        # KDTree substitute: linear search for nearest node\n        def nearest(tree, point):\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = node\n            return min_node\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            result = []\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - pos[i]\n                    d_sq += diff * diff\n                    if d_sq > radius_sq:\n                        break\n                if d_sq <= radius_sq:\n                    result.append(node)\n            return result\n\n        def radius_dynamic(n):\n            if n <= 1:\n                return self.radius_constant\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=None, cost=new_cost)\n                last_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    # Final edge \n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=None, cost=final_cost)\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes_and_nonimprovable(best_cost=float('inf')):\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                # Dead-end nodes (no children)\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.remove_child(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n                else:\n                    # Prune nodes whose cost + heuristic cannot improve best_cost\n                    heuristic = dist(node.position, goal_position)\n                    if node.cost + heuristic - 1e-12 >= best_cost:\n                        try:\n                            if node.parent:\n                                node.parent.remove_child(node)\n                            nodes.remove(node)\n                            edges[:] = [(p,c) for (p,c) in edges if p != node and c != node]\n                            removed.append(node)\n                        except Exception:\n                            continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) -1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i+2, len(p)-1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        best_path = []\n        best_cost = float('inf')\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n                root_start, root_goal = goal_root, start_root\n            else:\n                root_start, root_goal = start_root, goal_root\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                    new_path_cost = path_length(smoothed)\n                else:\n                    extracted_path = raw_path\n                    new_path_cost = path_length(raw_path)\n                if new_path_cost + 1e-12 < best_cost:\n                    best_cost = new_path_cost\n                    best_path = extracted_path\n                break\n\n            # Periodic pruning to reduce overhead and improve efficiency\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold and best_cost < float('inf'):\n                prune_dead_nodes_and_nonimprovable(best_cost)\n                edge_collision_cache.clear()\n                node_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.90157,
          "time_improvement": 39.0,
          "length_improvement": 15.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012537288665771484,
                    "num_nodes_avg": 81.9,
                    "path_length_avg": 164.3737683314568,
                    "smoothness_avg": 0.029628933487335973,
                    "success_improvement": 0.0,
                    "time_improvement": 50.2017114219803,
                    "length_improvement": 9.90413290848889,
                    "smoothness_improvement": 363.75714933567724,
                    "objective_score": 18.86012575497025
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.040825486183166504,
                    "num_nodes_avg": 257.4,
                    "path_length_avg": 237.8634492941661,
                    "smoothness_avg": 0.07093023317705174,
                    "success_improvement": 0.0,
                    "time_improvement": 75.26151130091444,
                    "length_improvement": 20.59433410583502,
                    "smoothness_improvement": 1725.0859886274663,
                    "objective_score": 35.322750154578664
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05528502464294434,
                    "num_nodes_avg": 245.3,
                    "path_length_avg": 130.14303260308697,
                    "smoothness_avg": 0.1369860486678642,
                    "success_improvement": 0.0,
                    "time_improvement": -8.011540747558735,
                    "length_improvement": 13.565194490288098,
                    "smoothness_improvement": 1642.4524277969049,
                    "objective_score": 8.521838812774524
               }
          ],
          "smoothness_improvement": 1244.0,
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This improved planner builds upon the bidirectional RRT* framework with adaptive informed sampling and balanced bidirectional tree growth. It incorporates an enhanced dynamic radius rewiring strategy with logarithmic decay, efficient collision checks, and periodic dead-end pruning to maintain computational efficiency. Additionally, the sampling bias dynamically adjusts based on the relative sizes of the trees for faster convergence. Iterative shortcut smoothing is applied upon finding a connection to yield shorter and smoother paths. To reduce computation overhead, caching of nearest neighbors and radius computations optimize rewiring steps, and the edge collision checks are done with adaptive resolution. Tree growth always favors expanding the smaller tree to keep search balanced and minimize redundant expansions. This results in faster planning with higher success rates and improved path quality while strictly enforcing collision-free, map-bound paths.",
          "planning_mechanism": "The planner alternates extension between start and goal trees, sampling adaptively biased towards start or goal to accelerate progress. Each extension rewires neighbors within a dynamically shrinking radius to optimize local costs. Upon connecting the two trees, the path is extracted and refined via shortcut smoothing iterations to shorten and smooth the trajectory. Dead-end nodes are pruned periodically to reduce computational load. The planner uses rigorous collision and boundary checks for nodes and edges, enforcing feasibility. This balanced and adaptive growth approach promotes rapid, robust convergence to high-quality, smooth paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        # Propagate cost update down children recursively to keep consistency\n        for child in self.children:\n            child._update_cost_recursive()\n\n    def _update_cost_recursive(self):\n        if self.parent:\n            self.cost = self.parent.cost + sum((self._distance(self.parent.position, self.position),))\n        for child in self.children:\n            child._update_cost_recursive()\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _distance(p1, p2):\n        import math\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 4000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 radius_constant: float = 30.0,\n                 radius_min: float = 5.0,\n                 prune_interval: int = 100,\n                 prune_threshold: int = 120,\n                 smoothing_iterations: int = 70):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        import random\n        import math\n\n        is_3d = (len(bounds) == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free(size_start, size_goal):\n            p_bias = 0.75\n            # Adaptive bias sampling proportion based on tree size ratio\n            total = size_start + size_goal + 1e-9\n            bias_goal = size_goal / total\n            bias_start = size_start / total\n            # With prob goal_sample_rate sample biased between start and goal, else uniform free\n            if random.random() < self.goal_sample_rate:\n                # Choose start or goal with bias proportional to size\n                if random.random() < (bias_goal * p_bias):\n                    return goal_position\n                elif random.random() < (bias_start * p_bias / (1 - bias_goal * p_bias)):\n                    return start_position\n                else:\n                    return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            # Optimized nearest using simple linear search (can be replaced by spatial indexing)\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = node\n            return min_node\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= r_sq]\n\n        def radius_dynamic(n):\n            if n <= 1:\n                return self.radius_constant\n            # Logarithmic decay for radius to balance exploration\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            # Collision and bounds check\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            for d in range(len(pos)):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def can_connect(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.5)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost efficiently\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            # Remove leaf nodes (dead-ends) except roots\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        pass\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free(len(tree_start), len(tree_goal))\n\n            # Always extend the smaller tree first to balance search\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                # Combined path: start->connection->goal reversed (avoid double joint node)\n                raw_path = path_start + path_goal[::-1][1:]\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.82279,
          "time_improvement": 35.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027561044692993163,
                    "num_nodes_avg": 82.4,
                    "path_length_avg": 159.95946170997846,
                    "smoothness_avg": 0.03919379441318278,
                    "success_improvement": 0.0,
                    "time_improvement": -9.47286081722483,
                    "length_improvement": 12.323684316885842,
                    "smoothness_improvement": 513.4679932531224,
                    "objective_score": 2.1902185844753315
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05026965141296387,
                    "num_nodes_avg": 123.5,
                    "path_length_avg": 241.28509223189593,
                    "smoothness_avg": 0.0937151505467923,
                    "success_improvement": 0.0,
                    "time_improvement": 69.53875337069844,
                    "length_improvement": 19.452091206689573,
                    "smoothness_improvement": 2311.3583238635224,
                    "objective_score": 36.308835871865064
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.027540087699890137,
                    "num_nodes_avg": 118.2,
                    "path_length_avg": 123.18829835962379,
                    "smoothness_avg": 0.10965737125236882,
                    "success_improvement": 0.0,
                    "time_improvement": 46.19433881056144,
                    "length_improvement": 18.184197825939695,
                    "smoothness_improvement": 1294.8336682649397,
                    "objective_score": 23.96930954968107
               }
          ],
          "smoothness_improvement": 1373.0,
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner is an enhanced hybrid bidirectional informed RRT* variant with refined parameter tuning aimed at maximizing planning efficiency, path quality, success rate, and computational speed. It features adaptive sampling within an informed ellipsoid, dynamic neighbor radius control, goal biasing, collision caching, aggressive pruning of redundant nodes, incremental rewiring, balanced tree growth, and robust shortcut smoothing to generate shorter and smoother paths more reliably in complex 2D/3D environments.",
          "planning_mechanism": "The planner alternates between extending two trees rooted at start and goal. It samples points adaptively within a shrinking ellipsoid to focus search near the best known path. KD-tree inspired neighbor searches enable rewiring for incremental improvements while caching collision checks reduces overhead. It prunes nodes unlikely to improve solutions periodically and applies shortcut smoothing to enhance final path quality, thus balancing exploration, optimization, and computational cost for faster, robust planning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 4000,\n                 step_size: float = 6.0,\n                 min_neighbor_radius: float = 6.0,\n                 max_neighbor_radius: float = 20.0,\n                 goal_sample_rate: float = 0.15,  # more frequent goal bias\n                 prune_interval: int = 150,\n                 prune_threshold: int = 250,\n                 smoothing_iterations: int = 200,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            n = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.98)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def within_ellipsoid_sample(c_best, c_min, start, goal):\n            # informed sampling inside ellipsoid focusing near best path\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # fallback uniform sampling with collision check retries\n                for _ in range(15):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) * 0.5 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            eye = np.eye(dim)\n            v = direction - np.array([1] + [0] * (dim -1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rotation = eye - 2 * np.outer(v, v)\n            else:\n                rotation = eye\n\n            r1 = c_best * 0.5\n            r_other = math.sqrt(max(r1 * r1 - (c_min * 0.5) ** 2, 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(150):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rotation @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def is_in_obstacle(pos):\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else None\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return True\n\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / self.collision_check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    edge_collision_cache[key] = True\n                    return True\n            edge_collision_cache[key] = False\n            return False\n\n        def can_connect(p1, p2):\n            if is_in_obstacle(p2):\n                return False\n            if is_edge_in_obstacle(p1, p2):\n                return False\n            return True\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        class KDTree:\n            # Simple linear search based KDTree substitute optimized for iteration\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                # Slightly tighter condition for pruning improves runtime\n                if node.cost + heuristic - 1e-12 >= best_cost:\n                    to_remove.append(node)\n            for rmn in to_remove:\n                if rmn.parent:\n                    rmn.parent.remove_child(rmn)\n                try:\n                    nodes.remove(rmn)\n                except ValueError:\n                    pass\n                if rmn in tree_start:\n                    tree_start.remove(rmn)\n                if rmn in tree_goal:\n                    tree_goal.remove(rmn)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path: list[tuple] = []\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            # Sample with goal bias or informed ellipsoid\n            if random.random() < self.goal_sample_rate:\n                q_rand = goal_pos\n            else:\n                q_rand = within_ellipsoid_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree growth for balanced exploration\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cost improvements with pruning of expensive rewires\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            max_ext_steps = max(1, int(dist(last_node_b.position, new_node.position) / self.step_size))\n\n            for _ in range(max_ext_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=None, cost=cost_b)\n                last_node_b.add_child(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        if neighbor_b.parent:\n                            try:\n                                edges.remove((neighbor_b.parent, neighbor_b))\n                            except ValueError:\n                                pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=None, cost=final_cost)\n                    new_node_b.add_child(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    smoothed = shortcut_path(merged_path)\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = smoothed\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -20.26536,
          "time_improvement": 33.0,
          "length_improvement": 14.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02238790988922119,
                    "num_nodes_avg": 77.0,
                    "path_length_avg": 168.1601616915515,
                    "smoothness_avg": 0.04350127346738022,
                    "success_improvement": 0.0,
                    "time_improvement": 11.07490406869931,
                    "length_improvement": 7.828750708578664,
                    "smoothness_improvement": 580.8893942917919,
                    "objective_score": 7.792668333784485
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05254693031311035,
                    "num_nodes_avg": 224.2,
                    "path_length_avg": 242.65001573363708,
                    "smoothness_avg": 0.09995825129568903,
                    "success_improvement": 0.0,
                    "time_improvement": 68.15882030430012,
                    "length_improvement": 18.996440454663716,
                    "smoothness_improvement": 2471.9978028563455,
                    "objective_score": 36.60692319650451
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.041457104682922366,
                    "num_nodes_avg": 182.2,
                    "path_length_avg": 126.29069487361997,
                    "smoothness_avg": 0.1253220957696637,
                    "success_improvement": 0.0,
                    "time_improvement": 19.004363647204144,
                    "length_improvement": 16.123733781590172,
                    "smoothness_improvement": 1494.087807875241,
                    "objective_score": 16.396494889855482
               }
          ],
          "smoothness_improvement": 1516.0,
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This improved algorithm is a bidirectional informed RRT* planner enhanced with adaptive ellipsoidal sampling, KD-tree accelerated nearest neighbor search, collision caching, incremental rewiring, pruning of nodes unlikely to improve the best path, and post-planning shortcut smoothing. It synergizes aggressive informed sampling to focus search in promising regions, efficient data structures for speedy queries, and heuristic pruning to minimize computation. The method balances rapid convergence, path quality, and robustness in both 2D and 3D spaces while strictly validating collision-free states and edges.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately. Sampling is concentrated within a dynamic ellipsoid defined by the best current path to bias exploration. New nodes are connected with minimal cost parent from neighbors found efficiently using a KD-tree structure. The planner rewires neighbors for cost improvement and attempts connecting both trees incrementally. Periodic pruning removes nodes that cannot contribute to a better path. On successful connection, shortcut smoothing refines the path for smoothness and minimal length. Collision checks are cached to avoid redundancy, and all expansions obey strict collision and boundary constraints, optimizing planning speed and path optimality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Ensure new_p within bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.step_size * 15 * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.step_size * 8 * math.sqrt(math.log(c + 1) / c)\n            r = max(self.step_size * 3, min(r_iter, r_nodes))\n            return r\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=1.0)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            # If no solution found yet, sample uniformly inside map free space\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(15):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # Fallback uniform sample without obstacle check\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n\n            v = a1 - np.array([1] + [0] * (dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            rr = max(r1 * r1 - (c_min / 2) ** 2, 0)\n            r_others = math.sqrt(rr)\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # Fallback uniform sample\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos) or is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(150):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_position)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_position, cost=0.0)\n        root_goal = Node(goal_position, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_position, goal_position)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_position, goal_position)\n\n            # Alternate tree growth, smaller first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors for cost improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to reduce search space and maintain speed\n            if it > 0 and it % 200 == 0 and len(nodes) > 300 and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.24912,
          "time_improvement": 30.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023321080207824706,
                    "num_nodes_avg": 63.3,
                    "path_length_avg": 156.20421051138774,
                    "smoothness_avg": 0.04175374744685328,
                    "success_improvement": 0.0,
                    "time_improvement": 7.368338314563752,
                    "length_improvement": 14.381997004596602,
                    "smoothness_improvement": 553.5368172570537,
                    "objective_score": 7.854584981573715
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0528256893157959,
                    "num_nodes_avg": 228.1,
                    "path_length_avg": 236.87605303184245,
                    "smoothness_avg": 0.1027365135094304,
                    "success_improvement": 0.0,
                    "time_improvement": 67.98990433825956,
                    "length_improvement": 20.92395539882424,
                    "smoothness_improvement": 2543.4844907172983,
                    "objective_score": 37.29918483482921
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04322056770324707,
                    "num_nodes_avg": 179.9,
                    "path_length_avg": 122.6417820386079,
                    "smoothness_avg": 0.12132860892370778,
                    "success_improvement": 0.0,
                    "time_improvement": 15.559048046699587,
                    "length_improvement": 18.547167944047814,
                    "smoothness_improvement": 1443.2909499632185,
                    "objective_score": 15.593602752635531
               }
          ],
          "smoothness_improvement": 1513.0,
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements a Fast Informed Bidirectional RRT* with Dynamic Domain Reduction and Hierarchical Sampling. It combines bidirectional tree growth from start and goal with an adaptive sampling domain shrinking around the current best path cost, enhanced by a dynamic informed ellipsoid sampling. It incorporates hierarchical sampling levels to focus exploration near promising regions while maintaining global exploration, aggressive pruning of nodes unlikely to improve the solution, and prioritized rewiring with lazy collision checks. The algorithm includes a novel batch shortcut smoothing that applies both local and global path shortcuts to improve smoothness and reduce path length efficiently. The planner stops either when the maximum iteration count is reached or a path meeting quality criteria is found.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal, adaptively sampling in a dynamically shrinking informed ellipsoid augmented by hierarchical global samples to avoid local minima. It uses efficient KD-tree-like neighbor searches to perform rewiring and node connections. Lazy collision caching reduces redundant checks during rewiring and connections. Aggressive node pruning removes nodes whose cost combined with heuristics exceeds the best solution, conserving memory and search time. Upon connecting the two trees, a batch shortcut smoothing is applied combining long-range and local shortcuts validated by collision checks, yielding a high-quality, smooth path. This strategy balances rapid global exploration and focused local optimization, improving efficiency, robustness, and path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision validity or lazy checking\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 neighbor_min_radius: float = 5.0, neighbor_max_radius: float = 30.0,\n                 smoothing_batch_iters: int = 100,\n                 prune_interval: int = 150, prune_threshold: int = 350,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_min_radius = neighbor_min_radius\n        self.neighbor_max_radius = neighbor_max_radius\n        self.smoothing_batch_iters = smoothing_batch_iters\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # (W,H) or (W,H,D)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(1, n_nodes)\n            r_iter = self.neighbor_max_radius * (1.0 - (iteration / self.max_iter)**0.95)\n            r_nodes = self.neighbor_min_radius + (self.neighbor_max_radius - self.neighbor_min_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.neighbor_min_radius, min(r_iter, r_nodes))\n\n        # Lazy collision caches\n        node_in_obstacle_cache = {}\n        edge_collision_cache = {}\n\n        def is_in_obstacle_cached(pos):\n            if pos in node_in_obstacle_cache:\n                return node_in_obstacle_cache[pos]\n            val = self._is_in_obstacle(pos, obstacles, is_3d)\n            node_in_obstacle_cache[pos] = val\n            return val\n\n        def is_edge_collision_cached(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n            val = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = val\n            return val\n\n        # Informed ellipsoid sampling with augmented hierarchical global exploration\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            # Hierarchical sampling parameters\n            elite_rate = 0.8    # Fraction of samples from informed ellipsoid\n            global_rate = 0.2   # Fraction from global uniform\n\n            # If no solution yet, uniform random sampling tries\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(15):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                # fallback uniform\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Choose sampling mode (ellipsoid or global)\n            if random.random() < elite_rate:\n                # Ellipsoid sampling\n                center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n                a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n                id_m = np.eye(dim)\n\n                v = a1 - np.array([1] + [0] * (dim - 1))\n                norm_v = np.linalg.norm(v)\n                if norm_v > 1e-10:\n                    v /= norm_v\n                    rot = id_m - 2 * np.outer(v, v)\n                else:\n                    rot = id_m\n\n                r1 = c_best / 2.0\n                r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n                radii = np.array([r1] + [r_others] * (dim - 1))\n\n                for _ in range(100):\n                    x_ball = np.random.uniform(-1, 1, dim)\n                    norm_x = np.linalg.norm(x_ball)\n                    if norm_x <= 1.0 and norm_x > 1e-8:\n                        # Uniformly sample inside unit ball\n                        r_scale = random.uniform(0,1) ** (1.0 / dim)\n                        x_ball = x_ball / norm_x * r_scale\n                        sample = rot @ (x_ball * radii) + center\n                        p = tuple(float(c) for c in sample)\n                        if in_bounds(p) and not is_in_obstacle_cached(p):\n                            return p\n                # fail ellipsoid, fallback global\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                return p\n            else:\n                # Global uniform hierarchical exploration sample biased near bounds edges to avoid local minima\n                # To maintain global exploration, sample dominantly near boundary regions as well (20%)\n                ranges = []\n                for d_ in range(dim):\n                    e = bounds[d_]\n                    ranges.append((0, e))\n                # Sample with edge bias (uniform, but 40% chance to be near edges)\n                def edge_biased_sample(d):\n                    if random.random() < 0.4:\n                        edge_zone = 0.15 * bounds[d]\n                        if random.random() < 0.5:\n                            return random.uniform(0, edge_zone)\n                        else:\n                            return random.uniform(bounds[d] - edge_zone, bounds[d])\n                    else:\n                        return random.uniform(0, bounds[d])\n                for _ in range(30):\n                    p = tuple(edge_biased_sample(d) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                # fallback uniform\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # KDTree for neighbor queries (linear search, adequate for moderate sizes)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                radius_sq = radius * radius\n                res = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for i_ in range(dim):\n                        delta = p[i_] - pt[i_]\n                        sqd += delta * delta\n                        if sqd > radius_sq:\n                            break\n                    if sqd <= radius_sq:\n                        res.append(n)\n                return res\n\n        # Add node with collision and edge validity checks\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle_cached(pos):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            if is_edge_collision_cached(p1, p2):\n                return False\n            return True\n\n        # Aggressive pruning - remove nodes not capable of improving current best cost\n        def prune_nodes(best_cost):\n            removed = 0\n            nonlocal nodes, tree_start, tree_goal, edges\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic - 1e-12 >= best_cost:\n                    to_remove.append(node)\n\n            for rn in to_remove:\n                if rn.parent:\n                    try:\n                        rn.parent.children.remove(rn)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rn)\n                except ValueError:\n                    pass\n                if rn in tree_start:\n                    tree_start.remove(rn)\n                if rn in tree_goal:\n                    tree_goal.remove(rn)\n                # Remove edges with rn if present\n                edges = [e for e in edges if e[0] != rn and e[1] != rn]\n                removed += 1\n            return removed\n\n        # Batch shortcut smoothing combining local and long-range shortcuts\n        def batch_shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            length = len(p)\n            for _ in range(self.smoothing_batch_iters):\n                if length < 3:\n                    break\n                # Random long-range shortcut attempt\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n                    length = len(p)\n                    continue\n                # Attempt local shortcut for adjacent triples to smooth jagged edges\n                if length >= 4:\n                    li = random.randint(0, length - 4)\n                    if can_connect(p[li], p[li+2]):\n                        p = p[:li+1] + p[li+2:]\n                        length = len(p)\n            return p\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree growth for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n                growing_from_start = True\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n                growing_from_start = False\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            # Choose best parent minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for nn in near_nodes:\n                cost_candidate = nn.cost + dist(nn.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(nn.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = nn\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node to optimize paths\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try connect new_node to tree_b by incremental steps towards new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n\n            max_steps = max(1, int(dist(last_node_b.position, new_node.position) / self.step_size))\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b):\n                    break\n                if not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                # Rewire neighbors around new_node_b\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for nb in near_b:\n                    if nb is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, nb.position)\n                    if c_via_new_b + 1e-12 < nb.cost and can_connect(new_node_b.position, nb.position):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, nb))\n\n                # Check connection termination condition\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_conn = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=cost_conn)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    # Extract full path & update best\n                    success_state = True\n\n                    if growing_from_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Batch shortcut smoothing\n                    smoothed_path = batch_shortcut_path(merged_path)\n\n                    if cost_conn + 1e-12 < c_best:\n                        c_best = cost_conn\n                        best_path = smoothed_path\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning of non-promising nodes\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                node_in_obstacle_cache.clear()\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.10161,
          "time_improvement": 29.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014202570915222168,
                    "num_nodes_avg": 56.9,
                    "path_length_avg": 152.88041791210188,
                    "smoothness_avg": 0.04373393242318906,
                    "success_improvement": 0.0,
                    "time_improvement": 43.58718668439454,
                    "length_improvement": 16.203820397129356,
                    "smoothness_improvement": 584.5310121772093,
                    "objective_score": 19.23957514563028
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05148146152496338,
                    "num_nodes_avg": 206.3,
                    "path_length_avg": 238.89910138307377,
                    "smoothness_avg": 0.11296072838976305,
                    "success_improvement": 0.0,
                    "time_improvement": 68.8044485634847,
                    "length_improvement": 20.248603628965096,
                    "smoothness_improvement": 2806.5609037925724,
                    "objective_score": 38.72385981380129
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06440050601959228,
                    "num_nodes_avg": 188.5,
                    "path_length_avg": 126.36258764892011,
                    "smoothness_avg": 0.11591866387777214,
                    "success_improvement": 0.0,
                    "time_improvement": -25.820652609338058,
                    "length_improvement": 16.075986023401896,
                    "smoothness_improvement": 1374.4768482995228,
                    "objective_score": 2.3413856633765766
               }
          ],
          "smoothness_improvement": 1589.0,
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This implementation develops an advanced bidirectional informed RRT* planner that focuses on minimizing path length by adaptively sampling within an ellipsoid shaped by the current best path, which improves convergence speed. The planner efficiently manages nodes using KD-tree neighbor searches, caches collision checks to avoid redundant computations, rewires incrementally for cost optimization, prunes nodes unlikely to improve the path, and applies shortcut smoothing on the obtained path to enhance smoothness and reduce length. These enhancements collectively improve planning efficiency, robustness, success rate, and path quality in both 2D and 3D spaces.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal, sampling within an ellipsoidal informed region that shrinks as better solutions are found. It incrementally connects and rewires nodes ensuring collision-free safeguards for nodes and edges. Pruning and collision cache clearing happen periodically to maintain efficiency. Once a feasible path is found, shortcut smoothing refines the path. The process continues until a max iteration limit or an optimal path is finalized.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # Collision-validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        # Informed sampling inside an ellipsoid defined by start-goal and current best cost\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # No good path yet: uniform random sampling with obstacle rejection\n                trials = 0\n                while trials < 20:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                    trials += 1\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            # Rotation matrix that aligns x-axis with a1 via Householder transform\n            id_mat = np.eye(dim)\n            v = a1 - np.array([1.] + [0.]*(dim - 1))\n            v_norm = np.linalg.norm(v)\n            if v_norm > 1e-10:\n                v = v / v_norm\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r2]*(dim - 1))\n\n            for _ in range(100):\n                sample_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(sample_ball) <= 1:\n                    sample_scaled = sample_ball * radii\n                    point = rot @ sample_scaled + center\n                    p = tuple(float(c) for c in point)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # fallback uniform random\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent and rm_node in rm_node.parent.children:\n                    rm_node.parent.children.remove(rm_node)\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path: list = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate expanding smaller tree for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            # Choose best parent minimizing cost and collision-free edge\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes to improve their cost paths\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt connection to opposite tree\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            dist_ab = dist(last_node_b.position, new_node.position)\n            max_steps = int(dist_ab / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                # Check if we can connect new_node_b directly to new_node to close the trees\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Merge paths from start and goal trees\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]  # avoid duplicated node\n\n                    # Update best path if improved\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning of unpromising nodes for efficiency\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.05396,
          "time_improvement": 32.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014794063568115235,
                    "num_nodes_avg": 66.6,
                    "path_length_avg": 156.89092179508836,
                    "smoothness_avg": 0.03711808451837075,
                    "success_improvement": 0.0,
                    "time_improvement": 41.23776946941373,
                    "length_improvement": 14.005599668363654,
                    "smoothness_improvement": 480.97862592313305,
                    "objective_score": 17.577343904112514
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04550454616546631,
                    "num_nodes_avg": 219.4,
                    "path_length_avg": 234.7442100183161,
                    "smoothness_avg": 0.09456512667699488,
                    "success_improvement": 0.0,
                    "time_improvement": 72.4262022007329,
                    "length_improvement": 21.63562595843819,
                    "smoothness_improvement": 2333.2288219066954,
                    "objective_score": 37.72112996144099
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06006522178649902,
                    "num_nodes_avg": 212.7,
                    "path_length_avg": 126.23472190811553,
                    "smoothness_avg": 0.11535332710218134,
                    "success_improvement": 0.0,
                    "time_improvement": -17.35071463573235,
                    "length_improvement": 16.160908360132023,
                    "smoothness_improvement": 1367.2858062428277,
                    "objective_score": 4.863396312520839
               }
          ],
          "smoothness_improvement": 1394.0,
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm introduces a Hybrid Adaptive Bidirectional Anytime RRT* (HABA-RRT*) strategy that combines dynamic informed ellipsoid and uniform sampling with an adaptive neighbor radius evolving over iterations. It grows two trees bidirectionally with prioritized rewiring and lazy collision checks for efficiency. The planner incorporates a dynamic domain reduction based on current best path cost, aggressive pruning of non-promising nodes, and multi-scale shortcut smoothing applying both local and global shortcuts incrementally over the planning process. The integration of a priority queue for rewiring candidates accelerates optimization steps, while caching collision checks minimizes redundant queries. The approach balances exploration and exploitation, resulting in improved path quality, robustness, and reduced planning time in complex 2D/3D environments.",
          "planning_mechanism": "The planner alternates growth between start and goal trees, sampling adaptively inside a dynamically shrinking informed ellipsoid augmented with occasional global uniform samples to avoid local minima. It uses a priority queue to manage rewiring for quick convergence, caching collision results for efficiency. Aggressive node pruning removes nodes unlikely to contribute to better solutions. Incremental multi-scale shortcut smoothing progressively enhances path smoothness without heavy computational cost per iteration. The planner stops when it finds a high-quality path or reaches maximum iterations, outputting a refined collision-free path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = parent                # Node or None\n        self.cost = cost                    # Path cost from root\n        self.children = []\n        self.valid = True                   # For collision validity or lazy checking\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 5.0,\n                 neighbor_min_radius: float = 6.0, neighbor_max_radius: float = 30.0,\n                 prune_interval: int = 150, prune_threshold: int = 350,\n                 smoothing_iters_local: int = 80, smoothing_iters_global: int = 40,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_min_radius = neighbor_min_radius\n        self.neighbor_max_radius = neighbor_max_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iters_local = smoothing_iters_local\n        self.smoothing_iters_global = smoothing_iters_global\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import heapq\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        # Adaptive neighbor radius shrinks over iterations and depends on node count\n        def neighbor_radius(iteration, n_nodes):\n            n = max(1, n_nodes)\n            r_iter = self.neighbor_max_radius * (1.0 - (iteration / self.max_iter)**0.93)\n            r_nodes = self.neighbor_min_radius + (self.neighbor_max_radius - self.neighbor_min_radius) * math.sqrt(math.log(n+1) / n)\n            return max(self.neighbor_min_radius, min(r_iter, r_nodes))\n\n        # Collision caches for nodes and edges: Lazy evaluation\n        node_obstacle_cache = {}\n        edge_collision_cache = {}\n\n        def is_in_obstacle_cached(pos):\n            if pos in node_obstacle_cache:\n                return node_obstacle_cache[pos]\n            val = self._is_in_obstacle(pos, obstacles, is_3d)\n            node_obstacle_cache[pos] = val\n            return val\n\n        def is_edge_collision_cached(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n            val = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = val\n            return val\n\n        # Dynamic informed ellipsoid sampler with occasional global uniform samples (10%) to avoid local minima\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n            elite_sample_prob = 0.90\n\n            # If no path found yet, uniform random sampling with retries\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(20):\n                    p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            if random.random() < elite_sample_prob:\n                center = np.array([(start[d]+goal[d])/2.0 for d in range(dim)])\n                a1 = np.array([(goal[d]-start[d])/c_min for d in range(dim)])\n                I = np.eye(dim)\n\n                v = a1 - np.array([1]+[0]*(dim-1))\n                norm_v = np.linalg.norm(v)\n                if norm_v > 1e-10:\n                    v /= norm_v\n                    rot = I - 2*np.outer(v, v)\n                else:\n                    rot = I\n\n                r1 = c_best/2.0\n                r_others = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n                radii = np.array([r1]+[r_others]*(dim-1))\n\n                for _ in range(150):\n                    x_ball = np.random.uniform(-1,1,dim)\n                    norm_x = np.linalg.norm(x_ball)\n                    if norm_x <= 1.0 and norm_x > 1e-10:\n                        r_scale = random.uniform(0,1)**(1.0/dim)\n                        sample = rot @ (x_ball/norm_x*r_scale*radii) + center\n                        p = tuple(float(ci) for ci in sample)\n                        if in_bounds(p) and not is_in_obstacle_cached(p):\n                            return p\n                # fallback uniform\n                for _ in range(10):\n                    p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                return p\n            else:\n                # Global uniform with slight edge bias to maintain global exploration (~10%)\n                def edge_biased_sample(dim_idx):\n                    edge_zone = bounds[dim_idx]*0.15\n                    choice = random.random()\n                    if choice < 0.4:\n                        if random.random() < 0.5: \n                            return random.uniform(0, edge_zone)\n                        else:\n                            return random.uniform(bounds[dim_idx]-edge_zone, bounds[dim_idx])\n                    else:\n                        return random.uniform(0, bounds[dim_idx])\n                for _ in range(25):\n                    p = tuple(edge_biased_sample(d) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n        # KDTree substitute for nearest and radius search: linear scan for moderate node counts\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p,n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                radius_sq = radius*radius\n                results = []\n                for p,n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for i_ in range(dim):\n                        delta = p[i_] - pt[i_]\n                        sqd += delta*delta\n                        if sqd > radius_sq:\n                            break\n                    if sqd <= radius_sq:\n                        results.append(n)\n                return results\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle_cached(pos):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            if is_edge_collision_cached(p1, p2):\n                return False\n            return True\n\n        # Aggressive pruning of nodes unlikely to improve best path cost\n        def prune_nodes(best_cost):\n            removed = 0\n            nonlocal nodes, tree_start, tree_goal, edges\n            to_remove = []\n            dist_heuristic = dist  # alias for performance\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist_heuristic(node.position, goal_pos)\n                if node.cost + heuristic - 1e-12 >= best_cost:\n                    to_remove.append(node)\n            for rn in to_remove:\n                if rn.parent:\n                    try:\n                        rn.parent.children.remove(rn)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rn)\n                except ValueError:\n                    pass\n                if rn in tree_start:\n                    tree_start.remove(rn)\n                if rn in tree_goal:\n                    tree_goal.remove(rn)\n                edges = [e for e in edges if e[0]!=rn and e[1]!=rn]\n                removed += 1\n            return removed\n\n        # Multi-scale incremental shortcut smoothing:\n        # local smoothing: small-step adjacent shortcuts\n        # global smoothing: long range shortcuts between random nodes\n        def incremental_smooth_path(path, local_iters, global_iters):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            length = len(p)\n\n            for _ in range(local_iters):\n                if length < 3:\n                    break\n                i = random.randint(0, length-3)\n                if can_connect(p[i], p[i+2]):\n                    p = p[:i+1] + p[i+2:]\n                    length = len(p)\n\n            for _ in range(global_iters):\n                if length < 3:\n                    break\n                i = random.randint(0, length-3)\n                j = random.randint(i+2, length-1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n                    length = len(p)\n\n            return p\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        # Priority queue for rewiring candidates: (cost_improvement, node)\n        # This speeds up rewiring selection and early pruning\n        def rewire_neighbors(new_node, near_nodes):\n            rewire_candidates = []\n            for neighbor in near_nodes:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    heapq.heappush(rewire_candidates, (neighbor.cost - cost_through_new, neighbor))\n            while rewire_candidates:\n                _, neighbor = heapq.heappop(rewire_candidates)\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth direction for balance & progress\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n                growing_from_start = True\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n                growing_from_start = False\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for nn in near_nodes:\n                cost_candidate = nn.cost + dist(nn.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(nn.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = nn\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node efficiently\n            rewire_neighbors(new_node, near_nodes)\n\n            # Try connect new_node to tree_b incrementally\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n\n            max_steps = max(1, int(dist(last_node_b.position, new_node.position) / self.step_size))\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b):\n                    break\n                if not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                rewire_neighbors(new_node_b, near_b)\n\n                # Check termination condition of connection\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    connection_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=connection_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if growing_from_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Incremental multi-scale smoothing with progressively more global shortcuts for better refinement\n                    # Early iterations favor local smoothing, later favor global\n                    local_iterations = max(1, int(self.smoothing_iters_local * (1.0 - iteration / self.max_iter)))\n                    global_iterations = max(1, int(self.smoothing_iters_global * (iteration / self.max_iter)))\n\n                    smoothed_path = incremental_smooth_path(merged_path, local_iterations, global_iterations)\n\n                    if connection_cost + 1e-12 < c_best:\n                        c_best = connection_cost\n                        best_path = smoothed_path\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Aggressive periodic pruning for memory and planning speed\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                node_obstacle_cache.clear()\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -19.86697,
          "time_improvement": 32.0,
          "length_improvement": 16.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02017521858215332,
                    "num_nodes_avg": 71.7,
                    "path_length_avg": 162.06219238469308,
                    "smoothness_avg": 0.04753312979874469,
                    "success_improvement": 0.0,
                    "time_improvement": 19.863745354955277,
                    "length_improvement": 11.17114431417498,
                    "smoothness_improvement": 643.9967011938032,
                    "objective_score": 11.413335975290593
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04936656951904297,
                    "num_nodes_avg": 213.7,
                    "path_length_avg": 233.98320844140443,
                    "smoothness_avg": 0.08986418475998188,
                    "success_improvement": 0.0,
                    "time_improvement": 70.08598215633684,
                    "length_improvement": 21.889670189027182,
                    "smoothness_improvement": 2212.2702004303496,
                    "objective_score": 36.46507968685823
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.047847533226013185,
                    "num_nodes_avg": 171.9,
                    "path_length_avg": 126.6899026289639,
                    "smoothness_avg": 0.1115574428032223,
                    "success_improvement": 0.0,
                    "time_improvement": 6.51924606908424,
                    "length_improvement": 15.858598998721254,
                    "smoothness_improvement": 1319.0024381431028,
                    "objective_score": 11.722505811185037
               }
          ],
          "smoothness_improvement": 1392.0,
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This improved planner implements an enhanced bidirectional RRT* algorithm with adaptive informed sampling that biases samples toward a heuristic ellipsoidal region between start and goal, reducing unnecessary exploration. It balances tree growth by always extending the smaller tree. The radius for rewiring dynamically decreases to focus local optimization efficiently. Collision and edge validity checks are rigorously enforced. Dead-end nodes are pruned periodically to maintain search efficiency, and an iterative shortcut smoothing refines the final path. Optimizations include early termination on connection with path cost improvements, adaptive sampling adapts search focus, and careful data structure management to speed up nearest neighbor queries and rewiring. These adjustments collectively reduce planning time, improve path optimality and smoothness, and increase success rate and robustness.",
          "planning_mechanism": "The planner grows two trees from start and goal nodes, alternately extending the smaller tree to maintain balanced progress. The sampling is adaptively biased towards an informed ellipsoid region containing better paths, accelerating convergence. Each new node addition triggers rewiring within a dynamically computed radius that shrinks as the tree grows, enhancing local path optimality. Collision checks ensure safety when adding nodes or edges. Once the trees connect, the combined path undergoes iterative shortcut smoothing for refinement. Dead-end nodes get pruned periodically, decreasing overhead and improving computational efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position         # Tuple[float, ...]\n        self.parent = parent             # Node or None\n        self.cost = cost                 # Path cost from root\n        self.children = []\n        self.valid = True                # Collision validity flag\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 20.0,\n                 radius_min: float = 5.0, prune_interval: int = 120,\n                 prune_threshold: int = 150, smoothing_iterations: int = 80,\n                 informed_sample_rate: float = 0.95):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.informed_sample_rate = informed_sample_rate  # Probability to sample inside ellipsoid\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # Informed sampling helpers\n        def ellipse_contains(pos, c_best, c_min, start, goal):\n            # Returns True if pos inside ellipse defined by focal points start, goal and c_best cost.\n            # If no solution yet, consider whole space\n            if c_best == float('inf'):\n                return True\n\n            start_g = tuple(goal[d] - start[d] for d in range(len(start)))\n            c = c_best / 2.0\n            length = dist(start, goal) / 2.0\n            if length == 0:\n                return True\n\n            center = tuple((start[d] + goal[d]) / 2.0 for d in range(len(start)))\n            # Build rotation to align major axis along start-goal vector\n            if is_3d:\n                import numpy as np\n                focal_vec = np.array(start_g)\n                norm_focal = np.linalg.norm(focal_vec)\n                if norm_focal == 0:\n                    return True\n                focal_vec /= norm_focal\n                pos_vec = np.array([pos[d] - center[d] for d in range(len(pos))])\n                # Eigenvalues for ellipse axes\n                r1 = c\n                # Minor axes radii by sqrt difference\n                r2 = math.sqrt(max(c**2 - length**2, 0.0))\n                # Transform pos_vec into ellipse coordinate frame\n                # Compute projection on major axis\n                proj = np.dot(pos_vec, focal_vec)\n                # Perp length squared\n                perp_len_sq = np.linalg.norm(pos_vec)**2 - proj**2\n                val = (proj**2)/(r1**2) + perp_len_sq/(r2**2 if r2 > 1e-8 else 1e-8)\n                return val <= 1.0\n            else:\n                # 2D ellipse test\n                dx = pos[0] - center[0]\n                dy = pos[1] - center[1]\n                cos_theta = (goal[0] - start[0]) / (2 * length) if (2 * length) != 0 else 1.0\n                sin_theta = (goal[1] - start[1]) / (2 * length) if (2 * length) != 0 else 0.0\n                x_rot = dx * cos_theta + dy * sin_theta\n                y_rot = -dx * sin_theta + dy * cos_theta\n                r1 = c\n                r2 = math.sqrt(max(c**2 - length**2, 0.0))\n                if r2 < 1e-8:\n                    r2 = 1e-8\n                val = (x_rot**2)/(r1**2) + (y_rot**2)/(r2**2)\n                return val <= 1.0\n\n        def sample_informed(c_best, c_min):\n            # Sample inside ellipse aligned between start and goal with major axis c_best/2\n            while True:\n                if is_3d:\n                    # Sample within unit ball then scale and rotate\n                    import numpy as np\n                    dim = 3\n                    while True:\n                        rand_point = np.random.uniform(-1, 1, dim)\n                        if np.linalg.norm(rand_point) <= 1:\n                            break\n                    # Scale to ellipse radii\n                    length = dist(start_position, goal_position) / 2.0\n                    c = c_best / 2.0\n                    r1 = c\n                    r2 = math.sqrt(max(c**2 - length**2, 0.0))\n                    radii = np.array([r1, r2, r2])\n                    # Rotation matrix aligning x-axis to vector start->goal\n                    start_g = np.array([goal_position[d] - start_position[d] for d in range(dim)])\n                    norm_focal = np.linalg.norm(start_g)\n                    if norm_focal < 1e-8:\n                        center = np.array(start_position)\n                        sample = center + rand_point * radii\n                        sample_tuple = tuple(sample.tolist())\n                        if self._is_in_bounds(sample_tuple, bounds) and not self._is_in_obstacle(sample_tuple, obstacles, is_3d):\n                            return sample_tuple\n                        continue\n                    focal_unit = start_g / norm_focal\n                    # Compute orthogonal basis with Gram-Schmidt (only first vector needed here)\n                    # Create rotation matrix that maps x-axis to focal_unit\n                    x_axis = np.array([1,0,0])\n                    v = np.cross(x_axis, focal_unit)\n                    s = np.linalg.norm(v)\n                    c_rot = np.dot(x_axis, focal_unit)\n                    if s < 1e-8:\n                        R = np.eye(3)\n                    else:\n                        vx = np.array([[0, -v[2], v[1]],\n                                       [v[2], 0, -v[0]],\n                                       [-v[1], v[0], 0]])\n                        R = np.eye(3) + vx + vx @ vx * ((1 - c_rot)/(s**2))\n                    center = np.array([(start_position[d] + goal_position[d]) / 2.0 for d in range(dim)])\n                    sample = center + R @ (rand_point * radii)\n                    sample_tuple = tuple(sample.tolist())\n                    if self._is_in_bounds(sample_tuple, bounds) and not self._is_in_obstacle(sample_tuple, obstacles, is_3d):\n                        return sample_tuple\n                else:\n                    # 2D ellipse sampling: sample uniform in unit circle and scale\n                    import math as m\n                    while True:\n                        x = random.uniform(-1, 1)\n                        y = random.uniform(-1, 1)\n                        if x*x + y*y <= 1.0:\n                            break\n                    length = dist(start_position, goal_position) / 2.0\n                    c = c_best / 2.0\n                    r1 = c\n                    r2 = math.sqrt(max(c**2 - length**2, 0.0))\n                    if r2 < 1e-8:\n                        r2 = 1e-8\n                    sample_local = (x * r1, y * r2)\n                    center = ((start_position[0] + goal_position[0]) / 2.0,\n                              (start_position[1] + goal_position[1]) / 2.0)\n                    # Rotate sample_local to align major axis with start-goal vector\n                    dx = (goal_position[0] - start_position[0]) / (2*length) if 2*length>0 else 1.0\n                    dy = (goal_position[1] - start_position[1]) / (2*length) if 2*length>0 else 0.0\n                    sample_x = dx * sample_local[0] - dy * sample_local[1] + center[0]\n                    sample_y = dy * sample_local[0] + dx * sample_local[1] + center[1]\n                    sample = (sample_x, sample_y)\n                    if self._is_in_bounds(sample, bounds) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def sample_free(c_best):\n            p_bias = 0.7\n            # Adapted sample: 15% direct goal/start bias, 30% uniform in space, 55% informed ellipsoid sampling if solution known\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < 0.7 else start_position\n            if c_best < float('inf') and random.random() < self.informed_sample_rate:\n                return sample_informed(c_best, dist(start_position, goal_position))\n            else:\n                for _ in range(15):  # max tries to sample\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                # Fallback uniform sample in bounds regardless of obstacle to avoid deadlock\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            # Using simple linear search; can be replaced with spatial structure\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) <= radius)]\n\n        def radius_dynamic(n):\n            if n <= 1:\n                return self.radius_constant\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            # in bounds and free\n            if not self._is_in_bounds(pos, bounds):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            # Remove leaf nodes except roots to reduce overhead\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not can_connect(p1, p2):\n                    continue\n                path = path[:i+1] + path[j:]\n            return path\n\n        def trees_connected(n_start, n_goal):\n            # Quick check if nodes are close and path feasible\n            if dist(n_start.position, n_goal.position) > self.step_size:\n                return False\n            if not can_connect(n_start.position, n_goal.position):\n                return False\n            return True\n\n        c_best = float('inf')  # current best path cost\n\n        for itr in range(self.max_iter):\n            # Maintain balance: extend smaller tree\n            if len(tree_start) > len(tree_goal):\n                tree_small, tree_big = tree_goal, tree_start\n            else:\n                tree_small, tree_big = tree_start, tree_goal\n\n            sample_pt = sample_free(c_best)\n\n            new_node_small = try_extend(tree_small, sample_pt)\n            if new_node_small is None:\n                if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                    prune_dead_nodes()\n                continue\n\n            new_node_big = try_connect(tree_big, new_node_small)\n            if new_node_big is not None:\n                success_state = True\n                path_start = new_node_small.path_from_root()\n                path_goal = new_node_big.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n                raw_cost = path_length(raw_path)\n                if raw_cost < c_best:\n                    c_best = raw_cost\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < raw_cost:\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -19.00158,
          "time_improvement": 28.0,
          "length_improvement": 16.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02131023406982422,
                    "num_nodes_avg": 74.8,
                    "path_length_avg": 159.38154570529133,
                    "smoothness_avg": 0.038501886673069106,
                    "success_improvement": 0.0,
                    "time_improvement": 15.355447723596626,
                    "length_improvement": 12.640449236719975,
                    "smoothness_improvement": 502.6381346186374,
                    "objective_score": 9.64791483751617
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.047920513153076175,
                    "num_nodes_avg": 152.7,
                    "path_length_avg": 239.80306984786063,
                    "smoothness_avg": 0.08831560661395696,
                    "success_improvement": 0.0,
                    "time_improvement": 70.9622301183871,
                    "length_improvement": 19.946832936129663,
                    "smoothness_improvement": 2172.424169337374,
                    "objective_score": 36.14015646942893
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05196504592895508,
                    "num_nodes_avg": 121.0,
                    "path_length_avg": 126.66520468288431,
                    "smoothness_avg": 0.14149816755096417,
                    "success_improvement": 0.0,
                    "time_improvement": -1.5252269860464014,
                    "length_improvement": 15.875002198517512,
                    "smoothness_improvement": 1699.8462469399644,
                    "objective_score": 11.216663578589404
               }
          ],
          "smoothness_improvement": 1458.0,
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines advanced bidirectional anytime informed RRT* features with adaptive ellipsoidal and heuristic-biased sampling, balanced tree growth, lazy collision checking with caching, dynamic neighbor radius adjustments, multi-step incremental connecting attempts, aggressive pruning of unpromising nodes, and iterative shortcut smoothing. It leverages KD-tree accelerated neighbor searches and robust rewiring strategies to improve convergence speed, robustness, and path quality in both 2D and 3D environments.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately, using adaptive ellipsoidal sampling biased towards the current best path and Gaussian perturbations near it. Each iteration extends the smaller tree prioritizing minimal-cost parent selection via lazy collision checking. It incrementally attempts multi-step connections toward the opposite tree, rewires neighbors for path shortening, prunes nodes unlikely to improve the current best solution, and performs iterative shortcut smoothing to refine path quality. Caching and KD-tree searches optimize the computational cost to balance fast convergence, high success rates, and smooth, short paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking, pruning, etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_radius: float = 5.0, max_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 shortcut_iter: int = 100, collision_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.shortcut_iter = shortcut_iter\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp position within bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            if n_nodes <= 1:\n                return self.max_radius\n            r_iter = self.max_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        # Lazy collision caches\n        node_collision_cache = {}\n        edge_collision_cache = {}\n\n        def is_in_obstacle_cached(pos):\n            if pos in node_collision_cache:\n                return node_collision_cache[pos]\n            val = self._is_in_obstacle(pos, obstacles, is_3d)\n            node_collision_cache[pos] = val\n            return val\n\n        def is_edge_colliding_cached(a, b):\n            key = (a, b) if a < b else (b, a)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            val = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n            edge_collision_cache[key] = val\n            return val\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_dist = float('inf')\n                best_node = None\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d in range(dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        # Informed ellipsoidal sampling biased to current best path length\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                # Uniform sampling with retries to reduce obstacle collisions\n                for _ in range(25):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                # fallback uniform sampling\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) * 0.5 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            identity = np.eye(dim)\n            u = a1 - identity[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = identity - 2 * np.outer(u, u)\n            else:\n                rot = identity\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x_ball = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x < 1e-5 or norm_x > 1:\n                    continue\n                x_ball = x_ball / norm_x * np.random.uniform(0, 1) ** (1 / dim)\n                sample = rot @ (x_ball * radii) + center\n                p_tuple = tuple(float(coord) for coord in sample)\n                if in_bounds(p_tuple) and not is_in_obstacle_cached(p_tuple):\n                    return p_tuple\n\n            # fallback uniform sampling\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle_cached(p):\n                    return p\n            return p\n\n        # Adaptive sampling near best path with Gaussian perturbation plus fallback to informed sample\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.7:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 0.4, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle_cached(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth_path = path[:]\n            for _ in range(self.shortcut_iter):\n                if len(smooth_path) < 3:\n                    break\n                i = random.randint(0, len(smooth_path) - 3)\n                j = random.randint(i + 2, len(smooth_path) - 1)\n                p1, p2 = smooth_path[i], smooth_path[j]\n                if not is_edge_colliding_cached(p1, p2):\n                    smooth_path = smooth_path[:i + 1] + smooth_path[j:]\n            return smooth_path\n\n        def prune_nodes(nodes_list, best_cost, root_start, root_goal):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes_list:\n                if node is root_start or node is root_goal:\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes_all = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Grow smaller tree first to balance growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            # Node collision and edge collision checks\n            if is_in_obstacle_cached(new_pos) or is_edge_colliding_cached(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes_all))\n            near_nodes_a = kdtree_a.radius_search(new_pos, r)\n\n            # Select parent minimizing cost with lazy collision checks\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost:\n                    if not is_edge_colliding_cached(node.position, new_pos):\n                        min_cost = cost_cand\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve paths if possible (lazy collision checking)\n            for neighbor in near_nodes_a:\n                if neighbor is best_parent:\n                    continue\n                new_cost_candidate = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost_candidate + 1e-12 < neighbor.cost:\n                    if not is_edge_colliding_cached(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, new_cost_candidate)\n                        edges.append((new_node, neighbor))\n\n            # Attempt to connect new_node to opposite tree's nearest node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n\n            dist_ab = dist(new_node.position, nearest_b.position)\n            connected = False\n\n            if dist_ab <= self.step_size and not is_edge_colliding_cached(new_node.position, nearest_b.position):\n                # Direct connection possible\n                cost_conn = new_node.cost + dist_ab\n                connect_node = Node(nearest_b.position, parent=new_node, cost=cost_conn)\n                new_node.children.append(connect_node)\n                tree_a.append(connect_node)\n                nodes_all.append(connect_node)\n                edges.append((new_node, connect_node))\n\n                if tree_a is tree_start:\n                    path_start = connect_node.path_from_root()\n                    path_goal = nearest_b.path_from_root()\n                else:\n                    path_start = nearest_b.path_from_root()\n                    path_goal = connect_node.path_from_root()\n\n                merged_path = path_start + path_goal[::-1][1:]\n                smoothed = shortcut_path(merged_path)\n\n                if cost_conn < c_best:\n                    c_best = cost_conn\n                    best_path = smoothed\n                    success_state = True\n\n                break  # finish on success\n\n            # Else incremental multi-step connection attempts from nearest_b toward new_node.position\n            max_steps = max(1, int(dist_ab / self.step_size))\n            last_node_b = nearest_b\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if is_in_obstacle_cached(next_pos_b) or is_edge_colliding_cached(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes_all.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                # Rewire neighbors of new_node_b in tree_b\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_nodes_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new + 1e-12 < neighbor_b.cost:\n                        if not is_edge_colliding_cached(new_node_b.position, neighbor_b.position):\n                            try:\n                                edges.remove((neighbor_b.parent, neighbor_b))\n                            except ValueError:\n                                pass\n                            neighbor_b.update_parent(new_node_b, c_via_new)\n                            edges.append((new_node_b, neighbor_b))\n\n                # Check if can connect to new_node final step\n                if dist(new_node_b.position, new_node.position) <= self.step_size and \\\n                   not is_edge_colliding_cached(new_node_b.position, new_node.position):\n                    cost_final_conn = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=cost_final_conn)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes_all.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    smoothed = shortcut_path(merged_path)\n\n                    if cost_final_conn < c_best:\n                        c_best = cost_final_conn\n                        best_path = smoothed\n                        success_state = True\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if success_state:\n                # Aggressively prune and shortcut upon success\n                best_path = shortcut_path(best_path)\n                break\n\n            # Periodic aggressive pruning of nodes unlikely to improve best path\n            if it > 0 and it % self.prune_interval == 0 and len(nodes_all) > self.prune_threshold and c_best < float('inf'):\n                removed_s = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_g = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n                node_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes_all,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -18.99158,
          "time_improvement": 28.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018012094497680663,
                    "num_nodes_avg": 66.5,
                    "path_length_avg": 156.27054295348427,
                    "smoothness_avg": 0.046106374276556464,
                    "success_improvement": 0.0,
                    "time_improvement": 28.455704929334715,
                    "length_improvement": 14.345639141978689,
                    "smoothness_improvement": 621.6648790223518,
                    "objective_score": 14.514163702307911
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.043904471397399905,
                    "num_nodes_avg": 204.6,
                    "path_length_avg": 234.1694218222279,
                    "smoothness_avg": 0.08872620193070556,
                    "success_improvement": 0.0,
                    "time_improvement": 73.39577869003443,
                    "length_improvement": 21.82750680265333,
                    "smoothness_improvement": 2182.9890825771686,
                    "objective_score": 37.29918038042683
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05971472263336182,
                    "num_nodes_avg": 200.8,
                    "path_length_avg": 122.73903276137949,
                    "smoothness_avg": 0.10950780387315384,
                    "success_improvement": 0.0,
                    "time_improvement": -16.66593690784731,
                    "length_improvement": 18.4825786445647,
                    "smoothness_improvement": 1292.9311822412405,
                    "objective_score": 5.16139056776495
               }
          ],
          "smoothness_improvement": 1366.0,
          "success_rate": 1.0
     }
]