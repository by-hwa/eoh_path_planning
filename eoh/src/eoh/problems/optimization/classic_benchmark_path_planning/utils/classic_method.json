[
    {
        "algorithm": "RRT",
        "algorithm_description": "This is a basic implementation of the Classic RRT (Rapidly-exploring Random Tree) algorithm. It incrementally builds a tree rooted at the start position by sampling random points in the configuration space and extending the tree toward these samples. When a node reaches near the goal, the path is extracted by backtracking through the parent nodes.",
        "planning_mechanism": "\n1.Initialization\nThe tree is initialized with the start position as the root node. This root node becomes the first element in the list of nodes.\n2.Random Sampling\nWith a certain probability (goal_sample_rate), the goal position is directly sampled. Otherwise, a random point is sampled uniformly within the environment bounds.\n3.Nearest Node Selection\nThe algorithm searches the current tree to find the node closest to the sampled point using Euclidean distance.\n4.Steer\nA new position is computed by moving from the nearest node in the direction of the sampled point by a fixed distance (step_size).\n5.Collision Checking\nThe new position is checked for collision against all obstacles. If it is collision-free, the node is considered valid.\n6.Add to Tree\nThe new node is added to the tree with the nearest node set as its parent. It is also appended to the parent\u2019s list of children.\n7.Goal Check\nIf the new node is within step_size of the goal, a direct connection is made to the goal. The final path is then extracted by tracing back through parent links.\n8.Failure Case\nIf the goal is not reached within the maximum number of iterations (max_iter), the algorithm returns failure with the current state of the tree.\n",
        "code": "\n# --- Node class ---\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def distance(self, other: 'Node') -> float:\n        return math.dist(self.position, other.position)\n\n\n# --- Planner class implementing basic RRT ---\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 1.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        root = Node(start_position)\n        nodes: List[Node] = [root]\n\n        for _ in range(self.max_iter):\n            # 1. Sample random point\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            # 2. Find nearest node\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # 3. Steer\n            new_position = self._steer(nearest.position, sample, self.step_size)\n            new_node = Node(new_position, parent=nearest, cost=nearest.cost + math.dist(nearest.position, new_position))\n\n            # 4. Collision check\n            if not self._is_in_obstacle(new_position, obstacles, is_3d):\n                nearest.children.append(new_node)\n                nodes.append(new_node)\n\n                # 5. Check goal reached\n                if math.dist(new_position, goal_position) <= self.step_size:\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.children.append(goal_node)\n                    nodes.append(goal_node)\n\n                    path = self._extract_path(goal_node)\n                    edges = [(node.parent, node) for node in nodes if node.parent]\n                    return PlannerResult(True, path, nodes, edges)\n\n        # No valid path\n        edges = [(node.parent, node) for node in nodes if node.parent]\n        return PlannerResult(False, [], nodes, edges)\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], step_size: float) -> Tuple[float, ...]:\n        vec = [t - f for f, t in zip(from_pos, to_pos)]\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        scale = step_size / dist\n        return tuple(f + scale * d for f, d in zip(from_pos, vec))\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _extract_path(self, node: Node) -> List[Tuple[float, ...]]:\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n    "
    },
    {
        "algorithm": "RRT*",
        "algorithm_description": "RRT* (Rapidly-Exploring Random Tree Star) is an asymptotically optimal sampling-based path planning algorithm. It incrementally builds a space-filling tree rooted at the start state by randomly sampling the configuration space. Unlike standard RRT, RRT* improves path quality over time by optimizing the tree through local rewiring operations. This enables RRT* to converge toward the shortest or lowest-cost path as the number of samples increases.",
        "planning_mechanism": "\n1.Initialization\nStart with the root node at the start position and an empty list of explored nodes.\n2.Sampling\nAt each iteration, sample a random point within the environment. With a small probability (goal_sample_rate), directly sample the goal to bias the tree.\n3.Nearest Node Search\nFind the existing node in the tree that is closest to the sampled point.\n4.Steering\nMove from the nearest node towards the sampled point by a predefined step size to generate a candidate new node.\n5.Collision Checking\nDiscard the new node if it collides with any obstacle.\n6.Best Parent Selection\nAmong nodes within a specified neighborhood radius (nearby nodes), choose the one that connects to the new node with the minimum cumulative cost. Set this node as the parent.\n7.Rewiring\nFor each nearby node, check whether passing through the new node would reduce its total cost. If so, update its parent to the new node and update its cost.\n8.Goal Check\nIf the new node is close enough to the goal, add a final node at the goal position.\n9.Path Extraction\nOnce a goal node is connected, backtrack using parent pointers to extract the final path.\n10.Termination\nRepeat for a fixed number of iterations (max_iter) or until a satisfactory path is found.\n",
        "code": "\n# --- Node class ---\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []             # List[Node]\n        self.valid = True              # For collision checking etc.\n\n    def distance(self, other: 'Node') -> float:\n        return math.dist(self.position, other.position)\n\n\n# --- Planner class implementing RRT* ---\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 1.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        root = Node(start_position)\n        nodes: List[Node] = [root]\n\n        for _ in range(self.max_iter):\n            # 1. Sample\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            # 2. Nearest\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # 3. Steer\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # 4. Create node\n            new_node = Node(new_pos)\n\n            # 5. Find near neighbors\n            neighbors = [n for n in nodes if math.dist(n.position, new_pos) <= self.neighbor_radius]\n\n            # 6. Choose parent with lowest cost\n            best_parent = nearest\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            for neighbor in neighbors:\n                temp_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    best_parent = neighbor\n                    min_cost = temp_cost\n\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.children.append(new_node)\n            nodes.append(new_node)\n\n            # 7. Rewire neighbors\n            for neighbor in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = potential_cost\n                    new_node.children.append(neighbor)\n\n            # 8. Goal check\n            if math.dist(new_node.position, goal_position) <= self.step_size:\n                goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_node.position, goal_position))\n                new_node.children.append(goal_node)\n                nodes.append(goal_node)\n                path = self._extract_path(goal_node)\n                edges = [(n.parent, n) for n in nodes if n.parent]\n                return PlannerResult(True, path, nodes, edges)\n\n        # Failure\n        edges = [(n.parent, n) for n in nodes if n.parent]\n        return PlannerResult(False, [], nodes, edges)\n\n    def _steer(self, from_pos, to_pos, step_size):\n        vec = [t - f for f, t in zip(from_pos, to_pos)]\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        scale = step_size / dist\n        return tuple(f + scale * d for f, d in zip(from_pos, vec))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, steps=10):\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _extract_path(self, node: Node) -> List[Tuple[float, ...]]:\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n    "
    },
    {
        "algorithm": "RRT-Connect",
        "algorithm_description": "RRT-Connect is an extension of the Rapidly-Exploring Random Tree (RRT) algorithm designed for faster convergence in high-dimensional configuration spaces. It grows two trees simultaneously: one from the start and one from the goal. At each iteration, the algorithm attempts to connect the trees by extending one tree toward a random sample and then trying to \u201cconnect\u201d the other tree toward the new node in a greedy fashion. This bidirectional growth dramatically improves the speed of finding a solution path compared to basic RRT.",
        "planning_mechanism": "\n1.Initialization\nTwo trees are initialized:\n\t\u2022\tT_start rooted at the start position\n\t\u2022\tT_goal rooted at the goal position\n2.Random Sampling\nA random point is sampled from the free configuration space (with optional goal biasing).\n3.Extend First Tree\n\t\u2022\tThe nearest node in T_start is found.\n\t\u2022\tThe tree is extended greedily toward the sampled point using a step-size constraint.\n\t\u2022\tThe extension is continued until the path is blocked or the sample is reached.\n\t\u2022\tNew nodes are added along this path.\n4.Connect Second Tree\n\t\u2022\tThe nearest node in T_goal is found.\n\t\u2022\tThe tree attempts to connect greedily to the newly added node(s) in T_start.\n\t\u2022\tThis is done via repeated steps toward the target until a collision or success.\n5.Swap Trees\nAfter each iteration, T_start and T_goal are swapped to alternate which tree is extended and which is connected.\n6.Termination\nIf the two trees successfully connect, the final path is formed by tracing back from the meeting point to both the start and goal.\nIf no connection is found within the maximum number of iterations, the algorithm fails.\n",
        "code": "\n# --- Node class ---\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def distance(self, other: 'Node') -> float:\n        return math.dist(self.position, other.position)\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        tree_a: List[Node] = [Node(start_position)]\n        tree_b: List[Node] = [Node(goal_position)]\n\n        for _ in range(self.max_iter):\n            sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            if self._extend(tree_a, sample, obstacles, is_3d):\n                if self._connect(tree_b, tree_a[-1].position, obstacles, is_3d):\n                    path_a = self._extract_path(tree_a[-1])\n                    path_b = self._extract_path(tree_b[-1])\n                    full_path = path_a + path_b[::-1]\n                    nodes = tree_a + tree_b\n                    edges = [(n.parent, n) for n in nodes if n.parent]\n                    return PlannerResult(True, full_path, nodes, edges)\n\n            tree_a, tree_b = tree_b, tree_a\n\n        nodes = tree_a + tree_b\n        edges = [(n.parent, n) for n in nodes if n.parent]\n        return PlannerResult(False, [], nodes, edges)\n\n    def _extend(self, tree: List[Node], target: Tuple[float, ...], obstacles, is_3d: bool) -> bool:\n        nearest = min(tree, key=lambda n: math.dist(n.position, target))\n        new_pos = self._steer(nearest.position, target, self.step_size)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + math.dist(nearest.position, new_pos))\n            nearest.children.append(new_node)\n            tree.append(new_node)\n            return True\n        return False\n\n    def _connect(self, tree: List[Node], target: Tuple[float, ...], obstacles, is_3d: bool) -> bool:\n        while True:\n            if not self._extend(tree, target, obstacles, is_3d):\n                return False\n            if math.dist(tree[-1].position, target) <= self.step_size:\n                return True\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], step_size: float) -> Tuple[float, ...]:\n        vec = [t - f for f, t in zip(from_pos, to_pos)]\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        scale = step_size / dist\n        return tuple(f + scale * d for f, d in zip(from_pos, vec))\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _extract_path(self, node: Node) -> List[Tuple[float, ...]]:\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n    "
    },
    {
        "algorithm": "RRT*-Connect",
        "algorithm_description": "RRT*-Connect is a hybrid sampling-based motion planning algorithm that merges the strengths of RRT* and RRT-Connect. It grows two trees from the start and goal positions, extending them toward randomly sampled points. At each iteration, it attempts to connect the two trees. Additionally, it performs rewiring to improve path quality, as in RRT*, leading to an asymptotically optimal solution.",
        "planning_mechanism": "\n1.Initialization\n\t\u2022\tInitialize two trees: one rooted at the start and the other at the goal.\n\t\u2022\tInsert the root nodes (start and goal) into their respective trees.\n2.Sampling\n\t\u2022\tGenerate a random sample from the configuration space.\n\t\u2022\tWith a small probability (goal bias), use the opposite tree\u2019s root as the sample.\n3.Extension\n\t\u2022\tFor the active tree, find the nearest node to the sample.\n\t\u2022\tSteer toward the sample up to a fixed step size and create a new node.\n\t\u2022\tIf the new node is collision-free, add it to the tree.\n4.Rewiring\n\t\u2022\tSearch nearby nodes within a radius.\n\t\u2022\tRewire to minimize cost-to-come by changing parents if a cheaper path is found.\n\t\u2022\tUpdate child-parent relationships accordingly.\n5.Connection Attempt\n\t\u2022\tAttempt to connect the newly added node to the other tree by greedy extension (repeated steering and validation).\n\t\u2022\tIf successful and a continuous collision-free path is formed, proceed to extract the full path.\n6.Path Extraction\n\t\u2022\tIf both trees are connected, extract the path by tracing from the connection point to the start and goal.\n\t\u2022\tMerge and return the complete path as the solution.\n7.Termination\n\t\u2022\tStop when a connection is made and optionally continue for a while to refine the solution further.\n\t\u2022\tIf max iterations are reached without a connection, return failure.\n",
        "code": "\n# --- Node class ---\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n\n# --- Planner class implementing RRT*-Connect ---\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 1.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map: Map) -> PlannerResult:\n        from math import dist\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        tree_start: List[Node] = [Node(start_position)]\n        tree_goal: List[Node] = [Node(goal_position)]\n\n        for _ in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            # Extend from start tree\n            new_node_start = self._extend(tree_start, sample, obstacles, is_3d)\n            if new_node_start is None:\n                continue\n\n            # Connect from goal tree to the new node\n            new_node_goal = self._connect(tree_goal, new_node_start.position, obstacles, is_3d)\n\n            if new_node_goal:\n                # Trees connected, build path\n                path_from_start = self._extract_path(new_node_start)\n                path_from_goal = self._extract_path(new_node_goal)[::-1]\n                full_path = path_from_start + path_from_goal\n                all_nodes = tree_start + tree_goal\n                edges = [(n.parent, n) for n in all_nodes if n.parent]\n                return PlannerResult(True, full_path, all_nodes, edges)\n\n            # Swap trees\n            tree_start, tree_goal = tree_goal, tree_start\n\n        all_nodes = tree_start + tree_goal\n        edges = [(n.parent, n) for n in all_nodes if n.parent]\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _extend(self, tree: List[Node], sample: Tuple[float, ...], obstacles, is_3d: bool) -> Node:\n        from math import dist\n\n        nearest = min(tree, key=lambda n: dist(n.position, sample))\n        new_pos = self._steer(nearest.position, sample, self.step_size)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos, parent=nearest, cost=nearest.cost + dist(nearest.position, new_pos))\n        nearest.children.append(new_node)\n        tree.append(new_node)\n\n        # RRT* rewiring\n        near_nodes = [n for n in tree if dist(n.position, new_node.position) <= self.step_size * 2]\n        for neighbor in near_nodes:\n            potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n            if potential_cost < neighbor.cost and not self._is_in_obstacle(self._steer(new_node.position, neighbor.position, self.step_size), obstacles, is_3d):\n                neighbor.parent = new_node\n                neighbor.cost = potential_cost\n\n        return new_node\n\n    def _connect(self, tree: List[Node], target: Tuple[float, ...], obstacles, is_3d: bool) -> Node:\n        from math import dist\n\n        current = min(tree, key=lambda n: dist(n.position, target))\n        while True:\n            new_pos = self._steer(current.position, target, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            new_node = Node(new_pos, parent=current, cost=current.cost + dist(current.position, new_pos))\n            current.children.append(new_node)\n            tree.append(new_node)\n\n            if dist(new_pos, target) <= self.step_size:\n                return new_node\n            current = new_node\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], step: float) -> Tuple[float, ...]:\n        from math import dist\n        vec = [t - f for f, t in zip(from_pos, to_pos)]\n        d = dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        scale = step / d\n        return tuple(f + scale * v for f, v in zip(from_pos, vec))\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles, is_3d: bool) -> bool:\n        if is_3d:\n            for x, y, z, w, h, d in obstacles:\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            for x, y, w, h in obstacles:\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _extract_path(self, node: Node) -> List[Tuple[float, ...]]:\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    "
    },
    {
        "algorithm": "BI-RRT",
        "algorithm_description": "The Bidirectional Rapidly-exploring Random Tree (Bi-RRT) algorithm improves the efficiency of path planning by growing two trees simultaneously\u2014one from the start position and one from the goal. These two trees explore the space and attempt to connect to each other, significantly reducing the time required to find a path, especially in large or complex environments.",
        "planning_mechanism": "\n1.Initialization\nTwo trees are initialized: one rooted at the start position and one at the goal. Each tree starts with a single node.\n2.Random Sampling\nA random point is sampled within the configuration space bounds during each iteration.\n3.Tree Extension\nOne of the trees is chosen (alternating each iteration). The nearest node in this tree is found, and a new node is created by steering toward the random sample.\n4.Collision Checking\nThe new node is only added if it lies in free space (i.e., not inside any obstacle).\n5.Attempt to Connect Trees\nAfter extending one tree, the algorithm attempts to connect the new node to the nearest node in the opposite tree. If the two nodes are within a defined distance (usually \u2264 step_size), the connection is successful.\n6.Path Construction\nIf a connection is made between the two trees, the algorithm traces the paths from both root nodes (start and goal) to the meeting point and merges them to form the final path.\n7.Termination\nThe algorithm terminates successfully when the two trees connect. If the maximum number of iterations is reached without finding a connection, the algorithm fails.\n",
        "code": "\n# --- Node class ---\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def distance(self, other: 'Node') -> float:\n        return math.dist(self.position, other.position)\n\n# --- Main Planner ---\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map: 'Map') -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        tree_start: List[Node] = [Node(start_position)]\n        tree_goal: List[Node] = [Node(goal_position)]\n\n        for _ in range(self.max_iter):\n            sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            if self._try_extend(tree_start, sample, tree_goal, obstacles, is_3d):\n                path = self._extract_path(tree_start[-1]) + self._extract_path(tree_goal[-1])[::-1]\n                nodes = tree_start + tree_goal\n                edges = [(node.parent, node) for node in nodes if node.parent]\n                return PlannerResult(True, path, nodes, edges)\n\n            # Swap trees for next iteration\n            tree_start, tree_goal = tree_goal, tree_start\n\n        nodes = tree_start + tree_goal\n        edges = [(node.parent, node) for node in nodes if node.parent]\n        return PlannerResult(False, [], nodes, edges)\n\n    def _try_extend(self, tree: List[Node], sample: Tuple[float, ...], other_tree: List[Node], obstacles, is_3d) -> bool:\n        nearest = min(tree, key=lambda n: math.dist(n.position, sample))\n        new_position = self._steer(nearest.position, sample, self.step_size)\n\n        if self._is_in_obstacle(new_position, obstacles, is_3d):\n            return False\n\n        new_node = Node(new_position, parent=nearest, cost=nearest.cost + math.dist(nearest.position, new_position))\n        nearest.children.append(new_node)\n        tree.append(new_node)\n\n        # Try connecting to other tree\n        other_nearest = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n        if math.dist(new_node.position, other_nearest.position) <= self.step_size:\n            final_node = Node(other_nearest.position, parent=new_node, cost=new_node.cost + math.dist(new_node.position, other_nearest.position))\n            new_node.children.append(final_node)\n            tree.append(final_node)\n            other_tree.append(other_nearest)  # Ensure it's captured if not already\n            return True\n        return False\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], step_size: float) -> Tuple[float, ...]:\n        vec = [t - f for f, t in zip(from_pos, to_pos)]\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        scale = step_size / dist\n        return tuple(f + scale * d for f, d in zip(from_pos, vec))\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _extract_path(self, node: Node) -> List[Tuple[float, ...]]:\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n    "
    },
    {
        "algorithm": "BI-RRT*",
        "algorithm_description": "Bi-RRT* is an optimal path planning algorithm that extends the idea of Bidirectional RRT by incorporating the rewiring strategy of RRT* to improve path quality over time. It grows two trees simultaneously\u2014one from the start and one from the goal\u2014and attempts to connect them. As new nodes are added, it rewires nearby nodes to reduce the total cost, ensuring asymptotic optimality. This combination yields fast convergence and high-quality paths.",
        "planning_mechanism": "\n1.Initialization\nTwo trees are initialized: one rooted at the start node and the other at the goal node. Each tree starts with a single node.\n\t2.Random Sampling\nA random sample is generated within the bounds of the search space.\n\t3.Tree Expansion (Alternating Trees)\nThe algorithm alternates between expanding the start tree and the goal tree. For the active tree:\n\t\u2022\tThe nearest node to the sample is found.\n\t\u2022\tA new node is created by moving from the nearest node toward the sample by a fixed step size.\n\t\u2022\tIf the new node is not in collision, it is added to the tree.\n\t4.Parent Selection and Rewiring\nAmong nearby nodes within a specified radius, the parent with the lowest total cost is selected.\nAfter the node is added, the algorithm checks nearby nodes to see if rewiring through the new node would reduce their cost and updates their parent accordingly.\n\t5.Connection Attempt\nAfter a new node is added to one tree, the algorithm attempts to connect it to the other tree:\n\t\u2022\tIf a node in the other tree is within the step size and there\u2019s no collision, the trees are considered connected.\n\t6.Path Extraction\nIf the trees connect, the final path is extracted by tracing back from the connection point to both roots and concatenating the two paths.\n\t7.Termination\nThe algorithm stops when a path is found or the maximum number of iterations is reached. If a path is found, it will be near-optimal due to rewiring.\n",
        "code": "\n# --- Node class ---\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n# --- PlannerResult structure ---\nclass PlannerResult(NamedTuple):\n    success: bool\n    path: List[Tuple[float, ...]]\n    nodes: List[Node]\n    edges: List[Tuple[Node, Node]]\n\n# --- Bi-RRT* Planner ---\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 1.0, radius: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map: 'Map') -> PlannerResult:\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        tree_start: List[Node] = [Node(start_position)]\n        tree_goal: List[Node] = [Node(goal_position)]\n\n        success = False\n        connection_node = None\n\n        for _ in range(self.max_iter):\n            sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                nearest = min(tree_a, key=lambda n: self._dist(n.position, sample))\n                new_pos = self._steer(nearest.position, sample)\n                if self._in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n                near_nodes = [n for n in tree_a if self._dist(n.position, new_pos) <= self.radius]\n                best_parent = min(near_nodes, key=lambda n: n.cost + self._dist(n.position, new_pos), default=nearest)\n                new_node.parent = best_parent\n                new_node.cost = best_parent.cost + self._dist(best_parent.position, new_pos)\n                best_parent.children.append(new_node)\n                tree_a.append(new_node)\n\n                for near in near_nodes:\n                    new_cost = new_node.cost + self._dist(new_node.position, near.position)\n                    if new_cost < near.cost:\n                        near.parent = new_node\n                        near.cost = new_cost\n\n                # Try to connect the two trees\n                connect_node = self._try_connect(new_node, tree_b, is_3d, obstacles)\n                if connect_node:\n                    success = True\n                    connection_node = (new_node, connect_node)\n                    break\n            if success:\n                break\n\n        nodes = tree_start + tree_goal\n        edges = [(n.parent, n) for n in nodes if n.parent]\n        path = (\n            self._extract_path(connection_node[0])[:-1]\n            + self._extract_path(connection_node[1])[::-1]\n            if success else []\n        )\n\n        return PlannerResult(success, path, nodes, edges)\n\n    def _dist(self, a, b):\n        import math\n        return math.dist(a, b)\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        vec = [t - f for f, t in zip(from_pos, to_pos)]\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        scale = self.step_size / dist\n        return tuple(f + scale * v for f, v in zip(from_pos, vec))\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _try_connect(self, node, tree, is_3d, obstacles):\n        for n in tree:\n            if self._dist(n.position, node.position) <= self.step_size:\n                if not self._in_obstacle(n.position, obstacles, is_3d):\n                    return n\n        return None\n\n    def _extract_path(self, node: Node) -> List[Tuple[float, ...]]:\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n    "
    },
    {
        "algorithm": "Informed-RRT*",
        "algorithm_description": "Informed RRT* is an optimal sampling-based motion planning algorithm that improves the efficiency of RRT* by focusing the search space. Once a feasible solution is found, it restricts sampling to a prolate hyperspheroid (ellipsoid in 2D/3D) defined by the start and goal states and the cost of the current best solution. This results in faster convergence toward an optimal solution.",
        "planning_mechanism": "\n1.Initialization: Start with the root node at the start position.\n2.Sampling:\n\t\u2022\tBefore a solution is found: sample uniformly within the search space.\n\t\u2022\tAfter a solution is found: sample within the informed ellipsoid (heuristic-based subset).\n3.Nearest Node: Find the node in the tree closest to the sampled point.\n4.Steering: Move toward the sample, limited by a step size.\n5.Collision Check: Ensure the new edge is obstacle-free.\n6.Add Node: Add the new node to the tree.\n7.Rewire: Improve nearby nodes\u2019 paths by rewiring through the new node if it reduces cost.\n8.Update Best Path: If the new node reaches the goal and has a lower cost, update the best solution.\n9.Repeat until iteration or time limit is reached.\n",
        "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def distance(self, other_pos) -> float:\n        return math.dist(self.position, other_pos)\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map: Map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        start_node = Node(start_pos)\n        goal_node = Node(goal_pos)\n        nodes.append(start_node)\n        best_cost = float(\"inf\")\n        c_best = float(\"inf\")\n\n        for _ in range(self.max_iter):\n            if c_best < float(\"inf\"):\n                sample = self._sample_in_ellipse(start_pos, goal_pos, c_best, bounds)\n            else:\n                sample = self._sample_uniform(bounds)\n\n            nearest = self._nearest_node(nodes, sample)\n            new_pos = self._steer(nearest.position, sample)\n            if not self._collision(nearest.position, new_pos, obstacles, is_3d):\n                new_node = Node(new_pos)\n                near_nodes = self._find_near(nodes, new_node, radius=5.0)\n                min_cost = nearest.cost + nearest.distance(new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    if not self._collision(near.position, new_pos, obstacles, is_3d):\n                        cost = near.cost + near.distance(new_pos)\n                        if cost < min_cost:\n                            min_cost = cost\n                            min_parent = near\n\n                new_node.cost = min_cost\n                new_node.parent = min_parent\n                min_parent.children.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if not self._collision(new_pos, near.position, obstacles, is_3d):\n                        new_cost = new_node.cost + new_node.distance(near.position)\n                        if new_cost < near.cost:\n                            if near.parent:\n                                near.parent.children.remove(near)\n                            near.parent = new_node\n                            new_node.children.append(near)\n                            near.cost = new_cost\n                            edges.append((new_node, near))\n\n                if new_node.distance(goal_pos) <= self.step_size:\n                    if not self._collision(new_node.position, goal_pos, obstacles, is_3d):\n                        goal_node.parent = new_node\n                        goal_node.cost = new_node.cost + new_node.distance(goal_pos)\n                        new_node.children.append(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success_state = True\n                        c_best = goal_node.cost\n                        extracted_path = self._extract_path(goal_node)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_uniform(self, bounds):\n        return tuple(random.uniform(0, b) for b in bounds)\n\n    def _sample_in_ellipse(self, start, goal, c_best, bounds):\n        c_min = math.dist(start, goal)\n        if c_min == 0:\n            return self._sample_uniform(bounds)\n\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a = c_best / 2\n        b = math.sqrt(a**2 - (c_min / 2)**2)\n        while True:\n            x = random.uniform(-1, 1)\n            y = random.uniform(-1, 1)\n            if x**2 + y**2 <= 1:\n                break\n        sample = (\n            b * x + center[0],\n            a * y + center[1]\n        )\n        return self._clip_to_bounds(sample, bounds)\n\n    def _clip_to_bounds(self, sample, bounds):\n        return tuple(max(0, min(s, b)) for s, b in zip(sample, bounds))\n\n    def _nearest_node(self, nodes, point):\n        return min(nodes, key=lambda n: math.dist(n.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        vec = tuple(t - f for f, t in zip(from_pos, to_pos))\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(f + ratio * (t - f) for f, t in zip(from_pos, to_pos))\n\n    def _collision(self, from_pos, to_pos, obstacles, is_3d):\n        steps = int(math.dist(from_pos, to_pos) / 0.5)\n        if steps == 0:\n            steps = 1\n        for i in range(steps + 1):\n            inter = tuple(f + (t - f) * i / steps for f, t in zip(from_pos, to_pos))\n            if self._in_obstacle(inter, obstacles, is_3d):\n                return True\n        return False\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                if x <= pos[0] <= x + w and y <= pos[1] <= y + h and z <= pos[2] <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= pos[0] <= x + w and y <= pos[1] <= y + h:\n                    return True\n        return False\n\n    def _find_near(self, nodes, new_node, radius):\n        return [node for node in nodes if node.distance(new_node.position) <= radius]\n\n    def _extract_path(self, goal_node):\n        path = []\n        current = goal_node\n        while current:\n            path.append(current.position)\n            current = current.parent\n        return path[::-1]\n    "
    }
]