[
    {
        "operator": "m3",
        "algorithm_description": "This algorithm combines bidirectional search with adaptive rewiring and goal biasing to improve path planning efficiency and path quality. It incrementally grows two trees from start and goal, extends toward random samples with a bias toward the goal, and rewires locally to minimize path costs while ensuring collision-free nodes and edges. Upon connection of the two trees, it extracts a smooth and optimized path.",
        "planning_mechanism": "The planner samples points within bounds (with goal bias), extends each tree toward samples within a step size, performs local rewiring to reduce costs, and attempts to connect the two trees on each iteration. It strictly checks for collisions for both nodes and edges, ensuring valid paths. The bidirectional approach accelerates convergence, and rewiring optimizes path costs and smoothness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # Validity flag (collision-free)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if (\n                not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, new_node):\n            nearest_node = nearest(tree, new_node.position)\n            pos_new = new_node.position\n            if (\n                math.dist(nearest_node.position, pos_new) <= self.step_size and\n                not self._is_edge_in_obstacle(nearest_node.position, pos_new, obstacles, is_3d) and\n                not self._is_in_obstacle(pos_new, obstacles, is_3d)\n            ):\n                return nearest_node\n            return None\n\n        for iter_num in range(self.max_iter):\n            rand_point = sample_free()\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            connect_node_goal = try_connect(tree_goal, new_node_start)\n            if connect_node_goal:\n                # Connect by creating a new node in goal tree near new_node_start\n                new_node_goal = Node(new_node_start.position)\n                best_parent = connect_node_goal\n                neighbors = near_nodes(tree_goal, new_node_goal.position)\n\n                min_cost = best_parent.cost + math.dist(best_parent.position, new_node_goal.position)\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_node_goal.position)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_node_goal.position, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                best_parent.add_child(new_node_goal)\n                new_node_goal.cost = min_cost\n                tree_goal.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((best_parent, new_node_goal))\n\n                # Extract path from start root to new_node_start\n                path_start = new_node_start.path_from_root()\n                # Extract path from goal root to new_node_goal\n                path_goal = new_node_goal.path_from_root()\n                # Connect paths\n                extracted_path = path_start + path_goal[::-1][1:]  # Avoid duplicate node\n                success_state = True\n                break\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
        "objective": -20.70232,
        "time_improvement": 53.0,
        "length_improvement": 16.0,
        "smoothness_improvement": 310.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.016640830039978027,
                "num_nodes_avg": 160.6,
                "path_length_avg": 167.68313601037386,
                "smoothness_avg": 0.023542751007624492,
                "success_improvement": 0.0,
                "time_improvement": 32.983222929654985,
                "length_improvement": 8.090216043387771,
                "smoothness_improvement": 268.49517717140276,
                "objective_score": 12.855485973431062
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03169040679931641,
                "num_nodes_avg": 374.2,
                "path_length_avg": 235.3172522277793,
                "smoothness_avg": 0.017255337523919966,
                "success_improvement": 0.0,
                "time_improvement": 80.45166169229154,
                "length_improvement": 21.44432797481391,
                "smoothness_improvement": 343.99226300771477,
                "objective_score": 30.14432541768882
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.025929951667785646,
                "num_nodes_avg": 309.0,
                "path_length_avg": 122.50151738270351,
                "smoothness_avg": 0.032717793611091894,
                "success_improvement": 0.0,
                "time_improvement": 45.99413055784529,
                "length_improvement": 18.640325049814344,
                "smoothness_improvement": 316.1679197567731,
                "objective_score": 19.10714377610032
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This planner employs a bidirectional RRT* framework with adaptive step sizing and informed, goal-biased sampling. It grows two trees simultaneously from start and goal using incremental steering and collision-checked extensions. The planner attempts to connect the two trees at each iteration with careful rewiring of neighbors to improve path cost locally. It incorporates path smoothing by rewiring and integrates obstacle and boundary checks to maintain robustness and feasibility. This design balances efficient exploration with exploitation via selective tree expansions, delivering fast convergence to high-quality, smooth paths with reduced search time.",
        "planning_mechanism": "The planning mechanism grows two trees alternately from the start and goal positions by sampling points biased towards the goal and free space. Each extension steers towards sampled points within a constrained step size, performing collision checking on nodes and edges. Upon adding a new node, neighbors within a fixed radius are rewired to minimize path costs, enhancing path quality incrementally. The algorithm attempts to connect the two trees when they are sufficiently close, reconstructing an optimized path by joining the two tree branches. The process continues until a feasible path is found or iteration limits are reached.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success = False\n        final_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free(tree_toggle):\n            import random\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_toggle else start_pos\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def dist(a, b):\n            import math\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            import math\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, position):\n            return [n for n in tree if dist(n.position, position) <= self.neighbor_radius]\n\n        def collision_free_node(pos):\n            return (within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    # Update edges list: remove old edge where neighbor is child\n                    for idx in range(len(edges)-1, -1, -1):\n                        p, c = edges[idx]\n                        if c == neighbor:\n                            edges.pop(idx)\n                    edges.append((new_node, neighbor))\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, from_node):\n            nearest_node = nearest(tree, from_node.position)\n            d = dist(nearest_node.position, from_node.position)\n            if d <= self.step_size and collision_free_node(from_node.position) and collision_free_edge(nearest_node.position, from_node.position):\n                return nearest_node\n            return None\n\n        grow_start = True\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free(grow_start)\n\n            if grow_start:\n                new_node = extend(tree_start, rand_point)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                other_node = try_connect(tree_goal, new_node)\n                if other_node:\n                    neighbors = near_nodes(tree_goal, new_node.position)\n                    min_cost = other_node.cost + dist(other_node.position, new_node.position)\n                    best_parent = other_node\n                    for neighbor in neighbors:\n                        tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                        if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                            min_cost = tentative_cost\n                            best_parent = neighbor\n\n                    connecting_node = Node(new_node.position)\n                    best_parent.add_child(connecting_node)\n                    connecting_node.cost = min_cost\n                    tree_goal.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((best_parent, connecting_node))\n\n                    rewire(tree_goal, connecting_node, neighbors)\n\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node.path_from_root()\n\n                    final_path = path_start + path_goal[::-1][1:]\n                    success = True\n                    break\n\n            else:\n                new_node = extend(tree_goal, rand_point)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                other_node = try_connect(tree_start, new_node)\n                if other_node:\n                    neighbors = near_nodes(tree_start, new_node.position)\n                    min_cost = other_node.cost + dist(other_node.position, new_node.position)\n                    best_parent = other_node\n                    for neighbor in neighbors:\n                        tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                        if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                            min_cost = tentative_cost\n                            best_parent = neighbor\n\n                    connecting_node = Node(new_node.position)\n                    best_parent.add_child(connecting_node)\n                    connecting_node.cost = min_cost\n                    tree_start.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((best_parent, connecting_node))\n\n                    rewire(tree_start, connecting_node, neighbors)\n\n                    path_start = connecting_node.path_from_root()\n                    path_goal = new_node.path_from_root()\n\n                    final_path = path_start + path_goal[::-1][1:]\n                    success = True\n                    break\n\n            grow_start = not grow_start\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -18.297,
        "time_improvement": 49.0,
        "length_improvement": 13.0,
        "smoothness_improvement": 223.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.01619853973388672,
                "num_nodes_avg": 96.6,
                "path_length_avg": 165.34162304377773,
                "smoothness_avg": 0.01912530007267728,
                "success_improvement": 0.0,
                "time_improvement": 34.76443641314628,
                "length_improvement": 9.373636404026437,
                "smoothness_improvement": 199.352477391238,
                "objective_score": 13.300820591705362
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.041682767868041995,
                "num_nodes_avg": 284.9,
                "path_length_avg": 253.60776085655706,
                "smoothness_avg": 0.013151497826404157,
                "success_improvement": 0.0,
                "time_improvement": 74.287838807303,
                "length_improvement": 15.338429731427555,
                "smoothness_improvement": 238.39751171437626,
                "objective_score": 26.546025147048294
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.030299663543701172,
                "num_nodes_avg": 239.7,
                "path_length_avg": 129.31894887790818,
                "smoothness_avg": 0.026002197175538512,
                "success_improvement": 0.0,
                "time_improvement": 36.89306889394285,
                "length_improvement": 14.112511661901763,
                "smoothness_improvement": 230.74602879030036,
                "objective_score": 15.04415314451471
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "This planner implements an enhanced bidirectional RRT* path planning algorithm with hybrid rewiring and informed sampling to minimize path length and improve overall planning performance. It grows two trees simultaneously from start and goal, alternates their expansion, and incrementally attempts to connect them while rewiring locally to maintain and improve path optimality. The algorithm integrates goal biasing and neighborhood-based rewiring to dynamically optimize paths and reduce redundant exploration. Node parent-child relationships are carefully managed for cost and structural consistency, enabling efficient path extraction and smooth, short final paths.",
        "planning_mechanism": "The planning mechanism samples points with goal bias, extends one tree toward samples using step-size limited steering while performing local rewiring to optimize parent connections. Then, it incrementally connects and rewires the other tree toward the newly added node. Trees alternate growth each iteration. Collision checks on nodes and edges ensure validity. Successful connection merges two trees' paths into one optimal path. Neighborhood rewiring ensures continuous path cost improvement and smoothness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Sample point with goal bias towards opposite tree's root\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                # Remove duplicate connection node to avoid repetition\n                if path_b and path_b[0] == path_a[-1]:\n                    path_b = path_b[1:]\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(max(0, min(bounds[d], random.uniform(0, bounds[d]))) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        # Clamp new_pos within bounds\n        new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new_node if path cost improves\n        for neighbor in neighbors:\n            if neighbor is best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.parent.remove_child(neighbor)\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        curr_node = self._nearest(tree, target_pos)\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if better cost path found\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -20.33585,
        "time_improvement": 54.0,
        "length_improvement": 14.0,
        "smoothness_improvement": 259.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.011076927185058594,
                "num_nodes_avg": 73.3,
                "path_length_avg": 160.95861505039585,
                "smoothness_avg": 0.021816597870768388,
                "success_improvement": 0.0,
                "time_improvement": 55.55534297289412,
                "length_improvement": 11.776032538405214,
                "smoothness_improvement": 241.47713217807282,
                "objective_score": 20.22919506043964
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.036408853530883786,
                "num_nodes_avg": 236.7,
                "path_length_avg": 245.6476544824274,
                "smoothness_avg": 0.01438500763053753,
                "success_improvement": 0.0,
                "time_improvement": 77.47230060024279,
                "length_improvement": 17.995742358070167,
                "smoothness_improvement": 270.13660743592806,
                "objective_score": 28.19152168886651
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.03534677028656006,
                "num_nodes_avg": 224.6,
                "path_length_avg": 131.35812474865287,
                "smoothness_avg": 0.028835292141927295,
                "success_improvement": 0.0,
                "time_improvement": 29.00431801715044,
                "length_improvement": 12.758188143673454,
                "smoothness_improvement": 266.78278764544785,
                "objective_score": 12.586846972107061
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This algorithm implements an improved bidirectional RRT* planner with adaptive rewiring, goal biasing, and incremental connection to rapidly find collision-free, lower cost, and smooth paths. It effectively balances exploration and exploitation by growing start and goal trees simultaneously with goal-directed sampling, local rewiring to optimize tree costs, and precise collision checks. A time budget is enforced to guarantee timely returns.",
        "planning_mechanism": "The planner alternates growing two trees from start and goal positions toward randomly sampled points biased toward the goal. It incrementally extends trees within a step size, rewires neighbors within a fixed radius to minimize costs, and attempts to connect the trees. Collision checks prevent invalid nodes and edges. The best path found so far is returned if a time budget is exceeded, ensuring both efficiency and quality.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0, max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        start_time = time.perf_counter()\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        best_path_cost = float('inf')\n        best_path_nodes = (None, None)  # (node_in_start_tree, node_in_goal_tree)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (\n                not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if beneficial via the new node\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if (\n                    cost_through_new < neighbor.cost and\n                    not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d)\n                ):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n\n            return new_node\n\n        def try_connect_and_rewire(tree, new_node):\n            # Incrementally extend tree towards new_node.position within step size and rewire\n            target_pos = new_node.position\n            current_node = nearest(tree, target_pos)\n\n            while True:\n                dist = math.dist(current_node.position, target_pos)\n                if dist <= self.step_size:\n                    new_pos = target_pos\n                else:\n                    new_pos = steer(current_node.position, target_pos)\n\n                if (\n                    not self._within_bounds(new_pos, bounds) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d)\n                ):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_node_goal = Node(new_pos)\n                best_parent.add_child(new_node_goal)\n                new_node_goal.cost = min_cost\n                tree.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((best_parent, new_node_goal))\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    cost_through_new = new_node_goal.cost + math.dist(new_node_goal.position, neighbor.position)\n                    if (\n                        cost_through_new < neighbor.cost and\n                        not self._is_edge_in_obstacle(new_node_goal.position, neighbor.position, obstacles, is_3d)\n                    ):\n                        neighbor.update_parent(new_node_goal, cost_through_new)\n                        edges.append((new_node_goal, neighbor))\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n\n                if new_node_goal.position == target_pos:\n                    return new_node_goal\n                current_node = new_node_goal\n\n        def path_cost_sum(path_nodes: List[Node]):\n            if not path_nodes:\n                return float('inf')\n            return path_nodes[-1].cost\n\n        def merge_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Avoid duplicate middle node\n            return path_start + path_goal[::-1][1:]\n\n        for iter_num in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_time_sec:\n                # Time limit exceeded, extract best path so far if any\n                if success_state:\n                    extracted_path = merge_paths(best_path_nodes[0], best_path_nodes[1])\n                break\n\n            rnd_point = sample_free()\n\n            new_node_start = try_extend_and_rewire(tree_start, rnd_point)\n            if new_node_start is None:\n                # Swap trees to maintain balanced growth\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            connect_node_goal = try_connect_and_rewire(tree_goal, new_node_start)\n            if connect_node_goal:\n                # Connected trees successfully\n                total_cost = new_node_start.cost + connect_node_goal.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = (new_node_start, connect_node_goal)\n                    extracted_path = merge_paths(new_node_start, connect_node_goal)\n                    success_state = True\n                # Swap trees to keep balanced exploration\n                tree_start, tree_goal = tree_goal, tree_start\n                # Early break for success to reduce planning time\n                if success_state:\n                    break\n            else:\n                # Swap trees for next iteration\n                tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
        "objective": -18.94623,
        "time_improvement": 50.0,
        "length_improvement": 14.0,
        "smoothness_improvement": 271.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.017641496658325196,
                "num_nodes_avg": 84.5,
                "path_length_avg": 170.50120424036766,
                "smoothness_avg": 0.019952942408527338,
                "success_improvement": 0.0,
                "time_improvement": 25.59526263553606,
                "length_improvement": 6.545588191379452,
                "smoothness_improvement": 212.30687720138977,
                "objective_score": 10.049230814943657
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.04605059623718262,
                "num_nodes_avg": 254.1,
                "path_length_avg": 248.84054005866628,
                "smoothness_avg": 0.015314310037129148,
                "success_improvement": 0.0,
                "time_improvement": 80.80057589266545,
                "length_improvement": 16.92986525060597,
                "smoothness_improvement": 294.04822770699855,
                "objective_score": 29.09638695645582
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.06053769588470459,
                "num_nodes_avg": 277.0,
                "path_length_avg": 124.08694361494807,
                "smoothness_avg": 0.03189665894955138,
                "success_improvement": 0.0,
                "time_improvement": 42.15658580257741,
                "length_improvement": 17.587360436241912,
                "smoothness_improvement": 305.72314747183384,
                "objective_score": 17.693063565380776
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This algorithm implements a bidirectional RRT* planner with goal biasing, adaptive rewiring, and incremental tree connections to improve planning efficiency, path quality, and robustness. It grows two search trees simultaneously from start and goal points, dynamically rewires nodes to reduce path costs, biases sampling toward the goal to accelerate convergence, and enforces a maximum planning time. It terminates early upon finding a feasible path or time expiration, returning the best solution found.",
        "planning_mechanism": "The planner alternates growing and rewiring two trees from start and goal by sampling points (biased toward goal), extending nodes stepwise with collision checks, rewiring neighbors for cost reduction, and incrementally connecting the trees. If trees connect, the resultant low-cost path is extracted by merging paths from both trees. Within a 30-second limit, the algorithm balances exploration and exploitation to find smooth, short, and feasible paths efficiently.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]; 2D or 3D\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []              # List of child nodes\n        self.valid = True               # Validity flag for collision check\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_radius: float=15.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        import time\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        start_time = time.perf_counter()\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        success_state = False\n        extracted_path = []\n        best_path_cost = float('inf')\n        best_path_nodes = (None, None)  # Tuple of nodes in start and goal trees\n\n        def sample_free():\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dimension))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (\n                not within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                cost_thru_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_thru_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    neighbor.update_parent(new_node, cost_thru_new)\n                    edges.append((new_node, neighbor))\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n\n            return new_node\n\n        def try_connect_and_rewire(tree, new_node):\n            target = new_node.position\n            current_node = nearest(tree, target)\n\n            while True:\n                dist = math.dist(current_node.position, target)\n                if dist <= self.step_size:\n                    new_pos = target\n                else:\n                    new_pos = steer(current_node.position, target)\n\n                if (\n                    not within_bounds(new_pos) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d)\n                ):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_node_goal = Node(new_pos)\n                best_parent.add_child(new_node_goal)\n                new_node_goal.cost = min_cost\n                tree.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((best_parent, new_node_goal))\n\n                for neighbor in neighbors:\n                    cost_thru_new = new_node_goal.cost + math.dist(new_node_goal.position, neighbor.position)\n                    if cost_thru_new < neighbor.cost and not self._is_edge_in_obstacle(new_node_goal.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node_goal, cost_thru_new)\n                        edges.append((new_node_goal, neighbor))\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n\n                if new_node_goal.position == target:\n                    return new_node_goal\n                current_node = new_node_goal\n\n        def merge_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]  # Avoid duplicate middle node\n\n        for iter_num in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_time_sec:\n                # Time exceeded, return best path found (if any)\n                if success_state:\n                    extracted_path = merge_paths(best_path_nodes[0], best_path_nodes[1])\n                break\n\n            rnd_point = sample_free()\n\n            new_node_start = try_extend_and_rewire(tree_start, rnd_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            connect_node_goal = try_connect_and_rewire(tree_goal, new_node_start)\n            if connect_node_goal:\n                total_cost = new_node_start.cost + connect_node_goal.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = (new_node_start, connect_node_goal)\n                    extracted_path = merge_paths(new_node_start, connect_node_goal)\n                    success_state = True\n\n                tree_start, tree_goal = tree_goal, tree_start\n\n                # Optional early break to reduce planning time on success\n                if success_state:\n                    break\n            else:\n                tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -21.99894,
        "time_improvement": 59.0,
        "length_improvement": 15.0,
        "smoothness_improvement": 276.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.013381409645080566,
                "num_nodes_avg": 76.5,
                "path_length_avg": 166.83413501227932,
                "smoothness_avg": 0.019463577249412372,
                "success_improvement": 0.0,
                "time_improvement": 43.56259621891708,
                "length_improvement": 8.555566943725118,
                "smoothness_improvement": 204.64724978778887,
                "objective_score": 15.803128503359092
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.052031731605529784,
                "num_nodes_avg": 274.1,
                "path_length_avg": 246.89388693282086,
                "smoothness_avg": 0.015621323729922434,
                "success_improvement": 0.0,
                "time_improvement": 78.30691969788298,
                "length_improvement": 17.57971409531666,
                "smoothness_improvement": 301.94791115559445,
                "objective_score": 28.5177582842062
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.04690549373626709,
                "num_nodes_avg": 239.1,
                "path_length_avg": 124.15395131017871,
                "smoothness_avg": 0.033219353543958816,
                "success_improvement": 0.0,
                "time_improvement": 55.18207519016236,
                "length_improvement": 17.542857115633282,
                "smoothness_improvement": 322.5477250815371,
                "objective_score": 21.67593260558305
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This improved planner builds upon a bidirectional RRT* framework and integrates adaptive neighbor radius based on current exploration to enhance rewiring efficiency. It incorporates goal-biased sampling, incremental steering with collision checking, and frequent attempts to connect the two growing trees with incremental rewiring. It introduces early termination based on a 30-second time limit to maintain practical runtime while preserving solution quality. Path smoothing is applied via random shortcutting after path extraction to improve smoothness without significant overhead. The node structure supports efficient parent-child management and cost updates for robust path quality improvement.",
        "planning_mechanism": "The planner alternately grows two trees from start and goal positions through nearest neighbor extensions towards goal-biased random samples. Each new node is connected by rewiring nearby nodes within an adaptive radius, optimizing path costs dynamically. Frequent connection attempts link the two trees, forming feasible paths when proximity and obstacle-free edges permit. The process is bounded by a max iteration and a 30-second runtime limit. Upon success or timeout, the best path found is extracted and smoothed by shortcutting to reduce unnecessary waypoints and improve smoothness.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = parent                # Node or None\n        self.cost = cost                    # Total cost from root\n        self.children = []\n        self.valid = True                   # For obstacle validity if needed\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, max_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_time = max_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size  # Tuple[int, ...]\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        # Adaptive neighbor radius based on number of nodes and dimension (RRT*)\n        def adaptive_neighbor_radius(n_nodes):\n            gamma_rrt_star = 2 * (1.5 ** (1 / dim))  # approx. factor for dimensional space\n            r = min(self.step_size * 5.0, gamma_rrt_star * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim)))\n            # Minimum radius floor\n            return max(r, self.step_size * 1.5)\n\n        def sample_free(tree_toggle):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_toggle else start_pos\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            # simple linear search suffices\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [n for n in tree if dist(n.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=1.0)\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-7 < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost + 1e-7 < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, from_node):\n            nearest_node = nearest(tree, from_node.position)\n            d = dist(nearest_node.position, from_node.position)\n            if d <= self.step_size and collision_free_node(from_node.position) and collision_free_edge(nearest_node.position, from_node.position):\n                return nearest_node\n            return None\n\n        # Path shortcutting for smoothing: attempt random shortcuts on path to reduce waypoints\n        def path_shortcut(path: List[Tuple[float, ...]], max_attempts=50):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=1.0):\n                    # Remove nodes between i+1 and j-1\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = list(tree_start) + list(tree_goal)\n        edges = []\n\n        grow_start = True\n        success = False\n        final_path = []\n        # Store best cost and best nodes to extract feasible path after timeout\n        best_cost = float('inf')\n        best_connection = None  # (node_in_start_tree, node_in_goal_tree)\n\n        time_start = time.time()\n\n        for iter_num in range(self.max_iter):\n            elapsed = time.time() - time_start\n            if elapsed > self.max_time:\n                break  # Timeout\n\n            rand_point = sample_free(grow_start)\n\n            current_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(current_tree, rand_point)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            # Track edges added during extend\n            # (parent,new_node) must be collision free and checked during extend\n            edges.append((new_node.parent, new_node))\n\n            # Attempt to connect new_node to other_tree\n            connecting_node = try_connect(other_tree, new_node)\n            if connecting_node:\n                # Rewire other tree around possible connection point with adaptive radius\n                radius_other = adaptive_neighbor_radius(len(other_tree))\n                neighbors_other = near_nodes(other_tree, new_node.position, radius_other)\n\n                # Find best parent in other tree for connecting node\n                min_cost = connecting_node.cost + dist(connecting_node.position, new_node.position)\n                best_parent_other = connecting_node\n                for neighbor in neighbors_other:\n                    tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                    if tentative_cost + 1e-7 < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                        min_cost = tentative_cost\n                        best_parent_other = neighbor\n\n                connecting_node_other = Node(new_node.position)\n                best_parent_other.add_child(connecting_node_other)\n                connecting_node_other.cost = min_cost\n                other_tree.append(connecting_node_other)\n\n                edges.append((best_parent_other, connecting_node_other))\n\n                rewire(other_tree, connecting_node_other, neighbors_other)\n\n                # Extract paths from both trees\n                if grow_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node_other.path_from_root()\n                else:\n                    path_start = connecting_node_other.path_from_root()\n                    path_goal = new_node.path_from_root()\n\n                # Combine paths, remove duplicated node\n                joined_path = path_start + path_goal[::-1][1:]\n\n                # Update best cost and path if improved\n                total_cost = new_node.cost + connecting_node_other.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (path_start, path_goal[::-1])\n\n                # Mark success and break\n                final_path = joined_path\n                success = True\n                break\n\n            nodes.extend([new_node])\n            grow_start = not grow_start\n\n        # If not success but have best connection for partial path:\n        if not success and best_connection is not None:\n            path_start, path_goal_rev = best_connection\n            final_path = path_start + path_goal_rev[1:]\n            success = True if len(final_path) > 1 else False\n\n        # Post-processing: path smoothing via shortcutting if path found and more than 2 points\n        if success and len(final_path) > 2:\n            final_path = path_shortcut(final_path, max_attempts=75)\n\n        # Build edge list from nodes (parent-child)\n        edges.clear()\n        all_nodes = []\n        node_set = set()\n        def collect_nodes_and_edges(node):\n            if node in node_set:\n                return\n            node_set.add(node)\n            all_nodes.append(node)\n            for c in node.children:\n                edges.append((node, c))\n                collect_nodes_and_edges(c)\n\n        # Collect from both trees, avoid duplicates by set\n        for node in tree_start:\n            collect_nodes_and_edges(node)\n        for node in tree_goal:\n            collect_nodes_and_edges(node)\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -25.46582,
        "time_improvement": 54.0,
        "length_improvement": 15.0,
        "smoothness_improvement": 1244.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.019983816146850585,
                "num_nodes_avg": 96.8,
                "path_length_avg": 170.2199533723818,
                "smoothness_avg": 0.03191661323621712,
                "success_improvement": 0.0,
                "time_improvement": 15.716301131147329,
                "length_improvement": 6.6997462488276955,
                "smoothness_improvement": 399.5643051817539,
                "objective_score": 8.052661115018507
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.05431396961212158,
                "num_nodes_avg": 257.2,
                "path_length_avg": 236.52350437862407,
                "smoothness_avg": 0.08310278940495856,
                "success_improvement": 0.0,
                "time_improvement": 77.35540855616505,
                "length_improvement": 21.04164628681887,
                "smoothness_improvement": 2038.2946279093733,
                "objective_score": 37.606424963760155
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.03142735958099365,
                "num_nodes_avg": 216.0,
                "path_length_avg": 125.86434766351888,
                "smoothness_avg": 0.10952251178835211,
                "success_improvement": 0.0,
                "time_improvement": 69.97134180929318,
                "length_improvement": 16.406893298066827,
                "smoothness_improvement": 1293.1182658369369,
                "objective_score": 30.738372531586002
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid planner combines bidirectional RRT* with adaptive neighbor radius, incremental extend-and-rewire steps, and goal-biased sampling. It grows two trees alternately from start and goal, dynamically rewiring neighbors to optimize path cost and smoothness. Rigorous collision checks for nodes and edges ensure path validity. The algorithm enforces a 30-second runtime limit, returns the best feasible path found so far, and applies path smoothing for improved quality and shorter lengths.",
        "planning_mechanism": "The planner alternately samples points biased towards the opposite tree\u2019s root, extends the current tree incrementally with step-size limits, rewires neighbors within an adaptive radius to minimize cost, and attempts incremental connections to the other tree. On successful connection or timeout, it reconstructs and smooths the combined path. Nodes and edges are tracked for roadmap analysis.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n        if parent is not None:\n            self.parent.add_child(self)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Update parent and cost, then propagate cost updates recursively to children\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n        # Recursively update children's costs\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=4.0, goal_sample_rate: float=0.15,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of rectangular obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        best_cost = math.inf\n        best_connection = None\n        extracted_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        start_time = time.time()\n        tree_a, tree_b = start_tree, goal_tree  # Alternate expansions\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free(tree_from_root_pos, tree_to_root_pos):\n            # Goal-biased sampling towards opposite tree root\n            if random.random() < self.goal_sample_rate:\n                return tree_to_root_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                    return p\n            return tree_to_root_pos  # fallback\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius*radius\n            return [node for node in tree if (math.dist(node.position, position)**2) <= radius_sq]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = 25.0\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        def valid_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def valid_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def add_node(tree, new_pos, best_parent, cost):\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and valid_edge(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree, sample):\n            if len(tree) == 0:\n                return None\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not valid_node(new_pos):\n                return None\n            if not valid_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            if len(tree) == 0:\n                return None\n            nearest_node = nearest(tree, target_pos)\n            curr_node = nearest_node\n            max_steps = int(math.dist(curr_node.position, target_pos) / self.step_size) + 3\n            for _ in range(max_steps):\n                new_pos = steer(curr_node.position, target_pos)\n                if not valid_node(new_pos) or not valid_edge(curr_node.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                        min_cost = cost_through_neighbor\n                        best_parent = neighbor\n\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n                rewire(tree, new_node, neighbors)\n\n                curr_node = new_node\n                if math.dist(curr_node.position, target_pos) <= self.step_size:\n                    return curr_node\n            return None\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_iters=100) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            smoothed_path = path[:]\n            for _ in range(max_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not valid_edge(smoothed_path[i], smoothed_path[j]):\n                    continue\n                # Shortcut path\n                smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n                length = len(smoothed_path)\n            return smoothed_path\n\n        for _ in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.max_time_sec:\n                # Timeout reached\n                break\n\n            sample = sample_free(tree_a[0].position, tree_b[0].position)\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    # Combine with no duplicated connect node\n                    combined_path = path_a + path_b[::-1][1:]\n                    extracted_path = path_smoothing(combined_path, max_iters=100)\n                    success_state = True\n\n                # Early termination when found a connection\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If timeout or no early stop but found best path, reconstruct path\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined_path = path_a + path_b[::-1][1:]\n            extracted_path = path_smoothing(combined_path, max_iters=100)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -29.71144,
        "time_improvement": 64.0,
        "length_improvement": 18.0,
        "smoothness_improvement": 1391.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.01094198226928711,
                "num_nodes_avg": 71.9,
                "path_length_avg": 159.3879990283421,
                "smoothness_avg": 0.03611968111442979,
                "success_improvement": 0.0,
                "time_improvement": 53.851119734292496,
                "length_improvement": 12.636912068096395,
                "smoothness_improvement": 465.3514445837642,
                "objective_score": 21.009475556825848
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.055727267265319826,
                "num_nodes_avg": 295.1,
                "path_length_avg": 229.22588968501387,
                "smoothness_avg": 0.0851665813883569,
                "success_improvement": 0.0,
                "time_improvement": 76.76617620629713,
                "length_improvement": 23.477800121738362,
                "smoothness_improvement": 2091.3974821314937,
                "objective_score": 38.18240029689428
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.04135787487030029,
                "num_nodes_avg": 235.5,
                "path_length_avg": 122.57216148158086,
                "smoothness_avg": 0.13488954490947164,
                "success_improvement": 0.0,
                "time_improvement": 60.482792556160256,
                "length_improvement": 18.593406603050504,
                "smoothness_improvement": 1615.7850547379617,
                "objective_score": 29.942444361147988
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This algorithm implements a bidirectional RRT* variant with informed sampling, adaptive rewiring, and goal biasing to efficiently explore and connect the search space while ensuring collision-free expansions and edge validations. It balances exploration and exploitation with incremental tree growth from both start and goal, dynamically rewiring to optimize path cost, and returns the best path found within a 30-second time limit.",
        "planning_mechanism": "The planner grows two trees alternately from start and goal, initially sampling uniformly and switching to ellipsoidal informed sampling after a first solution is found. Each extension steers towards samples within a step size limit, performs collision checks on nodes and edges, rewires neighbors adaptively for cost improvements, and attempts incremental connections between trees. Upon connection or timeout, it returns the best valid path found.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position         # Tuple[float, ...]\n        self.parent = parent             # Node or None\n        self.cost = cost                 # Cost from root to this node\n        self.children = []\n        self.valid = True\n\n        if parent:\n            parent.add_child(self)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        # Propagate cost updates down the subtree\n        for child in self.children:\n            dist_to_child = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist_to_child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.15,\n                 neighbor_radius_min=10.0, neighbor_radius_max=30.0, max_time_sec=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def sample_uniform():\n            for _ in range(100):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))  # fallback\n\n        def informed_sample(c_best):\n            if c_best == math.inf:\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_best < c_min:\n                return sample_uniform()\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n\n            # Rotation matrix (2D and 3D)\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                R = [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                # 3D rotation matrix around axis v\n                vx, vy, vz = direction\n                k = (-0.0, -vy, -vz)\n                k_norm = math.sqrt(k[0]**2 + k[1]**2 + k[2]**2)\n                if k_norm < 1e-10:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    k = tuple(ki / k_norm for ki in k)\n                    cos_t = vx\n                    sin_t = k_norm\n                    Kx, Ky, Kz = k\n                    K = [[0,-Kz,Ky],[Kz,0,-Kx],[-Ky,Kx,0]]\n                    I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                    def mat_add(A,B):\n                        return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                    def mat_scale(A,s):\n                        return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                    def mat_mul(A,B):\n                        return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                    K2 = mat_mul(K,K)\n                    R = mat_add(mat_add(I, mat_scale(K, sin_t)), mat_scale(K2, 1 - cos_t))\n\n            # Ellipsoid radii\n            a1 = c_best / 2.0\n            a_minor = math.sqrt(max(c_best**2 - (c_min**2), 0.0)) / 2.0\n            radii = [a1] + [a_minor] * (dim - 1)\n\n            while True:\n                # Sample unit n-ball\n                vec = [random.gauss(0, 1) for _ in range(dim)]\n                norm_vec = math.sqrt(sum(x*x for x in vec))\n                unit_vec = [x / norm_vec for x in vec]\n                r = random.random() ** (1.0 / dim)\n                ball_sample = [r * unit_vec[i] * radii[i] for i in range(dim)]\n\n                # Rotate sample\n                if dim == 2:\n                    x_rot = R[0][0]*ball_sample[0] + R[0][1]*ball_sample[1]\n                    y_rot = R[1][0]*ball_sample[0] + R[1][1]*ball_sample[1]\n                    sample_pt = (center[0] + x_rot, center[1] + y_rot)\n                else:\n                    x_rot = sum(R[0][j]*ball_sample[j] for j in range(dim))\n                    y_rot = sum(R[1][j]*ball_sample[j] for j in range(dim))\n                    z_rot = sum(R[2][j]*ball_sample[j] for j in range(dim))\n                    sample_pt = (center[0] + x_rot, center[1] + y_rot, center[2] + z_rot)\n\n                clamped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(dim))\n                if not self._is_in_obstacle(clamped, obstacles, is_3d):\n                    return clamped\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_path_cost = math.inf\n        best_path = []\n\n        grow_start_tree = True\n        use_informed = False\n\n        start_time = time.perf_counter()\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                    except ValueError:\n                        pass\n                    nbr.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, nbr))\n\n        def extend(tree, sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                c = nbr.cost + math.dist(nbr.position, new_pos)\n                if c < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = c\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, from_node):\n            nearest_node = nearest(tree, from_node.position)\n            dist_curr = math.dist(nearest_node.position, from_node.position)\n            if dist_curr <= self.step_size and collision_free_edge(nearest_node.position, from_node.position) and collision_free_node(from_node.position):\n                return nearest_node\n            return None\n\n        while True:\n            iter_count = 0\n            while iter_count < self.max_iter:\n                elapsed = time.perf_counter() - start_time\n                if elapsed > self.max_time_sec:\n                    if best_path:\n                        return PlannerResult(success=True, path=best_path, nodes=all_nodes, edges=edges)\n                    return PlannerResult(success=False, path=[], nodes=all_nodes, edges=edges)\n\n                iter_count += 1\n\n                if use_informed:\n                    sample = informed_sample(best_path_cost)\n                else:\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if grow_start_tree else start_pos\n                    else:\n                        sample = sample_uniform()\n\n                if grow_start_tree:\n                    new_node = extend(start_tree, sample)\n                    if new_node is None:\n                        grow_start_tree = not grow_start_tree\n                        continue\n\n                    connect_node = try_connect(goal_tree, new_node)\n                    if connect_node:\n                        neighbors = near_nodes(goal_tree, new_node.position,\n                                               adaptive_neighbor_radius(len(goal_tree)))\n\n                        min_cost_local = connect_node.cost + math.dist(connect_node.position, new_node.position)\n                        best_parent_local = connect_node\n                        for nbr in neighbors:\n                            c = nbr.cost + math.dist(nbr.position, new_node.position)\n                            if c < min_cost_local and collision_free_edge(nbr.position, new_node.position):\n                                min_cost_local = c\n                                best_parent_local = nbr\n\n                        connecting_node = Node(new_node.position)\n                        best_parent_local.add_child(connecting_node)\n                        connecting_node.cost = min_cost_local\n                        goal_tree.append(connecting_node)\n                        all_nodes.append(connecting_node)\n                        edges.append((best_parent_local, connecting_node))\n\n                        rewire(goal_tree, connecting_node, neighbors)\n\n                        # Extract combined path\n                        path_start = new_node.path_from_root()\n                        path_goal = connecting_node.path_from_root()\n                        merged_path = path_start + path_goal[::-1][1:]\n                        cost_path = 0.0\n                        for i in range(len(merged_path)-1):\n                            cost_path += math.dist(merged_path[i], merged_path[i+1])\n\n                        if cost_path < best_path_cost:\n                            best_path_cost = cost_path\n                            best_path = merged_path\n                            use_informed = True\n                            # Return early on first feasible path found\n                            return PlannerResult(success=True, path=best_path, nodes=all_nodes, edges=edges)\n                else:\n                    new_node = extend(goal_tree, sample)\n                    if new_node is None:\n                        grow_start_tree = not grow_start_tree\n                        continue\n\n                    connect_node = try_connect(start_tree, new_node)\n                    if connect_node:\n                        neighbors = near_nodes(start_tree, new_node.position,\n                                               adaptive_neighbor_radius(len(start_tree)))\n\n                        min_cost_local = connect_node.cost + math.dist(connect_node.position, new_node.position)\n                        best_parent_local = connect_node\n                        for nbr in neighbors:\n                            c = nbr.cost + math.dist(nbr.position, new_node.position)\n                            if c < min_cost_local and collision_free_edge(nbr.position, new_node.position):\n                                min_cost_local = c\n                                best_parent_local = nbr\n\n                        connecting_node = Node(new_node.position)\n                        best_parent_local.add_child(connecting_node)\n                        connecting_node.cost = min_cost_local\n                        start_tree.append(connecting_node)\n                        all_nodes.append(connecting_node)\n                        edges.append((best_parent_local, connecting_node))\n\n                        rewire(start_tree, connecting_node, neighbors)\n\n                        path_start = connecting_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                        merged_path = path_start + path_goal[::-1][1:]\n                        cost_path = 0.0\n                        for i in range(len(merged_path)-1):\n                            cost_path += math.dist(merged_path[i], merged_path[i+1])\n\n                        if cost_path < best_path_cost:\n                            best_path_cost = cost_path\n                            best_path = merged_path\n                            use_informed = True\n                            return PlannerResult(success=True, path=best_path, nodes=all_nodes, edges=edges)\n\n                grow_start_tree = not grow_start_tree\n\n            break\n\n        if best_path:\n            return PlannerResult(success=True, path=best_path, nodes=all_nodes, edges=edges)\n        else:\n            return PlannerResult(success=False, path=[], nodes=all_nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -18.70121,
        "time_improvement": 50.0,
        "length_improvement": 14.0,
        "smoothness_improvement": 209.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.020652365684509278,
                "num_nodes_avg": 101.9,
                "path_length_avg": 161.09272527755476,
                "smoothness_avg": 0.020914734892580944,
                "success_improvement": 0.0,
                "time_improvement": 12.896628076868538,
                "length_improvement": 11.702524597786873,
                "smoothness_improvement": 227.36101814263648,
                "objective_score": 7.3462984333311185
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.05064387321472168,
                "num_nodes_avg": 297.6,
                "path_length_avg": 251.50120631194395,
                "smoothness_avg": 0.01163127030182631,
                "success_improvement": 0.0,
                "time_improvement": 78.88554590521389,
                "length_improvement": 16.04165827223005,
                "smoothness_improvement": 199.28096253136158,
                "objective_score": 27.870400238666985
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.04441468715667725,
                "num_nodes_avg": 234.4,
                "path_length_avg": 130.89357935919415,
                "smoothness_avg": 0.02366342243242298,
                "success_improvement": 0.0,
                "time_improvement": 57.56202630266056,
                "length_improvement": 13.066717072077614,
                "smoothness_improvement": 200.99698668826508,
                "objective_score": 20.886936238655014
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e1",
        "algorithm_description": "This algorithm implements a time-limited bidirectional RRT* with adaptive informed sampling and dynamic neighbor radius tuning. It combines goal-biased sampling with ellipsoidal informed sampling to focus exploration progressively, uses rewiring within a dynamically chosen neighbor radius to optimize path cost locally, and alternates growth between two trees starting from start and goal positions. Collision-free nodes and edges are guaranteed for safe and feasible path expansion. The algorithm stops early either upon a successful connection or exceeding the 30-second execution limit, returning the best found path with smoothing applied for improved smoothness and quality.",
        "planning_mechanism": "The planner grows two RRT* trees from start and goal alternately, sampling with a bias towards the goal and inside an ellipsoidal informed subset after the first feasible solution to accelerate convergence. Each extension steers toward a sampled point, rewires neighbors to optimize cost, and attempts incremental connection to the opposite tree with rewiring. Paths are merged on successful connection, smoothed for smoothness, and returned immediately. Execution time is tracked and enforced with early termination, returning the best feasible path found so far.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 100000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = 30.0     # Enforced 30 sec time limit\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D or 3D\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos, resolution=None):\n            if resolution is None:\n                resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=resolution)\n\n        # Unit ball sample for uniform direction sampling in nD\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n\n        informed_sampling_enabled = False\n\n        def sample_free():\n            while True:\n                sample = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if collision_free_node(sample):\n                    return sample\n\n        # Ellipsoidal informed sampling\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n\n            # Construct rotation matrix to align x-axis with direction vector\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                R = ((cos_a, -sin_a), (sin_a, cos_a))\n            else:\n                # Use Householder transform to rotate direction to x-axis\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-10:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    # Compute rotation matrix R that aligns x-axis with \"direction\"\n                    # Approach: compute orthonormal basis with \"direction\" as first vector\n                    ux, uy, uz = direction\n                    # Construct an arbitrary orthogonal basis:\n                    if abs(ux) < 1e-10 and abs(uy) < 1e-10:\n                        # direction close to z-axis:\n                        vx_, vy_, vz_ = 1,0,0\n                    else:\n                        vx_, vy_, vz_ = -uy, ux, 0\n                    norm_v_ = math.sqrt(vx_*vx_ + vy_*vy_ + vz_*vz_)\n                    vx_ /= norm_v_\n                    vy_ /= norm_v_\n                    vz_ /= norm_v_\n                    wx = uy * vz_ - uz * vy_\n                    wy = uz * vx_ - ux * vz_\n                    wz = ux * vy_ - uy * vx_\n\n                    R = [\n                        [ux, vx_, wx],\n                        [uy, vy_, wy],\n                        [uz, vz_, wz]\n                    ]\n\n            # Radii of prolate hyperspheroid\n            a1 = c_best / 2.0\n            if dim == 2:\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        # Adaptive neighbor radius for rewiring (following RRT* theory)\n        def adaptive_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return 50.0  # large initial radius\n            gamma_rrt = 30.0\n            return max(5.0, min(30.0, gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target):\n            nearest = min(tree, key=lambda n: dist(n.position, target))\n            new_pos = steer(nearest.position, target)\n            new_pos = clamp(new_pos)\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            neighbors_radius = adaptive_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        def try_connect(new_node, other_tree):\n            curr = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                next_pos = steer(curr.position, new_node.position)\n                next_pos = clamp(next_pos)\n\n                if not collision_free_node(next_pos) or not collision_free_edge(curr.position, next_pos):\n                    return None\n\n                radius = adaptive_radius(len(other_tree)+1)\n                neighbors = near_nodes(other_tree, next_pos, radius)\n\n                min_cost = curr.cost + dist(curr.position, next_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr == curr:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(next_pos)\n                best_parent.add_child(connect_node)\n                connect_node.cost = min_cost\n                other_tree.append(connect_node)\n\n                rewire(other_tree, connect_node, neighbors)\n\n                if dist(connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connect_node.position, new_node.position):\n                        return connect_node\n                    else:\n                        return None\n\n                curr = connect_node\n\n        def path_smooth(path: List[Tuple[float, ...]], max_trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_path = []\n        best_cost = math.inf\n        success_state = False\n\n        grow_start = True\n        iter_count = 0\n\n        while iter_count < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                # time limit exceeded: return best path so far\n                if best_path:\n                    smooth_path = path_smooth(best_path)\n                    return PlannerResult(True, smooth_path, all_nodes, edges)\n                else:\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            iter_count += 1\n\n            if informed_sampling_enabled:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < 0.15:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_free()\n\n            if grow_start:\n                new_node = extend(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = try_connect(new_node, tree_goal)\n                if connected_node is not None:\n                    path_s = new_node.path_from_root()\n                    path_g = connected_node.path_from_root()\n                    # Make sure to remove duplicate connecting node\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined = path_s + path_g[::-1]\n\n                    total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined\n                        informed_sampling_enabled = True\n\n                    # Refresh edges\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    smooth_path = path_smooth(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smooth_path, all_nodes, edges)\n\n            else:\n                new_node = extend(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = try_connect(new_node, tree_start)\n                if connected_node is not None:\n                    path_g = new_node.path_from_root()\n                    path_s = connected_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined = path_s + path_g[::-1]\n\n                    total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined\n                        informed_sampling_enabled = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    smooth_path = path_smooth(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smooth_path, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        # Max iterations reached - return best path if any\n        if best_path:\n            smooth_path = path_smooth(best_path)\n            return PlannerResult(True, smooth_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -23.98338,
        "time_improvement": 49.0,
        "length_improvement": 14.0,
        "smoothness_improvement": 1290.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.02227151393890381,
                "num_nodes_avg": 81.2,
                "path_length_avg": 176.73650863221073,
                "smoothness_avg": 0.04163013462817498,
                "success_improvement": 0.0,
                "time_improvement": 6.067711973228136,
                "length_improvement": 3.1279190494893707,
                "smoothness_improvement": 551.6020082152062,
                "objective_score": 5.203907442942346
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.04452013969421387,
                "num_nodes_avg": 216.7,
                "path_length_avg": 234.6283220155596,
                "smoothness_avg": 0.08281404133923359,
                "success_improvement": 0.0,
                "time_improvement": 81.43865415108714,
                "length_improvement": 21.674312709409516,
                "smoothness_improvement": 2030.8649322014446,
                "objective_score": 38.92078344821527
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.04296309947967529,
                "num_nodes_avg": 221.2,
                "path_length_avg": 122.72804706569131,
                "smoothness_avg": 0.1091637086355884,
                "success_improvement": 0.0,
                "time_improvement": 58.94900983445225,
                "length_improvement": 18.489874820558175,
                "smoothness_improvement": 1288.5543162178765,
                "objective_score": 27.825449495536688
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This algorithm implements a bidirectional RRT* planner with goal-biased and informed sampling, adaptive neighbor radius, incremental extend-and-rewire expansions, and progressive tree connection attempts. It dynamically rewires nodes to optimize path cost while respecting map boundaries and obstacles, applies multiple passes of path smoothing, and enforces a strict time limit of 30 seconds to ensure timely responses.",
        "planning_mechanism": "The planner grows two trees from start and goal, alternately extending towards sampled points generated with a bias towards the goal and an ellipsoidal informed region after an initial solution is found. Each extension attempts to connect to the opposite tree incrementally. Adaptive neighbor radius ensures locally appropriate rewiring for cost optimization. On connection, best paths from both trees are combined, smoothed, and returned. The process halts if time runs out, returning the best available path.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent = None                    # Node or None\n        self.cost = cost                     # Cost from root\n        self.children: List[Node] = []        # List of child nodes\n        self.valid = True                     # For collision validity\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost updates recursively to descendants\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                           # Tuple[int, ...]\n        start_pos = map.start                       # Tuple[float, ...]\n        goal_pos = map.goal                         # Tuple[float, ...]\n        obstacles = map.obstacles                   # List of obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0  # tuning parameter\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= radius_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Node:\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors for potentially better paths\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...]) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], trials: int = 100) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Rotation matrix helper for informed sampling\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        # Initialize trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges: List[Tuple[Node, Node]] = []\n\n        grow_tree_start = True\n\n        iter_cnt = 0\n        while iter_cnt < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            iter_cnt += 1\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_tree_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_tree_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if not new_node:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    # Avoid duplication of connection node\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    # Update edges\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    # Apply smoothing and return early\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if not new_node:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_tree_start = not grow_tree_start\n\n        # On timeout or iteration limit, return best path found (if any)\n        if best_path:\n            smoothed = path_smoothing(best_path)\n            success = True\n        else:\n            smoothed = []\n            success = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -28.07081,
        "time_improvement": 56.0,
        "length_improvement": 17.0,
        "smoothness_improvement": 1580.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.01549065113067627,
                "num_nodes_avg": 67.1,
                "path_length_avg": 160.82071621613,
                "smoothness_avg": 0.04018716215495074,
                "success_improvement": 0.0,
                "time_improvement": 34.666663985190205,
                "length_improvement": 11.851617074613193,
                "smoothness_improvement": 529.0163555443684,
                "objective_score": 15.415404388201543
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.04627766609191895,
                "num_nodes_avg": 218.8,
                "path_length_avg": 234.7337667638325,
                "smoothness_avg": 0.10335063168007959,
                "success_improvement": 0.0,
                "time_improvement": 80.70590588186646,
                "length_improvement": 21.639112217377225,
                "smoothness_improvement": 2559.2861935795413,
                "objective_score": 41.33602517593309
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.049237298965454104,
                "num_nodes_avg": 211.2,
                "path_length_avg": 125.59843408327171,
                "smoothness_avg": 0.13770665612117666,
                "success_improvement": 0.0,
                "time_improvement": 52.95404893761946,
                "length_improvement": 16.583500436623012,
                "smoothness_improvement": 1651.6185014133298,
                "objective_score": 27.46100727567709
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This implementation is an optimized bidirectional RRT* planner with adaptive rewiring, goal biasing, and time-budget enforcement to minimize planning time while maintaining path quality and robustness. It grows two trees from start and goal simultaneously, incrementally extends and rewires nodes, performs efficient collision checks, and halts early upon connection or timeout.",
        "planning_mechanism": "The planner alternates extending two trees grown from start and goal positions respectively toward randomly sampled, goal-biased points. It uses rewiring within a neighborhood radius to locally optimize the path cost. At each iteration, it attempts to connect the trees, terminating early once a collision-free linkage is found or the time limit expires, returning the best path discovered.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.15, neighbor_radius: float=12.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        start_time = time.perf_counter()\n\n        # Initialize two trees\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        success = False\n        best_path_cost = float('inf')\n        best_path_nodes = (None, None)\n        extracted_path = []\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...]) -> List[Node]:\n            return [node for node in tree if math.dist(node.position, pos) <= self.neighbor_radius]\n\n        def try_extend_and_rewire(tree: List[Node], point: Tuple[float, ...]) -> Node or None:\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (\n                not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if (\n                    cost_through_new < neighbor.cost and\n                    not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d)\n                ):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n\n            return new_node\n\n        def try_connect(tree: List[Node], target_node: Node) -> Node or None:\n            current_node = nearest(tree, target_node.position)\n            while True:\n                dist = math.dist(current_node.position, target_node.position)\n                if dist <= self.step_size:\n                    new_pos = target_node.position\n                else:\n                    new_pos = steer(current_node.position, target_node.position)\n\n                if (\n                    not self._within_bounds(new_pos, bounds) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d)\n                ):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if (\n                        cost_through_new < neighbor.cost and\n                        not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d)\n                    ):\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n\n                if new_node.position == target_node.position:\n                    return new_node\n                current_node = new_node\n\n        def merge_paths(node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]  # avoid duplicate joining node\n\n        for iter_num in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_time_sec:\n                if success:\n                    extracted_path = merge_paths(best_path_nodes[0], best_path_nodes[1])\n                break\n\n            rnd_point = sample_free()\n            new_node_start = try_extend_and_rewire(tree_start, rnd_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            connect_node_goal = try_connect(tree_goal, new_node_start)\n            if connect_node_goal:\n                total_cost = new_node_start.cost + connect_node_goal.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = (new_node_start, connect_node_goal)\n                    extracted_path = merge_paths(new_node_start, connect_node_goal)\n                    success = True\n                tree_start, tree_goal = tree_goal, tree_start\n                # Early termination on success for reduced planning time\n                break\n            else:\n                tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
        "objective": -18.76002,
        "time_improvement": 53.0,
        "length_improvement": 10.0,
        "smoothness_improvement": 179.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.019108223915100097,
                "num_nodes_avg": 98.8,
                "path_length_avg": 176.1973261808077,
                "smoothness_avg": 0.016264515390411786,
                "success_improvement": 0.0,
                "time_improvement": 19.409196995003406,
                "length_improvement": 3.4234534949960658,
                "smoothness_improvement": 154.5749848204143,
                "objective_score": 7.280324721602305
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.04307892322540283,
                "num_nodes_avg": 286.6,
                "path_length_avg": 252.26151991778178,
                "smoothness_avg": 0.011662148021780783,
                "success_improvement": 0.0,
                "time_improvement": 82.03952641933448,
                "length_improvement": 15.78784370618765,
                "smoothness_improvement": 200.07546850611288,
                "objective_score": 28.76980400956844
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.04527461528778076,
                "num_nodes_avg": 224.4,
                "path_length_avg": 133.24569451252,
                "smoothness_avg": 0.022121184403052812,
                "success_improvement": 0.0,
                "time_improvement": 56.74037000503455,
                "length_improvement": 11.50455418292619,
                "smoothness_improvement": 181.3798327908465,
                "objective_score": 20.229921002049835
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This algorithm implements a bidirectional RRT* planner with informed ellipsoidal sampling, adaptive neighbor rewiring, and incremental connection attempts to efficiently find smooth, low-cost paths within a 30-second limit. It maintains two trees grown alternately from start and goal, leveraging collision-free incremental expansions, dynamic rewiring to optimize path cost locally, and path shortcut smoothing to improve final solution quality. Early termination upon path discovery or timeout ensures time-bounded planning.",
        "planning_mechanism": "The planner grows two trees from start and goal positions by sampling points biased towards the goal and, after a path is found, within an informed ellipsoid. Nodes are incrementally connected and rewired using an adaptive neighbor radius to reduce path cost. The planner alternates tree growth, performs collision checks on nodes and edges, and applies path shortcutting to smooth the final path before returning the best solution found within 30 seconds.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position         # Tuple[float, ...]\n        self.parent = None               # Node or None\n        self.cost = cost                 # Cost from root\n        self.children = []\n        self.valid = True\n\n        if parent:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def _distance(self, a, b):\n        from math import dist\n        return dist(a, b)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-10:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=5.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(src, tgt):\n            d = dist(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def collision_free_node(p):\n            return in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return 20.0\n            r = 20.0 * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(8.0, min(20.0, r))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (dist(n.position, pos) ** 2) <= radius_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx**2 + ky**2 + kz**2)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def informed_sample(c_best, c_min):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample):\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n            r = neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                cost_thru = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_node):\n            curr = min(tree, key=lambda n: dist(n.position, target_node.position))\n            while True:\n                new_pos = steer(curr.position, target_node.position)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr.position, new_pos):\n                    return None\n                r = neighbor_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, r)\n\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr is curr:\n                        continue\n                    cost_thru = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_node.position) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    else:\n                        return None\n                curr = new_node\n\n        def path_smoothing(path, iterations=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling_active = False\n        c_min = dist(start_pos, goal_pos)\n        grow_start_tree = True\n\n        start_time = time.perf_counter()\n\n        for _ in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            sample = informed_sample(best_cost, c_min) if informed_sampling_active else (\n                goal_pos if random.random() < 0.2 else uniform_sample()\n            )\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(start_tree, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(goal_tree, new_node)\n                if connect_node:\n                    path_s = new_node.path_from_root()\n                    path_g = connect_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        # Early return on improved path\n                        smoothed = path_smoothing(best_path)\n                        nodes = start_tree + goal_tree\n                        edges = []\n                        for node in nodes:\n                            for c in node.children:\n                                edges.append((node, c))\n                        return PlannerResult(True, smoothed, nodes, edges)\n            else:\n                new_node = extend_and_rewire(goal_tree, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(start_tree, new_node)\n                if connect_node:\n                    path_g = new_node.path_from_root()\n                    path_s = connect_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        smoothed = path_smoothing(best_path)\n                        nodes = start_tree + goal_tree\n                        edges = []\n                        for node in nodes:\n                            for c in node.children:\n                                edges.append((node, c))\n                        return PlannerResult(True, smoothed, nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        if best_path:\n            success_state = True\n            smoothed = path_smoothing(best_path)\n        else:\n            success_state = False\n            smoothed = []\n\n        nodes = start_tree + goal_tree\n        edges = []\n        for node in nodes:\n            for c in node.children:\n                edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -28.11571,
        "time_improvement": 55.0,
        "length_improvement": 18.0,
        "smoothness_improvement": 1604.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.019519495964050292,
                "num_nodes_avg": 70.2,
                "path_length_avg": 155.1714439963092,
                "smoothness_avg": 0.041852322405292755,
                "success_improvement": 0.0,
                "time_improvement": 17.674616909189453,
                "length_improvement": 14.948072696743845,
                "smoothness_improvement": 555.0797294155799,
                "objective_score": 11.067398259183504
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.06700973510742188,
                "num_nodes_avg": 318.4,
                "path_length_avg": 232.16109678947745,
                "smoothness_avg": 0.10635019012507274,
                "success_improvement": 0.0,
                "time_improvement": 72.06228738014165,
                "length_improvement": 22.497943505016327,
                "smoothness_improvement": 2636.4669928638355,
                "objective_score": 39.30060987936494
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.026527929306030273,
                "num_nodes_avg": 182.2,
                "path_length_avg": 124.3356742878965,
                "smoothness_avg": 0.1352033003313838,
                "success_improvement": 0.0,
                "time_improvement": 74.65271876929245,
                "length_improvement": 17.422165366551436,
                "smoothness_improvement": 1619.7760005456682,
                "objective_score": 33.979128706826366
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius, ellipsoidal informed sampling after an initial solution, incremental tree connection, and rewiring for path cost improvement. It alternately grows trees from start and goal within given bounds and obstacles, ensuring collision-free expansions and edges, with realtime time limit enforcement and path smoothing for enhanced path quality.",
        "planning_mechanism": "The planner maintains two trees growing from start and goal respectively, sampling points either uniformly or within an ellipsoidal informed region biased by the best path cost. It extends one tree towards the sample, rewires neighbors for cost optimization, then incrementally connects to the opposite tree with rewiring. Upon a connection, it extracts and smooths the path, terminating early if time limit is reached or a path is found.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent))\n\n    def _distance(self, other):\n        return math.dist(self.position, other.position)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for c in self.children:\n            c.update_parent(self, new_cost + c._distance(self))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 100000, step_size: float=5.0,\n                 max_planning_time: float=30.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=5.0,\n                 neighbor_radius_max: float=30.0,\n                 smoothing_trials: int=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = max_planning_time\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_p, to_p):\n            dist_ = math.dist(from_p, to_p)\n            if dist_ <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist_\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_p, to_p):\n            resolution = self.step_size / 5.0 if self.step_size > 0 else 0.5\n            return not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d, resolution=resolution)\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            val = 30.0 * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, val))\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            return [node for node in tree if (math.dist(node.position, pos) ** 2) <= r2]\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_enabled = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                vx /= norm_v\n                vy /= norm_v\n                vz /= norm_v\n                arbitrary = (1.0, 0.0, 0.0) if abs(vx) < 0.9 else (0.0, 1.0, 0.0)\n                wx = vy*arbitrary[2] - vz*arbitrary[1]\n                wy = vz*arbitrary[0] - vx*arbitrary[2]\n                wz = vx*arbitrary[1] - vy*arbitrary[0]\n                norm_w = math.sqrt(wx*wx + wy*wy + wz*wz)\n                if norm_w < 1e-12:\n                    wx, wy, wz = 0.0, 0.0, 1.0\n                else:\n                    wx /= norm_w\n                    wy /= norm_w\n                    wz /= norm_w\n                ux, uy, uz = vx, vy, vz\n                vx_, vy_, vz_ = wx, wy, wz\n                wx_, wy_, wz_ = uy*wz - uz*vy_, uz*vx_ - ux*wz, ux*vy_ - uy*vx_\n                return [\n                    [ux, vx_, wx_],\n                    [uy, vy_, wy_],\n                    [uz, vz_, wz_]\n                ]\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                r = random.random() ** (1.0 / n)\n                sample_unit = tuple(r * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def sample_free():\n            for _ in range(30):\n                pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return goal_pos  # fallback\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-9 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n        def extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, sample_pt))\n            new_pos = steer(nearest_node.position, sample_pt)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n            n_radius = adaptive_neighbor_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, n_radius)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                if tentative_cost + 1e-9 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(new_node, other_tree):\n            if not other_tree:\n                return None\n            current_node = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            while True:\n                step_pos = steer(current_node.position, new_node.position)\n                step_pos = clamp_to_bounds(step_pos)\n                if not collision_free_node(step_pos) or not collision_free_edge(current_node.position, step_pos):\n                    return None\n                radius = adaptive_neighbor_radius(len(other_tree)+1)\n                neighbors = near_nodes(other_tree, step_pos, radius)\n                min_cost = current_node.cost + math.dist(current_node.position, step_pos)\n                best_parent = current_node\n                for nbr in neighbors:\n                    if nbr == current_node:\n                        continue\n                    tentative_cost = nbr.cost + math.dist(nbr.position, step_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, step_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n                connect_node = Node(step_pos)\n                connect_node.update_parent(best_parent, min_cost)\n                other_tree.append(connect_node)\n                rewire(other_tree, connect_node, neighbors)\n                if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connect_node.position, new_node.position):\n                        return connect_node\n                    else:\n                        return None\n                current_node = connect_node\n\n        def path_smoothing(path, max_trials):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(max_trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        # Initialization\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_path_nodes = []\n        best_path_cost = math.inf\n        informed_sampling_enabled = False\n        grow_start = True\n\n        start_time = time.perf_counter()\n        iter_count = 0\n        while iter_count < self.max_iter:\n            iter_count += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed >= self.max_planning_time:\n                # Time exceeded, return best path found\n                if best_path_nodes:\n                    smoothed = path_smoothing(best_path_nodes, self.smoothing_trials)\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(True, smoothed, all_nodes, edges)\n                else:\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            # Sample point\n            if informed_sampling_enabled:\n                sample_pt = informed_sample(best_path_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(active_tree, sample_pt)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            connect_node = incremental_connect(new_node, other_tree)\n            if connect_node is not None:\n                if grow_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                else:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                # Compute combined cost\n                total_cost = 0.0\n                for i in range(len(combined_path)-1):\n                    total_cost += math.dist(combined_path[i], combined_path[i+1])\n\n                if total_cost + 1e-9 < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = combined_path\n                    informed_sampling_enabled = True\n\n                edges.clear()\n                all_nodes = tree_start + tree_goal\n                for node in all_nodes:\n                    for c in node.children:\n                        edges.append((node, c))\n\n                smoothed_path = path_smoothing(best_path_nodes, self.smoothing_trials)\n                return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        # Max iterations reached\n        if best_path_nodes:\n            smoothed_path = path_smoothing(best_path_nodes, self.smoothing_trials)\n            edges.clear()\n            all_nodes = tree_start + tree_goal\n            for node in all_nodes:\n                for c in node.children:\n                    edges.append((node, c))\n            return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n        edges.clear()\n        all_nodes = tree_start + tree_goal\n        for node in all_nodes:\n            for c in node.children:\n                edges.append((node, c))\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -28.86429,
        "time_improvement": 56.0,
        "length_improvement": 19.0,
        "smoothness_improvement": 1675.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.01880507469177246,
                "num_nodes_avg": 64.1,
                "path_length_avg": 158.15395981511193,
                "smoothness_avg": 0.04238641838992204,
                "success_improvement": 0.0,
                "time_improvement": 20.68775849014105,
                "length_improvement": 13.313308515470546,
                "smoothness_improvement": 563.4394913830222,
                "objective_score": 11.686186707051533
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.04519479274749756,
                "num_nodes_avg": 223.3,
                "path_length_avg": 232.93837097407726,
                "smoothness_avg": 0.11965000592321515,
                "success_improvement": 0.0,
                "time_improvement": 81.15737766058118,
                "length_improvement": 22.23846700959999,
                "smoothness_improvement": 2978.6808328201532,
                "objective_score": 43.68831086419512
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.035725188255310056,
                "num_nodes_avg": 197.3,
                "path_length_avg": 120.17187027929853,
                "smoothness_avg": 0.12455155358138663,
                "success_improvement": 0.0,
                "time_improvement": 65.86479165859849,
                "length_improvement": 20.187565730021888,
                "smoothness_improvement": 1484.2865681158646,
                "objective_score": 31.218383484163247
            }
        ],
        "success_rate": 1.0
    }
]