[
    {
        "operator": "m3",
        "algorithm_description": "Simplified RRT* planner with goal biasing and fixed neighbor radius, focusing on clarity and robustness while maintaining adaptive rewiring and collision checking. The planner grows a single tree by sampling free space or goal with a probability, extending the nearest node toward samples with fixed step size, rewiring neighbors within a constant radius to improve path costs, and connecting to the goal when reachable. Planning stops when time limit or iteration budget is reached, returning the best path found.",
        "planning_mechanism": "The algorithm samples points with goal bias, extends the nearest tree node toward the sample using a fixed step size after collision checks, selects the best parent among nearby nodes using a constant radius for rewiring, rewires neighbors to reduce costs while ensuring collision-free edges, and attempts goal connection when within step size. It records nodes and edges coherently and returns success status and best path upon completion or timeout.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent:\n            parent.children.append(self)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1, neighbor_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(frm, to, step):\n            d = dist(frm, to)\n            if d <= step:\n                return to\n            ratio = step / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(frm, to, resolution=1.0):\n            distance = dist(frm, to)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                pt = tuple(frm[d] + (to[d] - frm[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(pt):\n                    return True\n            return False\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n        success = False\n        best_path = []\n        best_goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            nearest = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            # Find neighbors within fixed radius\n            near_nodes = [node for node in nodes if dist(node.position, new_pos) <= self.neighbor_radius]\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for node in near_nodes:\n                cost_through_node = node.cost + dist(node.position, new_pos)\n                if cost_through_node < min_cost and not edge_in_obstacle(node.position, new_pos):\n                    min_cost = cost_through_node\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes:\n                if node == best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost < node.cost and not edge_in_obstacle(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Attempt goal connection\n            if dist(new_node.position, goal_pos) <= self.step_size:\n                if not in_obstacle(goal_pos) and not edge_in_obstacle(new_node.position, goal_pos):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist(new_node.position, goal_pos)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    # Extract path\n                    path = []\n                    cur = goal_node\n                    while cur:\n                        path.append(cur.position)\n                        cur = cur.parent\n                    best_path = path[::-1]\n                    best_goal_node = goal_node\n                    success = True\n                    break\n\n        if not success and nodes:\n            closest = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            path = []\n            cur = closest\n            while cur:\n                path.append(cur.position)\n                cur = cur.parent\n            best_path = path[::-1]\n\n        return PlannerResult(success, best_path, nodes, edges)",
        "objective": 29.61958,
        "time_improvement": -135.0,
        "length_improvement": 17.0,
        "smoothness_improvement": 170.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.05429637432098389,
                "num_nodes_avg": 331.4,
                "path_length_avg": 170.81499121557914,
                "smoothness_avg": 0.015409562646928202,
                "success_improvement": 0.0,
                "time_improvement": -121.51427167987083,
                "length_improvement": 6.373596577993225,
                "smoothness_improvement": 141.19311782529843,
                "objective_score": -31.92415796803882
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.20041484832763673,
                "num_nodes_avg": 962.2,
                "path_length_avg": 232.45333671582574,
                "smoothness_avg": 0.011532766289412601,
                "success_improvement": 0.0,
                "time_improvement": -12.0500623099593,
                "length_improvement": 22.400385405941385,
                "smoothness_improvement": 196.74638334238452,
                "objective_score": 10.808944467288965
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.4073710203170776,
                "num_nodes_avg": 898.2,
                "path_length_avg": 118.12973147669986,
                "smoothness_avg": 0.021483807722149535,
                "success_improvement": 0.0,
                "time_improvement": -271.7873291352426,
                "length_improvement": 21.543857086507963,
                "smoothness_improvement": 173.2724484560096,
                "objective_score": -67.74352224638795
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e1",
        "algorithm_description": "A unidirectional RRT* inspired algorithm with adaptive neighbor search radius scaling, dynamic rewiring to improve path quality during incremental growth, and time-constrained exploration enforcing collision-free constraints and early stopping with best path returned. The planner grows a single tree from start, incrementally steering towards random samples, rewiring neighborhoods using a theoretically justified radius, and attempts direct connections to goal when in range to ensure path convergence.",
        "planning_mechanism": "A single tree rooted at the start expands by sampling random collision-free states within bounds. For each sampled point, the nearest tree node is steered towards it with a fixed step size. New nodes are connected to the lowest-cost neighbor found in a dynamically computed radius to improve path cost. Local rewiring is performed to optimize path quality. When a new node is close enough to the goal, the planner attempts to connect directly to the goal, validating collision-free edges and updating the best path if improved. The planning proceeds within a hard 30-second time limit, returning the best feasible path found so far.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"] = None, cost: float = 0.0):\n        self.position = position         # Tuple[float, ...]\n        self.parent = parent             # Optional[Node]\n        self.cost = cost                 # Path cost to this node\n        self.children: List[\"Node\"] = [] # List of child nodes\n\n    def add_child(self, child: \"Node\") -> None:\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        cur = self\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = 50.0  # scaling for radius\n        self.max_radius = 60.0      # upper bound on neighbor radius\n        self.TIME_LIMIT = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_pos, parent=None, cost=0.0)\n        nodes.append(root)\n\n        best_goal_node: Optional[Node] = None\n        best_cost = math.inf\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > self.TIME_LIMIT:\n                break\n\n            rnd = self._sample_free(bounds, obstacles, is_3d)\n            nearest = self._nearest(nodes, rnd)\n            new_pos = self._steer(nearest.position, rnd)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            neighbors = self._near(nodes, new_pos, bounds)\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            min_parent = nearest\n            # Find best parent from neighbors\n            for n in neighbors:\n                cost_through_n = n.cost + self._dist(n.position, new_pos)\n                if cost_through_n < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through_n\n                    min_parent = n\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors if beneficial\n            for n in neighbors:\n                if n == min_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, n.position)\n                if cost_through_new < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d):\n                    # Rewire: remove old edge\n                    if n.parent is not None:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        if n in n.parent.children:\n                            n.parent.children.remove(n)\n                    # Add new parent-child edge\n                    new_node.add_child(n)\n                    n.cost = cost_through_new\n                    edges.append((new_node, n))\n\n            # Attempt connection to goal if close enough\n            dist_to_goal = self._dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d) and\n                    not self._is_in_obstacle(goal_pos, obstacles, is_3d)):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n\n            # Early stopping if solution found and time remains enough\n            if best_goal_node is not None and (time.monotonic() - start_time < self.TIME_LIMIT * 0.9):\n                # Optionally could prioritize more improvement, but here break early\n                break\n\n        success = (best_goal_node is not None)\n        extracted_path = best_goal_node.path_from_root() if success else []\n\n        return PlannerResult(success=success, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        attempts = 0\n        max_attempts = 1000\n        while attempts < max_attempts:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n            attempts += 1\n        # fallback in case of dense obstacles\n        return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n    def _nearest(self, nodes: List[Node], point: Tuple[float, ...]) -> Node:\n        return min(nodes, key=lambda n: self._dist(n.position, point))\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n        return math.dist(a, b)\n\n    def _near(self, nodes: List[Node], position: Tuple[float, ...], bounds=None) -> List[Node]:\n        n = max(len(nodes), 1)\n        d = len(position)\n        scale = max(1.0, sum(bounds)/d if bounds is not None else 1.0)\n        radius_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = min(radius_theory * 1.1 + scale*0.01, self.max_radius)\n        # Return neighbors within radius\n        return [node for node in nodes if self._dist(node.position, position) <= radius]\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles, is_3d) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles, is_3d, resolution=1.0) -> bool:\n        dist = self._dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 38.52299,
        "time_improvement": -160.0,
        "length_improvement": 14.0,
        "smoothness_improvement": 169.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.13740262985229493,
                "num_nodes_avg": 736.0,
                "path_length_avg": 165.6389692973759,
                "smoothness_avg": 0.015194004275516227,
                "success_improvement": 0.0,
                "time_improvement": -460.56493383329206,
                "length_improvement": 9.210656210676376,
                "smoothness_improvement": 137.81916122020544,
                "objective_score": -131.95399061748077
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.24984548091888428,
                "num_nodes_avg": 999.7,
                "path_length_avg": 247.3606138345263,
                "smoothness_avg": 0.008081446728356607,
                "success_improvement": 0.0,
                "time_improvement": -39.686265456022404,
                "length_improvement": 17.423907221538386,
                "smoothness_improvement": 107.9414451514142,
                "objective_score": -0.9118280781266204
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.08575613498687744,
                "num_nodes_avg": 455.1,
                "path_length_avg": 126.80630865397129,
                "smoothness_avg": 0.02842277145458693,
                "success_improvement": 0.0,
                "time_improvement": 21.73462815563979,
                "length_improvement": 15.781287659570605,
                "smoothness_improvement": 261.5355549515882,
                "objective_score": 17.296838817192242
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "This algorithm is a bidirectional RRT* planner with fixed neighbor radius and optimized rewiring to improve path smoothness and planning efficiency. It grows two trees from start and goal, repeatedly samples collision-free configurations, and rewires locally to reduce path cost. The planner attempts connections between the trees after each extension, terminating early when an optimal path is found or time limit is reached. The fixed neighbor radius speeds up neighbor searches and collisions checks, while consistent rewiring improves the path smoothness.",
        "planning_mechanism": "The planner alternates extending two trees toward random free samples within bounds, rewires the trees locally within a fixed radius, and attempts to connect them. The search terminates when a feasible path from start to goal is found or a 30-second timeout occurs. The output is the best path found to date with node and edge information.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n        best_path = []\n        success = False\n\n        best_cost = float('inf')\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(len(from_p)))\n\n        def is_colliding(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_colliding(p1, p2):\n            d = dist(p1, p2)\n            step_count = max(1, int(d / 1.0))\n            for i in range(step_count + 1):\n                inter = tuple(p1[j] + (p2[j] - p1[j]) * (i / step_count) for j in range(len(p1)))\n                if is_colliding(inter):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            current = node_start\n            while current:\n                path_start.append(current.position)\n                current = current.parent\n            path_start.reverse()\n\n            path_goal = []\n            current = node_goal\n            while current:\n                path_goal.append(current.position)\n                current = current.parent\n\n            # Remove duplicate point at connection\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n\n            return path_start + path_goal\n\n        # Attempt to connect two nodes by straight-line if collision free\n        def can_connect(n1, n2):\n            return dist(n1.position, n2.position) <= self.step_size and not is_edge_colliding(n1.position, n2.position)\n\n        def try_connect_tree(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            if can_connect(new_node, nearest_node):\n                return nearest_node\n            return None\n\n        def rewire(tree, new_node):\n            near_nodes = near(tree, new_node.position, self.radius)\n            # Choose best parent from near nodes\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                if not is_edge_colliding(near_node.position, new_node.position):\n                    cost_through_near = near_node.cost + dist(near_node.position, new_node.position)\n                    if cost_through_near < min_cost:\n                        min_cost = cost_through_near\n                        min_parent = near_node\n            # Re-assign parent if better\n            if min_parent != new_node.parent:\n                if new_node.parent:\n                    try:\n                        new_node.parent.children.remove(new_node)\n                    except ValueError:\n                        pass\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n            # Try rewiring near nodes to new_node\n            for near_node in near_nodes:\n                if near_node == new_node:\n                    continue\n                edge_free = not is_edge_colliding(new_node.position, near_node.position)\n                if edge_free:\n                    potential_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if potential_cost < near_node.cost:\n                        if near_node.parent:\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = potential_cost\n                        new_node.add_child(near_node)\n\n        # Update best solution path and cost\n        def update_best_path(node_start, node_goal):\n            nonlocal best_cost, best_path, success\n            candidate_path = extract_path(node_start, node_goal)\n            candidate_cost = node_start.cost + node_goal.cost + dist(node_start.position, node_goal.position)\n            if candidate_cost < best_cost:\n                best_cost = candidate_cost\n                best_path = candidate_path\n                success = True\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            rand_sample = None\n            # Goal bias 5%\n            if random.random() < 0.05:\n                rand_sample = goal_pos\n            else:\n                found_sample = False\n                while not found_sample:\n                    dim = len(bounds)\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_colliding(sample):\n                        rand_sample = sample\n                        found_sample = True\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, rand_sample)\n                new_pos = steer(nearest_node.position, rand_sample, self.step_size)\n\n                if is_colliding(new_pos):\n                    continue\n                if is_edge_colliding(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                new_node.parent = nearest_node\n                new_node.cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Rewire within fixed radius\n                rewire(tree_a, new_node)\n\n                # Try connect trees\n                connect_node = try_connect_tree(new_node, tree_b)\n                if connect_node:\n                    update_best_path(new_node, connect_node)\n\n            if success:\n                # Early stop on first solution\n                break\n\n        return PlannerResult(success, best_path, start_tree + goal_tree + nodes, edges)",
        "objective": 5.46059,
        "time_improvement": -53.0,
        "length_improvement": 15.0,
        "smoothness_improvement": 293.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.06232309341430664,
                "num_nodes_avg": 267.2,
                "path_length_avg": 168.2463107739374,
                "smoothness_avg": 0.02259680420437422,
                "success_improvement": 0.0,
                "time_improvement": -148.0264306480139,
                "length_improvement": 7.781531031403382,
                "smoothness_improvement": 253.68905554417486,
                "objective_score": -38.47056529784127
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.08523426055908204,
                "num_nodes_avg": 568.0,
                "path_length_avg": 241.3226903680994,
                "smoothness_avg": 0.016808760155440354,
                "success_improvement": 0.0,
                "time_improvement": 46.970110737287854,
                "length_improvement": 19.439539866622514,
                "smoothness_improvement": 332.5015056600573,
                "objective_score": 27.41726466946015
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.07625963687896728,
                "num_nodes_avg": 483.4,
                "path_length_avg": 124.7326333683994,
                "smoothness_avg": 0.03084680379066026,
                "success_improvement": 0.0,
                "time_improvement": -56.951465457596676,
                "length_improvement": 17.15852404644154,
                "smoothness_improvement": 292.3690673429857,
                "objective_score": -5.328479872699152
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "A simplified RRT* planner with goal-biased sampling, fixed rewiring radius, and early termination upon first goal reach. The planner samples randomly with a small probability of sampling the goal directly, extends the nearest node toward the sample by a fixed step size, determines the best parent among neighbors to minimize cost if connection is collision-free, and rewires nodes nearby to improve path cost and smoothness. The search stops immediately after first path to goal is found, ensuring efficient planning time and decent path quality.",
        "planning_mechanism": "A single tree grows incrementally from start toward goal, using goal bias sampling to accelerate goal approach. Each new node rewires neighbors to optimize path cost locally. Collision checking ensures all nodes and edges are valid. Upon connecting to the goal, the planner terminates early, returning the extracted path by tracing parents.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, neighbor_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        time_limit = 30.0  # seconds hard time limit\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n        success = False\n        path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        for iter_idx in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors for rewiring and parent selection\n            near_nodes = [n for n in nodes if dist(n.position, new_pos) <= self.neighbor_radius]\n\n            # Choose best parent minimizing cost + distance\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in near_nodes:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if cheaper through new node\n            for neighbor in near_nodes:\n                if neighbor == best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.update_parent(new_node, alt_cost)\n                            edges.append((new_node, neighbor))\n                        except Exception:\n                            # Edge may already removed; ignore\n                            pass\n\n            # Check if goal can be connected\n            if dist(new_pos, goal_pos) <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_pos, goal_pos, obstacles, is_3d) and\n                    not self._is_in_obstacle(goal_pos, obstacles, is_3d)):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist(new_pos, goal_pos)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    # Extract path\n                    path_tmp = []\n                    current = goal_node\n                    while current:\n                        path_tmp.append(current.position)\n                        current = current.parent\n                    path = path_tmp[::-1]\n                    success = True\n                    break\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 34.24822,
        "time_improvement": -158.0,
        "length_improvement": 19.0,
        "smoothness_improvement": 287.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.05595297813415527,
                "num_nodes_avg": 282.7,
                "path_length_avg": 160.14345768443917,
                "smoothness_avg": 0.020991279248420664,
                "success_improvement": 0.0,
                "time_improvement": -122.67536302290098,
                "length_improvement": 12.22283320768113,
                "smoothness_improvement": 228.55910353025726,
                "objective_score": -28.326113464610327
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.23264851570129394,
                "num_nodes_avg": 948.8,
                "path_length_avg": 225.03802962507376,
                "smoothness_avg": 0.017004339084283518,
                "success_improvement": 0.0,
                "time_improvement": -44.746079145276,
                "length_improvement": 24.875828350614626,
                "smoothness_improvement": 337.5338923690004,
                "objective_score": 3.189342728630977
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.19719173908233642,
                "num_nodes_avg": 505.7,
                "path_length_avg": 118.75610965494363,
                "smoothness_avg": 0.030953946710724024,
                "success_improvement": 0.0,
                "time_improvement": -305.8442144725285,
                "length_improvement": 21.127846525442067,
                "smoothness_improvement": 293.73191737772913,
                "objective_score": -77.60789683960466
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "An efficient informed RRT* planner that combines heuristic-driven sampling within an ellipsoidal informed set to focus exploration near the start-to-goal path, employs a fixed-radius rewiring strategy, and terminates early once a feasible path is found. This approach leverages heuristic pruning to reduce planning time and improves path quality by iterative rewiring focused on promising regions.",
        "planning_mechanism": "The planner grows a single tree from start, samples points preferentially within an ellipsoidal subset defined by the current best path cost to the goal (informed sampling), uses a fixed neighbor radius for rewiring new nodes, and updates parents to minimize path cost. Collision checks are conducted for each node and edge before insertion. The algorithm halts immediately when a path to the goal is found or when a 30-second time limit expires, returning the best path discovered so far.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.15, neighbor_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes = []\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio*(to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            # Node collision check\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            # Edge collision check with adaptive resolution\n            dist_edge = dist(p1,p2)\n            resolution = min(1.0, self.step_size*0.5)\n            steps = max(1,int(dist_edge/resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d]) * (i/steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        # Informed sampling related functions\n        def heuristic_cost(a,b):\n            return dist(a,b)\n\n        # Calculate ellipse parameters for informed sampling\n        def sample_informed(c_best, x_start, x_goal):\n            # If no path found yet, sample uniformly\n            if math.isinf(c_best):\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Calculate unit vector between start and goal\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0.0:\n                # start==goal\n                return x_start\n\n            # Ellipsoid parameters\n            center = tuple((x_start[i]+x_goal[i])/2.0 for i in range(dim))\n            a1 = tuple((x_goal[i]-x_start[i])/c_min for i in range(dim))\n\n            # Rotation matrix aligning x-axis to unit vector a1\n            # For 2D and 3D, we compute a rotation matrix using Gram-Schmidt or an identity fallback.\n            # We'll only build rotation matrix for 2D and 3D\n            def build_rotation_matrix(a):\n                # a: unit vector\n                # Build full basis with a and orthogonals\n                if dim == 2:\n                    # 2D rotation matrix rotating x-axis to a\n                    cos_theta = a[0]\n                    sin_theta = a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta, cos_theta]]\n                elif dim == 3:\n                    # Use standard basis and Gram Schmidt for orthonormal frame\n                    x_axis = a\n                    # Choose arbitrary vector not colinear with x_axis\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1,0,0)\n                    else:\n                        temp = (0,1,0)\n                    # Orthogonalize\n                    v = tuple(temp[i] - x_axis[i]*sum(x_axis[j]*temp[j] for j in range(3)) for i in range(3))\n                    norm_v = math.sqrt(sum(v[i]*v[i] for i in range(3)))\n                    if norm_v < 1e-10:\n                        # Degenerate case fallback to identity\n                        return [[1,0,0],[0,1,0],[0,0,1]]\n                    v_unit = tuple(v[i]/norm_v for i in range(3))\n                    # Third axis is cross product\n                    w = (x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                         x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                         x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    # Transpose R to get column vectors\n                    return [[R[0][0],R[1][0],R[2][0]],\n                            [R[0][1],R[1][1],R[2][1]],\n                            [R[0][2],R[1][2],R[2][2]]]\n                else:\n                    # For other dims fallback uniform sampling\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                # fallback uniform sample\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Ellipsoid radii\n            r1 = c_best/2.0\n            if c_best < c_min:\n                # numerical safety\n                r2 = 0.0001\n            else:\n                r2 = math.sqrt(c_best**2 - c_min**2)/2.0\n                if r2 < 0.001:\n                    r2 = 0.001\n            # For dim==2, ellipse radii = [r1, r2],\n            # For dim==3, radii = [r1, r2, r2]\n\n            radii = [r1] + [r2]*(dim-1)\n\n            # Sample point in unit n-ball via Gaussian and normalize\n            while True:\n                # Sample n dim gaussian\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x/norm_rnd for x in rnd]\n            # Scale by uniform radius in [0,1]^(1/dim)\n            u = random.random()\n            scale = u**(1.0/dim)\n            sample_ball = [scale*unit_ball[i]*radii[i] for i in range(dim)]\n\n            # Rotation and translation back to world frame: sample = R * sample_ball + center\n            sample = [0.0]*dim\n            # Matrix multiplication: sample = R * sample_ball\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j]*sample_ball[j]\n                sample[i] = s + center[i]\n\n            # Clamp sample inside bounds\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        root = Node(start_pos)\n        nodes.append(root)\n        positions = [start_pos]\n\n        best_goal_cost = float('inf')\n        best_goal_node = None\n\n        # Fixed radius pruning upper bound to avoid huge neighbors\n        fixed_radius = self.neighbor_radius\n\n        # Nearest neighbor search (linear)\n        def nearest_node(p):\n            best_idx = 0\n            best_d = dist(positions[0], p)\n            for i in range(1,len(positions)):\n                dcur = dist(positions[i], p)\n                if dcur < best_d:\n                    best_d = dcur\n                    best_idx = i\n            return nodes[best_idx], best_d\n\n        # Find neighbors within fixed radius\n        def nearby_nodes(p, radius):\n            result = []\n            for i, pos in enumerate(positions):\n                if dist(pos,p) <= radius:\n                    result.append(nodes[i])\n            return result\n\n        for iter in range(self.max_iter):\n            if time.monotonic()-start_time > time_limit:\n                break\n\n            # Sample point with goal bias and informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n\n            # Find nearest node\n            near_node, _ = nearest_node(sample)\n\n            # Steer toward sample\n            new_pos = steer(near_node.position, sample, self.step_size)\n\n            # Node collision & bounds check\n            if not is_free_node(new_pos):\n                continue\n\n            # Edge collision from nearest to new_pos\n            if not is_free_edge(near_node.position, new_pos):\n                continue\n\n            # Find neighbors for rewiring\n            neighbors = nearby_nodes(new_pos, fixed_radius)\n\n            # Choose best parent among neighbors\n            min_cost = near_node.cost + dist(near_node.position,new_pos)\n            best_parent = near_node\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position,new_pos)\n                if tentative_cost < min_cost and is_free_edge(nb.position,new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            positions.append(new_pos)\n            edges.append((best_parent,new_node))\n\n            # Rewire neighbors if cheaper to go via new_node\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Check goal connection possibility\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                positions.append(goal_pos)\n                edges.append((new_node, goal_node))\n\n                # Update best solution cost and node\n                if goal_cost < best_goal_cost:\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    # Early stop on first found path\n                    break\n\n        # If best path found, extract it\n        extracted_path = []\n        success = False\n        if best_goal_node is not None:\n            success = True\n            current = best_goal_node\n            while current is not None:\n                extracted_path.append(current.position)\n                current = current.parent\n            extracted_path.reverse()\n        else:\n            # No exact goal reached: extract path from node closest to goal\n            # Find closest node\n            min_dist = float('inf')\n            best_node = None\n            for n in nodes:\n                d = dist(n.position, goal_pos)\n                if d < min_dist:\n                    min_dist = d\n                    best_node = n\n            if best_node is not None:\n                current = best_node\n                while current is not None:\n                    extracted_path.append(current.position)\n                    current = current.parent\n                extracted_path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
        "objective": 18.33169,
        "time_improvement": -104.0,
        "length_improvement": 19.0,
        "smoothness_improvement": 277.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.03312251567840576,
                "num_nodes_avg": 199.7,
                "path_length_avg": 163.67692862769394,
                "smoothness_avg": 0.020726203772078875,
                "success_improvement": 0.0,
                "time_improvement": -31.81725886398311,
                "length_improvement": 10.28608179225304,
                "smoothness_improvement": 224.41009670489822,
                "objective_score": -2.251478100318617
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.2541221618652344,
                "num_nodes_avg": 968.5,
                "path_length_avg": 223.78483919358527,
                "smoothness_avg": 0.016494501307333334,
                "success_improvement": 0.0,
                "time_improvement": -58.106259320137475,
                "length_improvement": 25.29417938773204,
                "smoothness_improvement": 324.4153991467646,
                "objective_score": -0.633293167668195
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.15669703483581543,
                "num_nodes_avg": 482.5,
                "path_length_avg": 117.3805344167902,
                "smoothness_avg": 0.030113844927462913,
                "success_improvement": 0.0,
                "time_improvement": -222.5012635370204,
                "length_improvement": 22.04143810076968,
                "smoothness_improvement": 283.0458847045111,
                "objective_score": -52.11028677712176
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "A streamlined single-tree RRT* planner with goal bias sampling, fixed-radius rewiring, early stopping, and incremental cost optimization to efficiently find collision-free paths. The planner balances exploration and refinement by sampling with goal bias, connecting nodes with collision-checked edges, rewiring neighbors within a fixed radius to reduce path cost, and terminating early upon discovering a feasible path to the goal.",
        "planning_mechanism": "The planner samples mostly uniform points with a small probability to sample the goal directly to speed reaching it. Each iteration extends the tree toward the sample while respecting a fixed step size and avoiding collisions. Nearby nodes within a fixed radius are evaluated to select the lowest-cost valid parent for the new node. The planner then attempts to rewire these neighbors to the new node if it improves their cost and is collision-free. This local rewiring refines the path incrementally. The algorithm halts immediately when a node can connect to the goal without collision, returning the path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, rewiring_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewiring_radius = rewiring_radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        success = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > 30:\n                break\n\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_pos = tuple(nearest.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors for rewiring\n            neighbors = [n for n in nodes if math.dist(n.position, new_pos) <= self.rewiring_radius]\n\n            # Choose best parent minimizing cost\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                cost_through_nb = nb.cost + math.dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_nb\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper via new_node\n            for nb in neighbors:\n                if nb == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nb))\n\n            # Check if new node can connect to goal\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                        goal_node = Node(goal_pos)\n                        goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success = True\n                        break\n\n        extracted_path = []\n        if success and goal_node:\n            node = goal_node\n            while node:\n                extracted_path.append(node.position)\n                node = node.parent\n            extracted_path.reverse()\n\n        return PlannerResult(success=success, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 9.11942,
        "time_improvement": -70.0,
        "length_improvement": 18.0,
        "smoothness_improvement": 182.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.02458224296569824,
                "num_nodes_avg": 235.2,
                "path_length_avg": 160.91673392411104,
                "smoothness_avg": 0.01622189562126349,
                "success_improvement": 0.0,
                "time_improvement": 2.170356988333177,
                "length_improvement": 11.798988247370831,
                "smoothness_improvement": 153.90789288293342,
                "objective_score": 8.50003950933712
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.16582508087158204,
                "num_nodes_avg": 988.6,
                "path_length_avg": 230.06388904405716,
                "smoothness_avg": 0.011826311396694525,
                "success_improvement": 0.0,
                "time_improvement": -3.170786229848748,
                "length_improvement": 23.198051815215557,
                "smoothness_improvement": 204.29951038474306,
                "objective_score": 13.989092772098425
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.14947149753570557,
                "num_nodes_avg": 650.0,
                "path_length_avg": 121.70930984019235,
                "smoothness_avg": 0.022669727327406998,
                "success_improvement": 0.0,
                "time_improvement": -207.63024245189973,
                "length_improvement": 19.166471578680884,
                "smoothness_improvement": 188.3572582994048,
                "objective_score": -49.84740349686436
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "An improved RRT* variant with adaptive rewiring radius scaled to node density and informed sampling within an ellipsoidal heuristic to focus exploration near start-goal regions, combined with pruning of suboptimal branches and incremental best-path tracking. Early termination occurs upon reaching goal, ensuring faster convergence. This approach reduces redundant collision checks and limits neighbor searches by adaptive radius heuristic, improving planning speed while enhancing path length and smoothness through informed rewiring and bounded sampling.",
        "planning_mechanism": "A single-tree planner grows incrementally from the start node toward the goal using informed sampling constrained in an ellipse covering feasible nodes, adaptively adjusting rewiring neighbor radius based on the current node density to reduce computational overhead. Each new node is connected through optimal parent selection minimizing cost subject to collision constraints. Local rewiring improves path quality incrementally. The algorithm prunes nodes that are too costly or isolated periodically to streamline the search and uses early termination once the goal is reached.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, goal_sample_rate=0.1, min_radius=8.0, max_radius=35.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal\n        self.min_radius = min_radius   # Minimum rewiring radius\n        self.max_radius = max_radius   # Maximum rewiring radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_limit = 30.0\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_point_in_ellipse(p, f1, f2, max_dist):\n            # Check if p is inside ellipse defined by foci f1, f2 and major axis max_dist\n            # sum of distances from p to foci <= max_dist\n            return dist(p, f1) + dist(p, f2) <= max_dist + 1e-8\n\n        def heuristic_radius(n_nodes):\n            # Adaptive rewiring radius based on number of nodes and dimension,\n            # from RRT* theory: r = min(max_radius, gamma * (log(n)/n)^(1/d))\n            # gamma chosen to ensure connectivity, here gamma tuned empirically\n            if n_nodes <= 1:\n                return self.max_radius\n            gamma_rrt = 35.0\n            radius = gamma_rrt * (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            radius = max(self.min_radius, min(radius, self.max_radius))\n            return radius\n\n        def extract_path(end_node):\n            path = []\n            current = end_node\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            return path[::-1]\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_goal_cost = float('inf')\n        success = False\n\n        max_dist_start_goal = dist(start_pos, goal_pos)\n        # initialize informed sampling ellipse parameters:\n        c_min = max_dist_start_goal\n        # heuristic cost to beat is infinite initially; update upon feasible path\n\n        def sample_informed():\n            # If no solution found, sample uniformly in map\n            if best_goal_node is None:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                # Sample uniformly in an ellipsoid (informed sampling)\n                # Ellipse defined with foci = start and goal, and major axis = cost of best solution\n                c_best = best_goal_cost\n                if c_best < float('inf'):\n                    # Generate random point in unit ball\n                    while True:\n                        sample_ball = [random.gauss(0, 1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x * x for x in sample_ball))\n                        if norm > 1e-8:\n                            sample_ball = [x / norm for x in sample_ball]\n                            break\n                    radius = random.uniform(0, 1) ** (1.0 / dim)\n                    sample_ball = [x * radius for x in sample_ball]\n\n                    # Compute ellipse transform parameters\n                    # Rotation or aligning ellipse along start-goal vector\n                    # Construct transform matrix that scales unit ball to ellipse\n                    # Length of major axis a = c_best / 2\n                    # Minor axes radii b = sqrt(c_best^2 - c_min^2) / 2\n\n                    a = c_best / 2.0\n                    if c_best**2 - c_min**2 > 0:\n                        b = math.sqrt(c_best**2 - c_min**2) / 2.0\n                    else:\n                        b = 0.0  # Degenerate ellipse: almost line\n\n                    # Rotate sample_ball aligned with start->goal vector\n                    # Create unit vector for start->goal\n                    unit_vec = [(goal_pos[i] - start_pos[i]) / c_min for i in range(dim)]\n                    # Orthogonal basis: for dim>1, just 1D alignment, rest arbitrary axes (identity)\n                    # For simplicity, align first dimension to start->goal, scale others by b/a\n\n                    if dim == 1:\n                        # 1D case, scale by a along line (unit_vec=1 or -1)\n                        new_sample = [start_pos[0] + sample_ball[0] * a * unit_vec[0]]\n                    else:\n                        # Build sample point in aligned coords\n                        new_sample = [0.0] * dim\n                        new_sample[0] = sample_ball[0] * a\n                        for i in range(1, dim):\n                            new_sample[i] = sample_ball[i] * b\n                        # Rotate back to world frame: since only aligned with unit_vec on axis0,\n                        # approximate by placing first dim component along unit_vec, others arbitrary orthogonal\n                        # Find perpendicular basis by Gram-Schmidt (approx)\n                        # We only do a simple linear transform ignoring rotation for complexity,\n                        # Instead, we map sample: sample_world = start + unit_vec * new_sample[0] + perpendicular components\n                        base_point = list(start_pos)\n                        # Decompose new_sample into unit_vec axis and orthogonal components\n                        # For simplicity, distribute orthogonal components equally among remaining dims\n\n                        sample_world = [base_point[i] + unit_vec[i] * new_sample[0] for i in range(dim)]\n                        # Orthogonal part: we add equally distributed parts scaled by new_sample[i]\n                        # Construct orthogonal vectors to unit_vec by simple Gram-Schmidt approach\n                        # For dims>1, find orthogonal vectors:\n                        ortho_vectors = []\n                        def normalize(vec):\n                            nrm = math.sqrt(sum(x*x for x in vec))\n                            if nrm < 1e-10:\n                                return [0.0]*len(vec)\n                            return [x/nrm for x in vec]\n                        # Start with identity basis\n                        identity = [[0]*dim for _ in range(dim)]\n                        for i in range(dim):\n                            identity[i][i] = 1\n                        for i in range(dim):\n                            proj = sum(identity[i][j]*unit_vec[j] for j in range(dim))\n                            ortho = [identity[i][j]-proj*unit_vec[j] for j in range(dim)]\n                            ortho = normalize(ortho)\n                            ortho_vectors.append(ortho)\n                        # Add scaled orthogonal components\n                        for i in range(1, dim):\n                            for j in range(dim):\n                                sample_world[j] += ortho_vectors[i][j]*new_sample[i]\n                        return tuple(max(0.0, min(sample_world[i], bounds[i])) for i in range(dim))\n                    return tuple(new_sample)\n                else:\n                    # fallback: uniform sampling\n                    return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def node_density():\n            # Approximate node density as number of nodes / total volume\n            # Volume = product of bounds dimensions\n            volume = 1.0\n            for v in bounds:\n                volume *= v\n            return len(nodes) / max(1e-10, volume)\n\n        def prune_nodes():\n            # Periodically prune nodes that have cost worse than best_goal_cost + margin or disconnected\n            # Also prune isolated nodes without children nor parent (except root)\n            margin = 15.0\n            to_remove = []\n            for node in nodes:\n                if node is root:\n                    continue\n                if best_goal_cost < float('inf'):\n                    if node.cost > best_goal_cost + margin:\n                        to_remove.append(node)\n                        continue\n                if (node.parent is None) and (len(node.children) == 0):\n                    # isolated\n                    to_remove.append(node)\n            for node in to_remove:\n                # remove from nodes list and edges\n                nodes.remove(node)\n                if node.parent is not None:\n                    try:\n                        node.parent.children.remove(node)\n                    except Exception:\n                        pass\n                # Remove edges referencing this node\n                edges[:] = [(p, c) for p, c in edges if p != node and c != node]\n\n        iter_chunk = 100  # prune and update radius every chunk\n\n        for iter_idx in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Sample point with goal bias and informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed()\n\n            # Nearest node to sample\n            if not nodes:\n                break\n            nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if any(new_pos[i] < 0.0 or new_pos[i] > bounds[i] for i in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Adaptive neighbor radius for rewiring\n            r = heuristic_radius(len(nodes))\n\n            # Find neighbors within radius r\n            near_nodes = [n for n in nodes if dist(n.position, new_pos) <= r]\n\n            # Choose best parent minimizing cost + dist and collision free\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in near_nodes:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new node if improves cost and collision free\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except Exception:\n                            pass\n                        neighbor.update_parent(new_node, alt_cost)\n                        edges.append((new_node, neighbor))\n\n            # Check if new node can connect to goal directly\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d) and\n                    not self._is_in_obstacle(goal_pos, obstacles, is_3d)):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist_to_goal\n                    if goal_cost < best_goal_cost:\n                        goal_node.update_parent(new_node, goal_cost)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_goal_cost = goal_cost\n                        success = True\n\n                        # Early break on finding better path\n                        break\n\n            # Periodic pruning and radius update\n            if (iter_idx > 0) and (iter_idx % iter_chunk == 0) and (success):\n                prune_nodes()\n\n        # Extract path if success\n        if best_goal_node is not None and success:\n            extracted_path = extract_path(best_goal_node)\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -7.73775,
        "time_improvement": -3.0,
        "length_improvement": 13.0,
        "smoothness_improvement": 143.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.031192827224731445,
                "num_nodes_avg": 228.2,
                "path_length_avg": 173.47041072322037,
                "smoothness_avg": 0.016212433782287948,
                "success_improvement": 0.0,
                "time_improvement": -24.137702006209146,
                "length_improvement": 4.918119068040286,
                "smoothness_improvement": 153.759794556254,
                "objective_score": -3.521640188257302
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.1286400556564331,
                "num_nodes_avg": 775.0,
                "path_length_avg": 247.3898406969005,
                "smoothness_avg": 0.00894525060365523,
                "success_improvement": 0.0,
                "time_improvement": 19.964485390459707,
                "length_improvement": 17.414150453629286,
                "smoothness_improvement": 130.16774103563074,
                "objective_score": 17.088674594493636
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.050321340560913086,
                "num_nodes_avg": 417.3,
                "path_length_avg": 125.51343547763591,
                "smoothness_avg": 0.01937830391026074,
                "success_improvement": 0.0,
                "time_improvement": -3.567345296452773,
                "length_improvement": 16.639952463287656,
                "smoothness_improvement": 146.4905953809094,
                "objective_score": 9.64622086594131
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "This algorithm implements a bidirectional RRT* planner with goal bias sampling, fixed rewiring radius, and early termination to efficiently find and improve paths. It grows two trees from start and goal positions, alternates between them to expand new nodes by steering toward sampled points, rewires near neighbors within a fixed radius to optimize costs, and attempts to connect the two trees when nodes are close enough. Upon connection, it immediately returns the optimized path, ensuring faster convergence and higher path quality through continuous rewiring.",
        "planning_mechanism": "The planner maintains two trees and alternately extends them by sampling points with a small probability of sampling the goal directly (goal bias). Each new node chooses its parent from nearby nodes that yields minimal cost without collision, then rewires neighbors to improve their costs if possible. When the trees are close enough and a collision-free edge can connect them, the algorithm generates the combined path and stops early, returning an optimized, smooth path quickly.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_to_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, radius: float=15.0, goal_bias: float=0.05, time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.goal_bias = goal_bias\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = []\n        edges = []\n        success = False\n        best_path = []\n\n        def clamp(p):\n            return tuple(\n                min(max(p[d], 0.0), bounds[d]) for d in range(dim)\n            )\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return clamp(to_pos)\n            ratio = self.step_size / d\n            return clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim)))\n\n        def sample_free():\n            if random.random() < self.goal_bias:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback\n            return start_pos\n\n        def near_nodes(tree, pos):\n            return [node for node in tree if dist(node.position, pos) <= self.radius]\n\n        start_time = time.monotonic()\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                # Time limit reached; return best found\n                return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n            rand_point = sample_free()\n            # Alternate trees each iteration\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                if time.monotonic() - start_time > self.time_limit_sec:\n                    return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n                # Find nearest node in tree_a\n                nearest = min(tree_a, key=lambda n: dist(n.position, rand_point))\n                new_pos = steer(nearest.position, rand_point)\n\n                # Check node and edge collisions\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Find best parent in radius\n                neighbors = near_nodes(tree_a, new_pos)\n                min_cost = nearest.cost + dist(nearest.position, new_pos)\n                min_parent = nearest\n                for nb in neighbors:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        cost = nb.cost + dist(nb.position, new_pos)\n                        if cost < min_cost:\n                            min_cost = cost\n                            min_parent = nb\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors\n                for nb in neighbors:\n                    if nb is min_parent:\n                        continue\n                    if self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        continue\n                    new_cost = new_node.cost + dist(new_node.position, nb.position)\n                    if new_cost + 1e-10 < nb.cost:\n                        # Update parent/edges\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                                nb.parent.children.remove(nb)\n                            except ValueError:\n                                pass\n                        new_node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((new_node, nb))\n\n                # Check connection to other tree\n                connect_node = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n                connect_dist = dist(new_node.position, connect_node.position)\n                if connect_dist <= self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    # Connect trees and extract path\n                    path_from_start = new_node.path_to_root()\n                    path_from_goal = connect_node.path_to_root()\n                    # Remove duplicate node at connection point if any\n                    if path_from_start[-1] == path_from_goal[-1]:\n                        path_from_goal = path_from_goal[:-1]\n                    full_path = path_from_start + path_from_goal[::-1]\n\n                    success = True\n                    best_path = full_path\n                    # Early stop on connection\n                    return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n        return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 34.17936,
        "time_improvement": -148.0,
        "length_improvement": 14.0,
        "smoothness_improvement": 307.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.06862092018127441,
                "num_nodes_avg": 284.0,
                "path_length_avg": 170.5991073480199,
                "smoothness_avg": 0.023639461522089605,
                "success_improvement": 0.0,
                "time_improvement": -173.08981258681808,
                "length_improvement": 6.491925946701232,
                "smoothness_improvement": 270.00890673302524,
                "objective_score": -46.68174367435956
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.09145197868347169,
                "num_nodes_avg": 589.8,
                "path_length_avg": 238.92126140318732,
                "smoothness_avg": 0.017217767150899767,
                "success_improvement": 0.0,
                "time_improvement": 43.10165571180447,
                "length_improvement": 20.24120597641038,
                "smoothness_improvement": 343.0255502490592,
                "objective_score": 26.790348050632865
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.20080511569976806,
                "num_nodes_avg": 632.2,
                "path_length_avg": 125.97622721535136,
                "smoothness_avg": 0.03204491385721169,
                "success_improvement": 0.0,
                "time_improvement": -313.2809762847595,
                "length_improvement": 16.332588226871458,
                "smoothness_improvement": 307.60893895423396,
                "objective_score": -82.6466952545338
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "A simplified unidirectional RRT* variant with goal bias and fixed-radius rewiring that prioritizes early successful path discovery and incremental local path cost improvements while maintaining bounded computational effort. It samples mostly uniformly but occasionally samples the goal to speed convergence, extends towards samples by fixed step size clipped to map bounds, connects new nodes to lowest-cost neighbor within radius after collision checks, rewires neighbors to new node if beneficial, and terminates immediately upon first reaching goal vicinity collision-free. Path extraction traces back through parents from goal to start.",
        "planning_mechanism": "A single tree is grown from start by sampling mostly uniform points with some probability sampling the goal directly. Each iteration extends towards the sample obeying a maximum step size and checks node and edge collisions. The planner selects a minimum cost parent node within a fixed radius and adds the new node, then rewires neighbor nodes to improve costs. If a new node can connect to the goal collision-free within step distance, the path is extracted and returned immediately. This approach reduces runtime via goal bias, efficient rewiring, and early stopping while preserving path quality.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, rewiring_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewiring_radius = rewiring_radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        success = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > 30:\n                break\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Find nearest node\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest.position[d] for d in range(dim))\n            dist_to_sample = math.dist(nearest.position, sample)\n            if dist_to_sample == 0:\n                continue\n            scale = min(self.step_size, dist_to_sample) / dist_to_sample\n            new_pos = tuple(nearest.position[d] + direction[d]*scale for d in range(dim))\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors to consider for rewiring within fixed radius\n            neighbors = [n for n in nodes if math.dist(n.position, new_pos) <= self.rewiring_radius]\n\n            # Select parent minimizing cost + dist with collision-free edge\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                cost_through_nb = nb.cost + math.dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_nb\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if passing through new_node improves cost collision-free\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nb))\n\n            # If new node is close enough to goal and path is collision-free, finish early\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                        goal_node = Node(goal_pos)\n                        goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success = True\n                        break\n\n        path = []\n        if success and goal_node:\n            node = goal_node\n            while node is not None:\n                path.append(node.position)\n                node = node.parent\n            path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -7.90364,
        "time_improvement": -8.0,
        "length_improvement": 16.0,
        "smoothness_improvement": 170.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.025247907638549803,
                "num_nodes_avg": 233.8,
                "path_length_avg": 170.12946546952813,
                "smoothness_avg": 0.014816791053862539,
                "success_improvement": 0.0,
                "time_improvement": -0.4787803341404643,
                "length_improvement": 6.749344102254376,
                "smoothness_improvement": 131.91495516970375,
                "objective_score": 4.565547136959005
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.12624733448028563,
                "num_nodes_avg": 859.5,
                "path_length_avg": 236.88602288914717,
                "smoothness_avg": 0.011656507882273733,
                "success_improvement": 0.0,
                "time_improvement": 21.453156004545612,
                "length_improvement": 20.920627173489493,
                "smoothness_improvement": 199.93034365416824,
                "objective_score": 19.98797482372822
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.07023768424987793,
                "num_nodes_avg": 492.5,
                "path_length_avg": 121.35915641758058,
                "smoothness_avg": 0.02178086692654423,
                "success_improvement": 0.0,
                "time_improvement": -44.55756576526181,
                "length_improvement": 19.399026809465404,
                "smoothness_improvement": 177.0510196092805,
                "objective_score": -0.842598545852899
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "An improved informed RRT* planner that integrates adaptive neighbor radius, goal bias sampling, and incremental rewiring within an ellipsoidal informed set for focused exploration and faster convergence. The planner combines efficient spatial bounds checks, early termination upon finding a path, and path shortcutting to reduce overall planning time and yield shorter, smoother paths.",
        "planning_mechanism": "A single-tree informed RRT* sampling nodes adaptively in an ellipsoid defined by the best known path cost, with a neighbor radius that shrinks dynamically for better local rewiring. Each iteration samples either the goal (with probability goal_sample_rate) or informed samples, steers within step limits, and checks collision. Upon adding a new node, it rewires surrounding neighbors if a better path is found. The planner halts early upon detecting a valid path and applies post-processing shortcutting to improve smoothness and reduce path length.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.15,\n                 max_neighbor_radius=30.0, min_neighbor_radius=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            # Node collision & bounds check\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            # Edge collision check with adaptive resolution\n            d = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def heuristic_cost(a, b):\n            return dist(a, b)\n\n        # Ellipsoidal informed sampling\n        def sample_informed(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0:\n                return x_start\n\n            # Center and unit vector for ellipse\n            center = tuple((x_start[i] + x_goal[i]) / 2.0 for i in range(dim))\n            a1 = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n\n            # Build rotation matrix aligning x-axis to a1 for 2D or 3D\n            def build_rotation_matrix(a):\n                if dim == 2:\n                    cos_theta = a[0]\n                    sin_theta = a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta, cos_theta]]\n                elif dim == 3:\n                    x_axis = a\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1, 0, 0)\n                    else:\n                        temp = (0, 1, 0)\n                    v = tuple(temp[i] - x_axis[i] * sum(x_axis[j] * temp[j] for j in range(3)) for i in range(3))\n                    norm_v = math.sqrt(sum(v[i] * v[i] for i in range(3)))\n                    if norm_v < 1e-10:\n                        return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                    v_unit = tuple(v[i] / norm_v for i in range(3))\n                    w = (x_axis[1] * v_unit[2] - x_axis[2] * v_unit[1],\n                         x_axis[2] * v_unit[0] - x_axis[0] * v_unit[2],\n                         x_axis[0] * v_unit[1] - x_axis[1] * v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    return [[R[0][0], R[1][0], R[2][0]],\n                            [R[0][1], R[1][1], R[2][1]],\n                            [R[0][2], R[1][2], R[2][2]]]\n                else:\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            r1 = c_best / 2.0\n            if c_best < c_min:\n                r2 = 0.0001\n            else:\n                r2 = math.sqrt(abs(c_best * c_best - c_min * c_min)) / 2.0\n                if r2 < 0.001:\n                    r2 = 0.001\n            radii = [r1] + [r2] * (dim - 1)\n\n            while True:\n                rnd = [random.gauss(0, 1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x * x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x / norm_rnd for x in rnd]\n            u = random.random()\n            scale = u ** (1.0 / dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n\n            sample = [0.0] * dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j] * sample_ball[j]\n                sample[i] = s + center[i]\n\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        # Nearest node search linear\n        def nearest_node(p):\n            best_i = 0\n            best_d = dist(nodes[0].position, p)\n            for i in range(1, len(nodes)):\n                dcur = dist(nodes[i].position, p)\n                if dcur < best_d:\n                    best_d = dcur\n                    best_i = i\n            return nodes[best_i], best_d\n\n        # Neighbor radius shrinks as tree grows (adaptive)\n        def neighbor_radius(n):\n            # Following RRT* radius formula (Karaman & Frazzoli) with min/max caps\n            gamma_rrt_star = self.max_neighbor_radius\n            r = gamma_rrt_star * (math.log(n + 1) / (n + 1)) ** (1.0 / dim)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        def nearby_nodes(p, radius):\n            result = []\n            for node in nodes:\n                if dist(node.position, p) <= radius:\n                    result.append(node)\n            return result\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_goal_cost = float('inf')\n        success = False\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n\n            nearest, _ = nearest_node(sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n\n            if not is_free_edge(nearest.position, new_pos):\n                continue\n\n            n_nodes = len(nodes)\n            radius = neighbor_radius(n_nodes)\n\n            neighbors = nearby_nodes(new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost and is_free_edge(nb.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors via new node if cheaper\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                if goal_cost < best_goal_cost:\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    success = True\n                    break\n\n        # Extract path from best goal node or closest node to goal\n        path: List[Tuple[float, ...]] = []\n        if success and best_goal_node is not None:\n            current = best_goal_node\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            path.reverse()\n        else:\n            # No solution found: closest node to goal\n            min_dist = float('inf')\n            best_node = None\n            for n in nodes:\n                dcur = dist(n.position, goal_pos)\n                if dcur < min_dist:\n                    min_dist = dcur\n                    best_node = n\n            if best_node is not None:\n                current = best_node\n                while current is not None:\n                    path.append(current.position)\n                    current = current.parent\n                path.reverse()\n\n        # Post-processing shortcutting to smooth and shorten path\n        def shortcut_path(path_points):\n            if len(path_points) < 3:\n                return path_points\n            shortened = [path_points[0]]\n            i = 0\n            while i < len(path_points) - 1:\n                j = len(path_points) - 1\n                while j > i + 1:\n                    if is_free_edge(path_points[i], path_points[j]):\n                        shortened.append(path_points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    i += 1\n                    if i < len(path_points):\n                        shortened.append(path_points[i])\n            return shortened\n\n        path = shortcut_path(path)\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
        "objective": 4.05717,
        "time_improvement": -77.0,
        "length_improvement": 18.0,
        "smoothness_improvement": 1607.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.03238720893859863,
                "num_nodes_avg": 240.1,
                "path_length_avg": 156.8355269466239,
                "smoothness_avg": 0.04571460503828216,
                "success_improvement": 0.0,
                "time_improvement": -28.890967883954104,
                "length_improvement": 14.03596246259457,
                "smoothness_improvement": 615.5328397028414,
                "objective_score": 2.831951310884718
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.147990083694458,
                "num_nodes_avg": 859.9,
                "path_length_avg": 231.82003384026544,
                "smoothness_avg": 0.10402068439578667,
                "success_improvement": 0.0,
                "time_improvement": 7.925548965645519,
                "length_improvement": 22.611800134415976,
                "smoothness_improvement": 2576.527132574148,
                "objective_score": 28.827380433213982
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.15016646385192872,
                "num_nodes_avg": 570.8,
                "path_length_avg": 123.61458665916646,
                "smoothness_avg": 0.13595502682176802,
                "success_improvement": 0.0,
                "time_improvement": -209.06056635900154,
                "length_improvement": 17.901077435050915,
                "smoothness_improvement": 1629.3379060166778,
                "objective_score": -43.83083391658651
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "A bidirectional RRT* inspired path planner with goal bias sampling, fixed-radius rewiring, and early termination that balances fast convergence, improved path quality, and smoothness by incrementally optimizing connections and limiting search to feasible regions.",
        "planning_mechanism": "A planner growing two trees simultaneously from start and goal, alternately sampling with a small goal bias, steering towards sampled points with fixed step size, rewiring neighbors in a fixed radius for cost optimization, and stopping early upon first valid path connection. The final path excludes duplicate nodes and is constructed by concatenating and smoothing the two tree branches.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.05  # 5% samples biased to goal\n        self.rewire_radius = 15.0     # fixed radius for rewiring neighbors\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        time_limit = 30.0  # 30 s wall-clock hard limit\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_dist=None):\n            d = dist(from_pos, to_pos)\n            step = max_dist if max_dist is not None else self.step_size\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b, resolution=1.0):\n            distance = dist(a,b)\n            steps = max(1,int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, p):\n            return min(tree, key = lambda n: dist(n.position, p))\n\n        def near_nodes(tree, p, radius):\n            return [n for n in tree if dist(n.position, p) <= radius]\n\n        # Goal bias sampling: occasionally return goal directly, else uniform random in bounds free space\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                if not is_in_obstacle(goal_pos):\n                    return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            # fallback if unlucky\n            return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        # Initialize trees and supporting structures\n        start_node = Node(start_pos)\n        goal_node = Node(goal_pos)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        success = False\n        path = []\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        # Alternate tree growth\n        expand_start_tree = True\n\n        for iter_count in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            x_rand = sample_free()\n\n            nearest_node = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Choose best parent among neighbors\n            radius = self.rewire_radius\n            neighbors = near_nodes(tree_a, new_pos, radius)\n            best_parent = nearest_node\n            min_cost = new_cost\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        min_cost = tentative_cost\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire other neighbors if better connection found\n            for nb in neighbors:\n                if nb == best_parent or nb == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost:\n                    if not is_edge_in_obstacle(new_node.position, nb.position):\n                        # Remove old edge if exists\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        nb.parent = new_node\n                        nb.cost = alt_cost\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n            # Try connecting new_node to tree_b nodes in radius\n            near_other = near_nodes(tree_b, new_node.position, radius)\n            for other_node in near_other:\n                if is_edge_in_obstacle(new_node.position, other_node.position):\n                    continue\n                # Calculate total cost of connection\n                total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    best_start_node = new_node if expand_start_tree else other_node\n                    best_goal_node = other_node if expand_start_tree else new_node\n\n            if success:\n                # Extract combined path with duplicate connection point removed\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n                if path_start[-1] == path_goal[0]:\n                    path_goal = path_goal[1:]\n                path = path_start + path_goal[::-1]\n                break\n\n            expand_start_tree = not expand_start_tree\n\n        # If success, return full path\n        if success:\n            return PlannerResult(\n                success=True,\n                path=path,\n                nodes=nodes,\n                edges=edges\n            )\n\n        # Otherwise return best partial path from start tree nearest to goal\n        best_partial_node = None\n        best_dist = float('inf')\n        for node in tree_start:\n            d = dist(node.position, goal_pos)\n            if d < best_dist and node.valid:\n                best_dist = d\n                best_partial_node = node\n        if best_partial_node:\n            partial_path = best_partial_node.path_from_root()\n            return PlannerResult(\n                success=False,\n                path=partial_path,\n                nodes=nodes,\n                edges=edges\n            )\n\n        # No progress case\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": -31.88223,
        "time_improvement": 70.0,
        "length_improvement": 16.0,
        "smoothness_improvement": 318.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.012917828559875489,
                "num_nodes_avg": 112.2,
                "path_length_avg": 167.70136746333029,
                "smoothness_avg": 0.02325991201186068,
                "success_improvement": 0.0,
                "time_improvement": 48.591080225594155,
                "length_improvement": 8.080223095126494,
                "smoothness_improvement": 264.06813269298925,
                "objective_score": 20.74579858821909
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.019352173805236815,
                "num_nodes_avg": 256.2,
                "path_length_avg": 239.51954011716208,
                "smoothness_avg": 0.01718477585351879,
                "success_improvement": 0.0,
                "time_improvement": 87.95972855101965,
                "length_improvement": 20.041483321187638,
                "smoothness_improvement": 342.17666040477565,
                "objective_score": 40.123691860042356
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.013465619087219239,
                "num_nodes_avg": 182.0,
                "path_length_avg": 122.07168904397376,
                "smoothness_avg": 0.03515560414413786,
                "success_improvement": 0.0,
                "time_improvement": 72.28614329245853,
                "length_improvement": 18.92579656617262,
                "smoothness_improvement": 347.1766897966619,
                "objective_score": 34.77720437642444
            }
        ],
        "success_rate": 1.0
    }
]