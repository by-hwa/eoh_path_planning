[
    {
        "operator": "m3",
        "algorithm_description": "A single-tree RRT* with adaptive sampling and dynamic radius rewiring combined with path shortcutting to enhance planning speed, path length, and smoothness. The planner uses informed sampling biased towards the ellipsoidal region between start and goal after an initial solution is found, and dynamically adjusts rewiring radius based on node count to better optimize paths. Post-processing shortcutting is applied to the final path to reduce unnecessary detours.",
        "planning_mechanism": "The planner grows a single RRT* tree rooted at the start, uses goal biasing and informed elliptical sampling to concentrate search after an initial path is found, rewires neighbors within a radius that shrinks with tree size to optimize cost, and performs path shortcutting after planning to improve smoothness and length. It consistently checks node and edge validity against obstacles and respects map boundaries.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=7.0, goal_sample_rate=0.1, gamma_rrt_star=50.0, resolution=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star  # parameter controlling rewiring radius\n        self.resolution = resolution  # for edge collision checking\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        nodes = []\n        edges = []\n        root = Node(start)\n        nodes.append(root)\n        success = False\n        goal_node = None\n\n        # For ellipsoid informed sampling after first solution\n        c_best = float('inf')  # cost of best solution found\n        c_min = self._distance(start, goal)\n        x_center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n\n        # Helper to generate uniform random point in unit n-ball\n        def sample_unit_ball():\n            while True:\n                point = tuple(random.uniform(-1, 1) for _ in range(dim))\n                norm = math.sqrt(sum([p * p for p in point]))\n                if 0 < norm <= 1:\n                    return tuple(p / norm for p in point)\n\n        def informed_sample():\n            # If no solution yet, uniform sample\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Sample from ellipsoid defined by start and goal\n            # Following approach from Informed RRT*\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))  # unit vector from start to goal\n            # Compute rotation matrix C that rotates first axis to a1\n            # Done via Householder reflection\n            e1 = [1.0] + [0.0] * (dim - 1)\n            v = [a1[d] - e1[d] for d in range(dim)]\n            s = math.sqrt(sum([vi * vi for vi in v]))\n            if s < 1e-10:\n                C = [[1.0 if i == j else 0.0 for j in range(dim)] for i in range(dim)]\n            else:\n                v = [vi / s for vi in v]\n                C = [[-2 * v[i] * v[j] if i != j else 1 - 2 * v[i] * v[j] for j in range(dim)] for i in range(dim)]\n            r1 = c_best / 2.0  # major axis radius\n            if dim >= 2:\n                r_others = math.sqrt(c_best * c_best - c_min * c_min) / 2.0\n            else:\n                r_others = 0.0\n            # Radii vector for axes\n            L = [r1] + [r_others] * (dim - 1)\n\n            # Sample random point in unit ball, scale and rotate\n            sample_ball = sample_unit_ball()\n            # Scale point\n            scaled = [sample_ball[i] * L[i] for i in range(dim)]\n            # Rotate point by C\n            rotated = [0.0] * dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += C[i][j] * scaled[j]\n                rotated[i] = s\n            # Translate to ellipsoid center\n            p = tuple(rotated[i] + x_center[i] for i in range(dim))\n            # Clamp to bounds if out of range\n            p_clamped = tuple(min(max(0.0, p[i]), bounds[i]) for i in range(dim))\n            return p_clamped\n\n        for iter in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                sample = goal\n            else:\n                sample = informed_sample()\n\n            nearest = self._nearest(nodes, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n\n            # Check bounds\n            if any(new_pos[d] < 0.0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.resolution):\n                continue\n\n            # Create new node and initialize cost and parent using RRT* logic\n            new_node = Node(new_pos)\n            neighbors = self._near(nodes, new_pos, self._rewiring_radius(len(nodes), dim))\n            # Choose parent giving lowest cost path to new_node\n            min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n            min_parent = nearest\n            for node in neighbors:\n                dist_to_new = self._distance(node.position, new_pos)\n                cost = node.cost + dist_to_new\n                if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, self.resolution):\n                    min_cost = cost\n                    min_parent = node\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors if this new_node provides lower cost path\n            for node in neighbors:\n                if node == min_parent:\n                    continue\n                dist = self._distance(new_node.position, node.position)\n                new_cost = new_node.cost + dist\n                if new_cost < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, self.resolution):\n                        # Update parent-child relationships\n                        if node.parent:\n                            try:\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                            if node in node.parent.children:\n                                node.parent.children.remove(node)\n                        node.parent = new_node\n                        node.cost = new_cost\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n            # Check if we can connect to goal directly for solution\n            dist_to_goal = self._distance(new_node.position, goal)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal, obstacles, is_3d, self.resolution) and not self._is_in_obstacle(goal, obstacles, is_3d):\n                    goal_node = Node(goal, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success = True\n                    if goal_node.cost < c_best:\n                        c_best = goal_node.cost\n                    break\n\n        path = []\n        if success and goal_node is not None:\n            # Extract path from goal to start\n            current = goal_node\n            while current:\n                path.append(current.position)\n                current = current.parent\n            path = path[::-1]\n            path = self._shortcut_path(path, obstacles, is_3d)\n\n        return PlannerResult(success, path, nodes, edges)\n\n    def _nearest(self, nodes, point):\n        import math\n        return min(nodes, key=lambda node: math.dist(node.position, point))\n\n    def _near(self, nodes, point, radius):\n        import math\n        radsq = radius * radius\n        results = []\n        px, py = None, None\n        # Optimization to avoid repeated len, distance calls\n        for node in nodes:\n            # Early pruning with squared distance\n            d_sq = sum((node.position[i] - point[i]) ** 2 for i in range(len(point)))\n            if d_sq <= radsq:\n                results.append(node)\n        return results\n\n    def _steer(self, from_p, to_p, step_size):\n        import math\n        dist = self._distance(from_p, to_p)\n        if dist <= step_size:\n            return to_p\n        ratio = step_size / dist\n        return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n    def _distance(self, a, b):\n        import math\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, start_p, end_p, obstacles, is_3d, resolution):\n        import math\n        dist = self._distance(start_p, end_p)\n        steps = max(int(dist / resolution), 1)\n        for i in range(steps + 1):\n            interp = tuple(start_p[d] + (end_p[d] - start_p[d]) * (i / steps) for d in range(len(start_p)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _rewiring_radius(self, n, dim):\n        import math\n        # RRT* radius formula using gamma * (log(n)/n)^(1/d)\n        if n <= 1:\n            return float('inf')\n        from math import log\n        radius = min(self.gamma_rrt_star * (log(n) / n) ** (1 / dim), self.step_size * 5.0)\n        return radius\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        # Repeatedly try to shortcut between two nodes to remove intermediate points\n        if len(path) < 3:\n            return path\n        import random\n        max_attempts = max(50, len(path) * 5)\n        for _ in range(max_attempts):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.resolution):\n                # Shortcut possible, remove intermediate nodes\n                path = path[:i + 1] + path[j:]\n        return path",
        "objective": 54.41329,
        "time_improvement": -238.0,
        "length_improvement": 17.0,
        "smoothness_improvement": 1404.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.043636131286621097,
                "num_nodes_avg": 217.2,
                "path_length_avg": 168.666527582117,
                "smoothness_avg": 0.05273332461113374,
                "success_improvement": 0.0,
                "time_improvement": -68.95031459545683,
                "length_improvement": 7.55120354007871,
                "smoothness_improvement": 725.3910424114681,
                "objective_score": -12.527417042532482
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.2019017219543457,
                "num_nodes_avg": 679.5,
                "path_length_avg": 227.977801536768,
                "smoothness_avg": 0.08916900951698452,
                "success_improvement": 0.0,
                "time_improvement": -24.0749292915322,
                "length_improvement": 23.89444786984831,
                "smoothness_improvement": 2194.3828407135384,
                "objective_score": 18.086104138017017
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.3562834978103638,
                "num_nodes_avg": 559.7,
                "path_length_avg": 122.89733612085618,
                "smoothness_avg": 0.10939128752428735,
                "success_improvement": 0.0,
                "time_improvement": -620.9409236715871,
                "length_improvement": 18.37744109079621,
                "smoothness_improvement": 1291.449102884001,
                "objective_score": -168.79856693257838
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This algorithm is an enhanced bidirectional RRT* with path post-processing for smoothing. It combines two trees grown from start and goal with cost-aware rewiring and adds an efficient path shortcutting step after a solution is found to reduce zigzag and improve curvature, resulting in faster convergence, shorter, and smoother paths.",
        "planning_mechanism": "The planner grows two optimized trees from start and goal in bidirectional RRT* style, rewires nodes locally to minimize cost, and when a connecting path is found, performs path shortcut smoothing by attempting to connect non-adjacent waypoints directly while ensuring collision-free edges, yielding smoother and shorter solutions efficiently.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma_rrt_star=50.0, max_radius=60.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, parent=None, cost=0.0)\n        goal_root = Node(goal_pos, parent=None, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(len(from_p)))\n\n        def near_nodes(tree, position):\n            n = max(1, len(tree))\n            d = len(position)\n            scale = max(1.0, sum(bounds) / d)\n            r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n            radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def is_collision_free(from_p, to_p):\n            if self._is_in_obstacle(to_p, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d):\n                return False\n            return True\n\n        def choose_parent(tree, new_pos):\n            nearest_node = nearest(tree, new_pos)\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                if is_collision_free(nb.position, new_pos):\n                    cost_cand = nb.cost + dist(nb.position, new_pos)\n                    if cost_cand < min_cost:\n                        min_cost = cost_cand\n                        best_parent = nb\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire_from(pivot, neighbors):\n            for nb in neighbors:\n                if is_collision_free(pivot.position, nb.position):\n                    new_cost = pivot.cost + dist(pivot.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        pivot.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((pivot, nb))\n\n        def extend_and_rewire(tree, sample_p):\n            nearest_node = nearest(tree, sample_p)\n            new_pos = steer(nearest_node.position, sample_p)\n            if not is_collision_free(nearest_node.position, new_pos):\n                return None\n            new_node, neighbors = choose_parent(tree, new_pos)\n            rewire_from(new_node, neighbors)\n            return new_node\n\n        def connect_and_rewire(tree, target_node):\n            nearest_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(nearest_node.position, target_node.position)\n                if not is_collision_free(nearest_node.position, new_pos):\n                    return None\n                connect_node, neighbors = choose_parent(tree, new_pos)\n                rewire_from(connect_node, neighbors)\n                if dist(connect_node.position, target_node.position) <= self.step_size:\n                    if is_collision_free(connect_node.position, target_node.position) and not self._is_in_obstacle(target_node.position, obstacles, is_3d):\n                        final_node = Node(target_node.position, parent=None, cost=connect_node.cost + dist(connect_node.position, target_node.position))\n                        connect_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((connect_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = connect_node\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            import random\n            smoothed = path[:]\n            for _ in range(200):\n                if len(smoothed) <= 2:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) -1)\n                p_i = smoothed[i]\n                p_j = smoothed[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    # shortcut possible, remove intermediate nodes\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        success = False\n        path = []\n        for _ in range(self.max_iter):\n            rand_p = sample_free()\n            new_a = extend_and_rewire(tree_a, rand_p)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = connect_and_rewire(tree_b, new_a)\n            if new_b:\n                success = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                # Remove duplicate connection node\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                raw_path = path_a + path_b[::-1]\n                path = shortcut_path(raw_path)\n                break\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -23.33681,
        "time_improvement": 20.0,
        "length_improvement": 16.0,
        "smoothness_improvement": 1517.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.024225378036499025,
                "num_nodes_avg": 70.4,
                "path_length_avg": 165.27293783448243,
                "smoothness_avg": 0.04876837243675059,
                "success_improvement": 0.0,
                "time_improvement": 3.7953134482957775,
                "node_improvement": 82.27146814404432,
                "length_improvement": 9.411283855627978,
                "smoothness_improvement": 663.3309308509168,
                "objective_score": 10.102019002120105
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.044183778762817386,
                "num_nodes_avg": 245.6,
                "path_length_avg": 239.05510817474592,
                "smoothness_avg": 0.10604751432289401,
                "success_improvement": 0.0,
                "time_improvement": 72.73660116170906,
                "node_improvement": 83.49795068198617,
                "length_improvement": 20.19652407149841,
                "smoothness_improvement": 2628.6789264652084,
                "objective_score": 47.082289423737805
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.05563676357269287,
                "num_nodes_avg": 268.0,
                "path_length_avg": 121.72798255614921,
                "smoothness_avg": 0.10677056044821978,
                "success_improvement": 0.0,
                "time_improvement": -16.52295880407895,
                "node_improvement": 65.92498410680228,
                "length_improvement": 19.15407004984152,
                "smoothness_improvement": 1258.1136479183722,
                "objective_score": 12.826122628273087
            }
        ],
        "success_rate": 1.0
    }
]