[
    {
        "parents": [
            "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for iter_num in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or            self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, new_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            connect_node.parent = best_parent\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n\n            nearest = connect_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
            "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    "
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "This algorithm combines bidirectional search with adaptive rewiring and goal biasing to improve path planning efficiency and path quality. It incrementally grows two trees from start and goal, extends toward random samples with a bias toward the goal, and rewires locally to minimize path costs while ensuring collision-free nodes and edges. Upon connection of the two trees, it extracts a smooth and optimized path.",
            "planning_mechanism": "The planner samples points within bounds (with goal bias), extends each tree toward samples within a step size, performs local rewiring to reduce costs, and attempts to connect the two trees on each iteration. It strictly checks for collisions for both nodes and edges, ensuring valid paths. The bidirectional approach accelerates convergence, and rewiring optimizes path costs and smoothness.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # Validity flag (collision-free)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if (\n                not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, new_node):\n            nearest_node = nearest(tree, new_node.position)\n            pos_new = new_node.position\n            if (\n                math.dist(nearest_node.position, pos_new) <= self.step_size and\n                not self._is_edge_in_obstacle(nearest_node.position, pos_new, obstacles, is_3d) and\n                not self._is_in_obstacle(pos_new, obstacles, is_3d)\n            ):\n                return nearest_node\n            return None\n\n        for iter_num in range(self.max_iter):\n            rand_point = sample_free()\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            connect_node_goal = try_connect(tree_goal, new_node_start)\n            if connect_node_goal:\n                # Connect by creating a new node in goal tree near new_node_start\n                new_node_goal = Node(new_node_start.position)\n                best_parent = connect_node_goal\n                neighbors = near_nodes(tree_goal, new_node_goal.position)\n\n                min_cost = best_parent.cost + math.dist(best_parent.position, new_node_goal.position)\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_node_goal.position)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_node_goal.position, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                best_parent.add_child(new_node_goal)\n                new_node_goal.cost = min_cost\n                tree_goal.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((best_parent, new_node_goal))\n\n                # Extract path from start root to new_node_start\n                path_start = new_node_start.path_from_root()\n                # Extract path from goal root to new_node_goal\n                path_goal = new_node_goal.path_from_root()\n                # Connect paths\n                extracted_path = path_start + path_goal[::-1][1:]  # Avoid duplicate node\n                success_state = True\n                break\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
            "objective": -20.70232,
            "time_improvement": 53.0,
            "length_improvement": 16.0,
            "smoothness_improvement": 310.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016640830039978027,
                    "num_nodes_avg": 160.6,
                    "path_length_avg": 167.68313601037386,
                    "smoothness_avg": 0.023542751007624492,
                    "success_improvement": 0.0,
                    "time_improvement": 32.983222929654985,
                    "length_improvement": 8.090216043387771,
                    "smoothness_improvement": 268.49517717140276,
                    "objective_score": 12.855485973431062
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03169040679931641,
                    "num_nodes_avg": 374.2,
                    "path_length_avg": 235.3172522277793,
                    "smoothness_avg": 0.017255337523919966,
                    "success_improvement": 0.0,
                    "time_improvement": 80.45166169229154,
                    "length_improvement": 21.44432797481391,
                    "smoothness_improvement": 343.99226300771477,
                    "objective_score": 30.14432541768882
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025929951667785646,
                    "num_nodes_avg": 309.0,
                    "path_length_avg": 122.50151738270351,
                    "smoothness_avg": 0.032717793611091894,
                    "success_improvement": 0.0,
                    "time_improvement": 45.99413055784529,
                    "length_improvement": 18.640325049814344,
                    "smoothness_improvement": 316.1679197567731,
                    "objective_score": 19.10714377610032
                }
            ],
            "success_rate": 1.0
        },
        "objective": 41.4,
        "analysis": "1. Summary of key changes:\n   - Transitioned from a bidirectional tree approach with explicit connection attempts between two trees to a unidirectional RRT* style planner expanding a single tree.\n   - Introduced goal biasing by sampling the goal position with a certain probability to speed convergence toward the goal.\n   - Added a `update_parent` method in the `Node` class to cleanly handle rewiring of the tree structure.\n   - Implemented a fixed `neighbor_radius` for rewiring nearby nodes instead of a dynamic approach.\n   - Adjusted step size (from 5.0 to 3.0) and other parameters like `goal_sample_rate` and `neighbor_radius` for potentially finer motion increments and more localized rewiring.\n   - Simplified logic to directly extend tree toward samples without iterative intermediate connection steps.\n   - Removed explicit dual-tree swapping and connection logic, reducing complexity.\n   \n2. Primary contributors to the performance improvement:\n   - Goal-biased sampling increasing chances of extending towards the goal to find quicker solutions.\n   - More straightforward rewiring mechanism with `update_parent` improving tree quality and enabling effective cost optimization.\n   - Smaller step size and fixed neighbor radius allowing better path refinement and obstacle avoidance.\n   - Reduction of complexity by focusing on a single tree avoids overhead of managing dual trees and attempts to connect them.\n   \n3. Expected mechanism of impact:\n   - Goal biasing guides the search more directly towards the goal, reducing exploration in irrelevant areas and leading to faster success.\n   - Clean rewiring enhances the tree's path cost optimality during the build process, producing higher-quality paths sooner.\n   - Smaller steps and controlled neighbor radius make incremental expansions more precise and safer with obstacles, improving path feasibility.\n   - Simplified structure reduces computational overhead and potential failures associated with complex dual-tree connections, increasing reliability and efficiency."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success = False\n        final_path = []\n        nodes = []\n        edges = []\n\n        # Initialize two trees: start and goal\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            factor = self.step_size / dist\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position):\n            return [n for n in tree if math.dist(n.position, position) <= self.neighbor_radius]\n\n        def collision_free_node(pos):\n            return (within_bounds(pos) and\n                    not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    # Update edges accordingly\n                    # Remove old edges pointing to neighbor\n                    for idx, (p, c) in enumerate(edges):\n                        if c == neighbor:\n                            edges.pop(idx)\n                            break\n                    edges.append((new_node, neighbor))\n\n        def extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            # Choose best parent among neighbors to minimize cost\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby neighbors if better path found\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        def try_connect(tgt_tree, from_node):\n            nearest_node = nearest(tgt_tree, from_node.position)\n            dist = math.dist(nearest_node.position, from_node.position)\n\n            if dist <= self.step_size and collision_free_node(from_node.position) and collision_free_edge(nearest_node.position, from_node.position):\n                return nearest_node\n            return None\n\n        # Alternate tree growth\n        grow_start_tree = True\n\n        for _ in range(self.max_iter):\n            rand_point = sample()\n\n            if grow_start_tree:\n                new_node = extend(tree_start, rand_point)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = try_connect(tree_goal, new_node)\n                if connect_node:\n                    # Connect goal tree with new_node\n                    neighbors = near_nodes(tree_goal, new_node.position)\n                    min_cost = connect_node.cost + math.dist(connect_node.position, new_node.position)\n                    best_parent = connect_node\n                    for neighbor in neighbors:\n                        tentative_cost = neighbor.cost + math.dist(neighbor.position, new_node.position)\n                        if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                            min_cost = tentative_cost\n                            best_parent = neighbor\n\n                    connecting_node = Node(new_node.position)\n                    best_parent.add_child(connecting_node)\n                    connecting_node.cost = min_cost\n                    tree_goal.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((best_parent, connecting_node))\n\n                    # Rewire around connecting_node in goal tree\n                    rewire(tree_goal, connecting_node, neighbors)\n\n                    # Extract path from start root to new_node\n                    path_start = new_node.path_from_root()\n                    # Extract path from goal root to connecting_node\n                    path_goal = connecting_node.path_from_root()\n\n                    # Merge paths (avoid duplicate)\n                    final_path = path_start + path_goal[::-1][1:]\n                    success = True\n                    break\n            else:\n                new_node = extend(tree_goal, rand_point)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = try_connect(tree_start, new_node)\n                if connect_node:\n                    neighbors = near_nodes(tree_start, new_node.position)\n                    min_cost = connect_node.cost + math.dist(connect_node.position, new_node.position)\n                    best_parent = connect_node\n                    for neighbor in neighbors:\n                        tentative_cost = neighbor.cost + math.dist(neighbor.position, new_node.position)\n                        if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                            min_cost = tentative_cost\n                            best_parent = neighbor\n\n                    connecting_node = Node(new_node.position)\n                    best_parent.add_child(connecting_node)\n                    connecting_node.cost = min_cost\n                    tree_start.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((best_parent, connecting_node))\n\n                    rewire(tree_start, connecting_node, neighbors)\n\n                    path_start = connecting_node.path_from_root()\n                    path_goal = new_node.path_from_root()\n\n                    final_path = path_start + path_goal[::-1][1:]\n                    success = True\n                    break\n\n            grow_start_tree = not grow_start_tree\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=4.0, goal_sample_rate: float=0.1, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def clamp_pos(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        success_state = False\n        extracted_path = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        nodes.append(start_root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        def informed_sample():\n            c_min = dist(start_position, goal_position)\n            c_best = best_cost\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            start_goal_vec = [goal_position[d] - start_position[d] for d in range(dim)]\n            norm_sg = math.sqrt(sum(x*x for x in start_goal_vec))\n            if norm_sg < 1e-8:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            unit_vec = [x / norm_sg for x in start_goal_vec]\n\n            a1 = c_best / 2.0\n            a2 = math.sqrt(max(c_best**2 - c_min**2,0)) / 2.0\n\n            # Rotation matrix L: align unit_vec to x-axis\n            if dim == 2:\n                L = [[unit_vec[0], -unit_vec[1]],\n                     [unit_vec[1],  unit_vec[0]]]\n            elif dim == 3:\n                ux, uy, uz = unit_vec\n                if abs(ux) < 1e-6 and abs(uy) < 1e-6:\n                    L = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    vx = [-uy, ux, 0]\n                    norm_vx = math.sqrt(vx[0]*vx[0]+vx[1]*vx[1]+vx[2]*vx[2])\n                    vx = [x / norm_vx for x in vx]\n                    vy = [unit_vec[1]*vx[2] - unit_vec[2]*vx[1],\n                          unit_vec[2]*vx[0] - unit_vec[0]*vx[2],\n                          unit_vec[0]*vx[1] - unit_vec[1]*vx[0]]\n                    L = [vx, vy, unit_vec]\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            while True:\n                rnd = [random.uniform(-1,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd <= 1:\n                    break\n\n            if dim == 2:\n                sample_canonical = [a1 * rnd[0], a2 * rnd[1]]\n                x = L[0][0]*sample_canonical[0] + L[0][1]*sample_canonical[1]\n                y = L[1][0]*sample_canonical[0] + L[1][1]*sample_canonical[1]\n                mid = tuple(0.5*(start_position[d] + goal_position[d]) for d in range(dim))\n                sample = (mid[0] + x, mid[1] + y)\n                sample = clamp_pos(sample)\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            elif dim == 3:\n                sample_canonical = [a1 * rnd[0], a2 * rnd[1], a2 * rnd[2]]\n                x = sum(L[0][i]*sample_canonical[i] for i in range(3))\n                y = sum(L[1][i]*sample_canonical[i] for i in range(3))\n                z = sum(L[2][i]*sample_canonical[i] for i in range(3))\n                mid = tuple(0.5*(start_position[d] + goal_position[d]) for d in range(dim))\n                sample = (mid[0] + x, mid[1] + y, mid[2] + z)\n                sample = clamp_pos(sample)\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n            # fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    return goal_position\n            if best_goal_node is None:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            return informed_sample()\n\n        def nearest_node(point: Tuple[float, ...]) -> Node:\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near_nodes(new_node: Node) -> List[Node]:\n            r = self.neighbor_radius\n            return [n for n in nodes if dist(n.position, new_node.position) <= r]\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        for _ in range(self.max_iter):\n            rnd_point = sample_point()\n            nearest = nearest_node(rnd_point)\n            new_pos = steer(nearest.position, rnd_point, self.step_size)\n            new_pos = clamp_pos(new_pos)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n\n            # Rewire neighbors\n            neighbors = near_nodes(new_node)\n            for neighbor in neighbors:\n                if neighbor == nearest:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node, potential_cost)\n\n            nodes.append(new_node)\n\n            dist_to_goal = dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d)\n                    and not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    cost_through_new = new_node.cost + dist_to_goal\n                    if cost_through_new < best_cost:\n                        best_cost = cost_through_new\n                        goal_node = Node(goal_position, parent=new_node, cost=cost_through_new)\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        best_goal_node = goal_node\n                        success_state = True\n                        # Optional early termination on first found path\n                        break\n\n        if success_state and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n\n        # Collect edges\n        for node in nodes:\n            if node.parent is not None:\n                edges.append((node.parent, node))\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False"
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "This planner employs a bidirectional RRT* framework with adaptive step sizing and informed, goal-biased sampling. It grows two trees simultaneously from start and goal using incremental steering and collision-checked extensions. The planner attempts to connect the two trees at each iteration with careful rewiring of neighbors to improve path cost locally. It incorporates path smoothing by rewiring and integrates obstacle and boundary checks to maintain robustness and feasibility. This design balances efficient exploration with exploitation via selective tree expansions, delivering fast convergence to high-quality, smooth paths with reduced search time.",
            "planning_mechanism": "The planning mechanism grows two trees alternately from the start and goal positions by sampling points biased towards the goal and free space. Each extension steers towards sampled points within a constrained step size, performing collision checking on nodes and edges. Upon adding a new node, neighbors within a fixed radius are rewired to minimize path costs, enhancing path quality incrementally. The algorithm attempts to connect the two trees when they are sufficiently close, reconstructing an optimized path by joining the two tree branches. The process continues until a feasible path is found or iteration limits are reached.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success = False\n        final_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free(tree_toggle):\n            import random\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_toggle else start_pos\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def dist(a, b):\n            import math\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            import math\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, position):\n            return [n for n in tree if dist(n.position, position) <= self.neighbor_radius]\n\n        def collision_free_node(pos):\n            return (within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    # Update edges list: remove old edge where neighbor is child\n                    for idx in range(len(edges)-1, -1, -1):\n                        p, c = edges[idx]\n                        if c == neighbor:\n                            edges.pop(idx)\n                    edges.append((new_node, neighbor))\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, from_node):\n            nearest_node = nearest(tree, from_node.position)\n            d = dist(nearest_node.position, from_node.position)\n            if d <= self.step_size and collision_free_node(from_node.position) and collision_free_edge(nearest_node.position, from_node.position):\n                return nearest_node\n            return None\n\n        grow_start = True\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free(grow_start)\n\n            if grow_start:\n                new_node = extend(tree_start, rand_point)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                other_node = try_connect(tree_goal, new_node)\n                if other_node:\n                    neighbors = near_nodes(tree_goal, new_node.position)\n                    min_cost = other_node.cost + dist(other_node.position, new_node.position)\n                    best_parent = other_node\n                    for neighbor in neighbors:\n                        tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                        if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                            min_cost = tentative_cost\n                            best_parent = neighbor\n\n                    connecting_node = Node(new_node.position)\n                    best_parent.add_child(connecting_node)\n                    connecting_node.cost = min_cost\n                    tree_goal.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((best_parent, connecting_node))\n\n                    rewire(tree_goal, connecting_node, neighbors)\n\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node.path_from_root()\n\n                    final_path = path_start + path_goal[::-1][1:]\n                    success = True\n                    break\n\n            else:\n                new_node = extend(tree_goal, rand_point)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                other_node = try_connect(tree_start, new_node)\n                if other_node:\n                    neighbors = near_nodes(tree_start, new_node.position)\n                    min_cost = other_node.cost + dist(other_node.position, new_node.position)\n                    best_parent = other_node\n                    for neighbor in neighbors:\n                        tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                        if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                            min_cost = tentative_cost\n                            best_parent = neighbor\n\n                    connecting_node = Node(new_node.position)\n                    best_parent.add_child(connecting_node)\n                    connecting_node.cost = min_cost\n                    tree_start.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((best_parent, connecting_node))\n\n                    rewire(tree_start, connecting_node, neighbors)\n\n                    path_start = connecting_node.path_from_root()\n                    path_goal = new_node.path_from_root()\n\n                    final_path = path_start + path_goal[::-1][1:]\n                    success = True\n                    break\n\n            grow_start = not grow_start\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -18.297,
            "time_improvement": 49.0,
            "length_improvement": 13.0,
            "smoothness_improvement": 223.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01619853973388672,
                    "num_nodes_avg": 96.6,
                    "path_length_avg": 165.34162304377773,
                    "smoothness_avg": 0.01912530007267728,
                    "success_improvement": 0.0,
                    "time_improvement": 34.76443641314628,
                    "length_improvement": 9.373636404026437,
                    "smoothness_improvement": 199.352477391238,
                    "objective_score": 13.300820591705362
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.041682767868041995,
                    "num_nodes_avg": 284.9,
                    "path_length_avg": 253.60776085655706,
                    "smoothness_avg": 0.013151497826404157,
                    "success_improvement": 0.0,
                    "time_improvement": 74.287838807303,
                    "length_improvement": 15.338429731427555,
                    "smoothness_improvement": 238.39751171437626,
                    "objective_score": 26.546025147048294
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.030299663543701172,
                    "num_nodes_avg": 239.7,
                    "path_length_avg": 129.31894887790818,
                    "smoothness_avg": 0.026002197175538512,
                    "success_improvement": 0.0,
                    "time_improvement": 36.89306889394285,
                    "length_improvement": 14.112511661901763,
                    "smoothness_improvement": 230.74602879030036,
                    "objective_score": 15.04415314451471
                }
            ],
            "success_rate": 1.0
        },
        "objective": 24.2,
        "analysis": "1. Summary of key changes:  \n   - Switched from a bidirectional RRT* style planner with explicit two-tree growth and connecting steps to a unidirectional RRT* style planner focused on single-tree growth.  \n   - Introduced informed sampling strategy biased towards the probable best path improving sample efficiency.  \n   - Refined edge and node collision checks with updated resolution and bounds clamping.  \n   - Simplified node connection and rewiring logic to utilize a single tree and goal node tracking, removing explicit tree-to-tree connecting complexity.  \n   - Adjusted parameters such as goal sample rate and neighbor radius for tuning algorithm behavior.  \n\n2. Primary contributors to the performance improvement:  \n   - Implementation of informed sampling reduces random exploration and speeds up convergence.  \n   - Simplified single tree search reduces overhead and complexity of alternating between two trees and explicit connecting procedures.  \n   - Improved rewiring strategy that dynamically updates parent-child relationships and costs with careful edge collision checking.  \n   - Efficient bounding and obstacle checking tailored for both 2D and 3D scenarios.  \n\n3. Expected mechanism of impact:  \n   - Informed sampling focuses exploration in relevant search space regions, increasing chance of finding lower-cost paths quickly.  \n   - Single-tree growth avoids overhead from managing and synchronizing two trees and their connections, leading to faster iteration.  \n   - Better rewiring and parent updating ensures more optimal path improvements during progress, enhancing path cost optimization.  \n   - Clamping positions within bounds and resolution-tuned collision detection reduce invalid expansions and costly collision checks, improving runtime efficiency."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from old parent\n        if self.parent:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        # Alternate between start_tree and goal_tree\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Extend and rewire tree_a toward sample\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                # Swap trees and continue next iteration\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Try to connect tree_b to new_node_a using incremental connection and rewiring\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                # Connection succeeded, extract path from both trees\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            # Swap trees for next iteration\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        # Find best parent to minimize cost\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors if new_node offers cheaper cost path\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                # Rewire neighbor to new_node\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            # Find best parent with minimum cost\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost possible through new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False"
        ],
        "offspring": {
            "operator": "path_expert",
            "algorithm_description": "This planner implements an enhanced bidirectional RRT* path planning algorithm with hybrid rewiring and informed sampling to minimize path length and improve overall planning performance. It grows two trees simultaneously from start and goal, alternates their expansion, and incrementally attempts to connect them while rewiring locally to maintain and improve path optimality. The algorithm integrates goal biasing and neighborhood-based rewiring to dynamically optimize paths and reduce redundant exploration. Node parent-child relationships are carefully managed for cost and structural consistency, enabling efficient path extraction and smooth, short final paths.",
            "planning_mechanism": "The planning mechanism samples points with goal bias, extends one tree toward samples using step-size limited steering while performing local rewiring to optimize parent connections. Then, it incrementally connects and rewires the other tree toward the newly added node. Trees alternate growth each iteration. Collision checks on nodes and edges ensure validity. Successful connection merges two trees' paths into one optimal path. Neighborhood rewiring ensures continuous path cost improvement and smoothness.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Sample point with goal bias towards opposite tree's root\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                # Remove duplicate connection node to avoid repetition\n                if path_b and path_b[0] == path_a[-1]:\n                    path_b = path_b[1:]\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(max(0, min(bounds[d], random.uniform(0, bounds[d]))) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        # Clamp new_pos within bounds\n        new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new_node if path cost improves\n        for neighbor in neighbors:\n            if neighbor is best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.parent.remove_child(neighbor)\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        curr_node = self._nearest(tree, target_pos)\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if better cost path found\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -20.33585,
            "time_improvement": 54.0,
            "length_improvement": 14.0,
            "smoothness_improvement": 259.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011076927185058594,
                    "num_nodes_avg": 73.3,
                    "path_length_avg": 160.95861505039585,
                    "smoothness_avg": 0.021816597870768388,
                    "success_improvement": 0.0,
                    "time_improvement": 55.55534297289412,
                    "length_improvement": 11.776032538405214,
                    "smoothness_improvement": 241.47713217807282,
                    "objective_score": 20.22919506043964
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.036408853530883786,
                    "num_nodes_avg": 236.7,
                    "path_length_avg": 245.6476544824274,
                    "smoothness_avg": 0.01438500763053753,
                    "success_improvement": 0.0,
                    "time_improvement": 77.47230060024279,
                    "length_improvement": 17.995742358070167,
                    "smoothness_improvement": 270.13660743592806,
                    "objective_score": 28.19152168886651
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03534677028656006,
                    "num_nodes_avg": 224.6,
                    "path_length_avg": 131.35812474865287,
                    "smoothness_avg": 0.028835292141927295,
                    "success_improvement": 0.0,
                    "time_improvement": 29.00431801715044,
                    "length_improvement": 12.758188143673454,
                    "smoothness_improvement": 266.78278764544785,
                    "objective_score": 12.586846972107061
                }
            ],
            "success_rate": 1.0
        },
        "objective": 25.2,
        "analysis": "1. Summary of key changes:\n   - Introduction of a `Node` class with attributes for position, parent, cost, children, and validity, along with methods for adding/removing children, updating parent, and extracting path from root.\n   - Implementation of bidirectional search trees (`start_tree` and `goal_tree`) with alternate expansions.\n   - Use of goal-biased random sampling to improve sampling efficiency.\n   - Incorporation of rewiring in both tree expansion and connection phases to ensure lower-cost paths are found.\n   - Incremental connection and rewiring attempted from the second tree to the newly added node in the first tree.\n   - Comprehensive obstacle checking for points and edges in 2D and 3D spaces.\n   - Flexible parameters for max iterations, step size, goal sample rate, and neighbor radius to control exploration behavior.\n\n2. Primary contributors to the performance improvement:\n   - Bidirectional tree growth with alternating expansions improves convergence speed by approaching from both start and goal.\n   - Goal-biased sampling increases the probability of sampling near the goal, enhancing focus on relevant search space.\n   - Rewiring mechanism improves path cost optimization dynamically during tree expansions and connections.\n   - Incremental connection with rewiring provides more accurate, lower-cost connections between the two trees.\n   - Efficient and repeated collision checking on nodes and edges ensures valid and feasible path construction.\n   \n3. Expected mechanism of impact:\n   - By growing two trees simultaneously from start and goal and attempting to connect them frequently, the algorithm reduces the search space effectively, speeding up solution discovery.\n   - Goal bias helps avoid unnecessary exploration in irrelevant areas, focusing computational effort where it's most useful.\n   - Rewiring dynamically improves path quality to reduce total cost, leading to better optimized final paths.\n   - Incremental connection and rewiring reduce the chance of poor early connections, enhancing the overall graph structure.\n   - Robust obstacle checks maintain valid sampling and edge extensions, preventing invalid expansions and increasing success rate."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # Validity flag (collision-free)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if (\n                not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, new_node):\n            nearest_node = nearest(tree, new_node.position)\n            pos_new = new_node.position\n            if (\n                math.dist(nearest_node.position, pos_new) <= self.step_size and\n                not self._is_edge_in_obstacle(nearest_node.position, pos_new, obstacles, is_3d) and\n                not self._is_in_obstacle(pos_new, obstacles, is_3d)\n            ):\n                return nearest_node\n            return None\n\n        for iter_num in range(self.max_iter):\n            rand_point = sample_free()\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            connect_node_goal = try_connect(tree_goal, new_node_start)\n            if connect_node_goal:\n                # Connect by creating a new node in goal tree near new_node_start\n                new_node_goal = Node(new_node_start.position)\n                best_parent = connect_node_goal\n                neighbors = near_nodes(tree_goal, new_node_goal.position)\n\n                min_cost = best_parent.cost + math.dist(best_parent.position, new_node_goal.position)\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_node_goal.position)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_node_goal.position, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                best_parent.add_child(new_node_goal)\n                new_node_goal.cost = min_cost\n                tree_goal.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((best_parent, new_node_goal))\n\n                # Extract path from start root to new_node_start\n                path_start = new_node_start.path_from_root()\n                # Extract path from goal root to new_node_goal\n                path_goal = new_node_goal.path_from_root()\n                # Connect paths\n                extracted_path = path_start + path_goal[::-1][1:]  # Avoid duplicate node\n                success_state = True\n                break\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))"
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "This algorithm implements an improved bidirectional RRT* planner with adaptive rewiring, goal biasing, and incremental connection to rapidly find collision-free, lower cost, and smooth paths. It effectively balances exploration and exploitation by growing start and goal trees simultaneously with goal-directed sampling, local rewiring to optimize tree costs, and precise collision checks. A time budget is enforced to guarantee timely returns.",
            "planning_mechanism": "The planner alternates growing two trees from start and goal positions toward randomly sampled points biased toward the goal. It incrementally extends trees within a step size, rewires neighbors within a fixed radius to minimize costs, and attempts to connect the trees. Collision checks prevent invalid nodes and edges. The best path found so far is returned if a time budget is exceeded, ensuring both efficiency and quality.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0, max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        start_time = time.perf_counter()\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        best_path_cost = float('inf')\n        best_path_nodes = (None, None)  # (node_in_start_tree, node_in_goal_tree)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (\n                not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if beneficial via the new node\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if (\n                    cost_through_new < neighbor.cost and\n                    not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d)\n                ):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n\n            return new_node\n\n        def try_connect_and_rewire(tree, new_node):\n            # Incrementally extend tree towards new_node.position within step size and rewire\n            target_pos = new_node.position\n            current_node = nearest(tree, target_pos)\n\n            while True:\n                dist = math.dist(current_node.position, target_pos)\n                if dist <= self.step_size:\n                    new_pos = target_pos\n                else:\n                    new_pos = steer(current_node.position, target_pos)\n\n                if (\n                    not self._within_bounds(new_pos, bounds) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d)\n                ):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_node_goal = Node(new_pos)\n                best_parent.add_child(new_node_goal)\n                new_node_goal.cost = min_cost\n                tree.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((best_parent, new_node_goal))\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    cost_through_new = new_node_goal.cost + math.dist(new_node_goal.position, neighbor.position)\n                    if (\n                        cost_through_new < neighbor.cost and\n                        not self._is_edge_in_obstacle(new_node_goal.position, neighbor.position, obstacles, is_3d)\n                    ):\n                        neighbor.update_parent(new_node_goal, cost_through_new)\n                        edges.append((new_node_goal, neighbor))\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n\n                if new_node_goal.position == target_pos:\n                    return new_node_goal\n                current_node = new_node_goal\n\n        def path_cost_sum(path_nodes: List[Node]):\n            if not path_nodes:\n                return float('inf')\n            return path_nodes[-1].cost\n\n        def merge_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Avoid duplicate middle node\n            return path_start + path_goal[::-1][1:]\n\n        for iter_num in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_time_sec:\n                # Time limit exceeded, extract best path so far if any\n                if success_state:\n                    extracted_path = merge_paths(best_path_nodes[0], best_path_nodes[1])\n                break\n\n            rnd_point = sample_free()\n\n            new_node_start = try_extend_and_rewire(tree_start, rnd_point)\n            if new_node_start is None:\n                # Swap trees to maintain balanced growth\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            connect_node_goal = try_connect_and_rewire(tree_goal, new_node_start)\n            if connect_node_goal:\n                # Connected trees successfully\n                total_cost = new_node_start.cost + connect_node_goal.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = (new_node_start, connect_node_goal)\n                    extracted_path = merge_paths(new_node_start, connect_node_goal)\n                    success_state = True\n                # Swap trees to keep balanced exploration\n                tree_start, tree_goal = tree_goal, tree_start\n                # Early break for success to reduce planning time\n                if success_state:\n                    break\n            else:\n                # Swap trees for next iteration\n                tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
            "objective": -18.94623,
            "time_improvement": 50.0,
            "length_improvement": 14.0,
            "smoothness_improvement": 271.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017641496658325196,
                    "num_nodes_avg": 84.5,
                    "path_length_avg": 170.50120424036766,
                    "smoothness_avg": 0.019952942408527338,
                    "success_improvement": 0.0,
                    "time_improvement": 25.59526263553606,
                    "length_improvement": 6.545588191379452,
                    "smoothness_improvement": 212.30687720138977,
                    "objective_score": 10.049230814943657
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04605059623718262,
                    "num_nodes_avg": 254.1,
                    "path_length_avg": 248.84054005866628,
                    "smoothness_avg": 0.015314310037129148,
                    "success_improvement": 0.0,
                    "time_improvement": 80.80057589266545,
                    "length_improvement": 16.92986525060597,
                    "smoothness_improvement": 294.04822770699855,
                    "objective_score": 29.09638695645582
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06053769588470459,
                    "num_nodes_avg": 277.0,
                    "path_length_avg": 124.08694361494807,
                    "smoothness_avg": 0.03189665894955138,
                    "success_improvement": 0.0,
                    "time_improvement": 42.15658580257741,
                    "length_improvement": 17.587360436241912,
                    "smoothness_improvement": 305.72314747183384,
                    "objective_score": 17.693063565380776
                }
            ],
            "success_rate": 1.0
        },
        "objective": 31.2,
        "analysis": "1. Summary of key changes:\n   - Implementation of a bidirectional RRT-style planner with two trees grown from start and goal nodes.\n   - Introduction of rewiring that connects new nodes to nearby neighbors if it reduces traversal cost.\n   - Use of a goal sampling rate to bias node sampling towards the goal.\n   - Collision checking improvements including both node and edge obstacle checks with configurable resolution.\n   - Maintaining and updating a cost metric for each node and dynamically reassigning parents to achieve lower cost paths.\n   - Early termination when a connection between the two trees is found, extracting and concatenating paths from both trees.\n2. Primary contributors to the performance improvement:\n   - Bidirectional tree growth reducing exploration time.\n   - Rewiring to optimize path costs, improving path quality.\n   - Goal-biased random sampling enhancing convergence rate.\n   - Efficient obstacle and edge collision checking preventing invalid expansions.\n3. Expected mechanism of impact:\n   - Bidirectional search halves search space and speeds up path finding.\n   - Rewiring reduces path costs and avoids suboptimal path elongations.\n   - Goal bias sampling increases the likelihood of reaching the goal faster.\n   - Accurate collision checks prevent wasted computations on invalid expansions, improving overall efficiency and success rate."
    },
    {
        "parents": [
            "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0, max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        start_time = time.perf_counter()\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        best_path_cost = float('inf')\n        best_path_nodes = (None, None)  # (node_in_start_tree, node_in_goal_tree)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (\n                not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if beneficial via the new node\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if (\n                    cost_through_new < neighbor.cost and\n                    not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d)\n                ):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n\n            return new_node\n\n        def try_connect_and_rewire(tree, new_node):\n            # Incrementally extend tree towards new_node.position within step size and rewire\n            target_pos = new_node.position\n            current_node = nearest(tree, target_pos)\n\n            while True:\n                dist = math.dist(current_node.position, target_pos)\n                if dist <= self.step_size:\n                    new_pos = target_pos\n                else:\n                    new_pos = steer(current_node.position, target_pos)\n\n                if (\n                    not self._within_bounds(new_pos, bounds) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d)\n                ):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_node_goal = Node(new_pos)\n                best_parent.add_child(new_node_goal)\n                new_node_goal.cost = min_cost\n                tree.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((best_parent, new_node_goal))\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    cost_through_new = new_node_goal.cost + math.dist(new_node_goal.position, neighbor.position)\n                    if (\n                        cost_through_new < neighbor.cost and\n                        not self._is_edge_in_obstacle(new_node_goal.position, neighbor.position, obstacles, is_3d)\n                    ):\n                        neighbor.update_parent(new_node_goal, cost_through_new)\n                        edges.append((new_node_goal, neighbor))\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n\n                if new_node_goal.position == target_pos:\n                    return new_node_goal\n                current_node = new_node_goal\n\n        def path_cost_sum(path_nodes: List[Node]):\n            if not path_nodes:\n                return float('inf')\n            return path_nodes[-1].cost\n\n        def merge_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Avoid duplicate middle node\n            return path_start + path_goal[::-1][1:]\n\n        for iter_num in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_time_sec:\n                # Time limit exceeded, extract best path so far if any\n                if success_state:\n                    extracted_path = merge_paths(best_path_nodes[0], best_path_nodes[1])\n                break\n\n            rnd_point = sample_free()\n\n            new_node_start = try_extend_and_rewire(tree_start, rnd_point)\n            if new_node_start is None:\n                # Swap trees to maintain balanced growth\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            connect_node_goal = try_connect_and_rewire(tree_goal, new_node_start)\n            if connect_node_goal:\n                # Connected trees successfully\n                total_cost = new_node_start.cost + connect_node_goal.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = (new_node_start, connect_node_goal)\n                    extracted_path = merge_paths(new_node_start, connect_node_goal)\n                    success_state = True\n                # Swap trees to keep balanced exploration\n                tree_start, tree_goal = tree_goal, tree_start\n                # Early break for success to reduce planning time\n                if success_state:\n                    break\n            else:\n                # Swap trees for next iteration\n                tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))"
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "This algorithm implements a bidirectional RRT* planner with goal biasing, adaptive rewiring, and incremental tree connections to improve planning efficiency, path quality, and robustness. It grows two search trees simultaneously from start and goal points, dynamically rewires nodes to reduce path costs, biases sampling toward the goal to accelerate convergence, and enforces a maximum planning time. It terminates early upon finding a feasible path or time expiration, returning the best solution found.",
            "planning_mechanism": "The planner alternates growing and rewiring two trees from start and goal by sampling points (biased toward goal), extending nodes stepwise with collision checks, rewiring neighbors for cost reduction, and incrementally connecting the trees. If trees connect, the resultant low-cost path is extracted by merging paths from both trees. Within a 30-second limit, the algorithm balances exploration and exploitation to find smooth, short, and feasible paths efficiently.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]; 2D or 3D\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []              # List of child nodes\n        self.valid = True               # Validity flag for collision check\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_radius: float=15.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        import time\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        start_time = time.perf_counter()\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        success_state = False\n        extracted_path = []\n        best_path_cost = float('inf')\n        best_path_nodes = (None, None)  # Tuple of nodes in start and goal trees\n\n        def sample_free():\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dimension))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (\n                not within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                cost_thru_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_thru_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    neighbor.update_parent(new_node, cost_thru_new)\n                    edges.append((new_node, neighbor))\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n\n            return new_node\n\n        def try_connect_and_rewire(tree, new_node):\n            target = new_node.position\n            current_node = nearest(tree, target)\n\n            while True:\n                dist = math.dist(current_node.position, target)\n                if dist <= self.step_size:\n                    new_pos = target\n                else:\n                    new_pos = steer(current_node.position, target)\n\n                if (\n                    not within_bounds(new_pos) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d)\n                ):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_node_goal = Node(new_pos)\n                best_parent.add_child(new_node_goal)\n                new_node_goal.cost = min_cost\n                tree.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((best_parent, new_node_goal))\n\n                for neighbor in neighbors:\n                    cost_thru_new = new_node_goal.cost + math.dist(new_node_goal.position, neighbor.position)\n                    if cost_thru_new < neighbor.cost and not self._is_edge_in_obstacle(new_node_goal.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node_goal, cost_thru_new)\n                        edges.append((new_node_goal, neighbor))\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n\n                if new_node_goal.position == target:\n                    return new_node_goal\n                current_node = new_node_goal\n\n        def merge_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]  # Avoid duplicate middle node\n\n        for iter_num in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_time_sec:\n                # Time exceeded, return best path found (if any)\n                if success_state:\n                    extracted_path = merge_paths(best_path_nodes[0], best_path_nodes[1])\n                break\n\n            rnd_point = sample_free()\n\n            new_node_start = try_extend_and_rewire(tree_start, rnd_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            connect_node_goal = try_connect_and_rewire(tree_goal, new_node_start)\n            if connect_node_goal:\n                total_cost = new_node_start.cost + connect_node_goal.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = (new_node_start, connect_node_goal)\n                    extracted_path = merge_paths(new_node_start, connect_node_goal)\n                    success_state = True\n\n                tree_start, tree_goal = tree_goal, tree_start\n\n                # Optional early break to reduce planning time on success\n                if success_state:\n                    break\n            else:\n                tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -21.99894,
            "time_improvement": 59.0,
            "length_improvement": 15.0,
            "smoothness_improvement": 276.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013381409645080566,
                    "num_nodes_avg": 76.5,
                    "path_length_avg": 166.83413501227932,
                    "smoothness_avg": 0.019463577249412372,
                    "success_improvement": 0.0,
                    "time_improvement": 43.56259621891708,
                    "length_improvement": 8.555566943725118,
                    "smoothness_improvement": 204.64724978778887,
                    "objective_score": 15.803128503359092
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.052031731605529784,
                    "num_nodes_avg": 274.1,
                    "path_length_avg": 246.89388693282086,
                    "smoothness_avg": 0.015621323729922434,
                    "success_improvement": 0.0,
                    "time_improvement": 78.30691969788298,
                    "length_improvement": 17.57971409531666,
                    "smoothness_improvement": 301.94791115559445,
                    "objective_score": 28.5177582842062
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04690549373626709,
                    "num_nodes_avg": 239.1,
                    "path_length_avg": 124.15395131017871,
                    "smoothness_avg": 0.033219353543958816,
                    "success_improvement": 0.0,
                    "time_improvement": 55.18207519016236,
                    "length_improvement": 17.542857115633282,
                    "smoothness_improvement": 322.5477250815371,
                    "objective_score": 21.67593260558305
                }
            ],
            "success_rate": 1.0
        },
        "objective": 33.4,
        "analysis": "1. Summary of key changes:\n   - Added goal bias in sampling with a configurable `goal_sample_rate` parameter.\n   - Implemented incremental extension and rewiring when connecting the two trees instead of a direct connect check.\n   - Enhanced rewiring logic by properly updating parents and children, including removal from old parent's children.\n   - Introduced a time limit (`max_time_sec`) to prevent excessive planning time.\n   - Maintained and updated the best path found so far, allowing early termination upon success.\n   - Added thorough boundary checks to ensure new nodes remain within map limits.\n   - Improved node management with explicit methods for adding children and updating parents, improving data consistency.\n   - Several structural and readability improvements, including breaking down methods and improved variable naming.\n\n2. Primary contributors to the performance improvement:\n   - Goal bias sampling increasing likelihood of sampling near goal positions and thus faster convergence.\n   - Incremental tree connection with rewiring enabling more effective exploration and lower cost path rewiring.\n   - Time-based stopping criterion preventing unnecessary long computations.\n   - Maintenance of the best path cost and early break reducing total iterations needed.\n   - Safe bounds checking avoiding invalid expansions outside of map limits.\n   - More robust parent-child relationship handling reducing errors and ensuring correct path extraction.\n\n3. Expected mechanism of impact:\n   - Goal sampling focuses tree growth towards goal, increasing chance of connection.\n   - Incremental rewiring improves path optimality and exploration diversity, reducing total path cost.\n   - Time cutoff bounds computational resources, enabling practical planning durations.\n   - Tracking best path allows to terminate once a sufficiently good path is found.\n   - Boundary checks prevent wasted computational efforts on invalid nodes.\n   - Improved parent-child handling ensures structural integrity of trees and consistent cost updates, enhancing correctness and stability of algorithm."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success = False\n        final_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free(tree_toggle):\n            import random\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_toggle else start_pos\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def dist(a, b):\n            import math\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            import math\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, position):\n            return [n for n in tree if dist(n.position, position) <= self.neighbor_radius]\n\n        def collision_free_node(pos):\n            return (within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    # Update edges list: remove old edge where neighbor is child\n                    for idx in range(len(edges)-1, -1, -1):\n                        p, c = edges[idx]\n                        if c == neighbor:\n                            edges.pop(idx)\n                    edges.append((new_node, neighbor))\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, from_node):\n            nearest_node = nearest(tree, from_node.position)\n            d = dist(nearest_node.position, from_node.position)\n            if d <= self.step_size and collision_free_node(from_node.position) and collision_free_edge(nearest_node.position, from_node.position):\n                return nearest_node\n            return None\n\n        grow_start = True\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free(grow_start)\n\n            if grow_start:\n                new_node = extend(tree_start, rand_point)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                other_node = try_connect(tree_goal, new_node)\n                if other_node:\n                    neighbors = near_nodes(tree_goal, new_node.position)\n                    min_cost = other_node.cost + dist(other_node.position, new_node.position)\n                    best_parent = other_node\n                    for neighbor in neighbors:\n                        tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                        if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                            min_cost = tentative_cost\n                            best_parent = neighbor\n\n                    connecting_node = Node(new_node.position)\n                    best_parent.add_child(connecting_node)\n                    connecting_node.cost = min_cost\n                    tree_goal.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((best_parent, connecting_node))\n\n                    rewire(tree_goal, connecting_node, neighbors)\n\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node.path_from_root()\n\n                    final_path = path_start + path_goal[::-1][1:]\n                    success = True\n                    break\n\n            else:\n                new_node = extend(tree_goal, rand_point)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                other_node = try_connect(tree_start, new_node)\n                if other_node:\n                    neighbors = near_nodes(tree_start, new_node.position)\n                    min_cost = other_node.cost + dist(other_node.position, new_node.position)\n                    best_parent = other_node\n                    for neighbor in neighbors:\n                        tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                        if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                            min_cost = tentative_cost\n                            best_parent = neighbor\n\n                    connecting_node = Node(new_node.position)\n                    best_parent.add_child(connecting_node)\n                    connecting_node.cost = min_cost\n                    tree_start.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((best_parent, connecting_node))\n\n                    rewire(tree_start, connecting_node, neighbors)\n\n                    path_start = connecting_node.path_from_root()\n                    path_goal = new_node.path_from_root()\n\n                    final_path = path_start + path_goal[::-1][1:]\n                    success = True\n                    break\n\n            grow_start = not grow_start\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False"
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "This improved planner builds upon a bidirectional RRT* framework and integrates adaptive neighbor radius based on current exploration to enhance rewiring efficiency. It incorporates goal-biased sampling, incremental steering with collision checking, and frequent attempts to connect the two growing trees with incremental rewiring. It introduces early termination based on a 30-second time limit to maintain practical runtime while preserving solution quality. Path smoothing is applied via random shortcutting after path extraction to improve smoothness without significant overhead. The node structure supports efficient parent-child management and cost updates for robust path quality improvement.",
            "planning_mechanism": "The planner alternately grows two trees from start and goal positions through nearest neighbor extensions towards goal-biased random samples. Each new node is connected by rewiring nearby nodes within an adaptive radius, optimizing path costs dynamically. Frequent connection attempts link the two trees, forming feasible paths when proximity and obstacle-free edges permit. The process is bounded by a max iteration and a 30-second runtime limit. Upon success or timeout, the best path found is extracted and smoothed by shortcutting to reduce unnecessary waypoints and improve smoothness.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = parent                # Node or None\n        self.cost = cost                    # Total cost from root\n        self.children = []\n        self.valid = True                   # For obstacle validity if needed\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, max_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_time = max_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size  # Tuple[int, ...]\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        # Adaptive neighbor radius based on number of nodes and dimension (RRT*)\n        def adaptive_neighbor_radius(n_nodes):\n            gamma_rrt_star = 2 * (1.5 ** (1 / dim))  # approx. factor for dimensional space\n            r = min(self.step_size * 5.0, gamma_rrt_star * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim)))\n            # Minimum radius floor\n            return max(r, self.step_size * 1.5)\n\n        def sample_free(tree_toggle):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_toggle else start_pos\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            # simple linear search suffices\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [n for n in tree if dist(n.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=1.0)\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-7 < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost + 1e-7 < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, from_node):\n            nearest_node = nearest(tree, from_node.position)\n            d = dist(nearest_node.position, from_node.position)\n            if d <= self.step_size and collision_free_node(from_node.position) and collision_free_edge(nearest_node.position, from_node.position):\n                return nearest_node\n            return None\n\n        # Path shortcutting for smoothing: attempt random shortcuts on path to reduce waypoints\n        def path_shortcut(path: List[Tuple[float, ...]], max_attempts=50):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=1.0):\n                    # Remove nodes between i+1 and j-1\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = list(tree_start) + list(tree_goal)\n        edges = []\n\n        grow_start = True\n        success = False\n        final_path = []\n        # Store best cost and best nodes to extract feasible path after timeout\n        best_cost = float('inf')\n        best_connection = None  # (node_in_start_tree, node_in_goal_tree)\n\n        time_start = time.time()\n\n        for iter_num in range(self.max_iter):\n            elapsed = time.time() - time_start\n            if elapsed > self.max_time:\n                break  # Timeout\n\n            rand_point = sample_free(grow_start)\n\n            current_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(current_tree, rand_point)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            # Track edges added during extend\n            # (parent,new_node) must be collision free and checked during extend\n            edges.append((new_node.parent, new_node))\n\n            # Attempt to connect new_node to other_tree\n            connecting_node = try_connect(other_tree, new_node)\n            if connecting_node:\n                # Rewire other tree around possible connection point with adaptive radius\n                radius_other = adaptive_neighbor_radius(len(other_tree))\n                neighbors_other = near_nodes(other_tree, new_node.position, radius_other)\n\n                # Find best parent in other tree for connecting node\n                min_cost = connecting_node.cost + dist(connecting_node.position, new_node.position)\n                best_parent_other = connecting_node\n                for neighbor in neighbors_other:\n                    tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                    if tentative_cost + 1e-7 < min_cost and collision_free_edge(neighbor.position, new_node.position):\n                        min_cost = tentative_cost\n                        best_parent_other = neighbor\n\n                connecting_node_other = Node(new_node.position)\n                best_parent_other.add_child(connecting_node_other)\n                connecting_node_other.cost = min_cost\n                other_tree.append(connecting_node_other)\n\n                edges.append((best_parent_other, connecting_node_other))\n\n                rewire(other_tree, connecting_node_other, neighbors_other)\n\n                # Extract paths from both trees\n                if grow_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node_other.path_from_root()\n                else:\n                    path_start = connecting_node_other.path_from_root()\n                    path_goal = new_node.path_from_root()\n\n                # Combine paths, remove duplicated node\n                joined_path = path_start + path_goal[::-1][1:]\n\n                # Update best cost and path if improved\n                total_cost = new_node.cost + connecting_node_other.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (path_start, path_goal[::-1])\n\n                # Mark success and break\n                final_path = joined_path\n                success = True\n                break\n\n            nodes.extend([new_node])\n            grow_start = not grow_start\n\n        # If not success but have best connection for partial path:\n        if not success and best_connection is not None:\n            path_start, path_goal_rev = best_connection\n            final_path = path_start + path_goal_rev[1:]\n            success = True if len(final_path) > 1 else False\n\n        # Post-processing: path smoothing via shortcutting if path found and more than 2 points\n        if success and len(final_path) > 2:\n            final_path = path_shortcut(final_path, max_attempts=75)\n\n        # Build edge list from nodes (parent-child)\n        edges.clear()\n        all_nodes = []\n        node_set = set()\n        def collect_nodes_and_edges(node):\n            if node in node_set:\n                return\n            node_set.add(node)\n            all_nodes.append(node)\n            for c in node.children:\n                edges.append((node, c))\n                collect_nodes_and_edges(c)\n\n        # Collect from both trees, avoid duplicates by set\n        for node in tree_start:\n            collect_nodes_and_edges(node)\n        for node in tree_goal:\n            collect_nodes_and_edges(node)\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -25.46582,
            "time_improvement": 54.0,
            "length_improvement": 15.0,
            "smoothness_improvement": 1244.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019983816146850585,
                    "num_nodes_avg": 96.8,
                    "path_length_avg": 170.2199533723818,
                    "smoothness_avg": 0.03191661323621712,
                    "success_improvement": 0.0,
                    "time_improvement": 15.716301131147329,
                    "length_improvement": 6.6997462488276955,
                    "smoothness_improvement": 399.5643051817539,
                    "objective_score": 8.052661115018507
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05431396961212158,
                    "num_nodes_avg": 257.2,
                    "path_length_avg": 236.52350437862407,
                    "smoothness_avg": 0.08310278940495856,
                    "success_improvement": 0.0,
                    "time_improvement": 77.35540855616505,
                    "length_improvement": 21.04164628681887,
                    "smoothness_improvement": 2038.2946279093733,
                    "objective_score": 37.606424963760155
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03142735958099365,
                    "num_nodes_avg": 216.0,
                    "path_length_avg": 125.86434766351888,
                    "smoothness_avg": 0.10952251178835211,
                    "success_improvement": 0.0,
                    "time_improvement": 69.97134180929318,
                    "length_improvement": 16.406893298066827,
                    "smoothness_improvement": 1293.1182658369369,
                    "objective_score": 30.738372531586002
                }
            ],
            "success_rate": 1.0
        },
        "objective": 30.4,
        "analysis": "1. Summary of key changes:\n   - Introduction of a Bidirectional RRT* style planner using two trees grown from start and goal.\n   - Implementation of the `Node` class encapsulating position, parent, cost, children, and validity, with methods for path reconstruction and parent updating.\n   - Use of adaptive sampling between start and goal positions with a goal sampling rate to bias sampling.\n   - Incorporation of rewiring logic to optimize path costs dynamically when new nodes are added.\n   - Collision checking for nodes and edges to ensure validity within the environment's obstacles.\n   - Switching growth between the two trees alternately to efficiently connect start and goal.\n   - Returning a combined path from both trees when a connection is found.\n   - Maintenance of nodes and edges lists for tracking the constructed roadmap during planning.\n   - Methods for collision detection in 2D and 3D environments.\n   - Limiting maximum iterations, with configurable step size, goal sampling rate, and neighbor radius parameters.\n\n2. Primary contributors to the performance improvement:\n   - Bidirectional growth of trees from start and goal reduces search space and hastens connection.\n   - Rewiring operation leading to incremental path cost improvements and more optimal solutions.\n   - Goal-biased adaptive sampling improving convergence speed toward the goal.\n   - Efficient nearest and near node searches leveraging spatial locality with neighbor radius.\n   - Robust collision checking ensuring only feasible expansions and path segments.\n   - Dynamic parent updating for nodes to maintain minimal path cost trees.\n\n3. Expected mechanism of impact:\n   - Bidirectional tree growth shortens search time by tackling the planning problem simultaneously from both ends.\n   - Rewiring prevents suboptimal path selection by constantly improving parent-child connections, thus lowering the total path cost.\n   - Goal-directed sampling increases the probability of exploring regions closer to the goal, enhancing solution quality and convergence speed.\n   - Adaptive neighbor search enables better local path optimization around new nodes.\n   - Collision checks prune invalid nodes and edges early, preventing wasted computational effort on invalid paths.\n   - Together, these improvements enhance planner efficiency, solution optimality, and robustness in complex environments."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 4.0,\n                 goal_sample_rate: float = 0.15, neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 25.0, time_limit_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = math.inf\n        best_connection = None\n        extracted_path = []\n        success_state = False\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free(tree_from, tree_to):\n            if random.random() < self.goal_sample_rate:\n                return tree_to[0].position\n            for _ in range(50):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return tree_to[0].position\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, position) ** 2) <= radius_sq]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 50.0\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1 / dim)\n            return max(self.neighbor_radius_min, min(r, self.neighbor_radius_max))\n\n        def try_extend(tree_from, sample):\n            node_near = nearest(tree_from, sample)\n            new_pos = steer(node_near.position, sample)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(node_near.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            n_nodes = len(tree_from)\n            radius = adaptive_radius(n_nodes)\n            neighbors = near_nodes(tree_from, new_pos, radius)\n\n            min_cost = node_near.cost + math.dist(node_near.position, new_pos)\n            best_parent = node_near\n            for neighbor in neighbors:\n                cost_try = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_try < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_try\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            curr = nearest(tree, target_pos)\n            max_steps = int(math.dist(curr.position, target_pos) / self.step_size) + 2\n            last_node = curr\n            for _ in range(max_steps):\n                new_pos = steer(last_node.position, target_pos)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_node = Node(new_pos)\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + math.dist(last_node.position, new_pos)\n                best_parent = last_node\n                for neighbor in neighbors:\n                    cost_try = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_try < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_try\n                        best_parent = neighbor\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                last_node = new_node\n                if math.dist(last_node.position, target_pos) <= self.step_size:\n                    return last_node\n            return None\n\n        def path_smoothing(path, max_iters=100):\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                    length = len(path)\n            return path\n\n        start_time = time.time()\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            if (time.time() - start_time) > self.time_limit_sec:\n                break\n\n            sample = sample_free(tree_a, tree_b)\n            new_node_a = try_extend(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect(tree_b, new_node_a.position)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    combined = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined)\n                    success_state = True\n                    break  # Early termination on successful connection\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined = path_a + path_b[::-1]\n            extracted_path = path_smoothing(combined)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=3.0, goal_sample_rate: float=0.15,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import time\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def sample_free(tree_indicator):\n            # tree_indicator: True for start_tree sampling goal, False for goal_tree sampling start\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_indicator else start_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d) and self._within_bounds(p, bounds):\n                    return p\n            return goal_pos if tree_indicator else start_pos\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (math.dist(n.position, pos) ** 2) <= radius_sq]\n\n        def valid_node(pos):\n            return self._within_bounds(pos, bounds) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def valid_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            # Volume of ball in R^d: For 2D \u03c0r^2, 3D (4/3)\u03c0r^3; Using heuristic R ~ gamma * (log(n)/n)^(1/d)\n            gamma = 25.0  # tuning parameter\n            radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(radius, self.max_neighbor_radius))\n\n        def add_node(tree, new_pos, best_parent, cost):\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and valid_edge(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree, sample, tree_indicator):\n            if len(tree) == 0:\n                return None\n            nearest = min(tree, key=lambda node: math.dist(node.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not valid_node(new_pos): \n                return None\n            if not valid_edge(nearest.position, new_pos):\n                return None\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            if len(tree) == 0:\n                return None\n            nearest = min(tree, key=lambda node: math.dist(node.position, target_pos))\n            curr_node = nearest\n\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not valid_node(new_pos) or not valid_edge(curr_node.position, new_pos):\n                    return None\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                        min_cost = cost_through_neighbor\n                        best_parent = neighbor\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n                rewire(tree, new_node, neighbors)\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                curr_node = new_node\n\n        def path_smoothing(raw_path, iterations=50):\n            if len(raw_path) <= 2:\n                return raw_path[:]\n            path = raw_path[:]\n            for _ in range(iterations):\n                if len(path) <= 2:\n                    break\n                idx1 = random.randint(0, len(path) - 2)\n                idx2 = random.randint(idx1 + 1, len(path) -1)\n                if idx2 == idx1 + 1:\n                    continue\n                p1 = path[idx1]\n                p2 = path[idx2]\n                # Check collision-free shortcut\n                if valid_edge(p1, p2):\n                    # Remove intermediate nodes\n                    path = path[:idx1 + 1] + path[idx2:]\n            return path\n\n        start_time = time.time()\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        tree_a = start_tree\n        tree_b = goal_tree\n        success = False\n        best_path = []\n        best_cost = math.inf\n\n        for iter_cnt in range(self.max_iter):\n            if time.time() - start_time > self.max_time_sec:\n                # Time exceeded: return best found\n                break\n\n            sample = sample_free(tree_indicator=True)  # tree_a grows towards goal_pos\n            new_node_a = extend_and_rewire(tree_a, sample, True)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                # Found connection\n                path_from_start = new_node_a.path_from_root()\n                path_from_goal = new_node_b.path_from_root()\n                combined_path = path_from_start + path_from_goal[::-1][1:]  # avoid duplicate connect node\n\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    success = True\n\n                # Attempt smoothing\n                smoothed_path = path_smoothing(best_path, iterations=100)\n                best_path = smoothed_path\n\n                # Stop on first found improved solution\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False"
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "This hybrid planner combines bidirectional RRT* with adaptive neighbor radius, incremental extend-and-rewire steps, and goal-biased sampling. It grows two trees alternately from start and goal, dynamically rewiring neighbors to optimize path cost and smoothness. Rigorous collision checks for nodes and edges ensure path validity. The algorithm enforces a 30-second runtime limit, returns the best feasible path found so far, and applies path smoothing for improved quality and shorter lengths.",
            "planning_mechanism": "The planner alternately samples points biased towards the opposite tree\u2019s root, extends the current tree incrementally with step-size limits, rewires neighbors within an adaptive radius to minimize cost, and attempts incremental connections to the other tree. On successful connection or timeout, it reconstructs and smooths the combined path. Nodes and edges are tracked for roadmap analysis.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n        if parent is not None:\n            self.parent.add_child(self)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Update parent and cost, then propagate cost updates recursively to children\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n        # Recursively update children's costs\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=4.0, goal_sample_rate: float=0.15,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of rectangular obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        best_cost = math.inf\n        best_connection = None\n        extracted_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        start_time = time.time()\n        tree_a, tree_b = start_tree, goal_tree  # Alternate expansions\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free(tree_from_root_pos, tree_to_root_pos):\n            # Goal-biased sampling towards opposite tree root\n            if random.random() < self.goal_sample_rate:\n                return tree_to_root_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                    return p\n            return tree_to_root_pos  # fallback\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius*radius\n            return [node for node in tree if (math.dist(node.position, position)**2) <= radius_sq]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = 25.0\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        def valid_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def valid_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def add_node(tree, new_pos, best_parent, cost):\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and valid_edge(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree, sample):\n            if len(tree) == 0:\n                return None\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not valid_node(new_pos):\n                return None\n            if not valid_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            if len(tree) == 0:\n                return None\n            nearest_node = nearest(tree, target_pos)\n            curr_node = nearest_node\n            max_steps = int(math.dist(curr_node.position, target_pos) / self.step_size) + 3\n            for _ in range(max_steps):\n                new_pos = steer(curr_node.position, target_pos)\n                if not valid_node(new_pos) or not valid_edge(curr_node.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                        min_cost = cost_through_neighbor\n                        best_parent = neighbor\n\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n                rewire(tree, new_node, neighbors)\n\n                curr_node = new_node\n                if math.dist(curr_node.position, target_pos) <= self.step_size:\n                    return curr_node\n            return None\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_iters=100) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            smoothed_path = path[:]\n            for _ in range(max_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not valid_edge(smoothed_path[i], smoothed_path[j]):\n                    continue\n                # Shortcut path\n                smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n                length = len(smoothed_path)\n            return smoothed_path\n\n        for _ in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.max_time_sec:\n                # Timeout reached\n                break\n\n            sample = sample_free(tree_a[0].position, tree_b[0].position)\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    # Combine with no duplicated connect node\n                    combined_path = path_a + path_b[::-1][1:]\n                    extracted_path = path_smoothing(combined_path, max_iters=100)\n                    success_state = True\n\n                # Early termination when found a connection\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If timeout or no early stop but found best path, reconstruct path\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined_path = path_a + path_b[::-1][1:]\n            extracted_path = path_smoothing(combined_path, max_iters=100)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -29.71144,
            "time_improvement": 64.0,
            "length_improvement": 18.0,
            "smoothness_improvement": 1391.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01094198226928711,
                    "num_nodes_avg": 71.9,
                    "path_length_avg": 159.3879990283421,
                    "smoothness_avg": 0.03611968111442979,
                    "success_improvement": 0.0,
                    "time_improvement": 53.851119734292496,
                    "length_improvement": 12.636912068096395,
                    "smoothness_improvement": 465.3514445837642,
                    "objective_score": 21.009475556825848
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.055727267265319826,
                    "num_nodes_avg": 295.1,
                    "path_length_avg": 229.22588968501387,
                    "smoothness_avg": 0.0851665813883569,
                    "success_improvement": 0.0,
                    "time_improvement": 76.76617620629713,
                    "length_improvement": 23.477800121738362,
                    "smoothness_improvement": 2091.3974821314937,
                    "objective_score": 38.18240029689428
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04135787487030029,
                    "num_nodes_avg": 235.5,
                    "path_length_avg": 122.57216148158086,
                    "smoothness_avg": 0.13488954490947164,
                    "success_improvement": 0.0,
                    "time_improvement": 60.482792556160256,
                    "length_improvement": 18.593406603050504,
                    "smoothness_improvement": 1615.7850547379617,
                    "objective_score": 29.942444361147988
                }
            ],
            "success_rate": 1.0
        },
        "objective": 25.199999999999996,
        "analysis": "1. Summary of key changes:\n   - Enhanced node parent update with recursive cost propagation to children in `Node.update_parent`.\n   - Adaptive neighbor radius calculation with refined gamma value and separate minimum and maximum radius bounds.\n   - Improved rewiring logic that updates children costs recursively when parent's cost changes.\n   - More robust collision and bounds checking with clear separation of `_is_in_obstacle` and `_within_bounds`.\n   - Early termination of planning once a better path is found during iterations.\n   - More consistent management of tree growth with `extend_and_rewire` and `incremental_connect_and_rewire` functions, including rewiring neighbors on addition.\n   - Path smoothing with multiple randomized shortcut attempts to prune intermediate nodes efficiently.\n   - Switched from fixed radius to adaptive neighbor radius based on sampling density and logarithmic scaling.\n   \n2. Primary contributors to the performance improvement:\n   - Recursive parent update with propagation to descendants ensuring accurate cost calculation.\n   - Adaptive neighbor radius calculation improving efficiency and path quality.\n   - More effective rewiring strategy reducing path costs dynamically.\n   - Early stopping condition upon successful connection reduces unnecessary computation.\n   - Enhanced path smoothing leading to shorter and more optimal paths.\n\n3. Expected mechanism of impact:\n   - Propagation of cost updates through the tree allows better cost estimates and more optimal rewiring, directly improving path quality.\n   - Adaptive radius ensures connectivity while avoiding excessive neighbor checks, balancing speed and accuracy.\n   - Early termination prevents wasted iterations once a viable solution is found, lowering run-time.\n   - Improved smoothing removes redundant waypoints, shortening the path and reducing traversal cost.\n   - Clear and rigorous collision and bounds checks improve stability and correctness, avoiding invalid expansions and ensuring progress."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Path cost from root\n        self.children = []\n        self.valid = True                 # Collision status\n\n        if parent:\n            self.parent.add_child(self)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        # Propagate cost update to children\n        for child in self.children:\n            dist_to_child = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist_to_child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, neighbor_radius: float=15.0,\n                 max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def within_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, position):\n            radius = self.neighbor_radius\n            return [n for n in tree if dist(n.position, position) <= radius]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size/5)\n\n        c_min = dist(start_pos, goal_pos)\n        best_path_cost = math.inf\n        best_path_nodes = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        start_time = time.perf_counter()\n        grow_start = True\n        informed_sampling_enabled = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                k = (-0.0, -vy, -vz)\n                k_norm = math.sqrt(k[0]**2 + k[1]**2 + k[2]**2)\n                if k_norm < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                k = tuple(ki / k_norm for ki in k)\n                cos_theta = vx\n                sin_theta = k_norm\n                Kx, Ky, Kz = k\n                K = [[0, -Kz, Ky], [Kz, 0, -Kx], [-Ky, Kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-8:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best**2 - c_min**2, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best**2 - c_min**2, 0.0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            def unit_ball_sample(n):\n                while True:\n                    pt = [random.uniform(-1,1) for _ in range(n)]\n                    norm_sq = sum(x*x for x in pt)\n                    if norm_sq <= 1.0 and norm_sq > 1e-10:\n                        norm = math.sqrt(norm_sq)\n                        return tuple(x / norm for x in pt)\n\n            while True:\n                n = dim\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.uniform(0,1) ** (1.0/n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    sample_rot = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    sample_rot = (x_rot, y_rot, z_rot)\n\n                sample_point = tuple(center[d] + sample_rot[d] for d in range(n))\n                sample_point = clamp_to_bounds(sample_point)\n                if not self._is_in_obstacle(sample_point, obstacles, is_3d):\n                    return sample_point\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except Exception:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n        def extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            new_pos = clamp_to_bounds(new_pos)\n\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, from_node):\n            nearest_node = nearest(tree, from_node.position)\n            d_curr = dist(nearest_node.position, from_node.position)\n            if d_curr <= self.step_size and collision_free_node(from_node.position) and collision_free_edge(nearest_node.position, from_node.position):\n                return nearest_node\n            return None\n\n        while True:\n            iter_count = 0\n            while iter_count < self.max_iter:\n                elapsed = time.perf_counter() - start_time\n                if elapsed > self.max_time_sec:\n                    # Time limit reached - return best path found so far\n                    if best_path_nodes:\n                        return PlannerResult(success=True, path=best_path_nodes, nodes=all_nodes, edges=edges)\n                    return PlannerResult(success=False, path=[], nodes=all_nodes, edges=edges)\n\n                iter_count += 1\n                if informed_sampling_enabled:\n                    sample = informed_sample(best_path_cost)\n                else:\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if grow_start else start_pos\n                    else:\n                        sample = sample_free()\n\n                if grow_start:\n                    new_node = extend(tree_start, sample)\n                    if new_node is None:\n                        grow_start = not grow_start\n                        continue\n\n                    connect_node = try_connect(tree_goal, new_node)\n                    if connect_node:\n                        neighbors = near_nodes(tree_goal, new_node.position)\n                        min_cost_local = connect_node.cost + dist(connect_node.position, new_node.position)\n                        best_parent_local = connect_node\n                        for neighbor in neighbors:\n                            tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                            if tentative_cost < min_cost_local and collision_free_edge(neighbor.position, new_node.position):\n                                min_cost_local = tentative_cost\n                                best_parent_local = neighbor\n\n                        connecting_node = Node(new_node.position)\n                        best_parent_local.add_child(connecting_node)\n                        connecting_node.cost = min_cost_local\n                        tree_goal.append(connecting_node)\n                        all_nodes.append(connecting_node)\n                        edges.append((best_parent_local, connecting_node))\n\n                        rewire(tree_goal, connecting_node, neighbors)\n\n                        path_start = new_node.path_from_root()\n                        path_goal = connecting_node.path_from_root()\n                        merged_path = path_start + path_goal[::-1][1:]\n                        cost_path = 0.0\n                        for i in range(len(merged_path)-1):\n                            cost_path += dist(merged_path[i], merged_path[i+1])\n                        if cost_path < best_path_cost:\n                            best_path_cost = cost_path\n                            best_path_nodes = merged_path\n\n                        informed_sampling_enabled = True\n                        return PlannerResult(success=True, path=merged_path, nodes=all_nodes, edges=edges)\n                else:\n                    new_node = extend(tree_goal, sample)\n                    if new_node is None:\n                        grow_start = not grow_start\n                        continue\n\n                    connect_node = try_connect(tree_start, new_node)\n                    if connect_node:\n                        neighbors = near_nodes(tree_start, new_node.position)\n                        min_cost_local = connect_node.cost + dist(connect_node.position, new_node.position)\n                        best_parent_local = connect_node\n                        for neighbor in neighbors:\n                            tentative_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                            if tentative_cost < min_cost_local and collision_free_edge(neighbor.position, new_node.position):\n                                min_cost_local = tentative_cost\n                                best_parent_local = neighbor\n\n                        connecting_node = Node(new_node.position)\n                        best_parent_local.add_child(connecting_node)\n                        connecting_node.cost = min_cost_local\n                        tree_start.append(connecting_node)\n                        all_nodes.append(connecting_node)\n                        edges.append((best_parent_local, connecting_node))\n\n                        rewire(tree_start, connecting_node, neighbors)\n\n                        path_start = connecting_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                        merged_path = path_start + path_goal[::-1][1:]\n                        cost_path = 0.0\n                        for i in range(len(merged_path)-1):\n                            cost_path += dist(merged_path[i], merged_path[i+1])\n                        if cost_path < best_path_cost:\n                            best_path_cost = cost_path\n                            best_path_nodes = merged_path\n\n                        informed_sampling_enabled = True\n                        return PlannerResult(success=True, path=merged_path, nodes=all_nodes, edges=edges)\n\n                grow_start = not grow_start\n\n            break\n\n        # If max iterations reached without success but path found\n        if best_path_nodes:\n            return PlannerResult(success=True, path=best_path_nodes, nodes=all_nodes, edges=edges)\n        return PlannerResult(success=False, path=[], nodes=all_nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node']=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = None              # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n        if parent:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=10.0, neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree  # Trees alternate growth each iteration\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        best_connection_nodes = None\n        best_cost = math.inf\n\n        start_time = time.perf_counter()\n\n        # Precompute start-goal dist and initialize sampling ellipse params\n        c_best = math.dist(start_position, goal_position)\n        x_center = tuple((s+g)/2.0 for s, g in zip(start_position, goal_position))\n        use_informed_sampling = False\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def _ellipsoidal_sample(c_max: float) -> Tuple[float, ...]:\n            # Implements informed sampling inside an ellipse between start and goal\n            # Reference: Informed RRT* sampling (Gammell, 2014)\n            if c_max == math.inf:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            a1 = np.array([(g - s) / c_max for s, g in zip(start_position, goal_position)], dtype=float)\n            # Build orthonormal basis matrix C via a rotation matrix:\n            # Create identity and replace first dim with a1\n            I = np.eye(dim)\n            M = np.outer(a1, np.array([1.0] + [0]*(dim-1)))  # rank-1 matrix\n            U, _, Vt = np.linalg.svd(M)\n            C = np.dot(U, Vt)\n\n            # Sample in unit n-ball \n            while True:\n                z = np.random.normal(0, 1, dim)\n                norm_z = np.linalg.norm(z)\n                if norm_z > 1e-9:  # avoid division by zero\n                    break\n            z_unit = z / norm_z\n\n            # Sample radius with probability ~ r^{dim-1} to fill ball uniformly\n            r = random.random() ** (1/dim)\n            r *= z_unit\n\n            # Lengths of the ellipse axes\n            r1 = c_max / 2.0\n            r2 = math.sqrt(c_max**2 - c_best**2) / 2.0\n            if dim == 2:\n                L = np.diag([r1, r2])\n            elif dim == 3:\n                # For 3D, use r2 for axes 2 and 3\n                L = np.diag([r1, r2, r2])\n            else:\n                # fallback: use r2 for other axes\n                L = np.diag([r1] + [r2]*(dim-1))\n\n            sample_ball = np.dot(C, np.dot(L, r))\n            sample_pt = np.array(x_center) + sample_ball\n            sample_pt = np.clip(sample_pt, 0, bounds)\n            return tuple(float(x) for x in sample_pt)\n\n        def sample_free():\n            for _ in range(100):  # Max 100 attempts\n                if use_informed_sampling and best_cost < math.inf:\n                    sample = _ellipsoidal_sample(best_cost)\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d) and in_bounds(sample):\n                    return sample\n            # fallback to uniform sample ignoring obstacle if no free found (very unlikely)\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                c = nbr.cost + math.dist(nbr.position, new_pos)\n                if c < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                    min_cost = c\n                    best_parent = nbr\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nbr in neighbors:\n                if nbr == best_parent:\n                    continue\n                new_c = new_node.cost + math.dist(new_node.position, nbr.position)\n                if new_c < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                    if nbr.parent:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                            nbr.parent.remove_child(nbr)\n                        except ValueError:\n                            pass\n                    nbr.update_parent(new_node, new_c)\n                    edges.append((new_node, nbr))\n            return new_node\n\n        def incremental_connect_and_rewire(tree: List[Node], target_pos: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = nearest(tree, target_pos)\n            curr_node = nearest_node\n            max_steps = int(math.dist(curr_node.position, target_pos) / self.step_size) + 2\n            for _ in range(max_steps):\n                new_pos = steer(curr_node.position, target_pos)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_node = Node(new_pos)\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    c = nbr.cost + math.dist(nbr.position, new_pos)\n                    if c < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                        min_cost = c\n                        best_parent = nbr\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for nbr in neighbors:\n                    if nbr == best_parent:\n                        continue\n                    new_c = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if new_c < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                                nbr.parent.remove_child(nbr)\n                            except ValueError:\n                                pass\n                        nbr.update_parent(new_node, new_c)\n                        edges.append((new_node, nbr))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    # If direct connection between new_node and target_pos is collision-free, return new_node\n                    if not self._is_edge_in_obstacle(new_node.position, target_pos, obstacles, is_3d):\n                        return new_node\n                curr_node = new_node\n            return None\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_iterations: int=120) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_iterations):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                    length = len(path)\n            return path\n\n        for iteration in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                # Time exceeded: break and return best path if any\n                if best_connection_nodes is not None:\n                    node_a, node_b = best_connection_nodes\n                    path_a = node_a.path_from_root()\n                    path_b = node_b.path_from_root()\n                    combined_path = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined_path)\n                    success_state = True\n                break\n\n            # Goal-biased sampling: with probability goal_sample_rate, sample towards opposite tree root\n            if random.random() < self.goal_sample_rate:\n                sample = tree_b[0].position if tree_a is start_tree else tree_a[0].position\n            else:\n                sample = sample_free()\n\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b:\n                connect_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if connect_cost < best_cost:\n                    best_cost = connect_cost\n                    best_connection_nodes = (new_node_a, new_node_b)\n                    # Update informed sampling usage and parameters\n                    c_best = best_cost\n                    x_center = tuple((s+g)/2.0 for s,g in zip(start_position, goal_position))\n                    use_informed_sampling = True\n\n                    # Extract and smooth path early for faster return on success\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    # Make sure no duplicate point at connection\n                    if path_b and path_b[0] == new_node_a.position:\n                        path_b = path_b[1:]\n                    combined_path = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined_path)\n                    success_state = True\n                    break\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection_nodes is not None:\n            node_a, node_b = best_connection_nodes\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            if path_b and path_b[0] == node_a.position:\n                path_b = path_b[1:]\n            combined_path = path_a + path_b[::-1]\n            extracted_path = path_smoothing(combined_path)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False"
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "This algorithm implements a bidirectional RRT* variant with informed sampling, adaptive rewiring, and goal biasing to efficiently explore and connect the search space while ensuring collision-free expansions and edge validations. It balances exploration and exploitation with incremental tree growth from both start and goal, dynamically rewiring to optimize path cost, and returns the best path found within a 30-second time limit.",
            "planning_mechanism": "The planner grows two trees alternately from start and goal, initially sampling uniformly and switching to ellipsoidal informed sampling after a first solution is found. Each extension steers towards samples within a step size limit, performs collision checks on nodes and edges, rewires neighbors adaptively for cost improvements, and attempts incremental connections between trees. Upon connection or timeout, it returns the best valid path found.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position         # Tuple[float, ...]\n        self.parent = parent             # Node or None\n        self.cost = cost                 # Cost from root to this node\n        self.children = []\n        self.valid = True\n\n        if parent:\n            parent.add_child(self)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        # Propagate cost updates down the subtree\n        for child in self.children:\n            dist_to_child = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist_to_child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.15,\n                 neighbor_radius_min=10.0, neighbor_radius_max=30.0, max_time_sec=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def sample_uniform():\n            for _ in range(100):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))  # fallback\n\n        def informed_sample(c_best):\n            if c_best == math.inf:\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_best < c_min:\n                return sample_uniform()\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n\n            # Rotation matrix (2D and 3D)\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                R = [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                # 3D rotation matrix around axis v\n                vx, vy, vz = direction\n                k = (-0.0, -vy, -vz)\n                k_norm = math.sqrt(k[0]**2 + k[1]**2 + k[2]**2)\n                if k_norm < 1e-10:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    k = tuple(ki / k_norm for ki in k)\n                    cos_t = vx\n                    sin_t = k_norm\n                    Kx, Ky, Kz = k\n                    K = [[0,-Kz,Ky],[Kz,0,-Kx],[-Ky,Kx,0]]\n                    I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                    def mat_add(A,B):\n                        return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                    def mat_scale(A,s):\n                        return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                    def mat_mul(A,B):\n                        return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                    K2 = mat_mul(K,K)\n                    R = mat_add(mat_add(I, mat_scale(K, sin_t)), mat_scale(K2, 1 - cos_t))\n\n            # Ellipsoid radii\n            a1 = c_best / 2.0\n            a_minor = math.sqrt(max(c_best**2 - (c_min**2), 0.0)) / 2.0\n            radii = [a1] + [a_minor] * (dim - 1)\n\n            while True:\n                # Sample unit n-ball\n                vec = [random.gauss(0, 1) for _ in range(dim)]\n                norm_vec = math.sqrt(sum(x*x for x in vec))\n                unit_vec = [x / norm_vec for x in vec]\n                r = random.random() ** (1.0 / dim)\n                ball_sample = [r * unit_vec[i] * radii[i] for i in range(dim)]\n\n                # Rotate sample\n                if dim == 2:\n                    x_rot = R[0][0]*ball_sample[0] + R[0][1]*ball_sample[1]\n                    y_rot = R[1][0]*ball_sample[0] + R[1][1]*ball_sample[1]\n                    sample_pt = (center[0] + x_rot, center[1] + y_rot)\n                else:\n                    x_rot = sum(R[0][j]*ball_sample[j] for j in range(dim))\n                    y_rot = sum(R[1][j]*ball_sample[j] for j in range(dim))\n                    z_rot = sum(R[2][j]*ball_sample[j] for j in range(dim))\n                    sample_pt = (center[0] + x_rot, center[1] + y_rot, center[2] + z_rot)\n\n                clamped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(dim))\n                if not self._is_in_obstacle(clamped, obstacles, is_3d):\n                    return clamped\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_path_cost = math.inf\n        best_path = []\n\n        grow_start_tree = True\n        use_informed = False\n\n        start_time = time.perf_counter()\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                    except ValueError:\n                        pass\n                    nbr.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, nbr))\n\n        def extend(tree, sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                c = nbr.cost + math.dist(nbr.position, new_pos)\n                if c < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = c\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, from_node):\n            nearest_node = nearest(tree, from_node.position)\n            dist_curr = math.dist(nearest_node.position, from_node.position)\n            if dist_curr <= self.step_size and collision_free_edge(nearest_node.position, from_node.position) and collision_free_node(from_node.position):\n                return nearest_node\n            return None\n\n        while True:\n            iter_count = 0\n            while iter_count < self.max_iter:\n                elapsed = time.perf_counter() - start_time\n                if elapsed > self.max_time_sec:\n                    if best_path:\n                        return PlannerResult(success=True, path=best_path, nodes=all_nodes, edges=edges)\n                    return PlannerResult(success=False, path=[], nodes=all_nodes, edges=edges)\n\n                iter_count += 1\n\n                if use_informed:\n                    sample = informed_sample(best_path_cost)\n                else:\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_pos if grow_start_tree else start_pos\n                    else:\n                        sample = sample_uniform()\n\n                if grow_start_tree:\n                    new_node = extend(start_tree, sample)\n                    if new_node is None:\n                        grow_start_tree = not grow_start_tree\n                        continue\n\n                    connect_node = try_connect(goal_tree, new_node)\n                    if connect_node:\n                        neighbors = near_nodes(goal_tree, new_node.position,\n                                               adaptive_neighbor_radius(len(goal_tree)))\n\n                        min_cost_local = connect_node.cost + math.dist(connect_node.position, new_node.position)\n                        best_parent_local = connect_node\n                        for nbr in neighbors:\n                            c = nbr.cost + math.dist(nbr.position, new_node.position)\n                            if c < min_cost_local and collision_free_edge(nbr.position, new_node.position):\n                                min_cost_local = c\n                                best_parent_local = nbr\n\n                        connecting_node = Node(new_node.position)\n                        best_parent_local.add_child(connecting_node)\n                        connecting_node.cost = min_cost_local\n                        goal_tree.append(connecting_node)\n                        all_nodes.append(connecting_node)\n                        edges.append((best_parent_local, connecting_node))\n\n                        rewire(goal_tree, connecting_node, neighbors)\n\n                        # Extract combined path\n                        path_start = new_node.path_from_root()\n                        path_goal = connecting_node.path_from_root()\n                        merged_path = path_start + path_goal[::-1][1:]\n                        cost_path = 0.0\n                        for i in range(len(merged_path)-1):\n                            cost_path += math.dist(merged_path[i], merged_path[i+1])\n\n                        if cost_path < best_path_cost:\n                            best_path_cost = cost_path\n                            best_path = merged_path\n                            use_informed = True\n                            # Return early on first feasible path found\n                            return PlannerResult(success=True, path=best_path, nodes=all_nodes, edges=edges)\n                else:\n                    new_node = extend(goal_tree, sample)\n                    if new_node is None:\n                        grow_start_tree = not grow_start_tree\n                        continue\n\n                    connect_node = try_connect(start_tree, new_node)\n                    if connect_node:\n                        neighbors = near_nodes(start_tree, new_node.position,\n                                               adaptive_neighbor_radius(len(start_tree)))\n\n                        min_cost_local = connect_node.cost + math.dist(connect_node.position, new_node.position)\n                        best_parent_local = connect_node\n                        for nbr in neighbors:\n                            c = nbr.cost + math.dist(nbr.position, new_node.position)\n                            if c < min_cost_local and collision_free_edge(nbr.position, new_node.position):\n                                min_cost_local = c\n                                best_parent_local = nbr\n\n                        connecting_node = Node(new_node.position)\n                        best_parent_local.add_child(connecting_node)\n                        connecting_node.cost = min_cost_local\n                        start_tree.append(connecting_node)\n                        all_nodes.append(connecting_node)\n                        edges.append((best_parent_local, connecting_node))\n\n                        rewire(start_tree, connecting_node, neighbors)\n\n                        path_start = connecting_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                        merged_path = path_start + path_goal[::-1][1:]\n                        cost_path = 0.0\n                        for i in range(len(merged_path)-1):\n                            cost_path += math.dist(merged_path[i], merged_path[i+1])\n\n                        if cost_path < best_path_cost:\n                            best_path_cost = cost_path\n                            best_path = merged_path\n                            use_informed = True\n                            return PlannerResult(success=True, path=best_path, nodes=all_nodes, edges=edges)\n\n                grow_start_tree = not grow_start_tree\n\n            break\n\n        if best_path:\n            return PlannerResult(success=True, path=best_path, nodes=all_nodes, edges=edges)\n        else:\n            return PlannerResult(success=False, path=[], nodes=all_nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -18.70121,
            "time_improvement": 50.0,
            "length_improvement": 14.0,
            "smoothness_improvement": 209.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020652365684509278,
                    "num_nodes_avg": 101.9,
                    "path_length_avg": 161.09272527755476,
                    "smoothness_avg": 0.020914734892580944,
                    "success_improvement": 0.0,
                    "time_improvement": 12.896628076868538,
                    "length_improvement": 11.702524597786873,
                    "smoothness_improvement": 227.36101814263648,
                    "objective_score": 7.3462984333311185
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05064387321472168,
                    "num_nodes_avg": 297.6,
                    "path_length_avg": 251.50120631194395,
                    "smoothness_avg": 0.01163127030182631,
                    "success_improvement": 0.0,
                    "time_improvement": 78.88554590521389,
                    "length_improvement": 16.04165827223005,
                    "smoothness_improvement": 199.28096253136158,
                    "objective_score": 27.870400238666985
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04441468715667725,
                    "num_nodes_avg": 234.4,
                    "path_length_avg": 130.89357935919415,
                    "smoothness_avg": 0.02366342243242298,
                    "success_improvement": 0.0,
                    "time_improvement": 57.56202630266056,
                    "length_improvement": 13.066717072077614,
                    "smoothness_improvement": 200.99698668826508,
                    "objective_score": 20.886936238655014
                }
            ],
            "success_rate": 1.0
        },
        "objective": 26.8,
        "analysis": "1. Summary of key changes:\n   - Introduction of adaptive neighbor radius that adjusts based on the number of nodes, improving rewiring efficiency.\n   - Use of informed sampling with ellipsoidal sampling between start and goal to focus sampling and reduce search space.\n   - Implementation of incremental connect and rewire method for smoother and more efficient tree connection.\n   - Enhanced parent-child management with safer add/remove child and parent update to maintain tree consistency.\n   - Added path smoothing after path extraction to shorten and optimize the final path.\n   - More robust collision checking with smaller step discretization and early pruning.\n   - Enhanced alternating growth strategy and early success detection with path cost comparison.\n   - Application of matrix operations and numpy for rotation matrix and sampling in high dimensions for improved numeric stability and speed.\n\n2. Primary contributors to the performance improvement:\n   - Adaptive neighbor radius allowing efficient rewiring without excessive neighbors.\n   - Informed sampling focused around the current best solution, reducing random explorations.\n   - Incremental connection attempts rather than single-step, enhancing successful tree bridging.\n   - Path smoothing to reduce unnecessary waypoints, improving quality.\n   - Efficient and accurate collision detection lowering invalid expansions.\n   - Structured and consistent node parent-child link updates reducing errors and complexity.\n\n3. Expected mechanism of impact:\n   - By focusing sampling in an ellipsoidal informed subset, the planner rapidly converges to promising areas, improving success rate and speed.\n   - Adaptive neighbor radius balances between exploration and rewiring cost, resulting in faster convergence and less overhead.\n   - Incremental connection enables gradual bridging of trees, increasing connectivity success.\n   - Path smoothing post-processing reduces path length and complexity, offering better paths.\n   - Reliable collision detection and robust tree maintenance prevent invalid expansions and maintain correct tree topology.\n   - Overall, these changes reduce computational overhead, improve path quality, and accelerate convergence to a feasible and optimal path solution."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cumulative cost from root\n        self.children = []\n        self.valid = True               # For collision/status checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success = False\n        final_path = []\n\n        tree_a, tree_b = start_tree, goal_tree  # Alternate expansions\n\n        for _ in range(self.max_iter):\n            # Goal bias sampling towards opposite tree's root\n            if random.random() < self.goal_sample_rate:\n                sample = tree_b[0].position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                final_path = path_a + path_b[::-1]\n                success = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos)\n\n        # Find optimal parent among neighbors\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            if neighbor == nearest:\n                continue\n            candidate_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if candidate_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = candidate_cost\n                best_parent = neighbor\n\n        new_node = Node(new_pos)\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors through new_node if cheaper\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_pos)\n        current = nearest\n\n        while True:\n            new_pos = self._steer(current.position, target_pos)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = self._near_nodes(tree, new_pos)\n\n            min_cost = current.cost + math.dist(current.position, new_pos)\n            best_parent = current\n            for neighbor in neighbors:\n                if neighbor == current:\n                    continue\n                candidate_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if candidate_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = candidate_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            current = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size/5)\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n        def extend(tree, target_point):\n            nearest_node = min(tree, key=lambda n: dist(n.position, target_point))\n            new_pos = steer(nearest_node.position, target_point)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors_radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        def try_connect_trees(new_node, other_tree):\n            curr_node = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                next_pos = steer(curr_node.position, new_node.position)\n                next_pos = clamp_to_bounds(next_pos)\n                if not collision_free_node(next_pos) or not collision_free_edge(curr_node.position, next_pos):\n                    return None\n\n                neighbors_radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, next_pos, neighbors_radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, next_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_connect_node = Node(next_pos)\n                best_parent.add_child(new_connect_node)\n                new_connect_node.cost = min_cost\n                other_tree.append(new_connect_node)\n\n                rewire(other_tree, new_connect_node, neighbors)\n\n                if dist(new_connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(new_connect_node.position, new_node.position):\n                        return new_connect_node\n                    else:\n                        return None\n\n                curr_node = new_connect_node\n\n        def path_smoothing(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        grow_start = True\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                if best_path:\n                    extracted = path_smoothing(best_path)\n                    return PlannerResult(True, extracted, all_nodes, edges)\n                else:\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            iter_count += 1\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_free()\n\n            if grow_start:\n                new_node = extend(tree_start, sample)\n                if not new_node:\n                    grow_start = not grow_start\n                    continue\n                connect_node = try_connect_trees(new_node, tree_goal)\n                if connect_node:\n                    path_s = new_node.path_from_root()\n                    path_g = connect_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined_path = path_s + path_g[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    extracted = path_smoothing(best_path)\n                    return PlannerResult(True, extracted, all_nodes, edges)\n\n            else:\n                new_node = extend(tree_goal, sample)\n                if not new_node:\n                    grow_start = not grow_start\n                    continue\n                connect_node = try_connect_trees(new_node, tree_start)\n                if connect_node:\n                    path_g = new_node.path_from_root()\n                    path_s = connect_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined_path = path_s + path_g[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    extracted = path_smoothing(best_path)\n                    return PlannerResult(True, extracted, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        # Post max iterations: return best path if any\n        if best_path:\n            extracted = path_smoothing(best_path)\n            success_state = True\n        else:\n            extracted = []\n            success_state = False\n\n        return PlannerResult(success_state, extracted, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False"
        ],
        "offspring": {
            "operator": "e1",
            "algorithm_description": "This algorithm implements a time-limited bidirectional RRT* with adaptive informed sampling and dynamic neighbor radius tuning. It combines goal-biased sampling with ellipsoidal informed sampling to focus exploration progressively, uses rewiring within a dynamically chosen neighbor radius to optimize path cost locally, and alternates growth between two trees starting from start and goal positions. Collision-free nodes and edges are guaranteed for safe and feasible path expansion. The algorithm stops early either upon a successful connection or exceeding the 30-second execution limit, returning the best found path with smoothing applied for improved smoothness and quality.",
            "planning_mechanism": "The planner grows two RRT* trees from start and goal alternately, sampling with a bias towards the goal and inside an ellipsoidal informed subset after the first feasible solution to accelerate convergence. Each extension steers toward a sampled point, rewires neighbors to optimize cost, and attempts incremental connection to the opposite tree with rewiring. Paths are merged on successful connection, smoothed for smoothness, and returned immediately. Execution time is tracked and enforced with early termination, returning the best feasible path found so far.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 100000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = 30.0     # Enforced 30 sec time limit\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D or 3D\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos, resolution=None):\n            if resolution is None:\n                resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=resolution)\n\n        # Unit ball sample for uniform direction sampling in nD\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n\n        informed_sampling_enabled = False\n\n        def sample_free():\n            while True:\n                sample = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if collision_free_node(sample):\n                    return sample\n\n        # Ellipsoidal informed sampling\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n\n            # Construct rotation matrix to align x-axis with direction vector\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                R = ((cos_a, -sin_a), (sin_a, cos_a))\n            else:\n                # Use Householder transform to rotate direction to x-axis\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-10:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    # Compute rotation matrix R that aligns x-axis with \"direction\"\n                    # Approach: compute orthonormal basis with \"direction\" as first vector\n                    ux, uy, uz = direction\n                    # Construct an arbitrary orthogonal basis:\n                    if abs(ux) < 1e-10 and abs(uy) < 1e-10:\n                        # direction close to z-axis:\n                        vx_, vy_, vz_ = 1,0,0\n                    else:\n                        vx_, vy_, vz_ = -uy, ux, 0\n                    norm_v_ = math.sqrt(vx_*vx_ + vy_*vy_ + vz_*vz_)\n                    vx_ /= norm_v_\n                    vy_ /= norm_v_\n                    vz_ /= norm_v_\n                    wx = uy * vz_ - uz * vy_\n                    wy = uz * vx_ - ux * vz_\n                    wz = ux * vy_ - uy * vx_\n\n                    R = [\n                        [ux, vx_, wx],\n                        [uy, vy_, wy],\n                        [uz, vz_, wz]\n                    ]\n\n            # Radii of prolate hyperspheroid\n            a1 = c_best / 2.0\n            if dim == 2:\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        # Adaptive neighbor radius for rewiring (following RRT* theory)\n        def adaptive_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return 50.0  # large initial radius\n            gamma_rrt = 30.0\n            return max(5.0, min(30.0, gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target):\n            nearest = min(tree, key=lambda n: dist(n.position, target))\n            new_pos = steer(nearest.position, target)\n            new_pos = clamp(new_pos)\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            neighbors_radius = adaptive_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        def try_connect(new_node, other_tree):\n            curr = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                next_pos = steer(curr.position, new_node.position)\n                next_pos = clamp(next_pos)\n\n                if not collision_free_node(next_pos) or not collision_free_edge(curr.position, next_pos):\n                    return None\n\n                radius = adaptive_radius(len(other_tree)+1)\n                neighbors = near_nodes(other_tree, next_pos, radius)\n\n                min_cost = curr.cost + dist(curr.position, next_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr == curr:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(next_pos)\n                best_parent.add_child(connect_node)\n                connect_node.cost = min_cost\n                other_tree.append(connect_node)\n\n                rewire(other_tree, connect_node, neighbors)\n\n                if dist(connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connect_node.position, new_node.position):\n                        return connect_node\n                    else:\n                        return None\n\n                curr = connect_node\n\n        def path_smooth(path: List[Tuple[float, ...]], max_trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_path = []\n        best_cost = math.inf\n        success_state = False\n\n        grow_start = True\n        iter_count = 0\n\n        while iter_count < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                # time limit exceeded: return best path so far\n                if best_path:\n                    smooth_path = path_smooth(best_path)\n                    return PlannerResult(True, smooth_path, all_nodes, edges)\n                else:\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            iter_count += 1\n\n            if informed_sampling_enabled:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < 0.15:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_free()\n\n            if grow_start:\n                new_node = extend(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = try_connect(new_node, tree_goal)\n                if connected_node is not None:\n                    path_s = new_node.path_from_root()\n                    path_g = connected_node.path_from_root()\n                    # Make sure to remove duplicate connecting node\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined = path_s + path_g[::-1]\n\n                    total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined\n                        informed_sampling_enabled = True\n\n                    # Refresh edges\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    smooth_path = path_smooth(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smooth_path, all_nodes, edges)\n\n            else:\n                new_node = extend(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = try_connect(new_node, tree_start)\n                if connected_node is not None:\n                    path_g = new_node.path_from_root()\n                    path_s = connected_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined = path_s + path_g[::-1]\n\n                    total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined\n                        informed_sampling_enabled = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    smooth_path = path_smooth(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smooth_path, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        # Max iterations reached - return best path if any\n        if best_path:\n            smooth_path = path_smooth(best_path)\n            return PlannerResult(True, smooth_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -23.98338,
            "time_improvement": 49.0,
            "length_improvement": 14.0,
            "smoothness_improvement": 1290.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02227151393890381,
                    "num_nodes_avg": 81.2,
                    "path_length_avg": 176.73650863221073,
                    "smoothness_avg": 0.04163013462817498,
                    "success_improvement": 0.0,
                    "time_improvement": 6.067711973228136,
                    "length_improvement": 3.1279190494893707,
                    "smoothness_improvement": 551.6020082152062,
                    "objective_score": 5.203907442942346
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04452013969421387,
                    "num_nodes_avg": 216.7,
                    "path_length_avg": 234.6283220155596,
                    "smoothness_avg": 0.08281404133923359,
                    "success_improvement": 0.0,
                    "time_improvement": 81.43865415108714,
                    "length_improvement": 21.674312709409516,
                    "smoothness_improvement": 2030.8649322014446,
                    "objective_score": 38.92078344821527
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04296309947967529,
                    "num_nodes_avg": 221.2,
                    "path_length_avg": 122.72804706569131,
                    "smoothness_avg": 0.1091637086355884,
                    "success_improvement": 0.0,
                    "time_improvement": 58.94900983445225,
                    "length_improvement": 18.489874820558175,
                    "smoothness_improvement": 1288.5543162178765,
                    "objective_score": 27.825449495536688
                }
            ],
            "success_rate": 1.0
        },
        "objective": 17.4,
        "analysis": "1. Summary of key changes:\n   - Enhanced node addition and parent update methods to avoid duplicates and ensure proper references.\n   - Introduction of adaptive neighbor radius that dynamically adjusts based on the number of nodes and dimension.\n   - Implementation of informed sampling strategy using ellipsoidal sampling to focus search space after an initial solution.\n   - Collision checks refined with adjustable resolution tied to step size.\n   - Improved tree connection method with iterative incremental extension and rewiring for better path optimization.\n   - Added path smoothing functionality to shorten the final path.\n   - More comprehensive and safe handling of children nodes and edge updates.\n   - Use of time-based planning termination alongside iteration limits.\n\n2. Primary contributors to the performance improvement:\n   - Adaptive neighbor radius optimizing connectivity and rewiring process.\n   - Informed sampling focusing on promising areas to efficiently improve solution quality.\n   - Incremental connect method with rewiring enabling better tree joining.\n   - Path smoothing removing unnecessary waypoints for a more optimal path.\n   - Improved obstacle and edge collision checking with higher resolution and robust bounding.\n\n3. Expected mechanism of impact:\n   - Adaptive radius balances exploration and refinement, reducing unnecessary large neighbor sets and improving computational efficiency.\n   - Informed sampling reduces wasted sampling in irrelevant regions, accelerating convergence to lower-cost paths.\n   - Incremental connect with rewiring decreases path costs and helps avoid poor-quality connections.\n   - Path smoothing further shortens the trajectory by eliminating redundant nodes and edges.\n   - More precise collision and boundary checks ensure valid node and edge insertion, preventing invalid expansions and maintaining path feasibility."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size/5)\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n        def extend(tree, target_point):\n            nearest_node = min(tree, key=lambda n: dist(n.position, target_point))\n            new_pos = steer(nearest_node.position, target_point)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors_radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        def try_connect_trees(new_node, other_tree):\n            curr_node = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                next_pos = steer(curr_node.position, new_node.position)\n                next_pos = clamp_to_bounds(next_pos)\n                if not collision_free_node(next_pos) or not collision_free_edge(curr_node.position, next_pos):\n                    return None\n\n                neighbors_radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, next_pos, neighbors_radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, next_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr == curr_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, next_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_connect_node = Node(next_pos)\n                best_parent.add_child(new_connect_node)\n                new_connect_node.cost = min_cost\n                other_tree.append(new_connect_node)\n\n                rewire(other_tree, new_connect_node, neighbors)\n\n                if dist(new_connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(new_connect_node.position, new_node.position):\n                        return new_connect_node\n                    else:\n                        return None\n\n                curr_node = new_connect_node\n\n        def path_smoothing(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        grow_start = True\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                if best_path:\n                    extracted = path_smoothing(best_path)\n                    return PlannerResult(True, extracted, all_nodes, edges)\n                else:\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            iter_count += 1\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_free()\n\n            if grow_start:\n                new_node = extend(tree_start, sample)\n                if not new_node:\n                    grow_start = not grow_start\n                    continue\n                connect_node = try_connect_trees(new_node, tree_goal)\n                if connect_node:\n                    path_s = new_node.path_from_root()\n                    path_g = connect_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined_path = path_s + path_g[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    extracted = path_smoothing(best_path)\n                    return PlannerResult(True, extracted, all_nodes, edges)\n\n            else:\n                new_node = extend(tree_goal, sample)\n                if not new_node:\n                    grow_start = not grow_start\n                    continue\n                connect_node = try_connect_trees(new_node, tree_start)\n                if connect_node:\n                    path_g = new_node.path_from_root()\n                    path_s = connect_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined_path = path_s + path_g[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    extracted = path_smoothing(best_path)\n                    return PlannerResult(True, extracted, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        # Post max iterations: return best path if any\n        if best_path:\n            extracted = path_smoothing(best_path)\n            success_state = True\n        else:\n            extracted = []\n            success_state = False\n\n        return PlannerResult(success_state, extracted, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=3.0, goal_sample_rate: float=0.15,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import time\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def sample_free(tree_indicator):\n            # tree_indicator: True for start_tree sampling goal, False for goal_tree sampling start\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_indicator else start_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d) and self._within_bounds(p, bounds):\n                    return p\n            return goal_pos if tree_indicator else start_pos\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (math.dist(n.position, pos) ** 2) <= radius_sq]\n\n        def valid_node(pos):\n            return self._within_bounds(pos, bounds) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def valid_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            # Volume of ball in R^d: For 2D \u03c0r^2, 3D (4/3)\u03c0r^3; Using heuristic R ~ gamma * (log(n)/n)^(1/d)\n            gamma = 25.0  # tuning parameter\n            radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(radius, self.max_neighbor_radius))\n\n        def add_node(tree, new_pos, best_parent, cost):\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist\n                if new_cost < neighbor.cost and valid_edge(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree, sample, tree_indicator):\n            if len(tree) == 0:\n                return None\n            nearest = min(tree, key=lambda node: math.dist(node.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not valid_node(new_pos): \n                return None\n            if not valid_edge(nearest.position, new_pos):\n                return None\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            if len(tree) == 0:\n                return None\n            nearest = min(tree, key=lambda node: math.dist(node.position, target_pos))\n            curr_node = nearest\n\n            while True:\n                new_pos = steer(curr_node.position, target_pos)\n                if not valid_node(new_pos) or not valid_edge(curr_node.position, new_pos):\n                    return None\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                        min_cost = cost_through_neighbor\n                        best_parent = neighbor\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n                rewire(tree, new_node, neighbors)\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                curr_node = new_node\n\n        def path_smoothing(raw_path, iterations=50):\n            if len(raw_path) <= 2:\n                return raw_path[:]\n            path = raw_path[:]\n            for _ in range(iterations):\n                if len(path) <= 2:\n                    break\n                idx1 = random.randint(0, len(path) - 2)\n                idx2 = random.randint(idx1 + 1, len(path) -1)\n                if idx2 == idx1 + 1:\n                    continue\n                p1 = path[idx1]\n                p2 = path[idx2]\n                # Check collision-free shortcut\n                if valid_edge(p1, p2):\n                    # Remove intermediate nodes\n                    path = path[:idx1 + 1] + path[idx2:]\n            return path\n\n        start_time = time.time()\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        tree_a = start_tree\n        tree_b = goal_tree\n        success = False\n        best_path = []\n        best_cost = math.inf\n\n        for iter_cnt in range(self.max_iter):\n            if time.time() - start_time > self.max_time_sec:\n                # Time exceeded: return best found\n                break\n\n            sample = sample_free(tree_indicator=True)  # tree_a grows towards goal_pos\n            new_node_a = extend_and_rewire(tree_a, sample, True)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                # Found connection\n                path_from_start = new_node_a.path_from_root()\n                path_from_goal = new_node_b.path_from_root()\n                combined_path = path_from_start + path_from_goal[::-1][1:]  # avoid duplicate connect node\n\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    success = True\n\n                # Attempt smoothing\n                smoothed_path = path_smoothing(best_path, iterations=100)\n                best_path = smoothed_path\n\n                # Stop on first found improved solution\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False"
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "This algorithm implements a bidirectional RRT* planner with goal-biased and informed sampling, adaptive neighbor radius, incremental extend-and-rewire expansions, and progressive tree connection attempts. It dynamically rewires nodes to optimize path cost while respecting map boundaries and obstacles, applies multiple passes of path smoothing, and enforces a strict time limit of 30 seconds to ensure timely responses.",
            "planning_mechanism": "The planner grows two trees from start and goal, alternately extending towards sampled points generated with a bias towards the goal and an ellipsoidal informed region after an initial solution is found. Each extension attempts to connect to the opposite tree incrementally. Adaptive neighbor radius ensures locally appropriate rewiring for cost optimization. On connection, best paths from both trees are combined, smoothed, and returned. The process halts if time runs out, returning the best available path.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent = None                    # Node or None\n        self.cost = cost                     # Cost from root\n        self.children: List[Node] = []        # List of child nodes\n        self.valid = True                     # For collision validity\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost updates recursively to descendants\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                           # Tuple[int, ...]\n        start_pos = map.start                       # Tuple[float, ...]\n        goal_pos = map.goal                         # Tuple[float, ...]\n        obstacles = map.obstacles                   # List of obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0  # tuning parameter\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= radius_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Node:\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors for potentially better paths\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...]) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], trials: int = 100) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Rotation matrix helper for informed sampling\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        # Initialize trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges: List[Tuple[Node, Node]] = []\n\n        grow_tree_start = True\n\n        iter_cnt = 0\n        while iter_cnt < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            iter_cnt += 1\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_tree_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_tree_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if not new_node:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    # Avoid duplication of connection node\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    # Update edges\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    # Apply smoothing and return early\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if not new_node:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_tree_start = not grow_tree_start\n\n        # On timeout or iteration limit, return best path found (if any)\n        if best_path:\n            smoothed = path_smoothing(best_path)\n            success = True\n        else:\n            smoothed = []\n            success = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -28.07081,
            "time_improvement": 56.0,
            "length_improvement": 17.0,
            "smoothness_improvement": 1580.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01549065113067627,
                    "num_nodes_avg": 67.1,
                    "path_length_avg": 160.82071621613,
                    "smoothness_avg": 0.04018716215495074,
                    "success_improvement": 0.0,
                    "time_improvement": 34.666663985190205,
                    "length_improvement": 11.851617074613193,
                    "smoothness_improvement": 529.0163555443684,
                    "objective_score": 15.415404388201543
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04627766609191895,
                    "num_nodes_avg": 218.8,
                    "path_length_avg": 234.7337667638325,
                    "smoothness_avg": 0.10335063168007959,
                    "success_improvement": 0.0,
                    "time_improvement": 80.70590588186646,
                    "length_improvement": 21.639112217377225,
                    "smoothness_improvement": 2559.2861935795413,
                    "objective_score": 41.33602517593309
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.049237298965454104,
                    "num_nodes_avg": 211.2,
                    "path_length_avg": 125.59843408327171,
                    "smoothness_avg": 0.13770665612117666,
                    "success_improvement": 0.0,
                    "time_improvement": 52.95404893761946,
                    "length_improvement": 16.583500436623012,
                    "smoothness_improvement": 1651.6185014133298,
                    "objective_score": 27.46100727567709
                }
            ],
            "success_rate": 1.0
        },
        "objective": 23.6,
        "analysis": "1. Summary of key changes:  \n   - Rewrote the `Node` class with enhanced methods for managing children and updating parents, including recursive cost updates to children nodes.  \n   - Updated the `Planner` class with refined parameters and renamed variables for clarity (`min_neighbor_radius`, `max_neighbor_radius`, `max_time_sec`).  \n   - Introduced more robust sampling strategies, including informed sampling and adaptive neighbor radius based on current node count and dimension.  \n   - Improved node extension and rewiring methods with more thorough collision checking and cost-based re-parenting, including removing edges and updating children costs properly.  \n   - Enhanced incremental tree connection logic that incrementally extends and rewires opposing trees to find connections more efficiently.  \n   - Added path smoothing with randomized shortcut removal to reduce unnecessary nodes and create smoother paths.  \n   - Refined in-bounds and obstacle collision checks with stronger separation of 2D and 3D cases.  \n   - Comprehensive tracking and updating of edges between nodes for clearer graph structure maintenance.  \n   - Introduced early exit upon finding first improved feasible path within time/iteration limits.  \n\n2. Primary contributors to the performance improvement:  \n   - Adaptive neighbor radius calculation that scales with the number of nodes and dimensionality, improving neighborhood searches for rewiring.  \n   - Incremental connect and rewire strategy on alternating trees, which reduces redundant searches and accelerates tree connection.  \n   - Path smoothing that actively shortcuts the path, reducing overall length and unnecessary waypoints, leading to better-quality solutions.  \n   - More precise and efficient edge and node collision checking, allowing quicker pruning of invalid expansions.  \n   - Recursive update of parent-child relationships and costs ensures global cost consistency and better-informed path improvements.  \n\n3. Expected mechanism of impact:  \n   - Adaptive neighbor radius optimizes local searches, balancing exploration and exploitation and preventing inefficient rewiring, thus enhancing convergence speed.  \n   - Incremental tree connection alternates growth between start and goal trees, minimizing redundant computations and improving chance of early connect, reducing planning time.  \n   - Path smoothing removes unnecessary detours and refines solution quality, directly improving path optimality and reducing path cost.  \n   - Improved collision checking prevents wasteful expansion into invalid nodes/edges, focusing computation on valid and promising paths.  \n   - Recursive and consistent parent-child cost updates maintain accurate cost-to-come values, enabling effective cost-based decisions during rewiring and path selection."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0, max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        start_time = time.perf_counter()\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        best_path_cost = float('inf')\n        best_path_nodes = (None, None)  # (node_in_start_tree, node_in_goal_tree)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (\n                not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if beneficial via the new node\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if (\n                    cost_through_new < neighbor.cost and\n                    not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d)\n                ):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n\n            return new_node\n\n        def try_connect_and_rewire(tree, new_node):\n            # Incrementally extend tree towards new_node.position within step size and rewire\n            target_pos = new_node.position\n            current_node = nearest(tree, target_pos)\n\n            while True:\n                dist = math.dist(current_node.position, target_pos)\n                if dist <= self.step_size:\n                    new_pos = target_pos\n                else:\n                    new_pos = steer(current_node.position, target_pos)\n\n                if (\n                    not self._within_bounds(new_pos, bounds) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d)\n                ):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_node_goal = Node(new_pos)\n                best_parent.add_child(new_node_goal)\n                new_node_goal.cost = min_cost\n                tree.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((best_parent, new_node_goal))\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    cost_through_new = new_node_goal.cost + math.dist(new_node_goal.position, neighbor.position)\n                    if (\n                        cost_through_new < neighbor.cost and\n                        not self._is_edge_in_obstacle(new_node_goal.position, neighbor.position, obstacles, is_3d)\n                    ):\n                        neighbor.update_parent(new_node_goal, cost_through_new)\n                        edges.append((new_node_goal, neighbor))\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n\n                if new_node_goal.position == target_pos:\n                    return new_node_goal\n                current_node = new_node_goal\n\n        def path_cost_sum(path_nodes: List[Node]):\n            if not path_nodes:\n                return float('inf')\n            return path_nodes[-1].cost\n\n        def merge_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Avoid duplicate middle node\n            return path_start + path_goal[::-1][1:]\n\n        for iter_num in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_time_sec:\n                # Time limit exceeded, extract best path so far if any\n                if success_state:\n                    extracted_path = merge_paths(best_path_nodes[0], best_path_nodes[1])\n                break\n\n            rnd_point = sample_free()\n\n            new_node_start = try_extend_and_rewire(tree_start, rnd_point)\n            if new_node_start is None:\n                # Swap trees to maintain balanced growth\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            connect_node_goal = try_connect_and_rewire(tree_goal, new_node_start)\n            if connect_node_goal:\n                # Connected trees successfully\n                total_cost = new_node_start.cost + connect_node_goal.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = (new_node_start, connect_node_goal)\n                    extracted_path = merge_paths(new_node_start, connect_node_goal)\n                    success_state = True\n                # Swap trees to keep balanced exploration\n                tree_start, tree_goal = tree_goal, tree_start\n                # Early break for success to reduce planning time\n                if success_state:\n                    break\n            else:\n                # Swap trees for next iteration\n                tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))"
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "This implementation is an optimized bidirectional RRT* planner with adaptive rewiring, goal biasing, and time-budget enforcement to minimize planning time while maintaining path quality and robustness. It grows two trees from start and goal simultaneously, incrementally extends and rewires nodes, performs efficient collision checks, and halts early upon connection or timeout.",
            "planning_mechanism": "The planner alternates extending two trees grown from start and goal positions respectively toward randomly sampled, goal-biased points. It uses rewiring within a neighborhood radius to locally optimize the path cost. At each iteration, it attempts to connect the trees, terminating early once a collision-free linkage is found or the time limit expires, returning the best path discovered.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.15, neighbor_radius: float=12.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        start_time = time.perf_counter()\n\n        # Initialize two trees\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        success = False\n        best_path_cost = float('inf')\n        best_path_nodes = (None, None)\n        extracted_path = []\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...]) -> List[Node]:\n            return [node for node in tree if math.dist(node.position, pos) <= self.neighbor_radius]\n\n        def try_extend_and_rewire(tree: List[Node], point: Tuple[float, ...]) -> Node or None:\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (\n                not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if (\n                    cost_through_new < neighbor.cost and\n                    not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d)\n                ):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n\n            return new_node\n\n        def try_connect(tree: List[Node], target_node: Node) -> Node or None:\n            current_node = nearest(tree, target_node.position)\n            while True:\n                dist = math.dist(current_node.position, target_node.position)\n                if dist <= self.step_size:\n                    new_pos = target_node.position\n                else:\n                    new_pos = steer(current_node.position, target_node.position)\n\n                if (\n                    not self._within_bounds(new_pos, bounds) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d)\n                ):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if (\n                        cost_through_new < neighbor.cost and\n                        not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d)\n                    ):\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n\n                if new_node.position == target_node.position:\n                    return new_node\n                current_node = new_node\n\n        def merge_paths(node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]  # avoid duplicate joining node\n\n        for iter_num in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_time_sec:\n                if success:\n                    extracted_path = merge_paths(best_path_nodes[0], best_path_nodes[1])\n                break\n\n            rnd_point = sample_free()\n            new_node_start = try_extend_and_rewire(tree_start, rnd_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            connect_node_goal = try_connect(tree_goal, new_node_start)\n            if connect_node_goal:\n                total_cost = new_node_start.cost + connect_node_goal.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = (new_node_start, connect_node_goal)\n                    extracted_path = merge_paths(new_node_start, connect_node_goal)\n                    success = True\n                tree_start, tree_goal = tree_goal, tree_start\n                # Early termination on success for reduced planning time\n                break\n            else:\n                tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
            "objective": -18.76002,
            "time_improvement": 53.0,
            "length_improvement": 10.0,
            "smoothness_improvement": 179.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019108223915100097,
                    "num_nodes_avg": 98.8,
                    "path_length_avg": 176.1973261808077,
                    "smoothness_avg": 0.016264515390411786,
                    "success_improvement": 0.0,
                    "time_improvement": 19.409196995003406,
                    "length_improvement": 3.4234534949960658,
                    "smoothness_improvement": 154.5749848204143,
                    "objective_score": 7.280324721602305
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04307892322540283,
                    "num_nodes_avg": 286.6,
                    "path_length_avg": 252.26151991778178,
                    "smoothness_avg": 0.011662148021780783,
                    "success_improvement": 0.0,
                    "time_improvement": 82.03952641933448,
                    "length_improvement": 15.78784370618765,
                    "smoothness_improvement": 200.07546850611288,
                    "objective_score": 28.76980400956844
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04527461528778076,
                    "num_nodes_avg": 224.4,
                    "path_length_avg": 133.24569451252,
                    "smoothness_avg": 0.022121184403052812,
                    "success_improvement": 0.0,
                    "time_improvement": 56.74037000503455,
                    "length_improvement": 11.50455418292619,
                    "smoothness_improvement": 181.3798327908465,
                    "objective_score": 20.229921002049835
                }
            ],
            "success_rate": 1.0
        },
        "objective": 30.599999999999998,
        "analysis": "1. Summary of key changes:  \n   - Implemented a bidirectional RRT planner with two trees growing from start and goal.  \n   - Introduced incremental extend and rewiring in both trees to improve path quality dynamically.  \n   - Added nearest neighbor search and steering with a step size limit to control growth.  \n   - Integrated obstacle and boundary checks for nodes and edges to ensure feasible paths.  \n   - Implemented cost-based rewiring to optimize local paths in the tree after adding a new node.  \n   - Early break once a connection between the two trees is found to reduce planning time.  \n   - Maintains and updates nodes and edges lists for the constructed graph representation.  \n\n2. Primary contributors to the performance improvement:  \n   - Bidirectional tree growth reducing search space and time.  \n   - Rewiring step that dynamically updates parents of nearby nodes to lower overall path cost.  \n   - Incremental extension with obstacle and boundary validation preventing invalid expansions.  \n   - Early termination on successful tree connection minimizing unnecessary computations.  \n\n3. Expected mechanism of impact:  \n   - Bidirectional search reduces iterations and exploration time by connecting start and goal trees faster.  \n   - Rewiring ensures the planner continuously improves the path by optimizing connections, leading to smoother and lower-cost paths.  \n   - Obstacle and boundary checks prevent wasted attempts expanding into invalid regions, improving efficiency.  \n   - Early breaking on success avoids excess computation once a valid path is found, improving overall planning speed and efficiency."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=5.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(src, tgt):\n            d = dist(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def collision_free_node(p):\n            return in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size/5)\n\n        def neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return 25.0\n            r = 25.0 * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(10.0, min(25.0, r))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (dist(n.position, pos)**2) <= radius_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx**2 + ky**2 + kz**2)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def informed_sample(c_best, c_min):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample):\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            r = neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                cost_through = nbr.cost + dist(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest_node\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                r = neighbor_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, r)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path, iterations=120):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        all_edges = []\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_active = False\n        grow_start_tree = True\n        start_time = time.perf_counter()\n\n        for _ in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            if informed_sampling_active:\n                sample = informed_sample(best_cost, c_min)\n            else:\n                if random.random() < 0.2:\n                    sample = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample = uniform_sample()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(start_tree, sample)\n                if not new_node:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(goal_tree, new_node.position)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        # update edges\n                        all_nodes = start_tree + goal_tree\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(goal_tree, sample)\n                if not new_node:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(start_tree, new_node.position)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        all_nodes = start_tree + goal_tree\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        if best_path:\n            smoothed = path_smoothing(best_path)\n            success_state = True\n        else:\n            smoothed = []\n            success_state = False\n\n        all_nodes = start_tree + goal_tree\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = cost                # cost from root\n        self.children = []\n        self.valid = True\n\n        if parent:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def _distance(self, a, b):\n        from math import dist\n        return dist(a, b)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-10:\n            return  # no change\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        # update children's costs recursively\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=5.0, max_time_sec: float=30.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=10.0, neighbor_radius_max: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time_sec = max_time_sec\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n        \n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = self.neighbor_radius_max\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if dist(node.position, position)**2 <= radius_sq]\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size/5)\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n        \n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_active = False\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(0.0, c_best*c_best - c_min*c_min)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(0.0, c_best*c_best - c_min*c_min)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            while True:\n                dir_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(dim))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(dim))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            r = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_node):\n            curr = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(curr.position, target_node.position)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                r = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, r)\n\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr is curr:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist(new_node.position, target_node.position) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    else:\n                        return None\n\n                curr = new_node\n        \n        def path_smoothing(path, trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) -1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        start_time = time.perf_counter()\n        grow_start_tree = True\n\n        iter_count = 0\n\n        while iter_count < self.max_iter:\n            iter_count += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            if informed_sampling_active:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample = uniform_sample()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(tree_goal, new_node)\n                if connect_node:\n                    path_s = new_node.path_from_root()\n                    path_g = connect_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n\n                        all_nodes = tree_start + tree_goal\n                        edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                edges.append((node, c))\n\n                        smoothed_path = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(tree_start, new_node)\n                if connect_node:\n                    path_g = new_node.path_from_root()\n                    path_s = connect_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n\n                        all_nodes = tree_start + tree_goal\n                        edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                edges.append((node, c))\n\n                        smoothed_path = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # time expired or max_iter reached, return best found path if any\n        if best_path:\n            smoothed_path = path_smoothing(best_path)\n            success_state = True\n        else:\n            smoothed_path = []\n            success_state = False\n\n        all_nodes = tree_start + tree_goal\n        edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed_path, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False"
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "This algorithm implements a bidirectional RRT* planner with informed ellipsoidal sampling, adaptive neighbor rewiring, and incremental connection attempts to efficiently find smooth, low-cost paths within a 30-second limit. It maintains two trees grown alternately from start and goal, leveraging collision-free incremental expansions, dynamic rewiring to optimize path cost locally, and path shortcut smoothing to improve final solution quality. Early termination upon path discovery or timeout ensures time-bounded planning.",
            "planning_mechanism": "The planner grows two trees from start and goal positions by sampling points biased towards the goal and, after a path is found, within an informed ellipsoid. Nodes are incrementally connected and rewired using an adaptive neighbor radius to reduce path cost. The planner alternates tree growth, performs collision checks on nodes and edges, and applies path shortcutting to smooth the final path before returning the best solution found within 30 seconds.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position         # Tuple[float, ...]\n        self.parent = None               # Node or None\n        self.cost = cost                 # Cost from root\n        self.children = []\n        self.valid = True\n\n        if parent:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def _distance(self, a, b):\n        from math import dist\n        return dist(a, b)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-10:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=5.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(src, tgt):\n            d = dist(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def collision_free_node(p):\n            return in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return 20.0\n            r = 20.0 * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(8.0, min(20.0, r))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (dist(n.position, pos) ** 2) <= radius_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx**2 + ky**2 + kz**2)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def informed_sample(c_best, c_min):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample):\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n            r = neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                cost_thru = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_node):\n            curr = min(tree, key=lambda n: dist(n.position, target_node.position))\n            while True:\n                new_pos = steer(curr.position, target_node.position)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr.position, new_pos):\n                    return None\n                r = neighbor_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, r)\n\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr is curr:\n                        continue\n                    cost_thru = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_node.position) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    else:\n                        return None\n                curr = new_node\n\n        def path_smoothing(path, iterations=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling_active = False\n        c_min = dist(start_pos, goal_pos)\n        grow_start_tree = True\n\n        start_time = time.perf_counter()\n\n        for _ in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            sample = informed_sample(best_cost, c_min) if informed_sampling_active else (\n                goal_pos if random.random() < 0.2 else uniform_sample()\n            )\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(start_tree, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(goal_tree, new_node)\n                if connect_node:\n                    path_s = new_node.path_from_root()\n                    path_g = connect_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        # Early return on improved path\n                        smoothed = path_smoothing(best_path)\n                        nodes = start_tree + goal_tree\n                        edges = []\n                        for node in nodes:\n                            for c in node.children:\n                                edges.append((node, c))\n                        return PlannerResult(True, smoothed, nodes, edges)\n            else:\n                new_node = extend_and_rewire(goal_tree, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(start_tree, new_node)\n                if connect_node:\n                    path_g = new_node.path_from_root()\n                    path_s = connect_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        smoothed = path_smoothing(best_path)\n                        nodes = start_tree + goal_tree\n                        edges = []\n                        for node in nodes:\n                            for c in node.children:\n                                edges.append((node, c))\n                        return PlannerResult(True, smoothed, nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        if best_path:\n            success_state = True\n            smoothed = path_smoothing(best_path)\n        else:\n            success_state = False\n            smoothed = []\n\n        nodes = start_tree + goal_tree\n        edges = []\n        for node in nodes:\n            for c in node.children:\n                edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -28.11571,
            "time_improvement": 55.0,
            "length_improvement": 18.0,
            "smoothness_improvement": 1604.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019519495964050292,
                    "num_nodes_avg": 70.2,
                    "path_length_avg": 155.1714439963092,
                    "smoothness_avg": 0.041852322405292755,
                    "success_improvement": 0.0,
                    "time_improvement": 17.674616909189453,
                    "length_improvement": 14.948072696743845,
                    "smoothness_improvement": 555.0797294155799,
                    "objective_score": 11.067398259183504
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06700973510742188,
                    "num_nodes_avg": 318.4,
                    "path_length_avg": 232.16109678947745,
                    "smoothness_avg": 0.10635019012507274,
                    "success_improvement": 0.0,
                    "time_improvement": 72.06228738014165,
                    "length_improvement": 22.497943505016327,
                    "smoothness_improvement": 2636.4669928638355,
                    "objective_score": 39.30060987936494
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026527929306030273,
                    "num_nodes_avg": 182.2,
                    "path_length_avg": 124.3356742878965,
                    "smoothness_avg": 0.1352033003313838,
                    "success_improvement": 0.0,
                    "time_improvement": 74.65271876929245,
                    "length_improvement": 17.422165366551436,
                    "smoothness_improvement": 1619.7760005456682,
                    "objective_score": 33.979128706826366
                }
            ],
            "success_rate": 1.0
        },
        "objective": 37.4,
        "analysis": "1. Summary of key changes:\n   - Introduced parameters for goal sampling rate and adaptive neighbor radius limits for more flexible tuning (`goal_sample_rate`, `neighbor_radius_min`, `neighbor_radius_max`).\n   - Improved neighbor radius calculation to adapt between min and max limits, enhancing sampling efficiency.\n   - Added clamping of sampled points to ensure they lie within bounds.\n   - Enhanced early sampling strategy by probabilistically sampling the goal based on `goal_sample_rate`.\n   - Simplified and optimized functions such as `nearest`, `uniform_sample`, `informed_sample`, and steering logic.\n   - Added clearer separation of tree growth phases with explicit toggle for growing start or goal trees.\n   - Improved update and rewiring of parents and children with cost checks to avoid unnecessary updates.\n   - Reorganized collision checking with small fixed resolution related to step size.\n   - Streamlined path smoothing with controlled iteration counts.\n   - Updated edge and node management ensuring consistent connections and removals.\n   \n2. Primary contributors to the performance improvement:\n   - Adaptive neighbor radius with min and max limits, enabling more efficient local search.\n   - Goal sampling rate parameter guiding focused exploration toward the goal more frequently.\n   - Clamping samples within map bounds to avoid invalid states early.\n   - Refined incremental connect and extend & rewire logic to reduce redundant rewiring and improve path cost updates.\n   - More robust and stable parent-child cost updates with early exit conditions.\n   \n3. Expected mechanism of impact:\n   - By adaptively controlling neighbor search radius and goal sampling frequency, the planner focuses computational resources on promising regions, reducing unnecessary expansion.\n   - Clamping and refined collision checks reduce failed attempts and wasted iterations.\n   - Optimized rewiring and cost update minimize overhead related to maintaining the tree structure.\n   - Improved path smoothing helps generate shorter, more feasible paths faster.\n   - Clearer growth phase management (start vs goal tree) balances bidirectional search for connectivity efficiency."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        new_parent.add_child(self)\n        self.cost = new_cost\n        for child in self.children:\n            dist_to_child = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist_to_child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 100000, step_size: float = 5.0,\n                 max_planning_time: float = 30.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float = 30.0,\n                 smoothing_trials: int = 200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = max_planning_time\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_p, to_p):\n            dist_ = math.dist(from_p, to_p)\n            if dist_ <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist_\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def collision_node_free(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_edge_free(from_p, to_p):\n            resolution = self.step_size / 5.0 if self.step_size > 0 else 0.5\n            return not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d, resolution=resolution)\n\n        def adaptive_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            val = 25.0 * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, val))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, pos) ** 2) <= radius_sq]\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = math.dist(start_position, goal_position)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_enabled = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                vx /= norm_v\n                vy /= norm_v\n                vz /= norm_v\n                # Generate orthonormal basis using Gram-Schmidt like\n                arbitrary = (1.0, 0.0, 0.0) if abs(vx) < 0.9 else (0.0, 1.0, 0.0)\n                wx = vy*arbitrary[2] - vz*arbitrary[1]\n                wy = vz*arbitrary[0] - vx*arbitrary[2]\n                wz = vx*arbitrary[1] - vy*arbitrary[0]\n                norm_w = math.sqrt(wx*wx + wy*wy + wz*wz)\n                if norm_w < 1e-12:\n                    wx, wy, wz = 0.0, 0.0, 1.0\n                else:\n                    wx /= norm_w\n                    wy /= norm_w\n                    wz /= norm_w\n\n                # u,v,w basis\n                ux, uy, uz = vx, vy, vz\n                vx_, vy_, vz_ = wx, wy, wz\n                wx_, wy_, wz_ = uy*wz - uz*vy_, uz*vx_ - ux*wz, ux*vy_ - uy*vx_\n\n                return [\n                    [ux, vx_, wx_],\n                    [uy, vy_, wy_],\n                    [uz, vz_, wz_]\n                ]\n\n        def informed_sample(c_best: float):\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return sample_free()\n            center = tuple((start_position[d] + goal_position[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_position[d] - start_position[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_bounds(sample_pt)\n                if collision_node_free(sample_pt):\n                    return sample_pt\n\n        def sample_free():\n            for _ in range(30):\n                pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if collision_node_free(pt):\n                    return pt\n            return goal_position\n\n        def rewire(tree, new_node, neighbors, edges):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-9 < nbr.cost and collision_edge_free(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n                    if (nbr.parent, nbr) not in edges and nbr.parent is not None:\n                        edges.append((nbr.parent, nbr))\n\n        def extend(tree, sample_pt, nodes, edges):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, sample_pt))\n            new_pos = steer(nearest_node.position, sample_pt)\n            new_pos = clamp_bounds(new_pos)\n            if not collision_node_free(new_pos) or not collision_edge_free(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                tentative_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                if tentative_cost + 1e-9 < min_cost and collision_edge_free(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors, edges)\n            return new_node\n\n        def try_connect(new_node, other_tree, nodes, edges):\n            if not other_tree:\n                return None\n            curr_node = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n\n            while True:\n                next_pos = steer(curr_node.position, new_node.position)\n                next_pos = clamp_bounds(next_pos)\n\n                if not collision_node_free(next_pos) or not collision_edge_free(curr_node.position, next_pos):\n                    return None\n\n                radius = adaptive_radius(len(other_tree)+1)\n                neighbors = near_nodes(other_tree, next_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, next_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr is curr_node:\n                        continue\n                    tentative_cost = nbr.cost + math.dist(nbr.position, next_pos)\n                    if tentative_cost + 1e-9 < min_cost and collision_edge_free(nbr.position, next_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_connect_node = Node(next_pos)\n                best_parent.add_child(new_connect_node)\n                new_connect_node.cost = min_cost\n                other_tree.append(new_connect_node)\n                nodes.append(new_connect_node)\n                edges.append((best_parent, new_connect_node))\n\n                rewire(other_tree, new_connect_node, neighbors, edges)\n\n                if math.dist(new_connect_node.position, new_node.position) <= self.step_size:\n                    if collision_edge_free(new_connect_node.position, new_node.position):\n                        return new_connect_node\n                    else:\n                        return None\n\n                curr_node = new_connect_node\n\n        def path_smoothing(path, max_trials):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(max_trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_edge_free(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position, None, 0.0)]\n        tree_goal = [Node(goal_position, None, 0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling_enabled = False\n        grow_start_tree = True\n        start_time = time.perf_counter()\n\n        for iter_count in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed >= self.max_planning_time:\n                if best_path:\n                    best_path = path_smoothing(best_path, self.smoothing_trials)\n                    return PlannerResult(True, best_path, nodes, edges)\n                else:\n                    return PlannerResult(False, [], nodes, edges)\n\n            if informed_sampling_enabled:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_position if grow_start_tree else start_position\n                else:\n                    sample_pt = sample_free()\n\n            active_tree = tree_start if grow_start_tree else tree_goal\n            other_tree = tree_goal if grow_start_tree else tree_start\n\n            new_node = extend(active_tree, sample_pt, nodes, edges)\n            if new_node is None:\n                grow_start_tree = not grow_start_tree\n                continue\n\n            connect_node = try_connect(new_node, other_tree, nodes, edges)\n            if connect_node:\n                if grow_start_tree:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                else:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n                combined_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n\n                if combined_cost + 1e-9 < best_cost:\n                    best_cost = combined_cost\n                    best_path = combined_path\n                    informed_sampling_enabled = True\n\n                    # Rebuild edges for current trees\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            if (node, c) not in edges:\n                                edges.append((node, c))\n\n                    best_path = path_smoothing(best_path, self.smoothing_trials)\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # Max iterations reached\n        if best_path:\n            best_path = path_smoothing(best_path, self.smoothing_trials)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = None\n        self.cost = cost                # Path cost from root node\n        self.children = []\n        self.valid = True               # Collision-free flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent))\n\n    def _distance(self, other_node):\n        import math\n        return math.dist(self.position, other_node.position)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from old parent\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost updates recursively to children\n        for c in self.children:\n            c.update_parent(self, new_cost + c._distance(self))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=10.0, neighbor_radius_max: float=30.0,\n                 max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import time\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        # Rotation matrix aligning standard axis to vector direction (for informed sampling)\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                # Compute orthogonal vector k and Rodrigues formula components\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=self.step_size/5)\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        # Informed sampling inside an ellipsoid between start and goal with current best cost c_best\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d]-start_pos[d])/c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best/2\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2\n                radii = [a1, a2]\n            else:\n                a1 = c_best/2\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                # Sample unit n-ball\n                unit_dir = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0/n)\n                sample_unit = tuple(radius_sample*d for d in unit_dir)\n                sample_scaled = tuple(sample_unit[d]*radii[d] for d in range(n))\n                # Rotate sample\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        # Adaptive neighbor radius based on number of nodes and dimension (RRT* scaling)\n        def adaptive_neighbor_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        # Rewire neighbors if cheaper path via new_node is found, with recursive cost update\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_via_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_via_new)\n\n        # Extend tree towards target point, with rewiring and collision checks\n        def extend(tree, target_point):\n            nearest_node = min(tree, key=lambda n: dist(n.position, target_point))\n            new_pos = steer(nearest_node.position, target_point)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            # Find best parent minimizing cost\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        # Incrementally connect new_node with the opposite tree by successive steps with rewiring\n        def incremental_connect(new_node, other_tree):\n            current_node = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                step_pos = steer(current_node.position, new_node.position)\n                step_pos = clamp_to_bounds(step_pos)\n                if not collision_free_node(step_pos) or not collision_free_edge(current_node.position, step_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(other_tree)+1)\n                neighbors = near_nodes(other_tree, step_pos, radius)\n\n                min_cost = current_node.cost + dist(current_node.position, step_pos)\n                best_parent = current_node\n                for nbr in neighbors:\n                    if nbr == current_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, step_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, step_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(step_pos)\n                connect_node.update_parent(best_parent, min_cost)\n                other_tree.append(connect_node)\n\n                rewire(other_tree, connect_node, neighbors)\n\n                if dist(connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connect_node.position, new_node.position):\n                        return connect_node\n                    else:\n                        return None\n\n                current_node = connect_node\n\n        # Path smoothing by randomized shortcutting with collision checks\n        def path_smoothing(path, max_trials=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Initialization\n        c_min = dist(start_pos, goal_pos)\n        best_path_cost = math.inf\n        best_path_nodes: list = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        start_time = time.perf_counter()\n        grow_start = True\n        informed_sampling_enabled = False\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                # Time limit reached\n                if best_path_nodes:\n                    path_smoothed = path_smoothing(best_path_nodes)\n                    # Rebuild edges from trees if needed\n                    edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(success=True, path=path_smoothed, nodes=all_nodes, edges=edges)\n                else:\n                    edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(success=False, path=[], nodes=all_nodes, edges=edges)\n\n            iter_count += 1\n\n            # Select sample point respecting informed sampling after first solution\n            if informed_sampling_enabled:\n                sample = informed_sample(best_path_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_free()\n\n            if grow_start:\n                new_node = extend(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(new_node, tree_goal)\n                if connect_node:\n                    # Build combined path\n                    path_from_start = new_node.path_from_root()\n                    path_from_goal = connect_node.path_from_root()\n                    # Remove duplicate joining node\n                    if path_from_goal and path_from_goal[0] == new_node.position:\n                        path_from_goal = path_from_goal[1:]\n                    merged_path = path_from_start + path_from_goal[::-1]\n\n                    # Compute total cost of combined path\n                    cost_path = 0.0\n                    for i in range(len(merged_path)-1):\n                        cost_path += dist(merged_path[i], merged_path[i+1])\n\n                    if cost_path < best_path_cost:\n                        best_path_cost = cost_path\n                        best_path_nodes = merged_path\n                        informed_sampling_enabled = True\n\n                    # Update edges to reflect current tree structure\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    # Early return with smoothed path if meaningful improvement\n                    path_smoothed = path_smoothing(best_path_nodes)\n                    return PlannerResult(success=True, path=path_smoothed, nodes=all_nodes, edges=edges)\n\n            else:\n                new_node = extend(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(new_node, tree_start)\n                if connect_node:\n                    path_from_goal = new_node.path_from_root()\n                    path_from_start = connect_node.path_from_root()\n                    if path_from_start and path_from_start[0] == new_node.position:\n                        path_from_start = path_from_start[1:]\n                    merged_path = path_from_start + path_from_goal[::-1]\n\n                    cost_path = 0.0\n                    for i in range(len(merged_path)-1):\n                        cost_path += dist(merged_path[i], merged_path[i+1])\n\n                    if cost_path < best_path_cost:\n                        best_path_cost = cost_path\n                        best_path_nodes = merged_path\n                        informed_sampling_enabled = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    path_smoothed = path_smoothing(best_path_nodes)\n                    return PlannerResult(success=True, path=path_smoothed, nodes=all_nodes, edges=edges)\n\n            grow_start = not grow_start\n\n        # Max iter reached - return best path if found\n        if best_path_nodes:\n            path_smoothed = path_smoothing(best_path_nodes)\n            edges.clear()\n            all_nodes = tree_start + tree_goal\n            for node in all_nodes:\n                for c in node.children:\n                    edges.append((node, c))\n            success_state = True\n        else:\n            path_smoothed = []\n            success_state = False\n\n        return PlannerResult(success_state, path_smoothed, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False"
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius, ellipsoidal informed sampling after an initial solution, incremental tree connection, and rewiring for path cost improvement. It alternately grows trees from start and goal within given bounds and obstacles, ensuring collision-free expansions and edges, with realtime time limit enforcement and path smoothing for enhanced path quality.",
            "planning_mechanism": "The planner maintains two trees growing from start and goal respectively, sampling points either uniformly or within an ellipsoidal informed region biased by the best path cost. It extends one tree towards the sample, rewires neighbors for cost optimization, then incrementally connects to the opposite tree with rewiring. Upon a connection, it extracts and smooths the path, terminating early if time limit is reached or a path is found.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent))\n\n    def _distance(self, other):\n        return math.dist(self.position, other.position)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for c in self.children:\n            c.update_parent(self, new_cost + c._distance(self))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 100000, step_size: float=5.0,\n                 max_planning_time: float=30.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=5.0,\n                 neighbor_radius_max: float=30.0,\n                 smoothing_trials: int=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = max_planning_time\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_p, to_p):\n            dist_ = math.dist(from_p, to_p)\n            if dist_ <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist_\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_p, to_p):\n            resolution = self.step_size / 5.0 if self.step_size > 0 else 0.5\n            return not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d, resolution=resolution)\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            val = 30.0 * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, val))\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            return [node for node in tree if (math.dist(node.position, pos) ** 2) <= r2]\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_enabled = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                vx /= norm_v\n                vy /= norm_v\n                vz /= norm_v\n                arbitrary = (1.0, 0.0, 0.0) if abs(vx) < 0.9 else (0.0, 1.0, 0.0)\n                wx = vy*arbitrary[2] - vz*arbitrary[1]\n                wy = vz*arbitrary[0] - vx*arbitrary[2]\n                wz = vx*arbitrary[1] - vy*arbitrary[0]\n                norm_w = math.sqrt(wx*wx + wy*wy + wz*wz)\n                if norm_w < 1e-12:\n                    wx, wy, wz = 0.0, 0.0, 1.0\n                else:\n                    wx /= norm_w\n                    wy /= norm_w\n                    wz /= norm_w\n                ux, uy, uz = vx, vy, vz\n                vx_, vy_, vz_ = wx, wy, wz\n                wx_, wy_, wz_ = uy*wz - uz*vy_, uz*vx_ - ux*wz, ux*vy_ - uy*vx_\n                return [\n                    [ux, vx_, wx_],\n                    [uy, vy_, wy_],\n                    [uz, vz_, wz_]\n                ]\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                r = random.random() ** (1.0 / n)\n                sample_unit = tuple(r * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def sample_free():\n            for _ in range(30):\n                pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return goal_pos  # fallback\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-9 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n        def extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, sample_pt))\n            new_pos = steer(nearest_node.position, sample_pt)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n            n_radius = adaptive_neighbor_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, n_radius)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                if tentative_cost + 1e-9 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(new_node, other_tree):\n            if not other_tree:\n                return None\n            current_node = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            while True:\n                step_pos = steer(current_node.position, new_node.position)\n                step_pos = clamp_to_bounds(step_pos)\n                if not collision_free_node(step_pos) or not collision_free_edge(current_node.position, step_pos):\n                    return None\n                radius = adaptive_neighbor_radius(len(other_tree)+1)\n                neighbors = near_nodes(other_tree, step_pos, radius)\n                min_cost = current_node.cost + math.dist(current_node.position, step_pos)\n                best_parent = current_node\n                for nbr in neighbors:\n                    if nbr == current_node:\n                        continue\n                    tentative_cost = nbr.cost + math.dist(nbr.position, step_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, step_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n                connect_node = Node(step_pos)\n                connect_node.update_parent(best_parent, min_cost)\n                other_tree.append(connect_node)\n                rewire(other_tree, connect_node, neighbors)\n                if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connect_node.position, new_node.position):\n                        return connect_node\n                    else:\n                        return None\n                current_node = connect_node\n\n        def path_smoothing(path, max_trials):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(max_trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        # Initialization\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_path_nodes = []\n        best_path_cost = math.inf\n        informed_sampling_enabled = False\n        grow_start = True\n\n        start_time = time.perf_counter()\n        iter_count = 0\n        while iter_count < self.max_iter:\n            iter_count += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed >= self.max_planning_time:\n                # Time exceeded, return best path found\n                if best_path_nodes:\n                    smoothed = path_smoothing(best_path_nodes, self.smoothing_trials)\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(True, smoothed, all_nodes, edges)\n                else:\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            # Sample point\n            if informed_sampling_enabled:\n                sample_pt = informed_sample(best_path_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(active_tree, sample_pt)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            connect_node = incremental_connect(new_node, other_tree)\n            if connect_node is not None:\n                if grow_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                else:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                # Compute combined cost\n                total_cost = 0.0\n                for i in range(len(combined_path)-1):\n                    total_cost += math.dist(combined_path[i], combined_path[i+1])\n\n                if total_cost + 1e-9 < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = combined_path\n                    informed_sampling_enabled = True\n\n                edges.clear()\n                all_nodes = tree_start + tree_goal\n                for node in all_nodes:\n                    for c in node.children:\n                        edges.append((node, c))\n\n                smoothed_path = path_smoothing(best_path_nodes, self.smoothing_trials)\n                return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        # Max iterations reached\n        if best_path_nodes:\n            smoothed_path = path_smoothing(best_path_nodes, self.smoothing_trials)\n            edges.clear()\n            all_nodes = tree_start + tree_goal\n            for node in all_nodes:\n                for c in node.children:\n                    edges.append((node, c))\n            return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n        edges.clear()\n        all_nodes = tree_start + tree_goal\n        for node in all_nodes:\n            for c in node.children:\n                edges.append((node, c))\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -28.86429,
            "time_improvement": 56.0,
            "length_improvement": 19.0,
            "smoothness_improvement": 1675.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01880507469177246,
                    "num_nodes_avg": 64.1,
                    "path_length_avg": 158.15395981511193,
                    "smoothness_avg": 0.04238641838992204,
                    "success_improvement": 0.0,
                    "time_improvement": 20.68775849014105,
                    "length_improvement": 13.313308515470546,
                    "smoothness_improvement": 563.4394913830222,
                    "objective_score": 11.686186707051533
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04519479274749756,
                    "num_nodes_avg": 223.3,
                    "path_length_avg": 232.93837097407726,
                    "smoothness_avg": 0.11965000592321515,
                    "success_improvement": 0.0,
                    "time_improvement": 81.15737766058118,
                    "length_improvement": 22.23846700959999,
                    "smoothness_improvement": 2978.6808328201532,
                    "objective_score": 43.68831086419512
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.035725188255310056,
                    "num_nodes_avg": 197.3,
                    "path_length_avg": 120.17187027929853,
                    "smoothness_avg": 0.12455155358138663,
                    "success_improvement": 0.0,
                    "time_improvement": 65.86479165859849,
                    "length_improvement": 20.187565730021888,
                    "smoothness_improvement": 1484.2865681158646,
                    "objective_score": 31.218383484163247
                }
            ],
            "success_rate": 1.0
        },
        "objective": 31.200000000000003,
        "analysis": "1. Summary of key changes:\n   - Addition of the Node class with detailed parent-child relationship management, including cost propagation and path retrieval.\n   - Implementation of bidirectional RRT* style planning with separate start and goal trees.\n   - Introduction of adaptive neighbor radius calculation based on the tree size and dimension.\n   - Use of informed sampling within an ellipsoidal subset after first solution to improve sampling efficiency.\n   - Incremental connection of trees via stepwise collision-checked extensions and rewiring for cost optimization.\n   - Incorporation of randomized path smoothing (shortcutting) to refine the solution path.\n   - Use of time-based termination criteria in addition to iteration limit.\n   - More robust collision checking including relaxed resolution for edges and nodes.\n   - Early returns with improved path smoothing when solution improves over previous best.\n   - More explicit and modular helper functions (e.g. in_bounds, clamp_bounds, collision checks, steering).\n   - Inclusion of internal flags and mechanisms to switch between growth from start and goal trees dynamically.\n   - Rebuilding and updating of edges to reflect current tree connections after each iteration.\n\n2. Primary contributors to the performance improvement:\n   - Informed sampling that restricts random samples to an ellipsoidal region focused on promising areas, increasing convergence speed.\n   - Bidirectional incremental growing and connecting of two trees reducing overall search space.\n   - Adaptive neighbor radius for efficient rewiring enhancing lower-cost path formation.\n   - Efficient rewiring that updates costs and parents along children recursively for dynamic tree improvement.\n   - Early solution detection and immediate refinement through smoothing, improving path quality and termination efficiency.\n   - Structured node management with parent-child relationships facilitating quick cost updates and path extraction.\n\n3. Expected mechanism of impact:\n   - The informed sampling concentrates the search in regions likely containing shorter paths, reducing unnecessary exploration.\n   - Bidirectional tree expansion reduces the average path discovery time compared to unidirectional methods.\n   - Adaptive neighbor radius balances exploration and exploitation by dynamically adjusting rewiring scope.\n   - Rewiring accelerates the optimization of the tree, trimming longer paths and favoring cheaper routes.\n   - Path smoothing reduces path complexity and removes unnecessary detours, resulting in better feasible paths faster.\n   - Time-based termination combined with iterative improvements balances thoroughness and computational efficiency, leading to robust practical performance enhancements."
    }
]