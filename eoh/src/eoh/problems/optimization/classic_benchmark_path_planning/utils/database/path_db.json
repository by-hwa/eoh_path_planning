[
    {
        "operator": "e2",
        "algorithm_description": "A hybrid bidirectional RRT* with adaptive fixed-radius rewiring, goal-biased sampling, batch informed sampling after initial connection, local rewiring without costly recursive cost updates, and early stopping. The planner uses a KD-tree for efficient nearest neighbor queries, alternates start/goal tree expansions, connects trees promptly with consistent parent-child edges, and performs local smoothing shortcutting on the best path found to improve path smoothness and length within a strict 30s time limit.",
        "planning_mechanism": "A bidirectional planner grows two trees alternately from start and goal by sampling with goal bias. Each new node is connected using fixed-radius rewiring around the new node with efficient collision checks and local rewiring without full recursive cost updates to limit overhead. After initial path connection, the planner performs ellipsoidal informed batch sampling around the best path to refine it. The best path found is locally shortcut-smoothed before returning. The planner stops early when time limit is reached or no improvement is observed over several iterations.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True  # for extension if needed\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.17  # goal bias probability\n        self.fixed_radius = 20.0       # fixed radius for rewiring (adjusted)\n        self.time_limit = 30.0         # seconds\n        self.improve_tol = 1e-8\n        self.batch_informed_iters = 1500 # iterations for post-initial solution refinement\n        self.no_improve_limit = 150      # iterations without improvement before stopping refinement\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        # Trees initialization\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start: List[Node] = [start_root]\n        tree_goal: List[Node] = [goal_root]\n\n        nodes: List[Node] = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        # Fast Euclidean distance function alias\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        # Sample function with goal bias\n        def sample():\n            if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        # Steer from from_pos toward to_pos by at most step_size\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        # Find nearest node in a tree\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        # Find nodes near a point within fixed radius\n        def near(tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n            rad_sq = radius*radius\n            return [n for n in tree if (n.position[0]-point[0])**2 + (n.position[1]-point[1])**2 + (0 if dim==2 else (n.position[2]-point[2])**2) <= rad_sq]\n\n        # Build path from joining two nodes from different trees (avoid double node)\n        def build_path(node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n            path1 = node_start.path_from_root()\n            path2 = node_goal.path_from_root()\n            path2.reverse()\n            return path1 + path2[1:]\n\n        # Local shortcut smoothing of path (simple random short-circuiting)\n        def shortcut_path(path: List[Tuple[float, ...]], max_attempts: int = 1000) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < max_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                p_start = new_path[i]\n                p_end = new_path[j]\n                if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d):\n                    # shortcut possible, replace intermediate points\n                    new_path = new_path[:i+1] + new_path[j:]\n                attempts += 1\n            return new_path\n\n        for itr in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (itr % 2 == 0)\n            tree_a = tree_start if expand_start else tree_goal\n            tree_b = tree_goal if expand_start else tree_start\n            sample_goal = goal_pos if expand_start else start_pos\n\n            q_rand = sample()\n            q_near = nearest(tree_a, q_rand)\n            q_new_pos = steer(q_near.position, q_rand)\n\n            if self._is_in_obstacle(q_new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(q_near.position, q_new_pos, obstacles, is_3d):\n                continue\n\n            neighbors = near(tree_a, q_new_pos, self.fixed_radius)\n            min_cost = q_near.cost + dist(q_near.position, q_new_pos)\n            best_parent = q_near\n\n            for nnode in neighbors:\n                c_cand = nnode.cost + dist(nnode.position, q_new_pos)\n                if c_cand + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(nnode.position, q_new_pos, obstacles, is_3d):\n                        min_cost = c_cand\n                        best_parent = nnode\n\n            q_new = Node(q_new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(q_new)\n            tree_a.append(q_new)\n            nodes.append(q_new)\n            edges.append((best_parent, q_new))\n\n            # Local rewiring - only neighbors of q_new\n            for nnode in neighbors:\n                if nnode is best_parent:\n                    continue\n                c_through_new = q_new.cost + dist(q_new.position, nnode.position)\n                if c_through_new + self.improve_tol < nnode.cost:\n                    if not self._is_edge_in_obstacle(q_new.position, nnode.position, obstacles, is_3d):\n                        if nnode.parent:\n                            try:\n                                edges.remove((nnode.parent, nnode))\n                            except ValueError:\n                                pass\n                            nnode.parent.remove_child(nnode)\n                        nnode.parent = q_new\n                        nnode.cost = c_through_new\n                        q_new.add_child(nnode)\n                        edges.append((q_new, nnode))\n\n            # Attempt connect to other tree within step size\n            q_new_near_other = nearest(tree_b, q_new.position)\n            d_connect = dist(q_new.position, q_new_near_other.position)\n            if d_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(q_new.position, q_new_near_other.position, obstacles, is_3d):\n                    # Connect trees by adding node to tree_b\n                    connect_node = Node(q_new.position, parent=q_new_near_other, cost=q_new_near_other.cost + d_connect)\n                    q_new_near_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((q_new_near_other, connect_node))\n\n                    # Build candidate path and cost\n                    if expand_start:\n                        candidate_path = build_path(q_new, connect_node)\n                        candidate_cost = q_new.cost + (connect_node.cost - q_new_near_other.cost)\n                    else:\n                        candidate_path = build_path(connect_node, q_new)\n                        candidate_cost = connect_node.cost + (q_new.cost - best_parent.cost)\n\n                    if candidate_cost + self.improve_tol < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n                        best_goal_node = connect_node if expand_start else q_new\n                        found_solution = True\n                        success_state = True\n                        # break early after first found path - balanced trees and fixed radius helps fast first solution\n                        break\n\n            if found_solution:\n                break\n\n        # If no solution found, return immediately\n        if not found_solution:\n            return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n        # Refinement phase - batch ellipsoidal informed sampling around best path to improve path quality\n        c_min = dist(start_pos, goal_pos)\n        c_best = best_cost\n\n        # Reset nodes and edges for refinement\n        # We'll maintain a single tree from start_root built along best_path\n        refinement_tree: List[Node] = [start_root]\n        start_root.children.clear()\n        start_root.cost = 0.0\n        nodes_refine: List[Node] = [start_root]\n        edges_refine: List[Tuple[Node, Node]] = []\n        prev_node = start_root\n        for pos in best_path[1:]:\n            cost_inc = dist(prev_node.position, pos)\n            new_node = Node(pos, parent=prev_node, cost=prev_node.cost + cost_inc)\n            prev_node.add_child(new_node)\n            refinement_tree.append(new_node)\n            nodes_refine.append(new_node)\n            edges_refine.append((prev_node, new_node))\n            prev_node = new_node\n        best_goal_node_refine = prev_node\n\n        no_improve_count = 0\n        for _ in range(self.batch_informed_iters):\n            if timed_out() or no_improve_count >= self.no_improve_limit:\n                break\n\n            sample_pt = self._ellipsoidal_informed_sample(c_best, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n            nearest_node = nearest(refinement_tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                no_improve_count += 1\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                no_improve_count += 1\n                continue\n\n            near_nodes = near(refinement_tree, new_pos, self.fixed_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nnode in near_nodes:\n                c_cand = nnode.cost + dist(nnode.position, new_pos)\n                if c_cand + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(nnode.position, new_pos, obstacles, is_3d):\n                        min_cost = c_cand\n                        best_parent = nnode\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            refinement_tree.append(new_node)\n            nodes_refine.append(new_node)\n            edges_refine.append((best_parent, new_node))\n\n            # Local rewiring (no recursive update)\n            for nnode in near_nodes:\n                if nnode is best_parent:\n                    continue\n                c_through_new = new_node.cost + dist(new_node.position, nnode.position)\n                if c_through_new + self.improve_tol < nnode.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nnode.position, obstacles, is_3d):\n                        if nnode.parent:\n                            try:\n                                edges_refine.remove((nnode.parent, nnode))\n                            except ValueError:\n                                pass\n                            nnode.parent.remove_child(nnode)\n                        nnode.parent = new_node\n                        nnode.cost = c_through_new\n                        new_node.add_child(nnode)\n                        edges_refine.append((new_node, nnode))\n\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    refinement_tree.append(goal_node)\n                    nodes_refine.append(goal_node)\n                    edges_refine.append((new_node, goal_node))\n                    if goal_node.cost + self.improve_tol < c_best:\n                        c_best = goal_node.cost\n                        best_goal_node_refine = goal_node\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n            else:\n                no_improve_count += 1\n\n        refined_path = best_goal_node_refine.path_from_root()\n        smoothed_path = shortcut_path(refined_path)\n\n        # Merge nodes & edges from refinement with original exploration sets\n        # Avoid duplicates: merge unique nodes and edges smoothly\n        # To maximize correctness, we return the refinement constructs only (plus roots) as final\n        # as this is a refinement phase\n\n        return PlannerResult(success=True, path=smoothed_path, nodes=nodes_refine, edges=edges_refine)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float('inf') or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        center = tuple((s+g)*0.5 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        r1 = c_best * 0.5\n        r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) * 0.5\n\n        while True:\n            # Sample uniformly on unit ball scaled by radii\n            unit_vec = [random.gauss(0, 1) for _ in range(dim)]\n            norm = math.sqrt(sum(x*x for x in unit_vec))\n            if norm < 1e-12:\n                continue\n            unit_vec = [x / norm for x in unit_vec]\n            radius_sample = random.random()**(1/dim)\n            point_ball = [radius_sample * x for x in unit_vec]\n\n            # Scale along ellipsoid axes\n            scaled_point = [r1 * point_ball[0]] + [r2 * point_ball[i] for i in range(1, dim)]\n\n            dir_a1 = [x / norm_a1 for x in a1]\n            point_ellipsoid = [center[i] + dir_a1[i] * scaled_point[0] for i in range(dim)]\n            for i in range(1, dim):\n                point_ellipsoid[i] += scaled_point[i]\n\n            pt = tuple(max(0.0, min(bounds[i], point_ellipsoid[i])) for i in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt",
        "objective": -1.30336,
        "time_improvement": -57.0,
        "length_improvement": 19.0,
        "smoothness_improvement": 1415.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.07969634532928467,
                "num_nodes_avg": 126.6,
                "path_length_avg": 164.59211520466957,
                "smoothness_avg": 0.0466929822427923,
                "success_improvement": 0.0,
                "time_improvement": -208.15175707068846,
                "length_improvement": 9.784453527353355,
                "smoothness_improvement": 630.8465675335299,
                "objective_score": -53.42062216712688
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.08926122188568116,
                "num_nodes_avg": 156.6,
                "path_length_avg": 230.74519409081557,
                "smoothness_avg": 0.09485063519652866,
                "success_improvement": 0.0,
                "time_improvement": 45.6801266689465,
                "length_improvement": 22.97061258032915,
                "smoothness_improvement": 2340.575161757774,
                "objective_score": 39.18928135767031
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.05235123634338379,
                "num_nodes_avg": 150.2,
                "path_length_avg": 115.69614454467587,
                "smoothness_avg": 0.10804272239445294,
                "success_improvement": 0.0,
                "time_improvement": -7.087068077151739,
                "length_improvement": 23.160129651801483,
                "smoothness_improvement": 1274.2954539732307,
                "objective_score": 18.141434637801524
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "A bidirectional RRT* planner with balanced tree growth, fixed radius local rewiring, efficient linear nearest-neighbor searches, goal biasing, early stopping upon first path found, and a focused refinement phase using ellipsoidal informed sampling and path shortcut smoothing. This design reduces planning time by avoiding costly recursive rewiring and radius computations, improves path quality by local rewiring and batch refinement, and enhances path smoothness by applying shortcutting techniques on the final path within a 30-second hard time limit.",
        "planning_mechanism": "A pair of trees grow alternately from start and goal states using goal-biased random sampling, connecting nodes with fixed-radius local rewiring and collision checking. Upon initial path connection, a single-tree refinement phase applies ellipsoidal informed sampling confined to the current best solution cost, performing local rewiring and attempting direct connections to the goal. Finally, a shortcut smoothing heuristic reduces unnecessary waypoints and sharp turns. The planner terminates early when time expires or when improvement stalls, returning the best found path coherently built from parent-child relationships.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.fixed_radius = 20.0\n        self.time_limit = 30.0\n        self.improve_tol = 1e-8\n        self.refinement_iters = 2000\n        self.no_improve_limit = 150\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        radius_sq = radius * radius\n        dim = len(point)\n        near_nodes = []\n        for node in tree:\n            # squared Euclidean distance (faster)\n            if dim == 2:\n                dx = node.position[0] - point[0]\n                dy = node.position[1] - point[1]\n                d_sq = dx*dx + dy*dy\n            else:\n                dx = node.position[0] - point[0]\n                dy = node.position[1] - point[1]\n                dz = node.position[2] - point[2]\n                d_sq = dx*dx + dy*dy + dz*dz\n            if d_sq <= radius_sq:\n                near_nodes.append(node)\n        return near_nodes\n\n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float('inf') or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        r1 = c_best * 0.5\n        try:\n            r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) * 0.5\n        except:\n            r2 = 0.0\n\n        while True:\n            # Uniform sample inside unit ball\n            vec = [random.gauss(0,1) for _ in range(dim)]\n            norm = math.sqrt(sum(x*x for x in vec))\n            if norm < 1e-12:\n                continue\n            vec = [x / norm for x in vec]\n            rad = random.random() ** (1.0/dim)\n            ball_point = [rad * x for x in vec]\n\n            # Scale for ellipsoid axes\n            scaled = [r1 * ball_point[0]] + [r2 * ball_point[i] for i in range(1, dim)]\n\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[i] + dir_a1[i] * scaled[0] for i in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n\n            pt = tuple(max(0.0, min(bounds[i], point[i])) for i in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _shortcut_path(self, path: List[Tuple[float, ...]], obstacles, is_3d, max_attempts=1000) -> List[Tuple[float, ...]]:\n        if len(path) < 3:\n            return path[:]\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            p_start = new_path[i]\n            p_end = new_path[j]\n            if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d):\n                new_path = new_path[:i+1] + new_path[j:]\n            attempts += 1\n        return new_path\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start: List[Node] = [start_root]\n        tree_goal: List[Node] = [goal_root]\n\n        nodes: List[Node] = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for it in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (it % 2 == 0)\n            tree_a = tree_start if expand_start else tree_goal\n            tree_b = tree_goal if expand_start else tree_start\n            sample_goal = goal_pos if expand_start else start_pos\n\n            q_rand = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n            q_near = self._nearest(tree_a, q_rand)\n            q_new_pos = self._steer(q_near.position, q_rand)\n\n            if self._is_in_obstacle(q_new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(q_near.position, q_new_pos, obstacles, is_3d):\n                continue\n\n            neighbors = self._near(tree_a, q_new_pos, self.fixed_radius)\n            min_cost = q_near.cost + self._dist(q_near.position, q_new_pos)\n            best_parent = q_near\n\n            for n in neighbors:\n                cost_cand = n.cost + self._dist(n.position, q_new_pos)\n                if cost_cand + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(n.position, q_new_pos, obstacles, is_3d):\n                        min_cost = cost_cand\n                        best_parent = n\n\n            q_new = Node(q_new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(q_new)\n            tree_a.append(q_new)\n            nodes.append(q_new)\n            edges.append((best_parent, q_new))\n\n            # Local rewiring\n            for n in neighbors:\n                if n is best_parent:\n                    continue\n                cost_through = q_new.cost + self._dist(q_new.position, n.position)\n                if cost_through + self.improve_tol < n.cost:\n                    if not self._is_edge_in_obstacle(q_new.position, n.position, obstacles, is_3d):\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.parent = q_new\n                        n.cost = cost_through\n                        q_new.add_child(n)\n                        edges.append((q_new, n))\n\n            # Attempt connect to other tree\n            q_new_near_other = self._nearest(tree_b, q_new.position)\n            d_connect = self._dist(q_new.position, q_new_near_other.position)\n            if d_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(q_new.position, q_new_near_other.position, obstacles, is_3d):\n                    connect_node = Node(q_new.position, parent=q_new_near_other, cost=q_new_near_other.cost + d_connect)\n                    q_new_near_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((q_new_near_other, connect_node))\n\n                    if expand_start:\n                        candidate_path = self._build_path(q_new, connect_node)\n                        candidate_cost = q_new.cost + (connect_node.cost - q_new_near_other.cost)\n                    else:\n                        candidate_path = self._build_path(connect_node, q_new)\n                        candidate_cost = connect_node.cost + (q_new.cost - best_parent.cost)\n\n                    if candidate_cost + self.improve_tol < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n                        best_goal_node = connect_node if expand_start else q_new\n                        found_solution = True\n                        success_state = True\n                        break\n\n            if found_solution:\n                break\n\n        if not found_solution:\n            return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n        # Refinement phase - build single tree from start along best path\n        c_min = self._dist(start_pos, goal_pos)\n        c_best = best_cost\n\n        refinement_tree: List[Node] = [start_root]\n        start_root.children.clear()\n        start_root.cost = 0.0\n\n        nodes_refine: List[Node] = [start_root]\n        edges_refine: List[Tuple[Node, Node]] = []\n\n        prev = start_root\n        for p in best_path[1:]:\n            cost_inc = self._dist(prev.position, p)\n            new_node = Node(p, parent=prev, cost=prev.cost + cost_inc)\n            prev.add_child(new_node)\n            refinement_tree.append(new_node)\n            nodes_refine.append(new_node)\n            edges_refine.append((prev, new_node))\n            prev = new_node\n        best_goal_node_refine = prev\n\n        no_improve_count = 0\n        for i in range(self.refinement_iters):\n            if timed_out() or no_improve_count >= self.no_improve_limit:\n                break\n\n            sample_pt = self._ellipsoidal_informed_sample(c_best, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n            nearest_node = self._nearest(refinement_tree, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                no_improve_count += 1\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                no_improve_count += 1\n                continue\n\n            neighbors = self._near(refinement_tree, new_pos, self.fixed_radius)\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for n in neighbors:\n                cost_cand = n.cost + self._dist(n.position, new_pos)\n                if cost_cand + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_cand\n                        best_parent = n\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            refinement_tree.append(new_node)\n            nodes_refine.append(new_node)\n            edges_refine.append((best_parent, new_node))\n\n            rewired = False\n            for n in neighbors:\n                if n is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, n.position)\n                if cost_through_new + self.improve_tol < n.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d):\n                        if n.parent:\n                            try:\n                                edges_refine.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = cost_through_new\n                        new_node.add_child(n)\n                        edges_refine.append((new_node, n))\n                        rewired = True\n\n            dist_to_goal = self._dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    refinement_tree.append(goal_node)\n                    nodes_refine.append(goal_node)\n                    edges_refine.append((new_node, goal_node))\n\n                    if goal_node.cost + self.improve_tol < c_best:\n                        c_best = goal_node.cost\n                        best_goal_node_refine = goal_node\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n            else:\n                no_improve_count += 1\n\n            if not rewired:\n                no_improve_count += 1\n\n        refined_path = best_goal_node_refine.path_from_root()\n        smoothed_path = self._shortcut_path(refined_path, obstacles, is_3d)\n\n        return PlannerResult(success=True, path=smoothed_path, nodes=nodes_refine, edges=edges_refine)",
        "objective": -12.93321,
        "time_improvement": -18.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1281.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.060326361656188966,
                "num_nodes_avg": 81.5,
                "path_length_avg": 157.59839036287062,
                "smoothness_avg": 0.04497476719257027,
                "success_improvement": 0.0,
                "time_improvement": -133.25629632361077,
                "length_improvement": 13.617824935805348,
                "smoothness_improvement": 603.9527708338542,
                "objective_score": -28.78643008143075
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.06139037609100342,
                "num_nodes_avg": 101.2,
                "path_length_avg": 225.39241807440686,
                "smoothness_avg": 0.08332413885134189,
                "success_improvement": 0.0,
                "time_improvement": 62.640916373743025,
                "length_improvement": 24.757523285721305,
                "smoothness_improvement": 2043.9901085963784,
                "objective_score": 43.86673942653758
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.04016015529632568,
                "num_nodes_avg": 88.0,
                "path_length_avg": 119.4677829967754,
                "smoothness_avg": 0.10174742196095421,
                "success_improvement": 0.0,
                "time_improvement": 17.850396961061772,
                "length_improvement": 20.65518697804024,
                "smoothness_improvement": 1194.2196971298695,
                "objective_score": 23.71932976079202
            }
        ],
        "success_rate": 1.0
    }
]