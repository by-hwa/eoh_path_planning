[
    {
        "operator": "m3",
        "algorithm_description": "This algorithm is an enhanced bidirectional RRT* with path post-processing for smoothing. It combines two trees grown from start and goal with cost-aware rewiring and adds an efficient path shortcutting step after a solution is found to reduce zigzag and improve curvature, resulting in faster convergence, shorter, and smoother paths.",
        "planning_mechanism": "The planner grows two optimized trees from start and goal in bidirectional RRT* style, rewires nodes locally to minimize cost, and when a connecting path is found, performs path shortcut smoothing by attempting to connect non-adjacent waypoints directly while ensuring collision-free edges, yielding smoother and shorter solutions efficiently.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma_rrt_star=50.0, max_radius=60.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, parent=None, cost=0.0)\n        goal_root = Node(goal_pos, parent=None, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(len(from_p)))\n\n        def near_nodes(tree, position):\n            n = max(1, len(tree))\n            d = len(position)\n            scale = max(1.0, sum(bounds) / d)\n            r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n            radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def is_collision_free(from_p, to_p):\n            if self._is_in_obstacle(to_p, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d):\n                return False\n            return True\n\n        def choose_parent(tree, new_pos):\n            nearest_node = nearest(tree, new_pos)\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                if is_collision_free(nb.position, new_pos):\n                    cost_cand = nb.cost + dist(nb.position, new_pos)\n                    if cost_cand < min_cost:\n                        min_cost = cost_cand\n                        best_parent = nb\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire_from(pivot, neighbors):\n            for nb in neighbors:\n                if is_collision_free(pivot.position, nb.position):\n                    new_cost = pivot.cost + dist(pivot.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        pivot.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((pivot, nb))\n\n        def extend_and_rewire(tree, sample_p):\n            nearest_node = nearest(tree, sample_p)\n            new_pos = steer(nearest_node.position, sample_p)\n            if not is_collision_free(nearest_node.position, new_pos):\n                return None\n            new_node, neighbors = choose_parent(tree, new_pos)\n            rewire_from(new_node, neighbors)\n            return new_node\n\n        def connect_and_rewire(tree, target_node):\n            nearest_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(nearest_node.position, target_node.position)\n                if not is_collision_free(nearest_node.position, new_pos):\n                    return None\n                connect_node, neighbors = choose_parent(tree, new_pos)\n                rewire_from(connect_node, neighbors)\n                if dist(connect_node.position, target_node.position) <= self.step_size:\n                    if is_collision_free(connect_node.position, target_node.position) and not self._is_in_obstacle(target_node.position, obstacles, is_3d):\n                        final_node = Node(target_node.position, parent=None, cost=connect_node.cost + dist(connect_node.position, target_node.position))\n                        connect_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((connect_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = connect_node\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            import random\n            smoothed = path[:]\n            for _ in range(200):\n                if len(smoothed) <= 2:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) -1)\n                p_i = smoothed[i]\n                p_j = smoothed[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    # shortcut possible, remove intermediate nodes\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        success = False\n        path = []\n        for _ in range(self.max_iter):\n            rand_p = sample_free()\n            new_a = extend_and_rewire(tree_a, rand_p)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = connect_and_rewire(tree_b, new_a)\n            if new_b:\n                success = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                # Remove duplicate connection node\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                raw_path = path_a + path_b[::-1]\n                path = shortcut_path(raw_path)\n                break\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -23.33681,
        "time_improvement": 20.0,
        "length_improvement": 16.0,
        "smoothness_improvement": 1517.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.024225378036499025,
                "num_nodes_avg": 70.4,
                "path_length_avg": 165.27293783448243,
                "smoothness_avg": 0.04876837243675059,
                "success_improvement": 0.0,
                "time_improvement": 3.7953134482957775,
                "node_improvement": 82.27146814404432,
                "length_improvement": 9.411283855627978,
                "smoothness_improvement": 663.3309308509168,
                "objective_score": 10.102019002120105
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.044183778762817386,
                "num_nodes_avg": 245.6,
                "path_length_avg": 239.05510817474592,
                "smoothness_avg": 0.10604751432289401,
                "success_improvement": 0.0,
                "time_improvement": 72.73660116170906,
                "node_improvement": 83.49795068198617,
                "length_improvement": 20.19652407149841,
                "smoothness_improvement": 2628.6789264652084,
                "objective_score": 47.082289423737805
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.05563676357269287,
                "num_nodes_avg": 268.0,
                "path_length_avg": 121.72798255614921,
                "smoothness_avg": 0.10677056044821978,
                "success_improvement": 0.0,
                "time_improvement": -16.52295880407895,
                "node_improvement": 65.92498410680228,
                "length_improvement": 19.15407004984152,
                "smoothness_improvement": 1258.1136479183722,
                "objective_score": 12.826122628273087
            }
        ],
        "success_rate": 1.0
    }
]