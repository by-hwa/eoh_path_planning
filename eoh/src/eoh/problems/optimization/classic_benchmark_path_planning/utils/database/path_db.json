[
    {
        "operator": "e2",
        "algorithm_description": "A hybrid bidirectional RRT*-InformedConnect planner with dynamic informed sampling, priority rewiring, and early post-optimization termination to improve planning efficiency, path smoothness and length, and success rate under hard time constraints.",
        "planning_mechanism": "This planner grows two RRT* trees from start and goal alternately, using uniform sampling initially and ellipsoidal informed sampling after the first path found. It employs best-parent selection and incremental rewiring within a dynamically adapted neighborhood radius. After connecting the trees greedily with stepwise attempts, it continuously updates the best path and applies shortcutting smoothing before termination at a time limit or post-optimization stagnation threshold.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 8000,\n        step_size: float = 5.0,\n        goal_sample_rate: float = 0.15,\n        post_opt_iters: int = 400,\n        max_no_improve: int = 120,\n        improve_tol: float = 1e-6,\n        time_limit_sec: float = 30.0,\n        gamma_rrt_star: float = 50.0\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n            if dim == 2:\n                # Construct orthonormal basis {a1, a2}\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                # For 3D, build orthonormal basis {a1, b2, b3}\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm = math.sqrt(sum(x * x for x in v))\n                    if norm > 1e-12:\n                        v = [x / norm for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            # Candidate parents with collision-free edges\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                # fallback to nearest if no neighbors valid\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def can_connect(n1, n2):\n            return (not is_edge_in_obstacle(n1.position, n2.position)) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            sample = None\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_current = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_current.position, sample)\n\n            if (not within_bounds(new_pos)) or is_in_obstacle(new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node_current.position, new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            current = nearest_other\n            connected_other = None\n            tries = 0\n            max_greedy_steps = 20\n\n            while True:\n                tries += 1\n                if tries > max_greedy_steps:\n                    break\n                step_pos = steer(current.position, new_node.position)\n                if (not within_bounds(step_pos)) or is_in_obstacle(step_pos):\n                    break\n                if is_edge_in_obstacle(current.position, step_pos):\n                    break\n                other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                if other_new is None:\n                    break\n                rewire(other_tree, other_new, other_neighbors, edges)\n                current = other_new\n\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if can_connect(current, new_node):\n                        final_node = Node(new_node.position, parent=None, cost=current.cost + dist(current.position, new_node.position))\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                    break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i+1])\n\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                if found_first:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
        "objective": 70.02349,
        "time_improvement": -295.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1330.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.18990304470062255,
                "num_nodes_avg": 574.6,
                "path_length_avg": 151.92005163885307,
                "smoothness_avg": 0.0438427966152012,
                "success_improvement": 0.0,
                "time_improvement": -655.754757440736,
                "length_improvement": 16.73021236947447,
                "smoothness_improvement": 586.234973184576,
                "objective_score": -183.7571249446132
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.06414504051208496,
                "num_nodes_avg": 382.5,
                "path_length_avg": 235.82771215538,
                "smoothness_avg": 0.09195275777999899,
                "success_improvement": 0.0,
                "time_improvement": 60.0911139159804,
                "length_improvement": 21.273921758206445,
                "smoothness_improvement": 2266.01068857373,
                "objective_score": 42.12174067258664
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.18937287330627442,
                "num_nodes_avg": 510.0,
                "path_length_avg": 118.45844668308948,
                "smoothness_avg": 0.09740963788912176,
                "success_improvement": 0.0,
                "time_improvement": -289.7520523276069,
                "length_improvement": 21.32554009816004,
                "smoothness_improvement": 1139.043403918075,
                "objective_score": -68.43507461979567
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "A dual-tree bidirectional RRT* planner with adaptive fixed-radius rewiring, informed elliptical sampling after initial solution, goal bias sampling, and incremental cost propagation. It leverages efficient local neighbor searches, consistent cost updates with downstream propagation, and path shortcutting smoothing to deliver improved path length, smoothness, and reduced planning time under strict time limits.",
        "planning_mechanism": "Grows two RRT* trees from start and goal alternately, initially sampling uniformly and switching to informed elliptical sampling after the first found path. Nodes connect via collision-free edges with best-parent selection from neighbors within a fixed rewiring radius. The algorithm rewires neighbors to optimize path cost and propagates cost changes downstream. Frequent attempts connect the two trees to update the best path. With goal bias and early termination on post-optimization convergence or time expiration, the method balances exploration and exploitation to efficiently find short, smooth paths.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 10000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.05,\n                 post_opt_iters: int = 300,\n                 max_no_improve: int = 100,\n                 improve_tol: float = 1e-6,\n                 time_limit_sec: float = 30.0,\n                 gamma_rrt_star: float = 40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    # fallback: return start to avoid infinite loop in crowded maps\n                    return start_pos\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                # 3D case\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm_ = math.sqrt(sum(x * x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x / norm_ for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            min_node = None\n            min_d = float('inf')\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ < min_d:\n                    min_d = d_\n                    min_node = n\n            return min_node\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            result = []\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ <= radius:\n                    result.append(n)\n            return result\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            return not is_edge_in_obstacle(n1.position, n2.position) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            # Remove duplicated connection point if any\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    # Check if direct path is free\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if (time.monotonic() - start_time) > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            sample = None\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_curr = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_curr.position, sample)\n\n            if not within_bounds(new_pos):\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_in_obstacle(new_pos):\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node_curr.position, new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            connected_other = None\n            # Try to connect greedy in one step if possible\n            if dist(nearest_other.position, new_node.position) <= self.step_size and can_connect(nearest_other, new_node):\n                # Connect directly\n                final_node = Node(new_node.position, parent=None, cost=nearest_other.cost + dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_other = final_node\n            else:\n                # incremental connection attempts\n                current = nearest_other\n                tries = 0\n                max_greedy_steps = 20\n                while tries < max_greedy_steps:\n                    tries += 1\n                    step_pos = steer(current.position, new_node.position)\n                    if not within_bounds(step_pos) or is_in_obstacle(step_pos):\n                        break\n                    if is_edge_in_obstacle(current.position, step_pos):\n                        break\n                    other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                    if other_new is None:\n                        break\n                    rewire(other_tree, other_new, other_neighbors, edges)\n                    current = other_new\n                    if dist(current.position, new_node.position) <= self.step_size:\n                        if can_connect(current, new_node):\n                            final_node = Node(new_node.position, parent=None, cost=current.cost + dist(current.position, new_node.position))\n                            current.add_child(final_node)\n                            other_tree.append(final_node)\n                            nodes.append(final_node)\n                            edges.append((current, final_node))\n                            connected_other = final_node\n                        break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i + 1])\n\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                if found_first:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            return PlannerResult(\n                success=True,\n                path=best_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
        "objective": -13.97956,
        "time_improvement": -17.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1470.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.052588915824890135,
                "num_nodes_avg": 232.6,
                "path_length_avg": 153.88454915168901,
                "smoothness_avg": 0.04347023177026047,
                "success_improvement": 0.0,
                "time_improvement": -109.28744658079108,
                "length_improvement": 15.653440153233934,
                "smoothness_improvement": 580.4035243237437,
                "objective_score": -20.492152260678246
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.048712754249572755,
                "num_nodes_avg": 358.8,
                "path_length_avg": 233.0599917365158,
                "smoothness_avg": 0.10226409696877743,
                "success_improvement": 0.0,
                "time_improvement": 69.69256321821518,
                "length_improvement": 22.197866498438458,
                "smoothness_improvement": 2531.328872858417,
                "objective_score": 46.883133228819716
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.054259729385375974,
                "num_nodes_avg": 387.5,
                "path_length_avg": 119.05752821578226,
                "smoothness_avg": 0.10995381497824393,
                "success_improvement": 0.0,
                "time_improvement": -11.673021153817839,
                "length_improvement": 20.927658669342527,
                "smoothness_improvement": 1298.6044105768708,
                "objective_score": 15.547710908344518
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "A bidirectional RRT* planner integrating dynamic informed sampling, adaptive neighbor radius for rewiring, early goal-biased sampling, and incremental path shortcutting to minimize planning time and path length while improving smoothness. The planner alternates tree expansions from start and goal, uses ellipsoidal heuristic sampling after the first solution to focus search near optimum, and applies a fast shortcutting post-processing upon termination or timeout. Adaptive rewiring radius and thorough rewiring ensure quality paths with reduced unnecessary collision checks. Early stopping with best-path tracking guarantees efficient anytime performance under a strict 30-second limit.",
        "planning_mechanism": "The planner grows two RRT* trees bidirectionally with goal bias and uniform sampling initially, switching to ellipsoidal informed sampling after the first path is found to focus search. It uses an adaptive neighbor radius for rewiring to optimize local connections incrementally. After each expansion, it attempts greedy connections between the trees to find better solutions. The process is time-limited and interrupts as soon as a good path is found, followed by shortcut smoothing of the path to reduce jaggedness. The combination of adaptive radius, heuristic sampling, and path shortcutting reduces planning time and improves final path length and smoothness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision marking\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=8000, step_size=5.0, goal_sample_rate=0.15, post_opt_iters=400,\n                 max_no_improve=120, improve_tol=1e-6, time_limit_sec=30.0, gamma_rrt_star=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map):\n        import time, random, math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def informed_sample(start, goal, c_best, c_min):\n            # Ellipsoidal informed sampling around the line connecting start and goal\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n            if dim == 2:\n                # Construct orthonormal basis {a1, a2}\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                # For 3D, build orthonormal basis {a1, b2, b3}\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                def normalize(v):\n                    n = norm(v)\n                    if n < 1e-12:\n                        return v\n                    return tuple(x / n for x in v)\n                b2 = normalize(cross(a1, ref))\n                if norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = normalize(cross(a1, ref))\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(dim_)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def nearest(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            # Candidate parents with collision-free edge\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                # fallback to nearest if no neighbors valid\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos)\n            best_parent.add_child(new_node)\n            new_node.cost = new_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + self.improve_tol < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def can_connect(n1, n2):\n            if not n1.valid or not n2.valid:\n                return False\n            if is_edge_in_obstacle(n1.position, n2.position):\n                return False\n            return True\n\n        def stitch_path(n_start, n_goal, forward_start=True):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                merged = path_start + path_goal[-2::-1]\n            else:\n                merged = path_start + path_goal[::-1]\n            return merged if forward_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) -1\n                while j > i+1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        first_solution_found = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            forward_expand = (it % 2 == 0)\n            curr_tree = tree_start if forward_expand else tree_goal\n            other_tree = tree_goal if forward_expand else tree_start\n\n            if first_solution_found:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if forward_expand else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if forward_expand else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            # Try to connect newly added node with nearest in other tree greedily up to step_size*4 steps\n            nearest_other = nearest(other_tree, new_node.position)\n            current = nearest_other\n            connected_other = None\n            max_greedy = 20\n            steps_taken = 0\n            while steps_taken < max_greedy:\n                steps_taken += 1\n                step_pt = steer(current.position, new_node.position)\n                if not within_bounds(step_pt) or is_in_obstacle(step_pt) or is_edge_in_obstacle(current.position, step_pt):\n                    break\n                other_new, other_neighbors = add_node_rrt_star(other_tree, step_pt, nodes, edges)\n                if other_new is None:\n                    break\n                rewire(other_tree, other_new, other_neighbors, edges)\n                current = other_new\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if can_connect(current, new_node):\n                        final_node = Node(new_node.position)\n                        final_node.cost = current.cost + dist(current.position, new_node.position)\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                    break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, forward_expand)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += dist(candidate_path[i], candidate_path[i + 1])\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    first_solution_found = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    if first_solution_found:\n                        post_no_improve += 1\n                if first_solution_found:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": 44.20259,
        "time_improvement": -210.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1438.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.15432941913604736,
                "num_nodes_avg": 476.4,
                "path_length_avg": 153.09921531325637,
                "smoothness_avg": 0.04706276199143273,
                "success_improvement": 0.0,
                "time_improvement": -514.1828474051357,
                "length_improvement": 16.08389407448989,
                "smoothness_improvement": 636.634423589329,
                "objective_score": -141.42134565890012
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.06530447006225586,
                "num_nodes_avg": 391.7,
                "path_length_avg": 233.4809007688147,
                "smoothness_avg": 0.0966391206414232,
                "success_improvement": 0.0,
                "time_improvement": 59.369755858197294,
                "length_improvement": 22.057354948262333,
                "smoothness_improvement": 2386.594180448907,
                "objective_score": 42.97831062866112
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.13431777954101562,
                "num_nodes_avg": 430.3,
                "path_length_avg": 119.64756150983757,
                "smoothness_avg": 0.10922111748703889,
                "success_improvement": 0.0,
                "time_improvement": -176.44207602812656,
                "length_improvement": 20.535786649797195,
                "smoothness_improvement": 1289.284552570846,
                "objective_score": -34.16472805570542
            }
        ],
        "success_rate": 1.0
    }
]