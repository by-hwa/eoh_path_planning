[
    {
        "operator": "e2",
        "algorithm_description": "This hybrid algorithm combines the bidirectional search efficiency of the first dual-tree RRT with the path quality and rewiring optimization of the second algorithm\u2019s RRT*-style rewiring. It grows two trees simultaneously from start and goal, incorporating goal bias sampling for faster convergence and rewiring in each tree for improved path cost. The algorithm alternates growth between the two trees and attempts to connect them via incremental steer steps, ensuring collision-free edges. The Node class includes an `update_parent` method to support clean rewiring, promoting robustness and path smoothness.",
        "planning_mechanism": "The planner samples random points with goal bias, extends one tree towards the sample, rewires neighbors to optimize cost, then attempts to connect the other tree via a rewiring-enhanced incremental connection procedure. If connection succeeds, paths from both trees are combined into the final path. This bidirectional rewiring hybrid efficiently balances quick exploration, path optimality, and robustness while reducing redundant or complex connection logic.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from old parent\n        if self.parent:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        # Alternate between start_tree and goal_tree\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Extend and rewire tree_a toward sample\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                # Swap trees and continue next iteration\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Try to connect tree_b to new_node_a using incremental connection and rewiring\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                # Connection succeeded, extract path from both trees\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            # Swap trees for next iteration\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        # Find best parent to minimize cost\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors if new_node offers cheaper cost path\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                # Rewire neighbor to new_node\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            # Find best parent with minimum cost\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost possible through new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -16.50088,
        "time_improvement": 36.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 331.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.013587737083435058,
                "num_nodes_avg": 84.7,
                "path_length_avg": 148.70296472171577,
                "smoothness_avg": 0.023905809137381114,
                "success_improvement": 0.0,
                "time_improvement": 45.481061276420704,
                "length_improvement": 18.49354868676186,
                "smoothness_improvement": 274.1778252954413,
                "objective_score": 18.713917246755788
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.0670863151550293,
                "num_nodes_avg": 374.6,
                "path_length_avg": 238.30235227754707,
                "smoothness_avg": 0.019222022900071807,
                "success_improvement": 0.0,
                "time_improvement": 58.490856066975105,
                "length_improvement": 20.447815656860534,
                "smoothness_improvement": 394.59649428232086,
                "objective_score": 23.609802422876243
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.04745805263519287,
                "num_nodes_avg": 282.7,
                "path_length_avg": 119.32520386391828,
                "smoothness_avg": 0.03341984071111011,
                "success_improvement": 0.0,
                "time_improvement": 4.678227031831315,
                "length_improvement": 20.749881249195226,
                "smoothness_improvement": 325.0979070492782,
                "objective_score": 7.178933894634831
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid planner integrates bidirectional RRT* with incremental rewiring, adaptive neighbor radius, and goal-biased sampling to efficiently explore the space. It grows two trees simultaneously from start and goal, alternating expansion and performing rewiring for path cost optimization. A time limit ensures prompt termination, returning the best path found so far. Path smoothing via shortcutting improves path quality and smoothness post planning. The Node class manages parent-child relationships and supports clean rewiring.",
        "planning_mechanism": "The planner alternates growth between two trees, samples points with goal bias, extends and rewires each tree toward samples using an adaptive neighbor radius, and incrementally attempts connection between trees with rewiring. Collision and bounds checks ensure safety. Upon successful connection or time expiration, the best path is extracted and smoothed by shortcutting unnecessary waypoints to deliver a robust, smooth, and cost-efficient solution.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node']=None, cost: float=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=3.0,\n                 goal_sample_rate: float=0.1, neighbor_radius_min: float=10.0,\n                 neighbor_radius_max: float=30.0, time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        tree_a, tree_b = start_tree, goal_tree\n        start_time = time.time()\n        best_connection_nodes: Optional[Tuple[Node, Node]] = None\n        best_cost = math.inf\n\n        for _ in range(self.max_iter):\n            if (time.time() - start_time) > self.time_limit_sec:\n                # Time limit reached: return best found path if any\n                if best_connection_nodes is not None:\n                    node_a, node_b = best_connection_nodes\n                    path_a = node_a.path_from_root()\n                    path_b = node_b.path_from_root()\n                    combined_path = path_a + path_b[::-1]\n                    smoothed_path = self._path_smoothing(combined_path, obstacles, is_3d)\n                    extracted_path = smoothed_path\n                    success_state = True\n                break\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection_nodes = (new_node_a, new_node_b)\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    combined_path = path_a + path_b[::-1]\n                    extracted_path = self._path_smoothing(combined_path, obstacles, is_3d)\n                    success_state = True\n                    # Early termination can be left off for more improvement, here break for efficiency\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If not success but have best path found within iterations\n        if not success_state and best_connection_nodes is not None:\n            node_a, node_b = best_connection_nodes\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined_path = path_a + path_b[::-1]\n            extracted_path = self._path_smoothing(combined_path, obstacles, is_3d)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _adaptive_neighbor_radius(self, n_nodes: int, dim: int) -> float:\n        if n_nodes <= 1:\n            return self.neighbor_radius_max\n        gamma_rrt_star = 50.0\n        radius = gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1/dim)\n        radius = max(self.neighbor_radius_min, min(radius, self.neighbor_radius_max))\n        return radius\n\n    def _sample_free(self, bounds: Tuple[int, ...], obstacles, is_3d: bool) -> Tuple[float, ...]:\n        dims = len(bounds)\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(dims))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self,\n                          tree: List[Node],\n                          sample: Tuple[float, ...],\n                          obstacles,\n                          is_3d: bool,\n                          nodes: List[Node],\n                          edges: List[Tuple[Node, Node]],\n                          bounds: Tuple[int, ...]) -> Optional[Node]:\n        dims = len(bounds)\n        nearest = self._nearest(tree, sample)\n        new_pos = self._steer(nearest.position, sample)\n\n        if not self._in_bounds(new_pos, bounds):\n            return None\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        n_nodes = len(tree)\n        radius = self._adaptive_neighbor_radius(n_nodes, dims)\n        neighbors = self._near_nodes(tree, new_pos, radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self,\n                                       tree: List[Node],\n                                       target_pos: Tuple[float, ...],\n                                       obstacles,\n                                       is_3d: bool,\n                                       nodes: List[Node],\n                                       edges: List[Tuple[Node, Node]],\n                                       bounds: Tuple[int, ...]) -> Optional[Node]:\n        dims = len(bounds)\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        dist_total = math.dist(curr_node.position, target_pos)\n        max_steps = int(dist_total / self.step_size) + 2\n\n        for _ in range(max_steps):\n            new_pos = self._steer(curr_node.position, target_pos)\n\n            if not self._in_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            n_nodes = len(tree)\n            radius = self._adaptive_neighbor_radius(n_nodes, dims)\n            neighbors = self._near_nodes(tree, new_pos, radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n            curr_node = new_node\n\n        return None\n\n    def _path_smoothing(self,\n                        path: List[Tuple[float, ...]],\n                        obstacles,\n                        is_3d: bool,\n                        max_iterations: int=100) -> List[Tuple[float, ...]]:\n        if len(path) < 3:\n            return path[:]\n\n        length = len(path)\n        for _ in range(max_iterations):\n            if length <= 2:\n                break\n            i = random.randint(0, length - 3)\n            j = random.randint(i + 2, length - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                path = path[:i + 1] + path[j:]\n                length = len(path)\n        return path\n\n    def _in_bounds(self, pos: Tuple[float, ...], bounds: Tuple[int, ...]) -> bool:\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -15.71302,
        "time_improvement": 15.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1444.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.029410433769226075,
                "num_nodes_avg": 93.7,
                "path_length_avg": 151.35150865706538,
                "smoothness_avg": 0.03576982037913053,
                "success_improvement": 0.0,
                "time_improvement": -24.04138054474865,
                "length_improvement": 17.04183978693237,
                "smoothness_improvement": 459.8753643415842,
                "objective_score": -1.5046693843302004
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.08552870750427247,
                "num_nodes_avg": 391.9,
                "path_length_avg": 234.64078700173286,
                "smoothness_avg": 0.10682658825679274,
                "success_improvement": 0.0,
                "time_improvement": 64.34135357837532,
                "length_improvement": 21.670151538240148,
                "smoothness_improvement": 2648.7250599286954,
                "objective_score": 36.880061680804104
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.09911580085754394,
                "num_nodes_avg": 413.0,
                "path_length_avg": 119.99349451886602,
                "smoothness_avg": 0.10399153638493046,
                "success_improvement": 0.0,
                "time_improvement": 5.295432230668823,
                "length_improvement": 20.30603441676022,
                "smoothness_improvement": 1222.7646669595508,
                "objective_score": 11.763659887350446
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This implementation is a unidirectional RRT* planner enhanced with informed sampling and dynamic rewiring for faster convergence, better path quality, and robustness. It incorporates strict obstacle and edge collision checking, clamps nodes within map bounds, and respects a maximum execution time limit to ensure timely completion. The planner maintains a single tree from start to goal and incrementally improves path optimality via neighborhood rewiring and goal biasing with informed sampling to efficiently explore relevant regions.",
        "planning_mechanism": "The planner repeatedly samples points biased toward an ellipsoidal informed set once a solution is found, steers from the nearest node towards the sample with step size limits, and adds collision-free nodes. It rewires neighbors locally to optimize path costs dynamically. The search halts upon reaching the goal region or exhausting max iterations or time, returning the best path found, if any.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node']=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List['Node'] = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1,\n                 neighbor_radius: float = 20.0, max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_time = time.perf_counter()\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        goal_node: Optional[Node] = None\n        best_goal_cost = math.inf\n\n        # Precompute goal region radius as step_size for success criterion\n        goal_radius = self.step_size\n\n        # For informed sampling: initialize ellipsoid parameters only after first solution\n        informed_sampling_enabled = False\n        c_min = math.dist(start_position, goal_position)\n\n        while True:\n            iter_count = 0\n            while iter_count < self.max_iter:\n                # Enforce max time limit\n                if time.perf_counter() - start_time > self.max_time_sec:\n                    # Time limit reached, return best found path if any\n                    if goal_node:\n                        path = goal_node.path_from_root()\n                        return PlannerResult(success=False, path=path, nodes=nodes, edges=edges)\n                    else:\n                        return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n                iter_count += 1\n\n                sample = None\n                if informed_sampling_enabled:\n                    sample = self._informed_sample(bounds, obstacles, is_3d, start_position, goal_position, c_min)\n                else:\n                    # Goal bias sampling\n                    if random.random() < self.goal_sample_rate:\n                        sample = goal_position\n                    else:\n                        sample = self._sample_free(bounds, obstacles, is_3d)\n\n                nearest = self._nearest(nodes, sample)\n                new_pos = self._steer(nearest.position, sample)\n                new_pos = self._clamp_to_bounds(new_pos, bounds)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                neighbors = self._near_nodes(nodes, new_pos, self.neighbor_radius)\n\n                # Select best parent\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                best_parent = nearest\n                for neighbor in neighbors:\n                    tentative_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n                # Check if new node is within goal region\n                dist_to_goal = math.dist(new_node.position, goal_position)\n                if dist_to_goal <= goal_radius and not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d):\n                    # Create goal node and connect\n                    candidate_goal = Node(goal_position)\n                    candidate_goal.parent = new_node\n                    candidate_goal.cost = new_node.cost + dist_to_goal\n                    new_node.children.append(candidate_goal)\n\n                    nodes.append(candidate_goal)\n                    edges.append((new_node, candidate_goal))\n\n                    if candidate_goal.cost < best_goal_cost:\n                        best_goal_cost = candidate_goal.cost\n                        goal_node = candidate_goal\n                        # Enable informed sampling now that a solution exists\n                        informed_sampling_enabled = True\n                        c_min = best_goal_cost\n\n                # Early stopping if path found and cost within threshold\n                if goal_node and best_goal_cost <= c_min + 1e-6:\n                    break\n\n            # Break from outer while after max_iter or early stopping\n            break\n\n        success_state = bool(goal_node)\n        extracted_path = goal_node.path_from_root() if goal_node else []\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(max(0.0, min(bounds[d], random.uniform(0, bounds[d]))) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_best):\n        # Sample uniformly inside an ellipsoid defined by start, goal, and c_best (current best path cost)\n        # If c_best == inf, fallback to uniform random sampling\n\n        if c_best == math.inf or c_best < math.dist(start, goal) - 1e-8:\n            # Fallback\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        # Ellipsoid parameters\n        c_min = math.dist(start, goal)\n        if c_min < 1e-10:\n            return goal  # start == goal\n\n        # Define coordinate system centered at center between start and goal\n        center = tuple((start[d] + goal[d]) * 0.5 for d in range(len(start)))\n\n        # Unit vector from start to goal\n        direction = tuple((goal[d] - start[d]) / c_min for d in range(len(start)))\n\n        # Build rotation matrix from unit vector to canonical axis (x-axis)\n        # For 2D or 3D, perform a simple orthonormal basis construction\n        def rotation_matrix(direction):\n            if len(direction) == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a],\n                        [sin_a, cos_a]]\n            else:\n                # For 3D: use Rodrigues' rotation formula to rotate direction to x-axis\n                vx, vy, vz = direction\n                # Cross product vector between direction and x-axis unit vector\n                k = (-0.0, -vy, -vz)\n                k_norm = math.sqrt(k[0]**2 + k[1]**2 + k[2]**2)\n                if k_norm < 1e-10:\n                    # direction already aligned with x-axis\n                    return [[1,0,0],\n                            [0,1,0],\n                            [0,0,1]]\n                k = tuple(ki / k_norm for ki in k)\n                # Rodrigues rotation matrix about k by angle theta\n                cos_theta = vx\n                sin_theta = k_norm\n                Kx, Ky, Kz = k\n                K = [[0, -Kz, Ky],\n                     [Kz, 0, -Kx],\n                     [-Ky, Kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_sub(A,B):\n                    return [[A[i][j]-B[i][j] for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                return R\n\n        R = rotation_matrix(direction)\n\n        # Radii of ellipsoid axes\n        a1 = c_best * 0.5\n        # For other axes, use sqrt(c_best^2 - c_min^2)/2 or small to avoid collapse\n        if len(start) == 2:\n            a2 = math.sqrt(max(c_best**2 - c_min**2, 0.0)) * 0.5\n            radii = [a1, a2]\n        else:\n            # 3D: a2 and a3 equal radius for minor axes\n            a_minor = math.sqrt(max(c_best**2 - c_min**2, 0.0)) * 0.5\n            radii = [a1, a_minor, a_minor]\n\n        # Sample uniformly inside unit n-ball and scale\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    if norm > 1e-10:\n                        return tuple(x / norm for x in pt)\n                    else:\n                        return tuple(0.0 for _ in range(n))\n\n        while True:\n            # Sample direction uniformly on unit hypersphere and radius^(1/n) uniformly [0,1]\n            n = len(start)\n            direction_sample = unit_ball_sample(n)\n            radius_sample = random.uniform(0,1) ** (1.0/n)\n            sample_unit = tuple(radius_sample * d for d in direction_sample)\n\n            # Scale by ellipsoid radii\n            sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n            # Rotate by R if not identity (handle both 2D and 3D)\n            if n == 2:\n                x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                sample_rot = (x_rot, y_rot)\n            else:\n                # 3D rotation matrix multiply\n                x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                sample_rot = (x_rot, y_rot, z_rot)\n\n            sample_point = tuple(center[d] + sample_rot[d] for d in range(n))\n\n            # Clamp sample to bounds\n            sample_point = self._clamp_to_bounds(sample_point, bounds)\n\n            if not self._is_in_obstacle(sample_point, obstacles, is_3d):\n                return sample_point\n\n    def _nearest(self, nodes: List[Node], point: Tuple[float, ...]) -> Node:\n        return min(nodes, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, nodes: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in nodes if math.dist(node.position, position) <= radius]\n\n    def _clamp_to_bounds(self, pos: Tuple[float, ...], bounds: Tuple[int, ...]) -> Tuple[float, ...]:\n        return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(len(pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 61.62327,
        "time_improvement": -226.0,
        "length_improvement": 21.0,
        "smoothness_improvement": 412.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.13001458644866942,
                "num_nodes_avg": 274.8,
                "path_length_avg": 156.46987804680248,
                "smoothness_avg": 0.026606937359578836,
                "success_improvement": 0.0,
                "time_improvement": -448.34923281282516,
                "length_improvement": 14.236380418664291,
                "smoothness_improvement": 316.4563475666523,
                "objective_score": -130.07521202228145
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.45788438320159913,
                "num_nodes_avg": 942.2,
                "path_length_avg": 224.00162273237294,
                "smoothness_avg": 0.021616616263944684,
                "success_improvement": 0.0,
                "time_improvement": -90.90125174350273,
                "length_improvement": 25.221810802716526,
                "smoothness_improvement": 456.2111062906548,
                "objective_score": -19.94495783105424
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.2511225938796997,
                "num_nodes_avg": 608.1,
                "path_length_avg": 114.3334964647458,
                "smoothness_avg": 0.04435870758829401,
                "success_improvement": 0.0,
                "time_improvement": -139.94616907421286,
                "length_improvement": 24.065135624162266,
                "smoothness_improvement": 464.23948630389367,
                "objective_score": -34.84962616591194
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This planner uses a bidirectional RRT* approach with adaptive rewiring, goal-biased sampling, and incremental connection attempts between two trees grown from start and goal. It dynamically adjusts neighbor radius for efficient path optimization and applies robust collision checks to ensure feasibility. The algorithm enforces a 30-second time limit, returning the best path found within that interval. Path smoothing is applied post planning to improve path quality and smoothness.",
        "planning_mechanism": "The planner alternates expansions between two trees from start and goal positions, sampling points biased toward the opposite tree root. It extends each tree toward samples using a step size limit, rewires neighbors within an adaptive radius to minimize path cost, and incrementally attempts to connect the trees while avoiding collisions. Upon success or timeout, the best path is extracted and shortcut smoothing is applied before returning.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 4.0,\n                 goal_sample_rate: float = 0.15, neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 25.0, time_limit_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = math.inf\n        best_connection = None\n        extracted_path = []\n        success_state = False\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free(tree_from, tree_to):\n            # Goal bias toward opposite tree root\n            if random.random() < self.goal_sample_rate:\n                if tree_from is start_tree:\n                    return goal_pos\n                else:\n                    return start_pos\n            for _ in range(50):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback\n            if tree_from is start_tree:\n                return goal_pos\n            else:\n                return start_pos\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, position) ** 2) <= radius_sq]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 50.0\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1 / dim)\n            return max(self.neighbor_radius_min, min(r, self.neighbor_radius_max))\n\n        def try_extend(tree_from, sample):\n            node_near = nearest(tree_from, sample)\n            new_pos = steer(node_near.position, sample)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(node_near.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            n_nodes = len(tree_from)\n            radius = adaptive_radius(n_nodes)\n            neighbors = near_nodes(tree_from, new_pos, radius)\n\n            min_cost = node_near.cost + math.dist(node_near.position, new_pos)\n            best_parent = node_near\n            for neighbor in neighbors:\n                cost_try = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_try < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_try\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            node_near = nearest(tree, node.position)\n            dist_to = math.dist(node_near.position, node.position)\n            if dist_to <= self.step_size:\n                if not self._is_in_obstacle(node.position, obstacles, is_3d) and \\\n                   not self._is_edge_in_obstacle(node_near.position, node.position, obstacles, is_3d):\n                    return node_near\n            return None\n\n        def incremental_connect(tree, target_pos):\n            curr = nearest(tree, target_pos)\n            max_steps = int(math.dist(curr.position, target_pos) / self.step_size) + 2\n            last_node = curr\n            for _ in range(max_steps):\n                new_pos = steer(last_node.position, target_pos)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_node = Node(new_pos)\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + math.dist(last_node.position, new_pos)\n                best_parent = last_node\n                for neighbor in neighbors:\n                    cost_try = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_try < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_try\n                        best_parent = neighbor\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                last_node = new_node\n                if math.dist(last_node.position, target_pos) <= self.step_size:\n                    return last_node\n            return None\n\n        def path_smoothing(path, max_iters=100):\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                    length = len(path)\n            return path\n\n        import time\n        start_time = time.time()\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            if (time.time() - start_time) > self.time_limit_sec:\n                break\n\n            sample = sample_free(tree_a, tree_b)\n            new_node_a = try_extend(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect(tree_b, new_node_a.position)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    combined = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined)\n                    success_state = True\n                    # Optional early break for speed:\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined = path_a + path_b[::-1]\n            extracted_path = path_smoothing(combined)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -18.44179,
        "time_improvement": 28.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1195.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.0321617841720581,
                "num_nodes_avg": 84.7,
                "path_length_avg": 154.7988312384859,
                "smoothness_avg": 0.03852361475420025,
                "success_improvement": 0.0,
                "time_improvement": -35.64546993042573,
                "length_improvement": 15.152307653733788,
                "smoothness_improvement": 502.97822627162316,
                "objective_score": -5.148288317022846
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.0475306510925293,
                "num_nodes_avg": 266.0,
                "path_length_avg": 232.3176880735701,
                "smoothness_avg": 0.07877010053743526,
                "success_improvement": 0.0,
                "time_improvement": 80.18351111627115,
                "length_improvement": 22.445668827155995,
                "smoothness_improvement": 1926.8114226383475,
                "objective_score": 38.17824421350428
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.061810421943664554,
                "num_nodes_avg": 280.3,
                "path_length_avg": 118.64183299869458,
                "smoothness_avg": 0.09862513818512744,
                "success_improvement": 0.0,
                "time_improvement": 40.94050350026311,
                "length_improvement": 21.203743639253076,
                "smoothness_improvement": 1154.504477964368,
                "objective_score": 22.29542216775139
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This algorithm implements a unidirectional goal-biased RRT* planner that incrementally grows a single tree from the start position toward the goal. It employs collision checking for nodes and edges, rewires nearby nodes within a fixed neighbor radius to optimize path costs, and performs post-processing path smoothing. It enforces a 30-second time limit for efficient search termination and returns the best path found, focusing on improving planning efficiency, path quality, and robustness.",
        "planning_mechanism": "The planner iteratively samples free space with bias toward the goal, extends the tree toward samples respecting bounds and obstacles, rewires neighbors if cheaper paths are found, and stops when the goal is reached or timeout occurs. It returns the smoothed optimal path discovered within the time constraint.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 3.0, goal_sample_rate: float = 0.2,\n                 neighbor_radius: float = 10.0, max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import time\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if within_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, pos):\n            r_sq = self.neighbor_radius * self.neighbor_radius\n            return [n for n in tree if (math.dist(n.position, pos) ** 2) <= r_sq]\n\n        def add_node(tree, pos, parent_node, cost):\n            new_node = Node(pos)\n            parent_node.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist_edge = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist_edge\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        start_time = time.time()\n\n        tree = [Node(start_pos)]\n        nodes = tree[:]\n        edges = []\n\n        success = False\n        best_path = []\n        best_cost = math.inf\n\n        for _ in range(self.max_iter):\n            if time.time() - start_time > self.max_time_sec:\n                break\n\n            sample = sample_free()\n            nearest = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n\n            if not within_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost_through = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through\n                    best_parent = neighbor\n\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n            rewire(tree, new_node, neighbors)\n\n            if math.dist(new_pos, goal_pos) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_pos, goal_pos, obstacles, is_3d):\n                    goal_node = add_node(tree, goal_pos, new_node, new_node.cost + math.dist(new_pos, goal_pos))\n                    path = goal_node.path_from_root()\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_path = self._path_smoothing(path, obstacles, is_3d)\n                        success = True\n                    break\n\n        if not success and best_path:\n            best_path = self._path_smoothing(best_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smoothing(self, path, obstacles, is_3d, iterations=100):\n        import random\n        if len(path) <= 2:\n            return path[:]\n        p = path[:]\n        for _ in range(iterations):\n            if len(p) <= 2:\n                break\n            i = random.randint(0, len(p) - 2)\n            j = random.randint(i + 1, len(p) - 1)\n            if j == i + 1:\n                continue\n            if not self._is_edge_in_obstacle(p[i], p[j], obstacles, is_3d):\n                p = p[:i + 1] + p[j:]\n        return p\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 58.53755,
        "time_improvement": -227.0,
        "length_improvement": 22.0,
        "smoothness_improvement": 1023.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.09854881763458252,
                "num_nodes_avg": 333.9,
                "path_length_avg": 151.91618996165545,
                "smoothness_avg": 0.03582743627270239,
                "success_improvement": 0.0,
                "time_improvement": -315.6392757198005,
                "length_improvement": 16.732329015938678,
                "smoothness_improvement": 460.7771781908991,
                "objective_score": -89.0414310217979
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.9610401153564453,
                "num_nodes_avg": 1440.4,
                "path_length_avg": 218.19865128595058,
                "smoothness_avg": 0.068215898607693,
                "success_improvement": 0.0,
                "time_improvement": -300.6770436555585,
                "length_improvement": 27.159009700804205,
                "smoothness_improvement": 1655.2442051017,
                "objective_score": -76.49509013099821
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.17290010452270507,
                "num_nodes_avg": 608.2,
                "path_length_avg": 115.04346730722273,
                "smoothness_avg": 0.08280957331111555,
                "success_improvement": 0.0,
                "time_improvement": -65.20503819193696,
                "length_improvement": 23.593606795767627,
                "smoothness_improvement": 953.3316601505034,
                "objective_score": -10.076131797675043
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "This algorithm implements a unidirectional RRT* planner with goal-biased sampling, adaptive rewiring via a fixed neighbor radius to optimize path cost, and incremental tree expansion with collision and edge checks to ensure safety. It enforces a 30-second time limit for planning, returning the best feasible path found so far. Path smoothing via shortcutting is applied post-planning to reduce unnecessary waypoints and improve smoothness and path length. The Node class supports dynamic rewiring with clean parent-child relationship management to enhance path quality efficiently.",
        "planning_mechanism": "The planner grows a single tree from the start toward the goal by iteratively sampling random points with a fixed probability of sampling the goal directly. Each new sample guides a \u201csteer\u201d operation limited by a step size to ensure incremental expansion. Around each new node, neighboring nodes within a fixed radius are considered to find a better parent that minimizes cost while avoiding collisions. Rewiring nearby nodes through the new node further improves path cost. The search stops early if the goal is reached within step size or if the 30-second time limit expires, returning the best found path. Finally, path smoothing removes redundant waypoints for enhanced quality.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius: float = 20.0,\n                 time_limit_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes = [Node(start_position, None, 0.0)]\n        edges = []\n\n        best_goal_node = None\n        best_goal_cost = float('inf')\n        extracted_path = []\n        success_state = False\n\n        start_time = time.time()\n\n        for _ in range(self.max_iter):\n            if (time.time() - start_time) > self.time_limit_sec:\n                break\n\n            # Goal-biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            nearest = self._nearest(nodes, sample)\n            new_pos = self._steer(nearest.position, sample)\n\n            if not self._in_bounds(new_pos, bounds):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(nodes, new_pos, self.neighbor_radius)\n\n            # Choose best parent based on cost + collision check\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if cheaper\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Check if new node close enough to goal\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d):\n                # Connect goal node\n                goal_node = Node(goal_position)\n                goal_node.cost = new_node.cost + dist_to_goal\n                new_node.add_child(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n\n                if goal_node.cost < best_goal_cost:\n                    best_goal_cost = goal_node.cost\n                    best_goal_node = goal_node\n                    # Early success break to reduce time if desired\n                    break\n\n        if best_goal_node:\n            path = best_goal_node.path_from_root()\n            smoothed = self._path_smoothing(path, obstacles, is_3d)\n            extracted_path = smoothed\n            success_state = True\n        else:\n            # If no direct goal found, find closest node to goal and try reconstruct path\n            closest_to_goal = min(nodes, key=lambda n: math.dist(n.position, goal_position))\n            path = closest_to_goal.path_from_root()\n            if path:\n                extracted_path = self._path_smoothing(path, obstacles, is_3d)\n                success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        dims = len(bounds)\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(dims))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _path_smoothing(self, path, obstacles, is_3d, max_iterations=150):\n        if len(path) < 3:\n            return path[:]\n\n        length = len(path)\n        for _ in range(max_iterations):\n            if length <= 2:\n                break\n            i = random.randint(0, length - 3)\n            j = random.randint(i + 2, length - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                path = path[:i + 1] + path[j:]\n                length = len(path)\n        return path",
        "objective": 44.01672,
        "time_improvement": -180.0,
        "length_improvement": 21.0,
        "smoothness_improvement": 1149.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.0889700174331665,
                "num_nodes_avg": 215.6,
                "path_length_avg": 160.66670428403003,
                "smoothness_avg": 0.04392140708733276,
                "success_improvement": 0.0,
                "time_improvement": -275.23974913446966,
                "length_improvement": 11.936033455072419,
                "smoothness_improvement": 587.4653977788074,
                "objective_score": -77.24739106043236
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.5353069305419922,
                "num_nodes_avg": 955.2,
                "path_length_avg": 220.4520745125576,
                "smoothness_avg": 0.07340596398531327,
                "success_improvement": 0.0,
                "time_improvement": -123.18027619309659,
                "length_improvement": 26.40675216657153,
                "smoothness_improvement": 1788.7883255208592,
                "objective_score": -22.728790797010372
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.25174062252044677,
                "num_nodes_avg": 616.5,
                "path_length_avg": 114.97394025067749,
                "smoothness_avg": 0.09212451129349497,
                "success_improvement": 0.0,
                "time_improvement": -140.53669182421459,
                "length_improvement": 23.639783356202322,
                "smoothness_improvement": 1071.8169837291682,
                "objective_score": -32.07396595737807
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This planner implements a bidirectional RRT* algorithm with adaptive rewiring, goal-biased sampling toward the opposite tree root, incremental tree connection, and comprehensive collision checks. It grows two trees simultaneously from start and goal positions, rewiring nodes dynamically within an adaptive radius for path cost optimization. The planner enforces a 30-second time limit, returning the best feasible path found with shortcut smoothing applied for improved path quality and smoothness.",
        "planning_mechanism": "The planner alternately samples points biased to the opposite tree\u2019s root, extends trees incrementally toward these samples using limited step sizes, and dynamically rewires neighbors to minimize path costs. It attempts incremental connections between the two trees to form a valid path, performing collision checks on nodes and edges to enforce feasibility. Upon timeout or successful connection, the planner extracts and smooths the path, returning detailed exploration data.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = None                # Node or None\n        self.cost = cost                  # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True                 # For collision checking etc.\n        if parent is not None:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Update costs recursively for descendants\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, new_cost + dist)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=3.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=8.0,\n                 neighbor_radius_max: float=20.0,\n                 time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free(tree_from, tree_to_root):\n            # Biased sampling towards opposite tree root\n            if random.random() < self.goal_sample_rate:\n                return tree_to_root\n            for _ in range(50):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return tree_to_root\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, position) ** 2) <= radius_sq]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 50.0\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1 / dim)\n            return max(self.neighbor_radius_min, min(r, self.neighbor_radius_max))\n\n        def try_extend(tree_from, sample):\n            node_near = nearest(tree_from, sample)\n            new_pos = steer(node_near.position, sample)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(node_near.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            n_nodes = len(tree_from)\n            radius = adaptive_radius(n_nodes)\n\n            neighbors = near_nodes(tree_from, new_pos, radius)\n            min_cost = node_near.cost + math.dist(node_near.position, new_pos)\n            best_parent = node_near\n\n            for neighbor in neighbors:\n                cost_try = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_try < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_try\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            curr = nearest(tree, target_pos)\n            max_steps = int(math.dist(curr.position, target_pos) / self.step_size) + 2\n            last_node = curr\n            for _ in range(max_steps):\n                new_pos = steer(last_node.position, target_pos)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_node = Node(new_pos)\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + math.dist(last_node.position, new_pos)\n                best_parent = last_node\n                for neighbor in neighbors:\n                    cost_try = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_try < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_try\n                        best_parent = neighbor\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                last_node = new_node\n                if math.dist(last_node.position, target_pos) <= self.step_size:\n                    return last_node\n            return None\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_iters=150):\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                    length = len(path)\n            return path\n\n        start_time = time.perf_counter()\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_connection = None\n        extracted_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        # Alternate tree growth\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            if time.perf_counter() - start_time > self.time_limit_sec:\n                break\n\n            sample = sample_free(tree_a, tree_b[0].position)\n            new_node_a = try_extend(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect(tree_b, new_node_a.position)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    combined = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined)\n                    success_state = True\n                    break  # Early termination on successful connection\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined = path_a + path_b[::-1]\n            extracted_path = path_smoothing(combined)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -13.07332,
        "time_improvement": 5.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1514.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.029509496688842774,
                "num_nodes_avg": 85.7,
                "path_length_avg": 148.66975138070165,
                "smoothness_avg": 0.036425490759200756,
                "success_improvement": 0.0,
                "time_improvement": -24.459188095853403,
                "length_improvement": 18.511753445270763,
                "smoothness_improvement": 470.13802960070234,
                "objective_score": -1.284715591698356
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.1117234468460083,
                "num_nodes_avg": 434.6,
                "path_length_avg": 238.4083638968034,
                "smoothness_avg": 0.11045410754651208,
                "success_improvement": 0.0,
                "time_improvement": 53.42023743445464,
                "length_improvement": 20.412425926977505,
                "smoothness_improvement": 2742.0637440497085,
                "objective_score": 33.818875135980434
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.11888971328735351,
                "num_nodes_avg": 426.1,
                "path_length_avg": 119.60842651853757,
                "smoothness_avg": 0.1124686144285398,
                "success_improvement": 0.0,
                "time_improvement": -13.598425394164021,
                "length_improvement": 20.561778247610626,
                "smoothness_improvement": 1330.5924739614477,
                "objective_score": 6.685790401080157
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "This planner implements an adaptive bidirectional RRT* algorithm that grows two trees from start and goal positions with goal-biased sampling toward the opposite tree root. It uses an adaptive neighbor radius for rewiring and incrementally connects trees while performing comprehensive collision checks in 2D/3D. The algorithm enforces a 30-second time limit, returning the best feasible path with shortcut smoothing applied for improved path smoothness and length.",
        "planning_mechanism": "The planner alternately expands trees from start and goal by sampling points biased toward the opposite tree's root, extends trees incrementally with step size limits, and rewires neighbors dynamically to minimize path cost. It attempts incremental connections between trees to form feasible paths, performing collision checks on nodes and edges. Upon timeout or connection, it extracts and smooths the path, returning detailed exploration data.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = None                # Node or None\n        self.cost = cost                  # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True                 # For collision checking etc.\n        if parent is not None:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update cost of descendants\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 10000,\n                 step_size: float = 3.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 20.0,\n                 time_limit_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free(tree_from, tree_to_root):\n            # Biased sampling towards opposite tree root\n            if random.random() < self.goal_sample_rate:\n                return tree_to_root\n            for _ in range(50):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return tree_to_root\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, position) ** 2) <= radius_sq]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 50.0\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1 / dim)\n            return max(self.neighbor_radius_min, min(r, self.neighbor_radius_max))\n\n        def try_extend(tree_from, sample):\n            node_near = nearest(tree_from, sample)\n            new_pos = steer(node_near.position, sample)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(node_near.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            n_nodes = len(tree_from)\n            radius = adaptive_radius(n_nodes)\n\n            neighbors = near_nodes(tree_from, new_pos, radius)\n            min_cost = node_near.cost + math.dist(node_near.position, new_pos)\n            best_parent = node_near\n\n            for neighbor in neighbors:\n                cost_try = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_try < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_try\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            curr = nearest(tree, target_pos)\n            max_steps = int(math.dist(curr.position, target_pos) / self.step_size) + 2\n            last_node = curr\n            for _ in range(max_steps):\n                new_pos = steer(last_node.position, target_pos)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_node = Node(new_pos)\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + math.dist(last_node.position, new_pos)\n                best_parent = last_node\n                for neighbor in neighbors:\n                    cost_try = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_try < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_try\n                        best_parent = neighbor\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                last_node = new_node\n                if math.dist(last_node.position, target_pos) <= self.step_size:\n                    return last_node\n            return None\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_iters=150):\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                    length = len(path)\n            return path\n\n        start_time = time.perf_counter()\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_connection = None\n        extracted_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        # Alternate tree growth\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            if time.perf_counter() - start_time > self.time_limit_sec:\n                break\n\n            sample = sample_free(tree_a, tree_b[0].position)\n            new_node_a = try_extend(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect(tree_b, new_node_a.position)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    combined = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined)\n                    success_state = True\n                    break  # Early termination on successful connection\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined = path_a + path_b[::-1]\n            extracted_path = path_smoothing(combined)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -6.27058,
        "time_improvement": -13.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1234.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.05581696033477783,
                "num_nodes_avg": 96.8,
                "path_length_avg": 150.99529894966375,
                "smoothness_avg": 0.038797049437916134,
                "success_improvement": 0.0,
                "time_improvement": -135.41348869807948,
                "length_improvement": 17.23708397206323,
                "smoothness_improvement": 507.2580728446962,
                "objective_score": -34.640339450787714
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.0918731689453125,
                "num_nodes_avg": 360.9,
                "path_length_avg": 228.26438824460533,
                "smoothness_avg": 0.08188458513023869,
                "success_improvement": 0.0,
                "time_improvement": 61.69621940222309,
                "length_improvement": 23.7987769778312,
                "smoothness_improvement": 2006.9493544837585,
                "objective_score": 33.30336798865196
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.06875677108764648,
                "num_nodes_avg": 287.4,
                "path_length_avg": 121.03478103598215,
                "smoothness_avg": 0.1011770474774812,
                "success_improvement": 0.0,
                "time_improvement": 34.30330753792427,
                "length_improvement": 19.614461492827267,
                "smoothness_improvement": 1186.9645758007575,
                "objective_score": 20.148707438946523
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "This algorithm implements an improved Bidirectional RRT* planner that grows two trees from start and goal positions concurrently. It uses goal-biased adaptive sampling, dynamic rewiring with an adaptive neighbor radius based on dimensionality and node count, and robust collision and edge checking to incrementally find an optimized path minimizing path length. The planner enforces a 30-second time limit, early termination on finding a feasible connection, and applies post-processing shortcut path smoothing to enhance path quality and reduce waypoint redundancy. The Node class supports dynamic parent updates and child management to maintain tree consistency and enable efficient optimization.",
        "planning_mechanism": "The planner alternates growth between two trees rooted at start and goal, sampling points with goal bias to improve convergence. Each new node connects via the best parent in a dynamically sized neighborhood to minimize path cost. Rewiring nearby nodes through newly added nodes further reduces overall cost. When the two trees connect within step size distance, the algorithm merges paths. The process stops early on success or time expiration, returning the best solution found. Path smoothing shortcuts unnecessary waypoints to improve final path length and smoothness.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float = 5.0, goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 10.0, neighbor_radius_max: float = 50.0,\n                 time_limit_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes_start = [Node(start_pos, None, 0.0)]\n        nodes_goal = [Node(goal_pos, None, 0.0)]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_connection = None\n        best_cost = float('inf')\n\n        start_time = time.time()\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample():\n            # Goal biased sampling with probability goal_sample_rate\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n\n        def nearest(tree, p):\n            # Return node in tree closest to p\n            return min(tree, key=lambda n: math.dist(n.position, p))\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, position, r) -> List[Node]:\n            return [node for node in tree if math.dist(node.position, position) <= r]\n\n        def connect_two_nodes(n1: Node, n2: Node) -> float:\n            # Return combined cost and perform edge collision check\n            if self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                return float('inf')\n            return n1.cost + math.dist(n1.position, n2.position)\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_iter: int = 200) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            length = len(p)\n            for _ in range(max_iter):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length -1)\n                if not self._is_edge_in_obstacle(p[i], p[j], obstacles, is_3d):\n                    p = p[:i+1] + p[j:]\n                    length = len(p)\n            return p\n\n        def adaptive_radius(n_nodes: int) -> float:\n            # Adaptive neighbor radius based on node count & dimensionality\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt_star = 2 * (1 + 1/dim)**(1/dim) * ( (math.prod(bounds)) / math.pi )**(1/dim)\n            radius = min(self.neighbor_radius_max,\n                         max(self.neighbor_radius_min,\n                             gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1/dim)))\n            return radius\n\n        # Alternate tree indicator: 0 for start tree, 1 for goal tree\n        tree_indicator = 0\n\n        for i in range(self.max_iter):\n            if (time.time() - start_time) > self.time_limit_sec:\n                break\n\n            # Alternate tree growth\n            tree_a = nodes_start if tree_indicator == 0 else nodes_goal\n            tree_b = nodes_goal if tree_indicator == 0 else nodes_start\n\n            # Sample point\n            rand_point = sample()\n\n            # Find nearest node in tree_a\n            nearest_node = nearest(tree_a, rand_point)\n            new_pos = steer(nearest_node.position, rand_point)\n\n            if not in_bounds(new_pos):\n                tree_indicator = 1 - tree_indicator\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                tree_indicator = 1 - tree_indicator\n                continue\n\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                tree_indicator = 1 - tree_indicator\n                continue\n\n            # Create new node (parent not set yet)\n            new_node = Node(new_pos)\n\n            # Find neighbors for rewiring in tree_a\n            radius = adaptive_radius(len(tree_a) + 1)\n            neighbors = near_nodes(tree_a, new_pos, radius)\n\n            # Choose best parent minimizing cost\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                if neighbor == nearest_node:\n                    continue\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree_a.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if cheaper\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Attempt connection to opposite tree tree_b\n            nearest_to_new_in_b = nearest(tree_b, new_pos)\n            dist_btwn = math.dist(nearest_to_new_in_b.position, new_pos)\n\n            if dist_btwn <= self.step_size and not self._is_edge_in_obstacle(new_pos, nearest_to_new_in_b.position, obstacles, is_3d):\n                # Calculate combined path cost\n                total_cost = new_node.cost + nearest_to_new_in_b.cost + dist_btwn\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node, nearest_to_new_in_b)\n\n                    # Early stop if we find a good solution well before timeout\n                    if (time.time() - start_time) < (self.time_limit_sec * 0.95):\n                        break\n\n            tree_indicator = 1 - tree_indicator\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        if best_connection is not None:\n            node_a, node_b = best_connection\n\n            # Build paths from roots\n            path_from_start = node_a.path_from_root()\n            path_from_goal = node_b.path_from_root()\n            path_from_goal.reverse()\n            # Avoid duplicate node at connection\n            if path_from_start[-1] == path_from_goal[0]:\n                combined_path = path_from_start + path_from_goal[1:]\n            else:\n                combined_path = path_from_start + path_from_goal\n\n            # Smooth path\n            extracted_path = path_smoothing(combined_path)\n            success_state = True\n            # Combine all nodes for return\n            nodes = nodes_start + nodes_goal\n        else:\n            # No direct connection, fallback to closest node in start tree to goal\n            closest = min(nodes_start, key=lambda n: math.dist(n.position, goal_pos))\n            path_try = closest.path_from_root()\n            if path_try:\n                extracted_path = path_smoothing(path_try)\n            nodes = nodes_start + nodes_goal\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 25.53308,
        "time_improvement": -119.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1264.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.11463017463684082,
                "num_nodes_avg": 130.9,
                "path_length_avg": 157.45821380904326,
                "smoothness_avg": 0.0513603293441109,
                "success_improvement": 0.0,
                "time_improvement": -383.4639715146755,
                "length_improvement": 13.694657926197761,
                "smoothness_improvement": 703.9006849756177,
                "objective_score": -108.780756444285
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.0892021656036377,
                "num_nodes_avg": 330.3,
                "path_length_avg": 228.03126641185196,
                "smoothness_avg": 0.08413189698781737,
                "success_improvement": 0.0,
                "time_improvement": 62.80981466784782,
                "length_improvement": 23.87659975564418,
                "smoothness_improvement": 2064.7743072525614,
                "objective_score": 33.94213588774599
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.14358193874359132,
                "num_nodes_avg": 439.5,
                "path_length_avg": 118.31262095022007,
                "smoothness_avg": 0.08824597885832912,
                "success_improvement": 0.0,
                "time_improvement": -37.19170233753336,
                "length_improvement": 21.42239060645671,
                "smoothness_improvement": 1022.4823374373433,
                "objective_score": -1.7606208927819482
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e1",
        "algorithm_description": "This algorithm implements a bidirectional informed RRT* planner with adaptive neighborhood radius and heuristic-driven sampling focused on reducing planning time while improving path quality and smoothness. It dynamically balances exploration and exploitation by alternating tree growth from start and goal, progressively focusing sampling in ellipsoidal informed regions once solutions are found. The planner performs continuous rewiring for cost optimization, robust collision and boundary checks for feasibility, and incremental tree connections enhanced with pruning. A shortcut-based path smoothing is applied to the best solution before return. Planning is strictly time-bounded at 30 seconds, ensuring practical runtimes with early termination upon improved solutions.",
        "planning_mechanism": "The planner initializes two trees rooted at start and goal, grows them alternately towards sampled points biased inside an ellipsoidal informed region after an initial path is found, progressively rewires neighbors to minimize path cost, and incrementally attempts to connect the trees. It maintains the best solution found, applies shortcut smoothing, and halts when the max time or iterations are reached, returning the best feasible path with node and edge information.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            dist = math.dist(child.position, self.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 20000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = 30.0  # seconds\n        self.goal_sample_rate = 0.1  # 10% goal bias for sampling\n        self.smooth_trials = 120\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 8.0\n            gamma = self.step_size * 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            r = max(self.step_size, min(self.step_size * 15.0, r))\n            return r\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                # Use Rodrigues formula to get rotation matrix aligning x-axis with direction\n                norm_v = math.sqrt(vx * vx + vy * vy + vz * vz)\n                if norm_v < 1e-12:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                ux, uy, uz = vx / norm_v, vy / norm_v, vz / norm_v\n                # Build orthonormal basis with ux along x-axis\n                # Find orthogonal vector\n                if abs(ux) < 1e-6 and abs(uy) < 1e-6:\n                    vx_ = 0\n                    vy_ = 1\n                    vz_ = 0\n                else:\n                    vx_ = -uy\n                    vy_ = ux\n                    vz_ = 0\n                norm_ = math.sqrt(vx_ * vx_ + vy_ * vy_ + vz_ * vz_)\n                vx_ /= norm_\n                vy_ /= norm_\n                vz_ /= norm_\n                wx = uy * vz_ - uz * vy_\n                wy = uz * vx_ - ux * vz_\n                wz = ux * vy_ - uy * vx_\n                return [[ux, vx_, wx], [uy, vy_, wy], [uz, vz_, wz]]\n\n        rotation_mat = None  # Will be computed once informed sampling triggered\n\n        def informed_sample(c_best):\n            nonlocal rotation_mat\n\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                # Uniform random sample inside bounds and free space\n                while True:\n                    sample_pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                    if collision_free_node(sample_pt):\n                        return sample_pt\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            if rotation_mat is None:\n                rotation_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = rotation_mat[0][0] * sample_scaled[0] + rotation_mat[0][1] * sample_scaled[1]\n                    y_rot = rotation_mat[1][0] * sample_scaled[0] + rotation_mat[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = (rotation_mat[0][0] * sample_scaled[0] +\n                             rotation_mat[0][1] * sample_scaled[1] +\n                             rotation_mat[0][2] * sample_scaled[2])\n                    y_rot = (rotation_mat[1][0] * sample_scaled[0] +\n                             rotation_mat[1][1] * sample_scaled[1] +\n                             rotation_mat[1][2] * sample_scaled[2])\n                    z_rot = (rotation_mat[2][0] * sample_scaled[0] +\n                             rotation_mat[2][1] * sample_scaled[1] +\n                             rotation_mat[2][2] * sample_scaled[2])\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                # Clamp to bounds\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, position) ** 2) <= radius_sq]\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend(tree, sample_pt):\n            nearest = min(tree, key=lambda n: dist(n.position, sample_pt))\n            new_pos = steer(nearest.position, sample_pt)\n            new_pos = clamp(new_pos)\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        def incremental_connect(new_node, other_tree):\n            if not other_tree:\n                return None\n            curr = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                new_pos = steer(curr.position, new_node.position)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr.position, new_pos):\n                    return None\n\n                radius = adaptive_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, new_pos, radius)\n\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr == curr:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                conn_node = Node(new_pos)\n                best_parent.add_child(conn_node)\n                conn_node.cost = min_cost\n                other_tree.append(conn_node)\n\n                rewire(other_tree, conn_node, neighbors)\n\n                if dist(conn_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(conn_node.position, new_node.position):\n                        return conn_node\n                    return None\n                curr = conn_node\n\n        def path_shortcut(path, trials=self.smooth_trials):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialization\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start = True\n        informed_sampling = False\n        iter_count = 0\n        t_start = time.perf_counter()\n\n        while iter_count < self.max_iter:\n            iter_count += 1\n            if time.perf_counter() - t_start > self.max_planning_time:\n                # Time exceeded\n                if best_path:\n                    smooth_path = path_shortcut(best_path)\n                    # Build edges\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for n in all_nodes:\n                        for c in n.children:\n                            all_edges.append((n, c))\n                    return PlannerResult(True, smooth_path, all_nodes, all_edges)\n                else:\n                    return PlannerResult(False, [], all_nodes, all_edges)\n\n            # Sample point strategy\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                # Goal bias\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                    if not collision_free_node(sample_pt):\n                        continue\n\n            active_tree = tree_start if grow_start else tree_goal\n            opposite_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(active_tree, sample_pt)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            all_nodes.append(new_node)\n\n            connected_node = incremental_connect(new_node, opposite_tree)\n            if connected_node is not None:\n                path_1 = new_node.path_from_root()\n                path_2 = connected_node.path_from_root()\n                if path_2 and path_2[0] == new_node.position:\n                    path_2 = path_2[1:]\n                combined = path_1 + path_2[::-1]\n\n                total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined\n                    informed_sampling = True\n\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for n in all_nodes:\n                        for c in n.children:\n                            all_edges.append((n, c))\n\n                    smooth_path = path_shortcut(best_path)\n                    return PlannerResult(True, smooth_path, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        # No better path found within max_iter or time\n        if best_path:\n            smooth_path = path_shortcut(best_path)\n            success_state = True\n        else:\n            smooth_path = []\n            success_state = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for n in all_nodes:\n            for c in n.children:\n                all_edges.append((n, c))\n\n        return PlannerResult(success_state, smooth_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -3.77873,
        "time_improvement": -23.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1379.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.04545304775238037,
                "num_nodes_avg": 61.8,
                "path_length_avg": 155.75184724541754,
                "smoothness_avg": 0.04312486058361625,
                "success_improvement": 0.0,
                "time_improvement": -91.7026738677717,
                "length_improvement": 14.629944478829533,
                "smoothness_improvement": 574.9977152672259,
                "objective_score": -21.70982468822947
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.08447740077972413,
                "num_nodes_avg": 249.6,
                "path_length_avg": 226.8413398985369,
                "smoothness_avg": 0.0885047004593228,
                "success_improvement": 0.0,
                "time_improvement": 64.779664595404,
                "length_improvement": 24.273831475924386,
                "smoothness_improvement": 2177.2896901774284,
                "objective_score": 35.175114124693216
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.14994337558746337,
                "num_nodes_avg": 366.5,
                "path_length_avg": 120.99401428813727,
                "smoothness_avg": 0.11672384199377897,
                "success_improvement": 0.0,
                "time_improvement": -43.270018019577776,
                "length_improvement": 19.641536825641914,
                "smoothness_improvement": 1384.7186545030631,
                "objective_score": -2.1291047682296345
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "This implementation presents a bidirectional informed RRT* planner with adaptive neighborhood radius, goal-biased sampling, rewiring for path cost optimization, and time-bounded execution to ensure practical runtimes. The planner grows two trees from start and goal alternately, incrementally connecting and rewiring them to find the shortest path while avoiding obstacles, and applies shortcut smoothing before returning the final path.",
        "planning_mechanism": "The planner initializes start and goal trees and grows them toward sampled points, focusing sampling inside an ellipsoidal informed region after an initial solution is found. It performs rewiring within an adaptive radius to optimize paths locally, uses goal-biased samples to accelerate convergence, and incrementally attempts to connect the two trees. The algorithm halts early either when a time limit is reached or a better path is found, returning the best smoothed solution.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position\n        self.parent = None\n        self.children = []\n        self.cost = cost\n        self.valid = True\n        if parent is not None:\n            self.set_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def set_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for c in self.children:\n            dist = math.dist(c.position, self.position)\n            c.set_parent(self, self.cost + dist)\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 20000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = 30.0  # seconds\n        self.goal_sample_rate = 0.1     # goal bias rate\n        self.smooth_trials = 150        # shortcut smoothing attempts\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 8.0\n            gamma = self.step_size * 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            r = max(self.step_size, min(self.step_size * 15.0, r))\n            return r\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx * vx + vy * vy + vz * vz)\n                if norm_v < 1e-12:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                ux, uy, uz = vx / norm_v, vy / norm_v, vz / norm_v\n                # Construct orthonormal basis\n                if abs(ux) < 1e-6 and abs(uy) < 1e-6:\n                    vx_ = 0\n                    vy_ = 1\n                    vz_ = 0\n                else:\n                    vx_ = -uy\n                    vy_ = ux\n                    vz_ = 0\n                norm_ = math.sqrt(vx_ * vx_ + vy_ * vy_ + vz_ * vz_)\n                vx_ /= norm_\n                vy_ /= norm_\n                vz_ /= norm_\n                wx = uy * vz_ - uz * vy_\n                wy = uz * vx_ - ux * vz_\n                wz = ux * vy_ - uy * vx_\n                return [[ux, vx_, wx], [uy, vy_, wy], [uz, vz_, wz]]\n\n        rotation_mat = None  # Lazy initialization when informed sampling triggers\n\n        def informed_sample(c_best):\n            nonlocal rotation_mat\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                # Uniform random in free space\n                while True:\n                    sample_pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                    if collision_free_node(sample_pt):\n                        return sample_pt\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            if rotation_mat is None:\n                rotation_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = rotation_mat[0][0] * sample_scaled[0] + rotation_mat[0][1] * sample_scaled[1]\n                    y_rot = rotation_mat[1][0] * sample_scaled[0] + rotation_mat[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = (rotation_mat[0][0] * sample_scaled[0] +\n                             rotation_mat[0][1] * sample_scaled[1] +\n                             rotation_mat[0][2] * sample_scaled[2])\n                    y_rot = (rotation_mat[1][0] * sample_scaled[0] +\n                             rotation_mat[1][1] * sample_scaled[1] +\n                             rotation_mat[1][2] * sample_scaled[2])\n                    z_rot = (rotation_mat[2][0] * sample_scaled[0] +\n                             rotation_mat[2][1] * sample_scaled[1] +\n                             rotation_mat[2][2] * sample_scaled[2])\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [n for n in tree if (dist(n.position, position) ** 2) <= r_sq]\n\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.set_parent(new_node, cost_new)\n\n        def extend(tree: List[Node], sample_pt: Tuple[float, ...]) -> Node or None:\n            nearest = min(tree, key=lambda n: dist(n.position, sample_pt))\n            new_pos = steer(nearest.position, sample_pt)\n            new_pos = clamp(new_pos)\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(new_node: Node, other_tree: List[Node]) -> Node or None:\n            if not other_tree:\n                return None\n            curr = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                new_pos = steer(curr.position, new_node.position)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr.position, new_pos):\n                    return None\n\n                radius = adaptive_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, new_pos, radius)\n\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr == curr:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                conn_node = Node(new_pos)\n                best_parent.add_child(conn_node)\n                conn_node.cost = min_cost\n                other_tree.append(conn_node)\n\n                rewire(other_tree, conn_node, neighbors)\n\n                if dist(conn_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(conn_node.position, new_node.position):\n                        return conn_node\n                    return None\n                curr = conn_node\n\n        def path_shortcut(path: List[Tuple[float, ...]], trials=None) -> List[Tuple[float, ...]]:\n            if trials is None:\n                trials = self.smooth_trials\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        all_nodes = tree_start + tree_goal\n        all_edges: List[Tuple[Node, Node]] = []\n\n        grow_start = True\n        informed_sampling = False\n        iteration = 0\n        t_start = time.perf_counter()\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - t_start\n            if elapsed > self.max_planning_time:\n                if best_path:\n                    smooth = path_shortcut(best_path)\n                    # Update edges\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for n in all_nodes:\n                        for c in n.children:\n                            all_edges.append((n, c))\n                    return PlannerResult(True, smooth, all_nodes, all_edges)\n                else:\n                    return PlannerResult(False, [], all_nodes, all_edges)\n\n            sample_pt = None\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    for _ in range(10):\n                        candidate = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if collision_free_node(candidate):\n                            sample_pt = candidate\n                            break\n                    if sample_pt is None:\n                        grow_start = not grow_start\n                        continue\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(active_tree, sample_pt)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            all_nodes.append(new_node)\n\n            connected_node = incremental_connect(new_node, other_tree)\n            if connected_node is not None:\n                path_from_start = new_node.path_from_root()\n                path_from_goal = connected_node.path_from_root()\n                if path_from_goal and path_from_goal[0] == new_node.position:\n                    path_from_goal = path_from_goal[1:]\n                combined_path = path_from_start + path_from_goal[::-1]\n\n                total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    informed_sampling = True\n\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for n in all_nodes:\n                        for c in n.children:\n                            all_edges.append((n, c))\n\n                    smoothed = path_shortcut(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        if best_path:\n            success_state = True\n            smoothed = path_shortcut(best_path)\n        else:\n            success_state = False\n            smoothed = []\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for n in all_nodes:\n            for c in n.children:\n                all_edges.append((n, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -4.88187,
        "time_improvement": -19.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1314.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.05471546649932861,
                "num_nodes_avg": 66.4,
                "path_length_avg": 151.7619317937995,
                "smoothness_avg": 0.04383684801267038,
                "success_improvement": 0.0,
                "time_improvement": -130.7678307291169,
                "length_improvement": 16.81688036211761,
                "smoothness_improvement": 586.1418646373716,
                "objective_score": -32.93626382312468
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.07684826850891113,
                "num_nodes_avg": 240.4,
                "path_length_avg": 232.84684353780153,
                "smoothness_avg": 0.0832055995410256,
                "success_improvement": 0.0,
                "time_improvement": 67.96040399959922,
                "length_improvement": 22.26902150230001,
                "smoothness_improvement": 2040.9400067615263,
                "objective_score": 35.0466255341474
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.09910225868225098,
                "num_nodes_avg": 275.2,
                "path_length_avg": 117.73736682323056,
                "smoothness_avg": 0.11135035644550106,
                "success_improvement": 0.0,
                "time_improvement": 5.308371699922773,
                "length_improvement": 21.804447006945242,
                "smoothness_improvement": 1316.3683149584135,
                "objective_score": 12.535242486157948
            }
        ],
        "success_rate": 1.0
    }
]