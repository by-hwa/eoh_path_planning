[
    {
        "parents": [
            "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
            "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for iter_num in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or            self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, new_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            connect_node.parent = best_parent\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n\n            nearest = connect_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    "
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "This hybrid algorithm combines the bidirectional search efficiency of the first dual-tree RRT with the path quality and rewiring optimization of the second algorithm\u2019s RRT*-style rewiring. It grows two trees simultaneously from start and goal, incorporating goal bias sampling for faster convergence and rewiring in each tree for improved path cost. The algorithm alternates growth between the two trees and attempts to connect them via incremental steer steps, ensuring collision-free edges. The Node class includes an `update_parent` method to support clean rewiring, promoting robustness and path smoothness.",
            "planning_mechanism": "The planner samples random points with goal bias, extends one tree towards the sample, rewires neighbors to optimize cost, then attempts to connect the other tree via a rewiring-enhanced incremental connection procedure. If connection succeeds, paths from both trees are combined into the final path. This bidirectional rewiring hybrid efficiently balances quick exploration, path optimality, and robustness while reducing redundant or complex connection logic.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from old parent\n        if self.parent:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        # Alternate between start_tree and goal_tree\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Extend and rewire tree_a toward sample\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                # Swap trees and continue next iteration\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Try to connect tree_b to new_node_a using incremental connection and rewiring\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                # Connection succeeded, extract path from both trees\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            # Swap trees for next iteration\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        # Find best parent to minimize cost\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors if new_node offers cheaper cost path\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                # Rewire neighbor to new_node\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            # Find best parent with minimum cost\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost possible through new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -16.50088,
            "time_improvement": 36.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 331.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013587737083435058,
                    "num_nodes_avg": 84.7,
                    "path_length_avg": 148.70296472171577,
                    "smoothness_avg": 0.023905809137381114,
                    "success_improvement": 0.0,
                    "time_improvement": 45.481061276420704,
                    "length_improvement": 18.49354868676186,
                    "smoothness_improvement": 274.1778252954413,
                    "objective_score": 18.713917246755788
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0670863151550293,
                    "num_nodes_avg": 374.6,
                    "path_length_avg": 238.30235227754707,
                    "smoothness_avg": 0.019222022900071807,
                    "success_improvement": 0.0,
                    "time_improvement": 58.490856066975105,
                    "length_improvement": 20.447815656860534,
                    "smoothness_improvement": 394.59649428232086,
                    "objective_score": 23.609802422876243
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04745805263519287,
                    "num_nodes_avg": 282.7,
                    "path_length_avg": 119.32520386391828,
                    "smoothness_avg": 0.03341984071111011,
                    "success_improvement": 0.0,
                    "time_improvement": 4.678227031831315,
                    "length_improvement": 20.749881249195226,
                    "smoothness_improvement": 325.0979070492782,
                    "objective_score": 7.178933894634831
                }
            ],
            "success_rate": 1.0
        },
        "objective": 240.2,
        "analysis": "1. Summary of key changes:\n   - Introduction of rewiring steps during tree expansion to optimize path cost locally by reconnecting nodes through lower-cost paths.\n   - Use of a radius-based search for neighboring nodes to enable rewiring and better exploitation of the search space.\n   - Switching from a simple tree extension and connection approach to one that performs both extension and rewiring on both trees, promoting smoother and less costly paths.\n   - More modular and structured code with added methods like `_extend_and_rewire` and `_connect_and_rewire` that integrate rewiring during connection.\n   - Enhancement in node parent-child relationship management during rewiring to maintain consistent tree structure and cost updates.\n\n2. Primary contributors to the performance improvement:\n   - Incorporation of the rewiring process to reduce overall path cost dynamically.\n   - Neighborhood search to identify better parent nodes during node insertion.\n   - Improved tree connection strategy that integrates rewiring when connecting the two trees.\n   - Better path extraction using `path_from_root` that gives a smooth concatenated path from start to goal.\n\n3. Expected mechanism of impact:\n   - Rewiring reduces the cumulative cost of paths by locally optimizing tree connections, which leads to smoother, shorter, and more efficient planning outcomes.\n   - Radius-based neighbor evaluation introduces better structural adaptiveness of the tree, effectively improving exploration and exploitation balance.\n   - Enhanced connection process between start and goal trees leads to a more robust convergence towards feasible, lower-cost paths.\n   - Overall, these changes reduce unnecessary detours and decrease planning time while increasing solution quality."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from old parent\n        if self.parent:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        # Alternate between start_tree and goal_tree\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Extend and rewire tree_a toward sample\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                # Swap trees and continue next iteration\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Try to connect tree_b to new_node_a using incremental connection and rewiring\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                # Connection succeeded, extract path from both trees\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            # Swap trees for next iteration\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        # Find best parent to minimize cost\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors if new_node offers cheaper cost path\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                # Rewire neighbor to new_node\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            # Find best parent with minimum cost\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost possible through new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False"
        ],
        "offspring": {
            "operator": "path_expert",
            "algorithm_description": "This improved planner implements a unidirectional RRT* algorithm with enhanced goal biasing and adaptive neighbor radius for rewiring, targeting minimal path length and improved path smoothness. It uses a fixed step size for incremental expansions, rewires nearby nodes based on cost optimization with collision-free checks, and includes a post-processing path smoothing step to refine the final path. Collision checks tightly integrate both node and edge validations, and sampling is bounded within map limits to maintain robustness and path feasibility.",
            "planning_mechanism": "The planner grows a single tree from start towards the goal by sampling free points with goal bias, extending towards those samples by fixed increments while avoiding obstacles, and rewiring neighbors within an adaptive radius to minimize path cost. Once a node reaches within step size to the goal, it closes the path. Before returning, a path smoothing refinement reduces unnecessary turns and shortens the path length. The Node class supports clean parent updates facilitating rewiring.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from root to this node\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, min_neighbor_radius: float = 10.0, max_neighbor_radius: float = 50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n        start_node = Node(start_position, parent=None, cost=0.0)\n        nodes.append(start_node)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def sample_free():\n            # Goal biasing: sample goal with goal_sample_rate probability\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(s, obstacles, is_3d):\n                    return s\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def adaptive_neighbor_radius(n_nodes):\n            # RRT* adaptive radius (based on literature)\n            gamma_rrt = 30.0  # scaling factor, tuneable\n            unit_ball_volume = 3.14159 if dim == 2 else 4.18879  # pi or 4/3 pi\n            radius = min(self.max_neighbor_radius, max(self.min_neighbor_radius,\n                     gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))))\n            return radius\n\n        success_state = False\n        final_node = None\n\n        for i in range(self.max_iter):\n            sample = sample_free()\n\n            nearest_node = nearest(nodes, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if (not in_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                continue\n\n            new_node = Node(new_pos)\n            neighbors_radius = adaptive_neighbor_radius(len(nodes))\n            neighbors = near_nodes(nodes, new_pos, neighbors_radius)\n\n            # Choose best parent for new_node (lowest cost + collision free edge)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_candidate = nbr.cost + math.dist(nbr.position, new_pos)\n                if cost_candidate < min_cost:\n                    if not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = nbr\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if going through new_node is cheaper\n            for nbr in neighbors:\n                if nbr == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                                nbr.parent.remove_child(nbr)\n                            except ValueError:\n                                pass\n                        nbr.update_parent(new_node, new_cost)\n                        edges.append((new_node, nbr))\n\n            # Check if new_node is close enough to goal to connect\n            if math.dist(new_node.position, goal_position) <= self.step_size:\n                # Check direct connection to goal feasible\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and\n                    in_bounds(goal_position)):\n                    goal_node = Node(goal_position)\n                    cost_to_goal = new_node.cost + math.dist(new_node.position, goal_position)\n                    new_node.add_child(goal_node)\n                    goal_node.cost = cost_to_goal\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    final_node = goal_node\n                    success_state = True\n                    break\n\n        extracted_path = []\n        if success_state and final_node:\n            extracted_path = final_node.path_from_root()\n            extracted_path = self._path_smoothing(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smoothing(self, path, obstacles, is_3d, max_trials=100):\n        import random\n        import math\n\n        if len(path) < 3:\n            return path[:]\n\n        def can_connect(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        smoothed_path = path[:]\n        for _ in range(max_trials):\n            if len(smoothed_path) < 3:\n                break\n\n            i = random.randint(0, len(smoothed_path) - 3)\n            j = random.randint(i + 2, len(smoothed_path) - 1)\n\n            if can_connect(smoothed_path[i], smoothed_path[j]):\n                # Remove intermediate points between i and j\n                smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n        return smoothed_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": 54.22564,
            "time_improvement": -213.0,
            "length_improvement": 18.0,
            "smoothness_improvement": 1202.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.050071334838867186,
                    "num_nodes_avg": 215.8,
                    "path_length_avg": 168.18846965414065,
                    "smoothness_avg": 0.04524080984260282,
                    "success_improvement": 0.0,
                    "time_improvement": -100.90439041656103,
                    "length_improvement": 7.813234665715184,
                    "smoothness_improvement": 608.1169160277249,
                    "objective_score": -25.668085611686646
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.3605773448944092,
                    "num_nodes_avg": 990.0,
                    "path_length_avg": 223.64359211551306,
                    "smoothness_avg": 0.08056861039559834,
                    "success_improvement": 0.0,
                    "time_improvement": -123.10447180803207,
                    "length_improvement": 25.34133172796426,
                    "smoothness_improvement": 1973.0883767031735,
                    "objective_score": -21.9976333133009
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.2563539743423462,
                    "num_nodes_avg": 707.6,
                    "path_length_avg": 117.93268352857778,
                    "smoothness_avg": 0.08842235600801178,
                    "success_improvement": 0.0,
                    "time_improvement": -414.8992422758637,
                    "length_improvement": 21.67472695123567,
                    "smoothness_improvement": 1024.7258417624998,
                    "objective_score": -115.01119808369947
                }
            ],
            "success_rate": 1.0
        },
        "objective": 372.7999999999999,
        "analysis": "1. Summary of key changes:\n   - Implementation of a bidirectional RRT* style planner with two trees growing from start and goal positions.\n   - Addition of incremental connection and rewiring between the two trees to find a cheaper path.\n   - Incorporation of goal-biased random sampling to improve convergence speed.\n   - Introduction of rewiring logic to optimize paths dynamically after new nodes insertion.\n   - Use of node parent-child relationships with methods to add, remove, and update parents for flexible tree updates.\n   - Collision checking for nodes and edges in 2D and 3D space.\n   - Path extraction by concatenating paths from both trees.\n   - Smoothness of final path ensured by gradual rewiring and path extraction steps.\n\n2. Primary contributors to the performance improvement:\n   - Bidirectional search reducing exploration time to connect start and goal.\n   - Incremental connection with rewiring improves path quality by minimizing costs.\n   - Goal bias sampling focuses exploration towards achieving connection quickly.\n   - Edge and node obstacle collision checks reduce invalid expansions.\n   - Parent update mechanisms that rewire nearby nodes to better parents improving overall path cost.\n\n3. Expected mechanism of impact:\n   - Bidirectional growth reduces search space effectively, enabling faster path discovery.\n   - Rewiring enables continuous improvement of the path cost as new nodes provide better connectivity.\n   - Goal bias increases likelihood of sampling near target reducing unnecessary exploration.\n   - Collision checks prevent expansions into invalid paths, maintaining solution feasibility.\n   - The parent-child update system efficiently restructures tree topology leading to smoother, lower-cost paths."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from old parent\n        if self.parent:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        # Alternate between start_tree and goal_tree\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Extend and rewire tree_a toward sample\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                # Swap trees and continue next iteration\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Try to connect tree_b to new_node_a using incremental connection and rewiring\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                # Connection succeeded, extract path from both trees\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            # Swap trees for next iteration\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        # Find best parent to minimize cost\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors if new_node offers cheaper cost path\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                # Rewire neighbor to new_node\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            # Find best parent with minimum cost\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost possible through new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False"
        ],
        "offspring": {
            "operator": "path_expert",
            "algorithm_description": "This planner implements a bidirectional RRT* algorithm with goal bias sampling and incremental rewiring for path cost minimization. Two trees grow simultaneously from start and goal, each expanding toward sampled points with step size control and rewiring nearby nodes within a fixed radius to improve path quality. The planner attempts incremental, rewiring-enhanced connections between the trees at each iteration. Collision checks on nodes and edges ensure path feasibility. Clean rewiring via the Node's `update_parent` method maintains an optimized tree structure supporting shorter, smoother paths with higher success rates and reduced planning time.",
            "planning_mechanism": "The planner alternates growth between two trees, sampling points biased towards the opposing tree\u2019s root to accelerate connection. Each extension rewires neighbors for cost improvement. After extending one tree, it incrementally connects and rewires the other tree toward the new node. Upon successful connection, it concatenates the two root paths into a final optimized path. Robust collision checks and parent-child updates ensure path smoothness and reliability.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.15, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Goal-biased sampling towards the other tree's root\n            if random.random() < self.goal_sample_rate:\n                sample = tree_b[0].position if tree_a is start_tree else tree_a[0].position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                # Construct final path by merging roots paths at connection nodes\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                # Remove duplicated connection point in path_b\n                if path_b and path_b[0] == new_node_a.position:\n                    path_b = path_b[1:]\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors if cheaper through new_node\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_node.position, self.neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_node.position)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_node.position)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_node.position, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": 14.69474,
            "time_improvement": -63.0,
            "length_improvement": 16.0,
            "smoothness_improvement": 216.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02477607727050781,
                    "num_nodes_avg": 130.2,
                    "path_length_avg": 156.00336705470224,
                    "smoothness_avg": 0.01769763222411566,
                    "success_improvement": 0.0,
                    "time_improvement": 0.5893747997072792,
                    "length_improvement": 14.49208248577416,
                    "smoothness_improvement": 177.00637533089463,
                    "objective_score": 3.960260813721489
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0780069351196289,
                    "num_nodes_avg": 444.3,
                    "path_length_avg": 245.59103894997367,
                    "smoothness_avg": 0.013820258121187475,
                    "success_improvement": 0.0,
                    "time_improvement": 51.733806065035225,
                    "length_improvement": 18.014642252390974,
                    "smoothness_improvement": 255.60519578772144,
                    "objective_score": 20.40109624892737
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.17042129039764403,
                    "num_nodes_avg": 567.8,
                    "path_length_avg": 126.69445055050053,
                    "smoothness_avg": 0.02473458198827077,
                    "success_improvement": 0.0,
                    "time_improvement": -242.29932856916415,
                    "length_improvement": 15.85557848578538,
                    "smoothness_improvement": 214.62205717387496,
                    "objective_score": -68.4455725877228
                }
            ],
            "success_rate": 1.0
        },
        "objective": 175.6,
        "analysis": "1. Summary of key changes:  \n   - Introduction of a `Node` class encapsulating node properties and methods for managing parent-child relationships and cost updates.  \n   - Use of bidirectional trees (`start_tree` and `goal_tree`) with alternating expansions for efficient path planning.  \n   - Implementation of goal-biased sampling to improve convergence towards the goal.  \n   - Implementation of cost-based rewiring in both extending the tree and incremental connection phases to optimize path cost dynamically.  \n   - Detailed obstacle and edge collision checking with consideration for both 2D and 3D environments.  \n   - Maintained and updated global lists of nodes and edges to track the graph structure.  \n   - Path extraction merges the two trees upon successful connection, forming a complete root-to-root path.  \n   - Structured incremental connection and rewiring method allowing for multiple rewires to improve the solution gradually.\n\n2. Primary contributors to the performance improvement:  \n   - Cost-based rewiring for both new nodes and existing neighbors allowing for continuous optimization of paths (improves smoothness and path quality).  \n   - Bidirectional search strategy that enhances exploration efficiency and reduces time to find a feasible path.  \n   - Goal bias in sampling which focuses computational resources toward reaching the goal faster.  \n   - Comprehensive collision checking for nodes and edges improves reliability and path feasibility.  \n   - Clear node-parent-child relationships facilitating efficient updates and path reconstruction.\n\n3. Expected mechanism of impact:  \n   - Adaptive rewiring reduces overall path cost by dynamically improving the tree structure as new samples are added.  \n   - Alternating bidirectional trees reduce search space and increase the probability of early connection.  \n   - Goal-biased sampling channels sampling efforts into more promising areas, reducing unnecessary expansions.  \n   - Detailed obstacle checks prevent infeasible paths, ensuring the extracted path is valid and smooth.  \n   - The `Node` class encapsulation simplifies node management and enables efficient updates, promoting maintainability and clarity which indirectly supports performance by reducing errors and improving code extensibility."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True               # Validity flag (e.g., collision)\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1,\n                 neighbor_factor: float = 2.5, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        import math\n        import random\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n        center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n\n        def _rotation_matrix():\n            if np is None:\n                return None\n            a1 = [(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_position, goal_position)]\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s_], [s_, c]])\n            else:\n                a1v = np.array(a1)\n                eye = np.eye(3)\n                v = np.cross([1, 0, 0], a1v)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c = np.dot([1, 0, 0], a1v)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + (vx @ vx) * ((1 - c) / (s_ ** 2))\n                return R\n\n        rotation = _rotation_matrix()\n\n        def informed_sample():\n            r1 = c_best / 2\n            if c_best**2 - c_min**2 > 0:\n                r2 = math.sqrt(c_best**2 - c_min**2) / 2\n            else:\n                r2 = 0\n\n            while True:\n                if dim == 2:\n                    if np is None:\n                        # fallback uniform sample since no numpy\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                        if not self._is_in_obstacle(pt, obstacles, is_3d):\n                            return pt\n                    else:\n                        theta = random.uniform(0, 2 * math.pi)\n                        radius = math.sqrt(random.uniform(0, 1))\n                        sample_unit = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                        sample_ellipsoid = np.array([r1, r2]) * sample_unit\n                        if rotation is not None:\n                            sample_world = rotation @ sample_ellipsoid + np.array(center)\n                        else:\n                            sample_world = np.array(center) + sample_ellipsoid\n                        p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                        if not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n                else:\n                    if np is None:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                        if not self._is_in_obstacle(pt, obstacles, is_3d):\n                            return pt\n                    else:\n                        while True:\n                            sample_unit = np.random.uniform(-1, 1, 3)\n                            if np.linalg.norm(sample_unit) <= 1:\n                                break\n                        sample_ellipsoid = np.array([r1, r2, r2]) * sample_unit\n                        if rotation is not None:\n                            sample_world = rotation @ sample_ellipsoid + np.array(center)\n                        else:\n                            sample_world = np.array(center) + sample_ellipsoid\n                        p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                        if not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        for _ in range(self.max_iter):\n            # Sampling with bias towards goal and informed region\n            if c_best < float('inf') and random.random() < (1 - self.goal_sample_rate):\n                sample = informed_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position\n                else:\n                    sample = sample_free()\n\n            # Nearest node search\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer towards the sample by step size\n            vect = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            scale = min(self.step_size, dist_to_sample)\n            unit_vect = tuple(v / dist_to_sample for v in vect)\n            new_pos = tuple(\n                max(0, min(nearest_node.position[d] + unit_vect[d] * scale, bounds[d])) for d in range(dim)\n            )\n\n            # Validate new node position\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Dynamic neighbor radius for rewiring: gamma * (log(n)/n)^{1/dim}\n            gamma = self.neighbor_factor\n            unit_ball_vol = math.pi if dim == 2 else 4/3 * math.pi\n            radius = min(self.step_size,\n                         gamma * ((math.log(len(nodes)) / len(nodes)) ** (1/dim)))\n\n            # Find neighbors inside radius\n            near_nodes = [node for node in nodes if node != new_node and math.dist(node.position, new_node.position) <= radius]\n\n            # Choose best parent for new_node from neighbors\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n\n            for near in near_nodes:\n                cost_through_near = near.cost + math.dist(near.position, new_node.position)\n                if cost_through_near < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_node.position, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost_through_near\n                        min_parent = near\n\n            if min_parent != new_node.parent:\n                try:\n                    new_node.parent.children.remove(new_node)\n                    edges.remove((new_node.parent, new_node))\n                except (ValueError, AttributeError):\n                    pass\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                edges.append((min_parent, new_node))\n\n            # Rewire near nodes if beneficial to connect through new_node\n            for near in near_nodes:\n                if near == min_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                        try:\n                            if near.parent:\n                                near.parent.children.remove(near)\n                                edges.remove((near.parent, near))\n                        except (ValueError, AttributeError):\n                            pass\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Check if close to goal for connection\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d, self.collision_resolution)\n                    and not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n\n                    # Extract path by backtracking\n                    path = []\n                    curr = goal_node\n                    while curr:\n                        path.append(curr.position)\n                        curr = curr.parent\n                    extracted_path = path[::-1]\n\n                    # Update best cost bound for ellipsoid sampling\n                    c_best = goal_node.cost\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from root to this node\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, min_neighbor_radius: float = 10.0, max_neighbor_radius: float = 50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n        start_node = Node(start_position, parent=None, cost=0.0)\n        nodes.append(start_node)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def sample_free():\n            # Goal biasing: sample goal with goal_sample_rate probability\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(s, obstacles, is_3d):\n                    return s\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def adaptive_neighbor_radius(n_nodes):\n            # RRT* adaptive radius (based on literature)\n            gamma_rrt = 30.0  # scaling factor, tuneable\n            unit_ball_volume = 3.14159 if dim == 2 else 4.18879  # pi or 4/3 pi\n            radius = min(self.max_neighbor_radius, max(self.min_neighbor_radius,\n                     gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))))\n            return radius\n\n        success_state = False\n        final_node = None\n\n        for i in range(self.max_iter):\n            sample = sample_free()\n\n            nearest_node = nearest(nodes, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if (not in_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                continue\n\n            new_node = Node(new_pos)\n            neighbors_radius = adaptive_neighbor_radius(len(nodes))\n            neighbors = near_nodes(nodes, new_pos, neighbors_radius)\n\n            # Choose best parent for new_node (lowest cost + collision free edge)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_candidate = nbr.cost + math.dist(nbr.position, new_pos)\n                if cost_candidate < min_cost:\n                    if not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = nbr\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if going through new_node is cheaper\n            for nbr in neighbors:\n                if nbr == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                                nbr.parent.remove_child(nbr)\n                            except ValueError:\n                                pass\n                        nbr.update_parent(new_node, new_cost)\n                        edges.append((new_node, nbr))\n\n            # Check if new_node is close enough to goal to connect\n            if math.dist(new_node.position, goal_position) <= self.step_size:\n                # Check direct connection to goal feasible\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and\n                    in_bounds(goal_position)):\n                    goal_node = Node(goal_position)\n                    cost_to_goal = new_node.cost + math.dist(new_node.position, goal_position)\n                    new_node.add_child(goal_node)\n                    goal_node.cost = cost_to_goal\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    final_node = goal_node\n                    success_state = True\n                    break\n\n        extracted_path = []\n        if success_state and final_node:\n            extracted_path = final_node.path_from_root()\n            extracted_path = self._path_smoothing(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smoothing(self, path, obstacles, is_3d, max_trials=100):\n        import random\n        import math\n\n        if len(path) < 3:\n            return path[:]\n\n        def can_connect(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        smoothed_path = path[:]\n        for _ in range(max_trials):\n            if len(smoothed_path) < 3:\n                break\n\n            i = random.randint(0, len(smoothed_path) - 3)\n            j = random.randint(i + 2, len(smoothed_path) - 1)\n\n            if can_connect(smoothed_path[i], smoothed_path[j]):\n                # Remove intermediate points between i and j\n                smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n        return smoothed_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False"
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "This hybrid planner combines informed sampling from Informed RRT*, goal biasing, adaptive neighbor radius rewiring, and post-planning path smoothing to achieve fast convergence, lower path costs, and smoother trajectories. It uses a unidirectional tree from start to goal, dynamically adjusting its sampling domain based on the best path found so far, while leveraging careful collision checking and efficient rewiring to maintain path quality and robustness.",
            "planning_mechanism": "The planner iteratively grows a single tree from start by sampling within an informed ellipsoid around the current best path or globally with goal bias. For each sampled point, it extends toward it by fixed step increments, verifies node and edge collision, then adds the node with rewiring neighbors within an adaptive radius to optimize path cost. When close to the goal, it connects directly, then smooths the final path by shortcutting feasible edges.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from start to this node\n        self.children = []\n        self.valid = True                 # Validity flag (collision etc.)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15,\n                 neighbor_factor: float = 30.0, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialization\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position, cost=0.0)\n        nodes.append(root)\n\n        # Precompute minimum distance between start and goal\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n        center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n\n        # Rotation matrix for informed sampling\n        def _rotation_matrix():\n            try:\n                import numpy as np\n            except ImportError:\n                return None\n            a1 = [(g - s)/c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_position, goal_position)]\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s_],[s_, c]])\n            else:\n                a1v = np.array(a1)\n                eye = np.eye(3)\n                v = np.cross([1,0,0], a1v)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c = np.dot([1,0,0], a1v)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + (vx @ vx) * ((1 - c) / (s_ ** 2))\n                return R\n\n        rotation = _rotation_matrix()\n\n        def _informed_sample():\n            try:\n                import numpy as np\n            except ImportError:\n                # fallback uniform sample\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n\n            if c_best == float('inf'):\n                # No solution found yet, uniform sample in environment\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n            else:\n                r1 = c_best / 2.0\n                r2 = math.sqrt(c_best**2 - c_min**2) / 2.0 if c_best**2 - c_min**2 > 0 else 0.0\n\n                while True:\n                    if dim == 2:\n                        theta = random.uniform(0, 2*math.pi)\n                        radius = math.sqrt(random.uniform(0, 1))\n                        sample_unit = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                        sample_ellipsoid = np.array([r1, r2]) * sample_unit\n                        if rotation is not None:\n                            sample_world = rotation @ sample_ellipsoid + np.array(center)\n                        else:\n                            sample_world = np.array(center) + sample_ellipsoid\n                        p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                        if not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n                    else:\n                        while True:\n                            sample_unit = np.random.uniform(-1,1,3)\n                            if np.linalg.norm(sample_unit) <= 1:\n                                break\n                        sample_ellipsoid = np.array([r1, r2, r2]) * sample_unit\n                        if rotation is not None:\n                            sample_world = rotation @ sample_ellipsoid + np.array(center)\n                        else:\n                            sample_world = np.array(center) + sample_ellipsoid\n                        p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                        if not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def _steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + ratio*(to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def _adaptive_radius(n_nodes):\n            gamma = self.neighbor_factor\n            try:\n                import math\n                radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            except Exception:\n                radius = self.step_size * 2\n            return min(radius, self.step_size*3)\n\n        for _ in range(self.max_iter):\n            # Sample point biased by informed region and goal sample rate\n            if c_best < float(\"inf\") and random.random() < (1 - self.goal_sample_rate):\n                sample = _informed_sample()\n            else:\n                sample = _sample_free()\n\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = _steer(nearest_node.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=None, cost=new_cost)\n\n            # Find neighbors within adaptive radius for rewiring\n            radius = _adaptive_radius(len(nodes))\n            near_nodes = [node for node in nodes if node != new_node and math.dist(node.position, new_node.position) <= radius]\n\n            # Find best parent from neighbors (including nearest_node)\n            min_cost = new_cost\n            min_parent = nearest_node\n            for near in near_nodes:\n                cost_through_near = near.cost + math.dist(near.position, new_node.position)\n                if cost_through_near < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_node.position, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost_through_near\n                        min_parent = near\n\n            # Attach new_node to best parent found\n            min_parent.add_child(new_node)\n            new_node.cost = min_cost\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire near nodes through new_node if better cost\n            for near in near_nodes:\n                if near == min_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                                near.parent.remove_child(near)\n                            except ValueError:\n                                pass\n                        near.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near))\n\n            # Check if can connect directly to goal\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d)\n                    and not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d, self.collision_resolution)):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n\n                    # Extract path by backtracking\n                    path = []\n                    curr = goal_node\n                    while curr:\n                        path.append(curr.position)\n                        curr = curr.parent\n                    extracted_path = path[::-1]\n\n                    # Update c_best and center for informed sampling\n                    c_best = goal_node.cost\n                    center = tuple((start_position[i] + goal_position[i]) / 2 for i in range(dim))\n\n                    # Path smoothing\n                    extracted_path = self._path_smoothing(extracted_path, obstacles, is_3d)\n\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smoothing(self, path, obstacles, is_3d, max_trials=100):\n        import random\n        import math\n\n        if len(path) < 3:\n            return path[:]\n\n        def can_connect(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        smoothed_path = path[:]\n        for _ in range(max_trials):\n            if len(smoothed_path) < 3:\n                break\n            i = random.randint(0, len(smoothed_path) - 3)\n            j = random.randint(i + 2, len(smoothed_path) - 1)\n            if can_connect(smoothed_path[i], smoothed_path[j]):\n                # shortcut by removing intermediate nodes\n                smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n        return smoothed_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": 53.4914,
            "time_improvement": -213.0,
            "length_improvement": 15.0,
            "smoothness_improvement": 1490.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0764470100402832,
                    "num_nodes_avg": 292.6,
                    "path_length_avg": 163.94220213096608,
                    "smoothness_avg": 0.049851394553919355,
                    "success_improvement": 0.0,
                    "time_improvement": -206.73318378143102,
                    "length_improvement": 10.140681181581924,
                    "smoothness_improvement": 680.2825788047776,
                    "objective_score": -56.59040600408903
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.3096360683441162,
                    "num_nodes_avg": 987.2,
                    "path_length_avg": 243.2098846566309,
                    "smoothness_avg": 0.10466181034236757,
                    "success_improvement": 0.0,
                    "time_improvement": -91.58494691578414,
                    "length_improvement": 18.809540093234947,
                    "smoothness_improvement": 2593.0237649640285,
                    "objective_score": -10.748457231268107
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.2198101282119751,
                    "num_nodes_avg": 720.3,
                    "path_length_avg": 125.4537816233676,
                    "smoothness_avg": 0.10186386147835655,
                    "success_improvement": 0.0,
                    "time_improvement": -341.4991760953191,
                    "length_improvement": 16.67957171288138,
                    "smoothness_improvement": 1195.700799196556,
                    "objective_score": -93.13533449003668
                }
            ],
            "success_rate": 1.0
        },
        "objective": 778.8,
        "analysis": "1. Summary of key changes:\n   - Introduction of a dedicated path smoothing method (`_path_smoothing`) in the offspring algorithm to optimize the extracted path by removing unnecessary intermediate nodes.\n   - Use of an adaptive neighbor radius bounded between a minimum and maximum value for neighbor search and rewiring, replacing the previous unbounded or less constrained radius.\n   - More robust handling of node parent-child relationships with explicit methods to add, remove, and update parents/children, improving tree consistency.\n   - Enhanced goal biasing with a fixed `goal_sample_rate` and improved sampling strategy without complex informed sampling ellipsoids.\n   - Incorporation of explicit path validation through collision checking and edge validation during sampling, steering, and rewiring.\n   - Use of backtracking and separate extracted path smoothing step to generate a smoother final path result.\n\n2. Primary contributors to the performance improvement:\n   - Path smoothing (`_path_smoothing`) significantly reduces path irregularity, making the output path smoother and more practical.\n   - Adaptive neighbor radius that limits connectivity radius improves network rewiring efficiency and convergence speed.\n   - Improved parent-child management ensures the tree structure remains consistent, promoting better rewiring and cost optimization.\n   - Simplified and effective sampling strategies maintain efficient exploration while avoiding obstacles, leading to better sampling quality.\n   \n3. Expected mechanism of impact:\n   - The path smoothing removes redundant waypoints, reducing sharp turns and improving the overall path quality, directly enhancing smoothness.\n   - The constrained adaptive neighbor radius balances exploration and rewiring, leading to faster convergence and better path cost minimization.\n   - Enhanced tree integrity through clear parent-child updates reduces structural errors, keeping the planner stable and efficient in updating paths.\n   - More reliable collision and edge checking during node addition and rewiring prevents invalid expansions and improves success rate in complex environments.\n   - Balanced goal biasing and sampling facilitate trials closer to the goal, decreasing unnecessary computations and promoting faster goal discovery."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from old parent\n        if self.parent:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        # Alternate between start_tree and goal_tree\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Extend and rewire tree_a toward sample\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                # Swap trees and continue next iteration\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Try to connect tree_b to new_node_a using incremental connection and rewiring\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                # Connection succeeded, extract path from both trees\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            # Swap trees for next iteration\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        # Find best parent to minimize cost\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors if new_node offers cheaper cost path\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                # Rewire neighbor to new_node\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            # Find best parent with minimum cost\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost possible through new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False"
        ],
        "offspring": {
            "operator": "path_expert",
            "algorithm_description": "This algorithm implements an optimized bidirectional RRT* planner using two trees grown from the start and goal. It integrates goal-biased sampling and informed heuristics to focus growth toward promising regions. The planner performs rewiring after each new node addition to improve path cost locally and incrementally tries to connect the two trees with rewiring-enhanced incremental connection steps. The Node class supports dynamic parent updates allowing robust rewiring. This approach balances exploration, exploitation, and path cost optimization, ensuring improved path length, smoothness, and planning efficiency.",
            "planning_mechanism": "The planner alternates sampling points biased towards the opposing tree\u2019s root and extends one tree towards these samples with rewiring to minimize costs. After each extension, it incrementally attempts to connect the other tree to the newly added node, also rewiring whenever better connections are identified. If the trees connect, their paths are merged for the final planning outcome. Collision checks for nodes and edges ensure validity throughout the process. This dual-tree rewiring hybrid speeds up convergence while producing lower cost, smoother paths.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 20.0, connect_threshold: float = 1.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.connect_threshold = connect_threshold\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                sample = tree_b[0].position  # bias towards other tree's root to encourage connection\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_b and self._dist(new_node_a.position, new_node_b.position) <= self.connect_threshold:\n                # Connection successful, merge paths\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n                # Remove duplicate node at connection\n                if path_goal[0] == path_start[-1]:\n                    path_goal = path_goal[1:]\n                extracted_path = path_start + path_goal[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(\n                max(0.0, min(bounds[d], random.uniform(0, bounds[d]))) for d in range(len(bounds))\n            )\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: self._dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        return [node for node in tree if self._dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if not self._position_in_bounds(new_pos, bounds):\n            return None\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + self._dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors for better paths\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + self._dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n\n            if not self._position_in_bounds(new_pos, bounds):\n                return None\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            min_cost = curr_node.cost + self._dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + self._dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved costs\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + self._dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if self._dist(new_node.position, target_pos) <= self.connect_threshold:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = self._dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, p1, p2):\n        import math\n        return math.dist(p1, p2)\n\n    def _position_in_bounds(self, pos, bounds):\n        for dim in range(len(bounds)):\n            if pos[dim] < 0 or pos[dim] > bounds[dim]:\n                return False\n        return True",
            "objective": 5.1084,
            "time_improvement": -34.0,
            "length_improvement": 15.0,
            "smoothness_improvement": 402.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0566575288772583,
                    "num_nodes_avg": 117.3,
                    "path_length_avg": 169.87638754539265,
                    "smoothness_avg": 0.029805058432856506,
                    "success_improvement": 0.0,
                    "time_improvement": -127.33059420574068,
                    "length_improvement": 6.888060122749372,
                    "smoothness_improvement": 366.5138871945143,
                    "objective_score": -34.988996801199754
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06383743286132812,
                    "num_nodes_avg": 234.4,
                    "path_length_avg": 238.30680555959853,
                    "smoothness_avg": 0.020901029227638895,
                    "success_improvement": 0.0,
                    "time_improvement": 60.50107711487519,
                    "length_improvement": 20.446329023131142,
                    "smoothness_improvement": 437.7985364299979,
                    "objective_score": 24.428581621238777
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06713318824768066,
                    "num_nodes_avg": 232.0,
                    "path_length_avg": 122.82911290223119,
                    "smoothness_avg": 0.03935130317222395,
                    "success_improvement": 0.0,
                    "time_improvement": -34.840225703431656,
                    "length_improvement": 18.422751704166362,
                    "smoothness_improvement": 400.5456717396294,
                    "objective_score": -4.764789011498077
                }
            ],
            "success_rate": 1.0
        },
        "objective": 212.79999999999998,
        "analysis": "1. Summary of key changes:\n   - Implemented bidirectional RRT with two trees growing from start and goal positions.\n   - Added goal-biased sampling to improve convergence speed.\n   - Introduced extend-and-rewire method to optimize path cost dynamically while growing trees.\n   - Implemented incremental connect-and-rewire method for gradually connecting the two trees with path cost optimization.\n   - Added nearest node and near nodes utilities for efficient neighbor searching within a radius.\n   - Path extraction combines paths from both trees once connected.\n   - Obstacle checking refined both for points and edges, preventing invalid expansions.\n   - Node class enhanced with parent, children, cost properties and related update methods for reparenting and rewiring.\n   - Rewiring of neighbors to shorter cost paths whenever feasible.\n\n2. Primary contributors to the performance improvement:\n   - Bidirectional tree growth reducing overall planning time.\n   - Goal-biased sampling focusing search toward goal, increasing solution frequency.\n   - Dynamic rewiring of the tree to minimize path cost during expansion, increasing smoothness.\n   - Incremental connection strategy enabling finer and safer linkage between trees.\n   - Efficient neighbor detection allowing targeted rewiring for cost reduction.\n   - Rigorous obstacle collision checks for both nodes and edges ensuring feasible path generation.\n\n3. Expected mechanism of impact:\n   - Bidirectional and goal bias sampling reduces search space and iteration count.\n   - Rewiring improves path quality in real-time, resulting in smoother paths with lower cost.\n   - Incremental connection moves methodically toward conjoining trees, preventing failed jumps and enhancing robustness.\n   - Neighborhood-based rewiring helps in eliminating detours and optimizing routes during expansion.\n   - Accurate collision detection avoids invalid paths, reducing backtracking and failures.\n   - Overall, these changes collaboratively promote faster convergence to lower-cost, smoother paths with higher success rates."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from start to this node\n        self.children = []\n        self.valid = True                 # Validity flag (collision etc.)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15,\n                 neighbor_factor: float = 30.0, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialization\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position, cost=0.0)\n        nodes.append(root)\n\n        # Precompute minimum distance between start and goal\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n        center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n\n        # Rotation matrix for informed sampling\n        def _rotation_matrix():\n            try:\n                import numpy as np\n            except ImportError:\n                return None\n            a1 = [(g - s)/c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_position, goal_position)]\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s_],[s_, c]])\n            else:\n                a1v = np.array(a1)\n                eye = np.eye(3)\n                v = np.cross([1,0,0], a1v)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c = np.dot([1,0,0], a1v)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + (vx @ vx) * ((1 - c) / (s_ ** 2))\n                return R\n\n        rotation = _rotation_matrix()\n\n        def _informed_sample():\n            try:\n                import numpy as np\n            except ImportError:\n                # fallback uniform sample\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n\n            if c_best == float('inf'):\n                # No solution found yet, uniform sample in environment\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n            else:\n                r1 = c_best / 2.0\n                r2 = math.sqrt(c_best**2 - c_min**2) / 2.0 if c_best**2 - c_min**2 > 0 else 0.0\n\n                while True:\n                    if dim == 2:\n                        theta = random.uniform(0, 2*math.pi)\n                        radius = math.sqrt(random.uniform(0, 1))\n                        sample_unit = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                        sample_ellipsoid = np.array([r1, r2]) * sample_unit\n                        if rotation is not None:\n                            sample_world = rotation @ sample_ellipsoid + np.array(center)\n                        else:\n                            sample_world = np.array(center) + sample_ellipsoid\n                        p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                        if not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n                    else:\n                        while True:\n                            sample_unit = np.random.uniform(-1,1,3)\n                            if np.linalg.norm(sample_unit) <= 1:\n                                break\n                        sample_ellipsoid = np.array([r1, r2, r2]) * sample_unit\n                        if rotation is not None:\n                            sample_world = rotation @ sample_ellipsoid + np.array(center)\n                        else:\n                            sample_world = np.array(center) + sample_ellipsoid\n                        p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                        if not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def _steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + ratio*(to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def _adaptive_radius(n_nodes):\n            gamma = self.neighbor_factor\n            try:\n                import math\n                radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            except Exception:\n                radius = self.step_size * 2\n            return min(radius, self.step_size*3)\n\n        for _ in range(self.max_iter):\n            # Sample point biased by informed region and goal sample rate\n            if c_best < float(\"inf\") and random.random() < (1 - self.goal_sample_rate):\n                sample = _informed_sample()\n            else:\n                sample = _sample_free()\n\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = _steer(nearest_node.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=None, cost=new_cost)\n\n            # Find neighbors within adaptive radius for rewiring\n            radius = _adaptive_radius(len(nodes))\n            near_nodes = [node for node in nodes if node != new_node and math.dist(node.position, new_node.position) <= radius]\n\n            # Find best parent from neighbors (including nearest_node)\n            min_cost = new_cost\n            min_parent = nearest_node\n            for near in near_nodes:\n                cost_through_near = near.cost + math.dist(near.position, new_node.position)\n                if cost_through_near < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_node.position, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost_through_near\n                        min_parent = near\n\n            # Attach new_node to best parent found\n            min_parent.add_child(new_node)\n            new_node.cost = min_cost\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire near nodes through new_node if better cost\n            for near in near_nodes:\n                if near == min_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                                near.parent.remove_child(near)\n                            except ValueError:\n                                pass\n                        near.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near))\n\n            # Check if can connect directly to goal\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d)\n                    and not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d, self.collision_resolution)):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n\n                    # Extract path by backtracking\n                    path = []\n                    curr = goal_node\n                    while curr:\n                        path.append(curr.position)\n                        curr = curr.parent\n                    extracted_path = path[::-1]\n\n                    # Update c_best and center for informed sampling\n                    c_best = goal_node.cost\n                    center = tuple((start_position[i] + goal_position[i]) / 2 for i in range(dim))\n\n                    # Path smoothing\n                    extracted_path = self._path_smoothing(extracted_path, obstacles, is_3d)\n\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smoothing(self, path, obstacles, is_3d, max_trials=100):\n        import random\n        import math\n\n        if len(path) < 3:\n            return path[:]\n\n        def can_connect(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        smoothed_path = path[:]\n        for _ in range(max_trials):\n            if len(smoothed_path) < 3:\n                break\n            i = random.randint(0, len(smoothed_path) - 3)\n            j = random.randint(i + 2, len(smoothed_path) - 1)\n            if can_connect(smoothed_path[i], smoothed_path[j]):\n                # shortcut by removing intermediate nodes\n                smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n        return smoothed_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from old parent\n        if self.parent:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, goal_sample_rate: float = 0.12, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def within_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        def sample_free(tree_toggle: bool) -> Tuple[float, ...]:\n            # tree_toggle True: sample goal for start tree growth; False: sample start for goal tree growth\n            if random.random() < self.goal_sample_rate:\n                return goal_position if tree_toggle else start_position\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...]) -> List[Node]:\n            return [n for n in tree if dist(n.position, position) <= self.neighbor_radius]\n\n        def collision_free_node(pos: Tuple[float, ...]) -> bool:\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=0.5)\n\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    # Remove old edge\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n        def extend(tree: List[Node], target_point: Tuple[float, ...]) -> Node or None:\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            # Find best parent with minimal cost\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect_and_rewire(tree: List[Node], target_pos: Tuple[float, ...]) -> Node or None:\n            nearest_node = nearest(tree, target_pos)\n            current_node = nearest_node\n\n            while True:\n                new_pos = steer(current_node.position, target_pos)\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(current_node.position, new_pos):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n                min_cost = current_node.cost + dist(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                    if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors around the new_node\n                rewire(tree, new_node, neighbors)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n\n                current_node = new_node\n\n        grow_start = True\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free(grow_start)\n\n            if grow_start:\n                new_node_start = extend(start_tree, rand_point)\n                if new_node_start is None:\n                    grow_start = not grow_start\n                    continue\n\n                new_node_goal = incremental_connect_and_rewire(goal_tree, new_node_start.position)\n                if new_node_goal:\n                    # Assemble final path\n                    path_start = new_node_start.path_from_root()\n                    path_goal = new_node_goal.path_from_root()\n                    extracted_path = path_start + path_goal[::-1][1:]  # avoid duplicate node\n                    success_state = True\n                    break\n            else:\n                new_node_goal = extend(goal_tree, rand_point)\n                if new_node_goal is None:\n                    grow_start = not grow_start\n                    continue\n\n                new_node_start = incremental_connect_and_rewire(start_tree, new_node_goal.position)\n                if new_node_start:\n                    path_goal = new_node_goal.path_from_root()\n                    path_start = new_node_start.path_from_root()\n                    extracted_path = path_start + path_goal[::-1][1:]\n                    success_state = True\n                    break\n\n            grow_start = not grow_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False"
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "This planner implements a unidirectional informed RRT* path planning algorithm using adaptive sampling within an ellipsoidal informed set, goal biasing, and rewiring for path cost optimization. It incrementally grows a single tree from the start towards the goal, selectively rewiring neighbors within an adaptive radius to maintain lower-cost connections. Once a feasible path is found, it refines the solution by shortcut path smoothing, improving smoothness and path quality. The planner handles 2D and 3D environments with precise collision checks for nodes and edges.",
            "planning_mechanism": "The planner iteratively samples points biased by an informed ellipsoid centered around the current best path or performs global random sampling with occasional goal bias. For each sample, it extends the nearest tree node towards the sample within a fixed step size, checking node and edge collisions. It then connects the new node with the best parent from nearby nodes to minimize cost and rewires neighbors if improved paths are found via this new node. When the tree reaches near the goal, it connects directly, extracts the path, and performs shortcut smoothing.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from start to this node\n        self.children = []\n        self.valid = True                 # For collision or validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, neighbor_factor: float = 30.0, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position, cost=0.0)\n        nodes.append(root)\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n        center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n\n        def _rotation_matrix():\n            try:\n                import numpy as np\n            except ImportError:\n                return None\n            a1 = [(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_position, goal_position)]\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s_], [s_, c]])\n            else:\n                a1v = np.array(a1)\n                eye = np.eye(3)\n                v = np.cross([1, 0, 0], a1v)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c = np.dot([1, 0, 0], a1v)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + (vx @ vx) * ((1 - c) / (s_ ** 2))\n                return R\n\n        rotation = _rotation_matrix()\n\n        def _informed_sample():\n            try:\n                import numpy as np\n            except ImportError:\n                # Fallback uniform sampling\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n\n            if c_best == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n            else:\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best ** 2 - c_min ** 2, 0)) / 2.0\n                while True:\n                    if dim == 2:\n                        theta = random.uniform(0, 2 * math.pi)\n                        radius = math.sqrt(random.uniform(0, 1))\n                        sample_unit = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                        sample_ellipsoid = np.array([r1, r2]) * sample_unit\n                        if rotation is not None:\n                            sample_world = rotation @ sample_ellipsoid + np.array(center)\n                        else:\n                            sample_world = np.array(center) + sample_ellipsoid\n                        p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                        if not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n                    else:\n                        while True:\n                            sample_unit = np.random.uniform(-1, 1, 3)\n                            if np.linalg.norm(sample_unit) <= 1:\n                                break\n                        sample_ellipsoid = np.array([r1, r2, r2]) * sample_unit\n                        if rotation is not None:\n                            sample_world = rotation @ sample_ellipsoid + np.array(center)\n                        else:\n                            sample_world = np.array(center) + sample_ellipsoid\n                        p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                        if not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def _steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def _adaptive_radius(n):\n            import math\n            gamma = self.neighbor_factor\n            radius = gamma * ((math.log(n) / n) ** (1.0 / dim)) if n > 1 else self.step_size * 2\n            return min(radius, self.step_size * 3)\n\n        for _ in range(self.max_iter):\n            sample = _informed_sample() if (c_best < float('inf') and random.random() < (1 - self.goal_sample_rate)) else _sample_free()\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = _steer(nearest_node.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            cost_to_new = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=None, cost=cost_to_new)\n\n            radius = _adaptive_radius(len(nodes))\n            near_nodes = [node for node in nodes if node != new_node and math.dist(node.position, new_node.position) <= radius]\n\n            min_cost = cost_to_new\n            min_parent = nearest_node\n            for near in near_nodes:\n                candidate_cost = near.cost + math.dist(near.position, new_node.position)\n                if candidate_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_node.position, obstacles, is_3d, self.collision_resolution):\n                        min_cost = candidate_cost\n                        min_parent = near\n\n            min_parent.add_child(new_node)\n            new_node.cost = min_cost\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near in near_nodes:\n                if near == min_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                                near.parent.remove_child(near)\n                            except ValueError:\n                                pass\n                        near.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near))\n\n            dist_goal = math.dist(new_node.position, goal_position)\n            if dist_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d)\n                        and not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d, self.collision_resolution)):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n\n                    path = []\n                    curr = goal_node\n                    while curr:\n                        path.append(curr.position)\n                        curr = curr.parent\n                    extracted_path = path[::-1]\n\n                    c_best = goal_node.cost\n                    center = tuple((start_position[i] + goal_position[i]) / 2 for i in range(dim))\n\n                    extracted_path = self._path_smoothing(extracted_path, obstacles, is_3d)\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smoothing(self, path, obstacles, is_3d, max_trials=100):\n        import random\n\n        if len(path) < 3:\n            return path[:]\n\n        def can_connect(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        smoothed_path = path[:]\n        for _ in range(max_trials):\n            if len(smoothed_path) < 3:\n                break\n            i = random.randint(0, len(smoothed_path) - 3)\n            j = random.randint(i + 2, len(smoothed_path) - 1)\n            if can_connect(smoothed_path[i], smoothed_path[j]):\n                smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n        return smoothed_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": 37.68423,
            "time_improvement": -165.0,
            "length_improvement": 15.0,
            "smoothness_improvement": 1761.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.044990921020507814,
                    "num_nodes_avg": 194.6,
                    "path_length_avg": 165.5207622849113,
                    "smoothness_avg": 0.048098359834809604,
                    "success_improvement": 0.0,
                    "time_improvement": -80.51992404421507,
                    "length_improvement": 9.27544734731819,
                    "smoothness_improvement": 652.8437786748879,
                    "objective_score": -19.03666885042644
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.3306701898574829,
                    "num_nodes_avg": 1016.5,
                    "path_length_avg": 246.58571364093532,
                    "smoothness_avg": 0.12484997435332801,
                    "success_improvement": 0.0,
                    "time_improvement": -104.59964857864061,
                    "length_improvement": 17.682591210424434,
                    "smoothness_improvement": 3112.479765912828,
                    "objective_score": -12.280977501943154
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.20413784980773925,
                    "num_nodes_avg": 632.1,
                    "path_length_avg": 122.7958777824947,
                    "smoothness_avg": 0.12707901707366764,
                    "success_improvement": 0.0,
                    "time_improvement": -310.0206538848506,
                    "length_improvement": 18.444824888209006,
                    "smoothness_improvement": 1516.4357171797303,
                    "objective_score": -81.73505260191473
                }
            ],
            "success_rate": 1.0
        },
        "objective": 948.1999999999999,
        "analysis": "1. Summary of key changes:  \n   - The code structure was significantly changed from a single-tree RRT* (informed sampling) planner to a bidirectional RRT* planner with simultaneous growth of start and goal trees and incremental connect-and-rewire operations.  \n   - Introduced explicit tree toggling with separate `start_tree` and `goal_tree` lists, managing nodes and edges for both.  \n   - Added incremental connect-and-rewire method that extends the tree stepwise towards a target point, allowing multiple rewires per iteration.  \n   - Removed informed sampling and replaced with simple uniform random sampling with goal bias for each tree.  \n   - Adjusted neighbor radius and rewiring strategies to work with bidirectional expansion and local neighborhoods.  \n   - Integrated stricter collision checks, node and edge validation, and rewiring steps to maintain optimized paths.  \n   - Added detailed path reconstruction by connecting paths from both trees with removal of duplicate nodes.  \n   - Implemented path smoothing routine for extracted paths improving path quality.  \n   - The `Node` class remains similar but with enhanced management of parent-child relationships reflecting bidirectional growth.  \n   - Parameters like step size, goal sample rate, and neighbor radius are tuned differently in offspring.  \n\n2. Primary contributors to the performance improvement:  \n   - Bidirectional tree growth enabling faster convergence by simultaneous exploration from start and goal.  \n   - Incremental connect-and-rewire process enhancing local optimization and reducing overall path cost dynamically.  \n   - More systematic nearest neighbor and near node searching within adaptive radius to optimize rewiring.  \n   - Removal of expensive informed sampling and complicated rotation matrix calculations favoring simpler randomized sampling with goal bias, improving iteration speed and robustness.  \n   - Enhanced path smoothing that effectively shortcuts unnecessary nodes improving smoothness and reducing path length.  \n\n3. Expected mechanism of impact:  \n   - Bidirectional growth reduces search space and time to find a connecting path by meeting in the middle rather than expanding from one end only.  \n   - Incremental connection and continuous rewiring enable local path cost improvements promptly, accelerating convergence to near-optimal solutions.  \n   - Removing complex informed sampling simplifications decreases computational overhead per iteration, allowing more iterations and faster response.  \n   - Better handling of collisions and node validity ensures generated paths are feasible and efficient.  \n   - Path smoothing enhances the quality of the final path by eliminating jagged or unnecessary waypoints, directly improving smoothness metric."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from old parent\n        if self.parent:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        # Alternate between start_tree and goal_tree\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Extend and rewire tree_a toward sample\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                # Swap trees and continue next iteration\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Try to connect tree_b to new_node_a using incremental connection and rewiring\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                # Connection succeeded, extract path from both trees\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            # Swap trees for next iteration\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        # Find best parent to minimize cost\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors if new_node offers cheaper cost path\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                # Rewire neighbor to new_node\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            # Find best parent with minimum cost\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost possible through new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False"
        ],
        "offspring": {
            "operator": "path_expert",
            "algorithm_description": "This planner implements an enhanced bidirectional RRT* path planning algorithm with hybrid rewiring and informed sampling to minimize path length and improve overall planning performance. It grows two trees simultaneously from start and goal, alternates their expansion, and incrementally attempts to connect them while rewiring locally to maintain and improve path optimality. The algorithm integrates goal biasing and neighborhood-based rewiring to dynamically optimize paths and reduce redundant exploration. Node parent-child relationships are carefully managed for cost and structural consistency, enabling efficient path extraction and smooth, short final paths.",
            "planning_mechanism": "The planning mechanism samples points with goal bias, extends one tree toward samples using step-size limited steering while performing local rewiring to optimize parent connections. Then, it incrementally connects and rewires the other tree toward the newly added node. Trees alternate growth each iteration. Collision checks on nodes and edges ensure validity. Successful connection merges two trees' paths into one optimal path. Neighborhood rewiring ensures continuous path cost improvement and smoothness.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Sample point with goal bias towards opposite tree's root\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_b:\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                # Remove duplicate connection node to avoid repetition\n                if path_b and path_b[0] == path_a[-1]:\n                    path_b = path_b[1:]\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(max(0, min(bounds[d], random.uniform(0, bounds[d]))) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        # Clamp new_pos within bounds\n        new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new_node if path cost improves\n        for neighbor in neighbors:\n            if neighbor is best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.parent.remove_child(neighbor)\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        import math\n\n        curr_node = self._nearest(tree, target_pos)\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            new_pos = tuple(max(0, min(bounds[d], new_pos[d])) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if better cost path found\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -20.33585,
            "time_improvement": 54.0,
            "length_improvement": 14.0,
            "smoothness_improvement": 259.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011076927185058594,
                    "num_nodes_avg": 73.3,
                    "path_length_avg": 160.95861505039585,
                    "smoothness_avg": 0.021816597870768388,
                    "success_improvement": 0.0,
                    "time_improvement": 55.55534297289412,
                    "length_improvement": 11.776032538405214,
                    "smoothness_improvement": 241.47713217807282,
                    "objective_score": 20.22919506043964
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.036408853530883786,
                    "num_nodes_avg": 236.7,
                    "path_length_avg": 245.6476544824274,
                    "smoothness_avg": 0.01438500763053753,
                    "success_improvement": 0.0,
                    "time_improvement": 77.47230060024279,
                    "length_improvement": 17.995742358070167,
                    "smoothness_improvement": 270.13660743592806,
                    "objective_score": 28.19152168886651
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03534677028656006,
                    "num_nodes_avg": 224.6,
                    "path_length_avg": 131.35812474865287,
                    "smoothness_avg": 0.028835292141927295,
                    "success_improvement": 0.0,
                    "time_improvement": 29.00431801715044,
                    "length_improvement": 12.758188143673454,
                    "smoothness_improvement": 266.78278764544785,
                    "objective_score": 12.586846972107061
                }
            ],
            "success_rate": 1.0
        },
        "objective": 184.20000000000002,
        "analysis": "1. Summary of key changes:\n   - Implementation of a `Node` class encapsulating position, parent, cost, children, and validity state with methods for child management and parent updating.\n   - Introduction of bidirectional tree growth using two trees (start_tree and goal_tree) that alternate expansion.\n   - Incorporation of goal-biased sampling to improve sample efficiency.\n   - Use of nearest neighbor search and steering functions to incrementally extend trees subject to step size limits.\n   - Integration of rewiring logic during node extension and incremental connection to minimize path cost and enhance path optimality.\n   - Addition of obstacle collision checks for individual points and edges during tree growth.\n   - Maintenance of global node and edge lists to track graph structure.\n   - Path extraction method joining paths from both trees once connected.\n   - Adjustable parameters for max iterations, step size, goal sampling rate, and neighbor radius.\n\n2. Primary contributors to the performance improvement:\n   - Bidirectional RRT* style tree expansion improving exploration efficiency and faster connection.\n   - Rewiring with cost optimization leading to smoother, lower-cost paths.\n   - Goal biasing accelerating convergence towards solution.\n   - Detailed obstacle collision checking avoiding invalid expansions.\n   - Structured Node class facilitating efficient parent-child relationship management and path reconstruction.\n\n3. Expected mechanism of impact:\n   - Bidirectional growth reduces the search space and meets in the middle, speeding up convergence.\n   - Rewiring adjusts the tree dynamically to find better parents for nodes, decreasing overall path cost and increasing smoothness.\n   - Goal-biased sampling directs the exploration towards goal region more frequently, improving sampling efficiency.\n   - Collision checks prevent expansion through obstacles, reducing invalid paths and improving solution validity.\n   - Clear path construction from root to goal ensures proper path extraction and usable output."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D point\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost to reach this node from start\n        self.children = []\n        self.valid = True               # Collision validity flag\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, neighbor_radius: float = 15.0, goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal directly\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = [Node(start_pos, cost=0.0)]\n        edges = []\n        goal_reached_node = None\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            distance = dist(from_pos, to_pos)\n            if distance <= step:\n                return to_pos\n            ratio = step / distance\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        # Informed sampling: use elliptical sampling focused on start-goal distance when goal bias not used\n        c_min = dist(start_pos, goal_pos)\n        x_center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n        # Create sampling ellipsoid axes lengths\n        sampling_ellipsoid_axes = [c_min / 2 for _ in range(dim)]\n        # Note: basic elliptical sampling without rotation for simplicity\n\n        for _ in range(self.max_iter):\n            if goal_reached_node:\n                # Optional: Informed sampling biased within ellipse after first solution\n                # Draw sample inside ellipse to improve path quality\n                import numpy as np\n                while True:\n                    # Sample in unit ball, scale by ellipsoid axes + translate by center\n                    rand_dir = np.random.normal(size=dim)\n                    rand_dir /= np.linalg.norm(rand_dir)\n                    rand_radius = np.random.uniform(0, 1) ** (1 / dim)\n                    sample_np = x_center + rand_dir * rand_radius * np.array(sampling_ellipsoid_axes)\n                    sample = tuple(sample_np)\n                    if within_bounds(sample):\n                        break\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if not within_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=0.5):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.children.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Find nearby nodes for rewiring\n            near_nodes = [node for node in nodes if node is not new_node and dist(node.position, new_node.position) <= self.neighbor_radius]\n\n            # Choose best parent among near nodes including current parent\n            min_cost = new_node.cost\n            min_parent = nearest_node\n            for near in near_nodes:\n                if self._is_edge_in_obstacle(near.position, new_node.position, obstacles, is_3d, resolution=0.5):\n                    continue\n                cost_through_near = near.cost + dist(near.position, new_node.position)\n                if cost_through_near < min_cost:\n                    min_cost = cost_through_near\n                    min_parent = near\n            if min_parent != nearest_node:\n                new_node.parent.children.remove(new_node)\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.children.append(new_node)\n\n            # Rewire near nodes if better through new_node\n            for near in near_nodes:\n                if near == new_node.parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d, resolution=0.5):\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    near.update_parent(new_node, cost_through_new)\n\n            # Check goal reach condition with final connection\n            if dist(new_node.position, goal_pos) <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d, resolution=0.5)\n                        and not self._is_in_obstacle(goal_pos, obstacles, is_3d)):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist(new_node.position, goal_pos))\n                    new_node.children.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    goal_reached_node = goal_node\n                    # Update ellipsoid axes for informed sampling\n                    c_min = dist(start_pos, goal_pos)\n                    path_length = goal_reached_node.cost\n                    # Shrink ellipsoid axes to current best cost/2\n                    factor = path_length / 2 if path_length > c_min else c_min / 2\n                    sampling_ellipsoid_axes = [factor for _ in range(dim)]\n                    x_center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n                    break\n\n        success = goal_reached_node is not None\n        extracted_path = goal_reached_node.path_from_root() if success else []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True               # Validity flag (e.g., collision)\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1,\n                 neighbor_factor: float = 2.5, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        import math\n        import random\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n        center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n\n        def _rotation_matrix():\n            if np is None:\n                return None\n            a1 = [(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_position, goal_position)]\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s_], [s_, c]])\n            else:\n                a1v = np.array(a1)\n                eye = np.eye(3)\n                v = np.cross([1, 0, 0], a1v)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c = np.dot([1, 0, 0], a1v)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                R = eye + vx + (vx @ vx) * ((1 - c) / (s_ ** 2))\n                return R\n\n        rotation = _rotation_matrix()\n\n        def informed_sample():\n            r1 = c_best / 2\n            if c_best**2 - c_min**2 > 0:\n                r2 = math.sqrt(c_best**2 - c_min**2) / 2\n            else:\n                r2 = 0\n\n            while True:\n                if dim == 2:\n                    if np is None:\n                        # fallback uniform sample since no numpy\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                        if not self._is_in_obstacle(pt, obstacles, is_3d):\n                            return pt\n                    else:\n                        theta = random.uniform(0, 2 * math.pi)\n                        radius = math.sqrt(random.uniform(0, 1))\n                        sample_unit = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                        sample_ellipsoid = np.array([r1, r2]) * sample_unit\n                        if rotation is not None:\n                            sample_world = rotation @ sample_ellipsoid + np.array(center)\n                        else:\n                            sample_world = np.array(center) + sample_ellipsoid\n                        p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                        if not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n                else:\n                    if np is None:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                        if not self._is_in_obstacle(pt, obstacles, is_3d):\n                            return pt\n                    else:\n                        while True:\n                            sample_unit = np.random.uniform(-1, 1, 3)\n                            if np.linalg.norm(sample_unit) <= 1:\n                                break\n                        sample_ellipsoid = np.array([r1, r2, r2]) * sample_unit\n                        if rotation is not None:\n                            sample_world = rotation @ sample_ellipsoid + np.array(center)\n                        else:\n                            sample_world = np.array(center) + sample_ellipsoid\n                        p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                        if not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        for _ in range(self.max_iter):\n            # Sampling with bias towards goal and informed region\n            if c_best < float('inf') and random.random() < (1 - self.goal_sample_rate):\n                sample = informed_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position\n                else:\n                    sample = sample_free()\n\n            # Nearest node search\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer towards the sample by step size\n            vect = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            scale = min(self.step_size, dist_to_sample)\n            unit_vect = tuple(v / dist_to_sample for v in vect)\n            new_pos = tuple(\n                max(0, min(nearest_node.position[d] + unit_vect[d] * scale, bounds[d])) for d in range(dim)\n            )\n\n            # Validate new node position\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Dynamic neighbor radius for rewiring: gamma * (log(n)/n)^{1/dim}\n            gamma = self.neighbor_factor\n            unit_ball_vol = math.pi if dim == 2 else 4/3 * math.pi\n            radius = min(self.step_size,\n                         gamma * ((math.log(len(nodes)) / len(nodes)) ** (1/dim)))\n\n            # Find neighbors inside radius\n            near_nodes = [node for node in nodes if node != new_node and math.dist(node.position, new_node.position) <= radius]\n\n            # Choose best parent for new_node from neighbors\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n\n            for near in near_nodes:\n                cost_through_near = near.cost + math.dist(near.position, new_node.position)\n                if cost_through_near < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_node.position, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost_through_near\n                        min_parent = near\n\n            if min_parent != new_node.parent:\n                try:\n                    new_node.parent.children.remove(new_node)\n                    edges.remove((new_node.parent, new_node))\n                except (ValueError, AttributeError):\n                    pass\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                edges.append((min_parent, new_node))\n\n            # Rewire near nodes if beneficial to connect through new_node\n            for near in near_nodes:\n                if near == min_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                        try:\n                            if near.parent:\n                                near.parent.children.remove(near)\n                                edges.remove((near.parent, near))\n                        except (ValueError, AttributeError):\n                            pass\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Check if close to goal for connection\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d, self.collision_resolution)\n                    and not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n\n                    # Extract path by backtracking\n                    path = []\n                    curr = goal_node\n                    while curr:\n                        path.append(curr.position)\n                        curr = curr.parent\n                    extracted_path = path[::-1]\n\n                    # Update best cost bound for ellipsoid sampling\n                    c_best = goal_node.cost\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False"
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "This hybrid planner combines goal-biased informed sampling with bidirectional RRT* style growth and dynamic rewiring. It maintains two trees grown from start and goal positions respectively, alternating expansions and incremental connect-and-rewire steps to efficiently explore the space. The sampling is guided by an ellipsoidal informed region after the first solution, focusing search and improving convergence speed. The planner uses adaptive neighbor radius recalculated per iteration for rewiring to optimize path cost continuously. Path smoothing is performed at the end to enhance smoothness and reduce unnecessary waypoints. Robust collision and edge validity checks ensure feasible expansions within bounds.",
            "planning_mechanism": "The planner alternates expansions of start and goal trees by sampling informed points biased toward the current best path. Each expansion attempts to connect the opposite tree via incremental steps and performs rewiring on neighborhood nodes to optimize the tree costs. Once a path is found, it extracts and smooths the path before returning. The informed sampler shrinks the ellipsoidal sampling domain as better returns are found, focusing effort on promising regions.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position              # Tuple[float,...] (2D/3D)\n        self.parent = parent                  # Node or None\n        self.cost = cost                      # Path cost from root\n        self.children = []\n        self.valid = True                     # Validity flag (collision-free)\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 5.0, neighbor_factor: float = 2.5,\n                 goal_sample_rate: float = 0.1, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_factor = neighbor_factor\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        import math\n        import random\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos, step):\n            distance = dist(from_pos, to_pos)\n            if distance <= step:\n                return to_pos\n            ratio = step / distance\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        # Rotation matrix from unit vector a1 to x-axis (for informed sampling)\n        def _rotation_matrix():\n            if np is None:\n                return None\n            a1 = [(g - s) / c_min if c_min > 1e-9 else 1.0 for s, g in zip(start_pos, goal_pos)]\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s_],[s_, c]])\n            else:\n                a1v = np.array(a1)\n                eye = np.eye(3)\n                v = np.cross([1,0,0], a1v)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-9:\n                    return eye\n                c = np.dot([1,0,0], a1v)\n                vx = np.array([[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]])\n                R = eye + vx + (vx @ vx) * ((1 - c)/(s_**2))\n                return R\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        center = tuple((s + g)/2 for s,g in zip(start_pos, goal_pos))\n        rotation = _rotation_matrix() if np else None\n\n        def informed_sample():\n            if np is None or c_best == float('inf'):\n                # fallback uniform sampling inside bounds\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n            r1 = c_best / 2.0\n            if c_best**2 - c_min**2 > 0:\n                r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n            else:\n                r2 = 0.0\n            while True:\n                if dim == 2:\n                    theta = random.uniform(0, 2 * math.pi)\n                    radius = math.sqrt(random.uniform(0,1))\n                    unit_sample = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                    sample_ellipsoid = np.array([r1, r2]) * unit_sample\n                    if rotation is not None:\n                        sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    else:\n                        sample_world = np.array(center) + sample_ellipsoid\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                else:\n                    # 3D sampling inside unit ball\n                    while True:\n                        unit_sample = np.random.uniform(-1, 1, 3)\n                        if np.linalg.norm(unit_sample) <= 1:\n                            break\n                    sample_ellipsoid = np.array([r1, r2, r2]) * unit_sample\n                    if rotation is not None:\n                        sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    else:\n                        sample_world = np.array(center) + sample_ellipsoid\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        # Initialize trees and data\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        edges = []\n        path_found = False\n        best_goal_node = None\n\n        def nearest_node(tree, pos):\n            return min(tree, key=lambda n: dist(n.position, pos))\n\n        def get_near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def try_connect(tree_from, tree_to, new_node, radius):\n            # Incremental connect and rewire from new_node towards nearest in tree_to within radius\n            # Returns connected goal node if success else None\n            connected_goal_node = None\n            nearest_in_to = nearest_node(tree_to, new_node.position)\n            direction = tuple(nearest_in_to.position[d] - new_node.position[d] for d in range(dim))\n            dist_to_nearest = dist(new_node.position, nearest_in_to.position)\n            steps = max(1, int(dist_to_nearest / self.step_size))\n\n            last_node = new_node\n            for i in range(1, steps + 1):\n                interm_pos = tuple(new_node.position[d] + direction[d]* i/steps for d in range(dim))\n                if not within_bounds(interm_pos):\n                    return None\n                if self._is_in_obstacle(interm_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, interm_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n                new_cost = last_node.cost + dist(last_node.position, interm_pos)\n                interm_node = Node(interm_pos, parent=last_node, cost=new_cost)\n                last_node.add_child(interm_node)\n                tree_from.append(interm_node)\n                edges.append((last_node, interm_node))\n\n                # Rewire near nodes around interm_node\n                neighbor_radius = min(self.step_size,\n                                      self.neighbor_factor * ((math.log(len(tree_from)) / len(tree_from)) ** (1/dim)))\n                near_nodes = get_near_nodes(tree_from, interm_node.position, neighbor_radius)\n                for near in near_nodes:\n                    if near == interm_node.parent:\n                        continue\n                    if self._is_edge_in_obstacle(interm_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                        continue\n                    cost_through_interm = interm_node.cost + dist(interm_node.position, near.position)\n                    if cost_through_interm < near.cost:\n                        near.update_parent(interm_node, cost_through_interm)\n\n                last_node = interm_node\n\n            # Final connection to nearest_in_to node\n            if (self._is_edge_in_obstacle(last_node.position, nearest_in_to.position, obstacles, is_3d, self.collision_resolution)\n                    or self._is_in_obstacle(nearest_in_to.position, obstacles, is_3d)):\n                return None\n            cost_connect = last_node.cost + dist(last_node.position, nearest_in_to.position)\n            connect_node = Node(nearest_in_to.position, parent=last_node, cost=cost_connect)\n            last_node.add_child(connect_node)\n            tree_from.append(connect_node)\n            edges.append((last_node, connect_node))\n\n            # Rewire near nodes in tree_from around connect_node\n            neighbor_radius = min(self.step_size,\n                                  self.neighbor_factor * ((math.log(len(tree_from)) / len(tree_from)) ** (1/dim)))\n            near_nodes = get_near_nodes(tree_from, connect_node.position, neighbor_radius)\n            for near in near_nodes:\n                if near == connect_node.parent:\n                    continue\n                if self._is_edge_in_obstacle(connect_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                    continue\n                cost_through_connect = connect_node.cost + dist(connect_node.position, near.position)\n                if cost_through_connect < near.cost:\n                    near.update_parent(connect_node, cost_through_connect)\n\n            return connect_node\n\n        # Main loop alternating expansions of start and goal trees\n        for it in range(self.max_iter):\n            # Alternate trees\n            if it % 2 == 0:\n                tree_from = start_tree\n                tree_to = goal_tree\n            else:\n                tree_from = goal_tree\n                tree_to = start_tree\n\n            # Sample point\n            if c_best < float('inf') and random.random() > self.goal_sample_rate:\n                sample = informed_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if tree_from is start_tree else start_pos\n                else:\n                    sample = sample_free()\n\n            # Nearest node in tree_from\n            nearest = nearest_node(tree_from, sample)\n\n            # Steer towards sample\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if not within_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_from.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Dynamic neighbor radius for rewiring\n            neighbor_radius = min(self.step_size,\n                                  self.neighbor_factor * ((math.log(len(tree_from)) / len(tree_from)) ** (1/dim)))\n\n            # Find neighbors to possibly rewire\n            near_nodes = get_near_nodes(tree_from, new_node.position, neighbor_radius)\n\n            # Choose best parent among near nodes (including current)\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n            for near in near_nodes:\n                if self._is_edge_in_obstacle(near.position, new_node.position, obstacles, is_3d, self.collision_resolution):\n                    continue\n                cost_through_near = near.cost + dist(near.position, new_node.position)\n                if cost_through_near < min_cost:\n                    min_cost = cost_through_near\n                    min_parent = near\n            if min_parent != new_node.parent:\n                try:\n                    new_node.parent.children.remove(new_node)\n                    edges.remove((new_node.parent, new_node))\n                except (ValueError, AttributeError):\n                    pass\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                edges.append((min_parent, new_node))\n\n            # Rewire neighbors if shorter through new_node\n            for near in near_nodes:\n                if near == min_parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d, self.collision_resolution):\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    try:\n                        if near.parent:\n                            near.parent.children.remove(near)\n                            edges.remove((near.parent, near))\n                    except (ValueError, AttributeError):\n                        pass\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            # Try to connect tree_from's new_node to tree_to\n            connect_node = try_connect(tree_from, tree_to, new_node, neighbor_radius)\n            if connect_node is not None:\n                # Path found, extract full path\n                if tree_from is start_tree:\n                    path_start = connect_node.path_from_root()\n                    # Corresponding node in tree_to has same position as connect_node.parent or connect_node itself at connection point\n                    # Find corresponding node in tree_to for path merging\n                    counterpart = nearest_node(tree_to, connect_node.position)\n                    path_goal = counterpart.path_from_root()\n                    path_goal.reverse()\n                    full_path = path_start + path_goal[1:]\n                    cost_path = connect_node.cost + counterpart.cost\n                else:\n                    path_start = nearest_node(tree_to, connect_node.position).path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    path_goal.reverse()\n                    full_path = path_start + path_goal[1:]\n                    cost_path = connect_node.cost + nearest_node(tree_to, connect_node.position).cost\n\n                # Update best solution\n                if cost_path < c_best:\n                    c_best = cost_path\n                    best_goal_node = connect_node if tree_from is start_tree else nearest_node(tree_to, connect_node.position)\n                    extracted_path = full_path\n                    path_found = True\n                    center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n                    # update rotation for informed sampling to bias future samples\n                    rotation = _rotation_matrix() if np else None\n\n                # Optional early stop to allow better rewiring in remaining iterations or break immediately\n                # Here break on first found path for planning efficiency\n                break\n\n        # If found path, apply simple path smoothing by shortcuts along path\n        def path_smoothing(path, iterations=30):\n            if len(path) < 3:\n                return path\n            for _ in range(iterations):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path)-1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.collision_resolution):\n                    # shortcut path between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        if path_found:\n            extracted_path = path_smoothing(extracted_path, iterations=40)\n\n        # Combine all nodes from both trees and edges\n        all_nodes = start_tree + [n for n in goal_tree if n not in start_tree]\n\n        return PlannerResult(\n            success=path_found,\n            path=extracted_path if path_found else [],\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": 3.56739,
            "time_improvement": -32.0,
            "length_improvement": 12.0,
            "smoothness_improvement": 729.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015814971923828126,
                    "num_nodes_avg": 92.2,
                    "path_length_avg": 164.28036986617082,
                    "smoothness_avg": 0.023170487001020087,
                    "success_improvement": 0.0,
                    "time_improvement": 36.54458575876863,
                    "length_improvement": 9.955326087305531,
                    "smoothness_improvement": 262.66843708381487,
                    "objective_score": 14.26778313051077
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.10339927673339844,
                    "num_nodes_avg": 621.6,
                    "path_length_avg": 246.6354463547729,
                    "smoothness_avg": 0.038038996749436046,
                    "success_improvement": 0.0,
                    "time_improvement": 36.02248907874998,
                    "length_improvement": 17.66598899906865,
                    "smoothness_improvement": 878.7707847448972,
                    "objective_score": 18.73379844716321
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.13381729125976563,
                    "num_nodes_avg": 728.5,
                    "path_length_avg": 137.74339529427704,
                    "smoothness_avg": 0.09003650182892373,
                    "success_improvement": 0.0,
                    "time_improvement": -168.77844219043237,
                    "length_improvement": 8.51739548117924,
                    "smoothness_improvement": 1045.257657460649,
                    "objective_score": -43.70376527359062
                }
            ],
            "success_rate": 1.0
        },
        "objective": 253.39999999999998,
        "analysis": "1. Summary of key changes:\n   - Introduction of a more sophisticated informed sampling strategy using ellipsoidal regions aligned and scaled based on current best path cost and start-goal distance.\n   - Dynamic neighbor radius calculation for rewiring based on the number of nodes and problem dimensionality, replacing a fixed radius.\n   - Enhanced rewiring logic with careful checks for obstacle collisions before changing parents, including safe removal and addition of edges and children.\n   - Improved handling of goal connection and path extraction with early break after finding a better path.\n   - Incorporation of numpy-based operations for rotation matrices and sampling, enabling more precise and efficient sampling in ellipsoidal regions.\n   - Better defined node class with explicit methods for child management, parent updates, and cost management.\n   - More robust collision checking with adjustable resolution within edge checks.\n   - Inclusion of path smoothing by incremental iteration with iteration limits and sampling strategies adapted during the planning process.\n\n2. Primary contributors to the performance improvement:\n   - Ellipsoidal informed sampling that focuses samples in the region likely to yield better solutions rather than uniform random sampling.\n   - Adaptive neighbor radius that scales with the logarithm of the number of nodes and dimension to optimize rewiring effectiveness.\n   - Effective rewiring with collision checks leading to lower cost paths and adaptive parent-child relationships.\n   - Use of linear algebra (numpy) for efficient geometric computations allowing precise rotations and sampling.\n   - Early termination upon reaching goals and dynamically shrinking sampling region to concentrate computational efforts.\n\n3. Expected mechanism of impact:\n   - Ellipsoidal informed sampling reduces the search space and concentrates exploration around the most promising regions, increasing the chance of discovering optimal or near-optimal paths faster.\n   - The adaptive neighbor radius optimizes the balance between exploration and exploitation during rewiring, enhancing the planner\u2019s ability to improve path quality.\n   - Careful rewiring reduces redundant or costly path segments and promotes the construction of lower-cost trees.\n   - Utilizing efficient sampling and rotation computations speeds up calculations and improves numerical accuracy in sampling.\n   - Early goal connections and path extraction reduce unnecessary iterations and refine the path, improving convergence speed and solution quality."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost to this node\n        self.children = []\n        self.valid = True               # Validity flag\n    \n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n    \n    def path_from_root(self):\n        node, path = self, []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, goal_sample_rate: float = 0.1,\n                 initial_neighbor_radius: float = 20.0, min_neighbor_radius: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.initial_neighbor_radius = initial_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = [Node(start_pos, cost=0.0)]\n        edges = []\n        goal_node = None\n\n        def neighbor_radius(iteration):\n            # Decrease neighbor radius as iterations increase, but not below min_neighbor_radius\n            decay = max(self.min_neighbor_radius,\n                        self.initial_neighbor_radius * ((1 - iteration / self.max_iter) ** 0.5))\n            return decay\n\n        for i in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Find nearest node\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            vec = tuple(sample[d] - nearest.position[d] for d in range(dim))\n            dist_sample = math.dist(nearest.position, sample)\n            if dist_sample == 0:\n                continue\n            unit_vec = tuple(v / dist_sample for v in vec)\n            step_len = min(self.step_size, dist_sample)\n            new_pos = tuple(nearest.position[d] + unit_vec[d] * step_len for d in range(dim))\n\n            # Check bounds\n            if not all(0 <= new_pos[d] <= bounds[d] for d in range(dim)):\n                continue\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Edge collision check\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors using adaptive radius\n            radius = neighbor_radius(i)\n            near_nodes = [node for node in nodes if node is not nearest and math.dist(node.position, new_pos) <= radius]\n\n            # Choose best parent minimizing cost\n            best_parent = nearest\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                cost_through_near = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_through_near < min_cost:\n                    best_parent = near_node\n                    min_cost = cost_through_near\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost improves\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if near_node.parent:\n                        try:\n                            near_node.parent.children.remove(near_node)\n                            edges.remove((near_node.parent, near_node))\n                        except (ValueError, IndexError):\n                            pass\n                    near_node.update_parent(new_node, new_cost)\n                    edges.append((new_node, near_node))\n\n            # Check if close enough to goal to connect\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_in_obstacle(goal_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos)\n                    goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    break\n\n        success = goal_node is not None\n        if success:\n            extracted_path = goal_node.path_from_root()\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float=5.0, neighbor_factor: float=2.5,\n                 collision_resolution: float=0.3, goal_sample_rate: float=0.1, smoothing_iterations: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n        self.goal_sample_rate = goal_sample_rate\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of rectangular obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n        center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n\n        # Rotation matrix for ellipsoid sampling aligned with start-goal axis\n        def _rotation_matrix():\n            if np is None:\n                return None\n            a1 = np.array([(g - s) / c_min if c_min > 1e-6 else 1.0 for s, g in zip(start_position, goal_position)])\n            if dim == 2:\n                angle = math.atan2(a1[1], a1[0])\n                c, s_ = math.cos(angle), math.sin(angle)\n                return np.array([[c, -s_], [s_, c]])\n            else:\n                eye = np.eye(3)\n                v = np.cross(np.array([1,0,0]), a1)\n                s_ = np.linalg.norm(v)\n                if s_ < 1e-6:\n                    return eye\n                c = np.dot(np.array([1,0,0]), a1)\n                vx = np.array([[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]])\n                return eye + vx + (vx @ vx) * ((1 - c) / (s_ ** 2))\n\n        rotation = _rotation_matrix()\n\n        def _informed_sample():\n            # Ellipsoidal informed sampling within bounds and obstacles\n            if c_best == float('inf'):\n                # No solution yet, fallback to global uniform sampling\n                return _sample_free()\n            r1 = c_best / 2\n            r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2\n            while True:\n                if dim == 2:\n                    theta = random.uniform(0, 2*math.pi)\n                    radius = math.sqrt(random.uniform(0,1))\n                    unit_vector = np.array([radius * math.cos(theta), radius * math.sin(theta)])\n                    sample_ellipsoid = np.array([r1, r2]) * unit_vector\n                    if rotation is not None:\n                        sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    else:\n                        sample_world = sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n                else:\n                    while True:\n                        unit_vector = np.random.uniform(-1,1,3)\n                        if np.linalg.norm(unit_vector) <= 1:\n                            break\n                    sample_ellipsoid = np.array([r1, r2, r2]) * unit_vector\n                    if rotation is not None:\n                        sample_world = rotation @ sample_ellipsoid + np.array(center)\n                    else:\n                        sample_world = sample_ellipsoid + np.array(center)\n                    p = tuple(np.clip(sample_world, [0]*dim, bounds))\n\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def _steer(from_pos, to_pos):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            dist = math.dist(from_pos, to_pos)\n            if dist == 0:\n                return from_pos\n            scale = min(self.step_size, dist)\n            unit_dir = tuple(direction[d] / dist for d in range(dim))\n            new_pt = tuple(max(0, min(from_pos[d] + unit_dir[d]*scale, bounds[d])) for d in range(dim))\n            return new_pt\n\n        def _near_nodes(new_node):\n            # Adaptive neighbor radius based on node density\n            n = len(nodes)\n            if n <= 1:\n                return []\n            radius = self.neighbor_factor * ((math.log(n) / n) ** (1.0/dim))\n            # Clamp radius between step_size and 3*step_size for better rewiring stability\n            radius = max(self.step_size, min(radius, 3*self.step_size))\n            nearlist = [node for node in nodes if node != new_node and math.dist(node.position, new_node.position) <= radius]\n            return nearlist\n\n        def _extract_path(goal_node):\n            path = []\n            current = goal_node\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            return path[::-1]\n\n        def _path_smoothing(path):\n            if len(path) < 3:\n                return path\n            smoothed = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) -1)\n                p1 = smoothed[i]\n                p2 = smoothed[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    # Shortcut by removing intermediate points\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        for iter in range(self.max_iter):\n            # Sample with goal bias + informed sampling + occasional global exploration\n            rand_val = random.random()\n            if rand_val < self.goal_sample_rate:\n                sample = goal_position\n            elif c_best < float('inf') and rand_val < 0.9:\n                sample = _informed_sample()\n            else:\n                sample = _sample_free()\n\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = _steer(nearest.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            near_nodes = _near_nodes(new_node)\n\n            # Choose best parent among near nodes\n            min_cost = new_node.cost\n            min_parent = nearest\n            for near_node in near_nodes:\n                cost_through_near = near_node.cost + math.dist(near_node.position, new_node.position)\n                if cost_through_near < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_node.position, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost_through_near\n                        min_parent = near_node\n            if min_parent != new_node.parent:\n                new_node.update_parent(min_parent, min_cost)\n                try:\n                    edges.remove((nearest, new_node))\n                except ValueError:\n                    pass\n                edges.append((min_parent, new_node))\n\n            # Rewire nodes near the new node through new_node if cheaper\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, self.collision_resolution):\n                        near_node.update_parent(new_node, cost_through_new)\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except (ValueError, AttributeError):\n                            pass\n                        edges.append((new_node, near_node))\n\n            dist_goal = math.dist(new_node.position, goal_position)\n            if dist_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d, self.collision_resolution) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n\n                    path = _extract_path(goal_node)\n                    c_best = goal_node.cost\n                    center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n                    rotation = _rotation_matrix()\n                    extracted_path = _path_smoothing(path)\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False"
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "This algorithm is a unidirectional RRT* variant combining goal biasing, adaptive neighbor search, rewiring for path optimization, and post-planning path smoothing. It incrementally grows a single tree in the free space by sampling points mostly towards the goal and locally rewires nodes to improve path cost, while ensuring collision-free expansions and edges. After finding a path, a shortcut-based smoothing step refines path quality and smoothness.",
            "planning_mechanism": "The planner samples points biased towards the goal, steers from the nearest tree node constrained by step size, verifies node and edge collision-free validity, selects the best parent among nearby nodes reachable with lower cost, then rewires neighbors through the new node to reduce path costs. Upon reaching near the goal, it extracts the path and performs iterative shortcut smoothing to improve smoothness and length.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float = 0.1,\n                 neighbor_radius_factor: float = 2.0, smoothing_iters: int = 50,\n                 collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.smoothing_iters = smoothing_iters\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                      # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start             # Tuple[float, ...]\n        goal_position = map.goal               # Tuple[float, ...]\n        obstacles = map.obstacles              # List of rectangular obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_position, None, 0.0)\n        nodes.append(root)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            dist = math.dist(from_pos, to_pos)\n            if dist == 0:\n                return from_pos\n            scale = min(self.step_size, dist)\n            unit_dir = tuple(direction[d] / dist for d in range(dim))\n            new_pt = tuple(from_pos[d] + unit_dir[d]*scale for d in range(dim))\n            # Clamp within bounds\n            clamped = tuple(min(max(new_pt[d], 0), bounds[d]) for d in range(dim))\n            return clamped\n\n        def get_near_nodes(new_node):\n            n = len(nodes)\n            if n <= 1:\n                return []\n            radius = self.neighbor_radius_factor * ((math.log(n) / n) ** (1.0/dim))\n            # Clamp radius to reasonable range [step_size, 3 * step_size]\n            radius = max(self.step_size, min(radius, 3 * self.step_size))\n            near_nodes = [node for node in nodes if node != new_node and math.dist(node.position, new_node.position) <= radius]\n            return near_nodes\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = path[:]\n            for _ in range(self.smoothing_iters):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) -1)\n                p1 = smoothed[i]\n                p2 = smoothed[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        success = False\n        extracted_path: List[Tuple[float, ...]] = []\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            sample = sample_free()\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n\n            near_nodes = get_near_nodes(new_node)\n\n            # Choose best parent among near nodes\n            min_cost = new_cost\n            min_parent = nearest\n            for near_node in near_nodes:\n                cost_through_near = near_node.cost + math.dist(near_node.position, new_node.position)\n                if cost_through_near < min_cost:\n                    if (not self._is_edge_in_obstacle(near_node.position, new_node.position, obstacles, is_3d, self.collision_resolution)\n                    and not self._is_in_obstacle(new_node.position, obstacles, is_3d)):\n                        min_cost = cost_through_near\n                        min_parent = near_node\n            if min_parent != new_node.parent:\n                new_node.update_parent(min_parent, min_cost)\n\n            nodes.append(new_node)\n            edges.append((new_node.parent, new_node))\n\n            # Rewire neighbors through new node if cheaper\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if (not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, self.collision_resolution)\n                    and not self._is_in_obstacle(near_node.position, obstacles, is_3d)):\n                        old_parent = near_node.parent\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n                        if old_parent is not None:\n                            try:\n                                edges.remove((old_parent, near_node))\n                            except ValueError:\n                                pass\n\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d, self.collision_resolution)\n                    and not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position, new_node, new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success = True\n                    extracted_path = smooth_path(goal_node.path_from_root())\n                    break\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": 55.07973,
            "time_improvement": -212.0,
            "length_improvement": 14.0,
            "smoothness_improvement": 1161.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.08290293216705322,
                    "num_nodes_avg": 338.4,
                    "path_length_avg": 173.27420760865655,
                    "smoothness_avg": 0.034201947019211795,
                    "success_improvement": 0.0,
                    "time_improvement": -232.63668932266376,
                    "length_improvement": 5.02566110417002,
                    "smoothness_improvement": 435.3347415673609,
                    "objective_score": -66.60920086812833
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.27761938571929934,
                    "num_nodes_avg": 893.1,
                    "path_length_avg": 238.9802557610417,
                    "smoothness_avg": 0.08414581084828399,
                    "success_improvement": 0.0,
                    "time_improvement": -71.77486964055507,
                    "length_improvement": 20.221511961700152,
                    "smoothness_improvement": 2065.132320904116,
                    "objective_score": -7.1624968953059085
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.21509213447570802,
                    "num_nodes_avg": 740.7,
                    "path_length_avg": 126.31603938261885,
                    "smoothness_avg": 0.08518901475173495,
                    "success_improvement": 0.0,
                    "time_improvement": -332.02285958375217,
                    "length_improvement": 16.106901165488942,
                    "smoothness_improvement": 983.5979796430843,
                    "objective_score": -91.46748774381243
                }
            ],
            "success_rate": 1.0
        },
        "objective": 633.4,
        "analysis": "1. Summary of key changes:\n   - Added collision validity flag (`self.valid = True`) to Node.\n   - Enhanced Node parent-child management with explicit `remove_child` and better `update_parent` logic.\n   - Introduced informed sampling with ellipsoidal sampling aligned between start and goal positions.\n   - Added adaptive neighbor radius calculation based on node density with radius clamping.\n   - Implemented path smoothing post initial solution using random shortcutting that respects collision constraints.\n   - Increased iteration limit and step size, and introduced parameters for neighbor factor, collision resolution, and smoothing iterations.\n   - Utilized numpy for efficient vector/matrix operations including rotation matrices in informed sampling.\n   - Improved sampling strategy combining goal bias, informed sampling, and global uniform samples.\n   - More robust and clear rewiring logic with improved edge and node update handling.\n\n2. Primary contributors to the performance improvement:\n   - Ellipsoidal informed sampling focused in promising regions reducing unnecessary exploration.\n   - Adaptive neighbor radius improving efficient rewiring and connectivity.\n   - Path smoothing that reduces unnecessary detours, yielding shorter and smoother paths.\n   - Enhanced node parent-child management ensuring integrity and correctness during rewiring.\n   - Better collision checking with adjusted resolution parameters improving safety and precision.\n\n3. Expected mechanism of impact:\n   - Informed sampling accelerates convergence by sampling more likely feasible and optimal regions.\n   - Adaptive radius balances exploration and rewiring complexity, optimizing time and quality trade-offs.\n   - Path smoothing removes redundant waypoints, improving path quality without extra search.\n   - Robust tree structure updates prevent errors or inconsistencies that could degrade path validity.\n   - Fine-tuned collision resolution prevents false positives/negatives, ensuring feasible path discovery."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # Validity flag (collision-free)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if (\n                not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, new_node):\n            nearest_node = nearest(tree, new_node.position)\n            pos_new = new_node.position\n            if (\n                math.dist(nearest_node.position, pos_new) <= self.step_size and\n                not self._is_edge_in_obstacle(nearest_node.position, pos_new, obstacles, is_3d) and\n                not self._is_in_obstacle(pos_new, obstacles, is_3d)\n            ):\n                return nearest_node\n            return None\n\n        for iter_num in range(self.max_iter):\n            rand_point = sample_free()\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            connect_node_goal = try_connect(tree_goal, new_node_start)\n            if connect_node_goal:\n                # Connect by creating a new node in goal tree near new_node_start\n                new_node_goal = Node(new_node_start.position)\n                best_parent = connect_node_goal\n                neighbors = near_nodes(tree_goal, new_node_goal.position)\n\n                min_cost = best_parent.cost + math.dist(best_parent.position, new_node_goal.position)\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_node_goal.position)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_node_goal.position, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                best_parent.add_child(new_node_goal)\n                new_node_goal.cost = min_cost\n                tree_goal.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((best_parent, new_node_goal))\n\n                # Extract path from start root to new_node_start\n                path_start = new_node_start.path_from_root()\n                # Extract path from goal root to new_node_goal\n                path_goal = new_node_goal.path_from_root()\n                # Connect paths\n                extracted_path = path_start + path_goal[::-1][1:]  # Avoid duplicate node\n                success_state = True\n                break\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))"
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "This improved planner employs bidirectional RRT* with adaptive rewiring and goal biasing strategies. It grows two trees from start and goal positions alternately, samples points with bias toward the goal, and uses a fixed neighbor radius for efficient rewiring, enabling faster convergence and better path optimization. Collision checks are rigorously applied for nodes and edges to guarantee feasible paths. The rewiring step ensures smoother and lower-cost paths dynamically, while incremental connections accelerate success detection and reduce planning time. The planner parameters are tuned for balanced exploration and exploitation to optimize success rate and path quality.",
            "planning_mechanism": "The planner samples random points favoring the goal, extends both start and goal trees toward these samples by a fixed step size, and rewires nearby nodes to minimize path cost while maintaining collision-free constraints. It frequently attempts to connect the two trees incrementally. The bidirectional growth with rewiring and goal biasing greatly reduces the search space and time, improves path smoothness and length, and robustly avoids obstacles through continuous validation during expansion and connection.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample_free():\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            for _ in range(100):  # limit retries for efficiency\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if (not self._is_in_obstacle(p, obstacles, is_3d)):\n                    return p\n            return goal_position  # fallback\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            radius_sq = self.neighbor_radius * self.neighbor_radius\n            return [n for n in tree if (math.dist(n.position, position) ** 2) <= radius_sq]\n\n        def valid_new_node(pos, obstacles, is_3d):\n            return (self._within_bounds(pos, bounds) and\n                    not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def try_extend_and_rewire(tree, other_tree, sample_point):\n            nearest_node = nearest(tree, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n\n            if (not valid_new_node(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                edge_dist = math.dist(neighbor.position, new_pos)\n                cost_try = neighbor.cost + edge_dist\n                if cost_try < min_cost:\n                    # Check edge collision\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_try\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        new_node.add_child(neighbor)\n                        neighbor.cost = new_cost\n                        edges.append((new_node, neighbor))\n\n            # Try to connect to the other tree\n            connection_node = try_connect(other_tree, new_node)\n            if connection_node:\n                # Create a connecting node in the other tree at new_node's position, with rewiring\n                connecting_neighbors = near_nodes(other_tree, new_node.position)\n                min_conn_cost = connection_node.cost + math.dist(connection_node.position, new_node.position)\n                best_conn_parent = connection_node\n                for neighbor in connecting_neighbors:\n                    edge_dist = math.dist(neighbor.position, new_node.position)\n                    cost_try = neighbor.cost + edge_dist\n                    if cost_try < min_conn_cost:\n                        if not self._is_edge_in_obstacle(neighbor.position, new_node.position, obstacles, is_3d):\n                            min_conn_cost = cost_try\n                            best_conn_parent = neighbor\n\n                new_node_other = Node(new_node.position)\n                best_conn_parent.add_child(new_node_other)\n                new_node_other.cost = min_conn_cost\n                other_tree.append(new_node_other)\n                nodes.append(new_node_other)\n                edges.append((best_conn_parent, new_node_other))\n\n                # Rewire in other tree through new_node_other\n                for neighbor in connecting_neighbors:\n                    if neighbor == best_conn_parent:\n                        continue\n                    cost_via_new = new_node_other.cost + math.dist(new_node_other.position, neighbor.position)\n                    if cost_via_new < neighbor.cost:\n                        if not self._is_edge_in_obstacle(new_node_other.position, neighbor.position, obstacles, is_3d):\n                            if neighbor.parent:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            new_node_other.add_child(neighbor)\n                            neighbor.cost = cost_via_new\n                            edges.append((new_node_other, neighbor))\n\n                # Extract combined path: start root to new_node, and goal root to new_node_other, reversed\n                path_start = new_node.path_from_root()\n                path_goal = new_node_other.path_from_root()\n                extracted = path_start + path_goal[::-1][1:]  # remove duplicate connecting node\n                return extracted\n            return None\n\n        def try_connect(tree, node):\n            # Find nearest node in tree to node.position that can connect within step_size and collision free edge\n            nearest_node = nearest(tree, node.position)\n            if math.dist(nearest_node.position, node.position) <= self.step_size:\n                # Node position collision and edge collision checked outside usually, but safe to check here too:\n                if (not self._is_in_obstacle(node.position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(nearest_node.position, node.position, obstacles, is_3d)):\n                    return nearest_node\n            return None\n\n        # Main loop: alternate expansions from start and goal trees\n        for iter_num in range(self.max_iter):\n            sample = sample_free()\n            # First extend start tree toward sample, then goal tree toward start tree's new node and vice versa\n            extracted_path = try_extend_and_rewire(tree_start, tree_goal, sample)\n            if extracted_path:\n                success_state = True\n                break\n            # Swap trees\n            tree_start, tree_goal = tree_goal, tree_start\n\n        if success_state:\n            return PlannerResult(\n                success=True,\n                path=extracted_path,\n                nodes=nodes,\n                edges=edges,\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges,\n            )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
            "objective": 3.74921,
            "time_improvement": -31.0,
            "length_improvement": 17.0,
            "smoothness_improvement": 449.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.052749800682067874,
                    "num_nodes_avg": 179.5,
                    "path_length_avg": 167.67689676740173,
                    "smoothness_avg": 0.029109394951206242,
                    "success_improvement": 0.0,
                    "time_improvement": -111.65136868689285,
                    "length_improvement": 8.093635871327926,
                    "smoothness_improvement": 355.6252430492584,
                    "objective_score": -30.098557216555978
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06149802207946777,
                    "num_nodes_avg": 338.4,
                    "path_length_avg": 234.39611255074652,
                    "smoothness_avg": 0.023209304182747068,
                    "success_improvement": 0.0,
                    "time_improvement": 61.9485696271455,
                    "length_improvement": 21.751830912542975,
                    "smoothness_improvement": 497.1921136081793,
                    "objective_score": 25.42089763869314
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07147982120513915,
                    "num_nodes_avg": 325.3,
                    "path_length_avg": 120.17915296485121,
                    "smoothness_avg": 0.04661454427600806,
                    "success_improvement": 0.0,
                    "time_improvement": -43.570646294679634,
                    "length_improvement": 20.182728917042017,
                    "smoothness_improvement": 492.9335624630725,
                    "objective_score": -6.569980292680125
                }
            ],
            "success_rate": 1.0
        },
        "objective": 213.79999999999998,
        "analysis": "1. Summary of key changes:\n   - Introduction of a bidirectional RRT* style planner with two trees grown from start and goal.\n   - Use of informed sampling that respects obstacles and bounds to sample free points efficiently.\n   - Implementation of rewiring neighbors to optimize path costs incrementally.\n   - Dynamic parent selection for new nodes based on minimal cumulative cost.\n   - Collision checks for nodes and edges ensuring validity in 2D or 3D space.\n   - Clear separation of node data structure with fields for parent, children, cost, validity, and position.\n   - Extraction of the final path by connecting paths from both trees once they connect.\n2. Primary contributors to the performance improvement:\n   - Bidirectional growth of trees reducing search time.\n   - Cost-based rewiring optimizing path quality dynamically.\n   - Efficient obstacle collision checks preventing invalid expansions.\n   - Goal bias sampling increasing chances of converging to the goal.\n3. Expected mechanism of impact:\n   - The bidirectional approach halves the search space and rapidly connects start to goal.\n   - Rewiring ensures continuous path refinement leading to smoother and lower-cost paths.\n   - Collision-aware sampling and edge validation reduce wasted computations on invalid paths.\n   - Sampling bias towards the goal accelerates convergence and solution discovery."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # Validity flag (collision-free)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if (\n                not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, new_node):\n            nearest_node = nearest(tree, new_node.position)\n            pos_new = new_node.position\n            if (\n                math.dist(nearest_node.position, pos_new) <= self.step_size and\n                not self._is_edge_in_obstacle(nearest_node.position, pos_new, obstacles, is_3d) and\n                not self._is_in_obstacle(pos_new, obstacles, is_3d)\n            ):\n                return nearest_node\n            return None\n\n        for iter_num in range(self.max_iter):\n            rand_point = sample_free()\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            connect_node_goal = try_connect(tree_goal, new_node_start)\n            if connect_node_goal:\n                # Connect by creating a new node in goal tree near new_node_start\n                new_node_goal = Node(new_node_start.position)\n                best_parent = connect_node_goal\n                neighbors = near_nodes(tree_goal, new_node_goal.position)\n\n                min_cost = best_parent.cost + math.dist(best_parent.position, new_node_goal.position)\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_node_goal.position)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_node_goal.position, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                best_parent.add_child(new_node_goal)\n                new_node_goal.cost = min_cost\n                tree_goal.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((best_parent, new_node_goal))\n\n                # Extract path from start root to new_node_start\n                path_start = new_node_start.path_from_root()\n                # Extract path from goal root to new_node_goal\n                path_goal = new_node_goal.path_from_root()\n                # Connect paths\n                extracted_path = path_start + path_goal[::-1][1:]  # Avoid duplicate node\n                success_state = True\n                break\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))"
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "The algorithm is a bidirectional RRT* inspired planner with enhanced efficiency through goal-biased random sampling, dynamic local rewiring during tree expansions, and incremental connection attempts between start and goal trees. It incorporates efficient nearest neighbor querying, adaptive steering with step size limits, and rigorous collision checking for node positions and edges. The rewiring optimizes cost and path quality while alternating tree expansions accelerates convergence. This leads to faster planning times, improved path smoothness, and higher success rates.",
            "planning_mechanism": "The planner grows two trees simultaneously, sampling mostly towards the goal to improve search focus. On each iteration, one tree is extended toward a sampled point with rewiring of nearby nodes to minimize cost. Then it attempts connecting the other tree to the newly added node via rewiring to form a continuous path. Collision checks ensure validity at every step. By alternating expansions and rewiring, the method quickly converges to a collision-free, optimized path between start and goal.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision validation\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            # Efficient nearest search: linear for simplicity, can be optimized with spatial indexing\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                dist = math.dist(node.position, point)\n                if dist < min_dist:\n                    min_dist = dist\n                    min_node = node\n            return min_node\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.neighbor_radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not self._within_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for neighbor in neighbors:\n                potential_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if potential_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = potential_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    # Remove old edge\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    # Re-assign parent\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, connect_to_node):\n            nearest_node = nearest(tree, connect_to_node.position)\n            dist = math.dist(nearest_node.position, connect_to_node.position)\n            if dist > self.step_size:\n                return None\n            if self._is_in_obstacle(connect_to_node.position, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, connect_to_node.position, obstacles, is_3d):\n                return None\n\n            neighbors = near_nodes(tree, connect_to_node.position)\n            min_cost = nearest_node.cost + dist\n            best_parent = nearest_node\n\n            for neighbor in neighbors:\n                potential_cost = neighbor.cost + math.dist(neighbor.position, connect_to_node.position)\n                if potential_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, connect_to_node.position, obstacles, is_3d):\n                    min_cost = potential_cost\n                    best_parent = neighbor\n\n            new_node = Node(connect_to_node.position, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        # Alternate tree expansion each iteration to balance growth\n        start_tree = tree_start\n        goal_tree = tree_goal\n\n        for i in range(self.max_iter):\n            sample = sample_free()\n            new_node_start = try_extend(start_tree, sample)\n            if new_node_start is None:\n                start_tree, goal_tree = goal_tree, start_tree\n                continue\n\n            new_node_goal = try_connect(goal_tree, new_node_start)\n            if new_node_goal:\n                # Paths connecting start_tree root to new_node_start, and goal_tree root to new_node_goal\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                path_goal.reverse()\n                extracted_path = path_start + path_goal[1:]  # Avoid duplicating connecting node\n                success_state = True\n                break\n\n            start_tree, goal_tree = goal_tree, start_tree\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
            "objective": -10.74705,
            "time_improvement": 23.0,
            "length_improvement": 14.0,
            "smoothness_improvement": 218.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021436524391174317,
                    "num_nodes_avg": 147.8,
                    "path_length_avg": 161.4200586584748,
                    "smoothness_avg": 0.018596289666266766,
                    "success_improvement": 0.0,
                    "time_improvement": 13.988874486413575,
                    "length_improvement": 11.523107984775253,
                    "smoothness_improvement": 191.07231576642934,
                    "objective_score": 7.45664552171127
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06319136619567871,
                    "num_nodes_avg": 366.1,
                    "path_length_avg": 251.15246650705654,
                    "smoothness_avg": 0.0131187349704594,
                    "success_improvement": 0.0,
                    "time_improvement": 60.90082591838002,
                    "length_improvement": 16.15807765702018,
                    "smoothness_improvement": 237.55449983278646,
                    "objective_score": 22.689635806081974
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05267148017883301,
                    "num_nodes_avg": 345.6,
                    "path_length_avg": 130.14155852635278,
                    "smoothness_avg": 0.025465211964407646,
                    "success_improvement": 0.0,
                    "time_improvement": -5.793192023664093,
                    "length_improvement": 13.566173501866952,
                    "smoothness_improvement": 223.915616540841,
                    "objective_score": 2.094855175978368
                }
            ],
            "success_rate": 1.0
        },
        "objective": 167.6,
        "analysis": "1. Summary of key changes:\n   - Implemented a `Node` class with attributes for position, parent, cost, children, and validity, enabling structured tree representation.\n   - Added methods in `Node` to manage children and extract paths from root, supporting efficient path reconstruction.\n   - Designed a bidirectional RRT* planner (`Planner` class) with methods for sampling, nearest neighbor search, steering, neighborhood querying, tree extension, and tree connection.\n   - Incorporated path cost optimization by selecting the best parent node among neighbors to minimize cost and rewiring neighbors to reduce their cost when a better path is found.\n   - Introduced obstacle collision checks for nodes and edges, including incremental edge checking for collision detection.\n   - Added goal bias in sampling to increase the efficiency of finding paths.\n   - Maintained detailed bookkeeping of nodes and edges in the planner for search and path extraction.\n   - Carefully managed tree swapping between start and goal trees during the bidirectional search.\n   - Ensured extracted path concatenation and avoidance of duplicate nodes at connection points.\n   - Embedded bounds checking for sampled and steered points to maintain search within the allowed space.\n\n2. Primary contributors to the performance improvement:\n   - Use of bidirectional RRT* with rewiring for path cost optimization.\n   - Efficient nearest and near neighbor queries supporting parent selection and rewiring.\n   - Obstacle collision and edge collision detection methods to prune invalid paths.\n   - Goal sample rate bias to speed up reaching the goal.\n   - Structured node management facilitating path reconstruction and tree maintenance.\n   - Step size and neighbor radius parameters tuned for space exploration and local optimization.\n\n3. Expected mechanism of impact:\n   - Bidirectional growth reduces the search space and time to connect start and goal.\n   - Rewiring optimizes path cost by locally improving the tree, resulting in shorter and smoother paths.\n   - Collision checks prevent invalid branches, avoiding wasted computations and ensuring feasible paths.\n   - Goal-biased sampling concentrates samples near the goal, improving convergence likelihood.\n   - Structured node and edge management supports dynamic tree updates and accurate path extraction.\n   - Parameter tuning balances exploration (step size) and exploitation (neighbor radius), enhancing planner effectiveness and efficiency."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from old parent\n        if self.parent:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.1, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        # Alternate between start_tree and goal_tree\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Extend and rewire tree_a toward sample\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                # Swap trees and continue next iteration\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Try to connect tree_b to new_node_a using incremental connection and rewiring\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                # Connection succeeded, extract path from both trees\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n                break\n\n            # Swap trees for next iteration\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        # Find best parent to minimize cost\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors if new_node offers cheaper cost path\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                # Rewire neighbor to new_node\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_pos)\n        curr_node = nearest\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            # Find best parent with minimum cost\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost possible through new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False"
        ],
        "offspring": {
            "operator": "path_expert",
            "algorithm_description": "This implementation presents an optimized bidirectional RRT* planner that incorporates goal-biased sampling, incremental tree expansions with rewiring, and efficient parent selection to minimize the path length. The planner simultaneously grows two trees from the start and goal positions, alternately extending and rewiring to improve path cost. Edge and node collision checks ensure feasibility. The rewiring mechanism dynamically updates parent-child links to exploit lower-cost paths, promoting shorter and smoother trajectories. The step size and neighbor radius are tuned for finer motion increments and localized rewiring to balance exploration and exploitation, enhancing overall efficiency and success rate.",
            "planning_mechanism": "The planning mechanism samples points biased toward the opposite tree\u2019s root for faster connection. Each iteration extends one tree toward the sample with collision checks, selects the minimal cost parent from neighbors within a fixed radius, and rewires neighbors if the new node provides a lower cost path. After extension, the other tree attempts an incremental connection using similar rewiring logic. Trees swap roles each iteration to maintain bidirectional growth. Upon a successful connection, paths are merged from both trees to construct the final optimized path.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n    \n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=3.0, goal_sample_rate: float=0.15, neighbor_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            # Sample with goal bias toward opposite tree's root\n            if random.random() < self.goal_sample_rate:\n                sample = goal_tree[0].position if tree_a is start_tree else start_tree[0].position\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Extend and rewire tree_a toward sample\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Try incremental connect with rewiring from tree_b to new_node_a.position\n            new_node_b = self._incremental_connect_and_rewire(tree_b, new_node_a.position, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                # Connection succeeded: merge paths carefully avoiding duplicate node\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                # Avoid duplicating connecting node\n                if path_b:\n                    path_b = path_b[::-1]\n                    if path_a[-1] == path_b[0]:\n                        path_b = path_b[1:]\n                extracted_path = path_a + path_b\n                success_state = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, target_point, obstacles, is_3d, nodes, edges):\n        import math\n\n        nearest = self._nearest(tree, target_point)\n        new_pos = self._steer(nearest.position, target_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n        # Choose best parent minimizing cost\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost_through_neighbor < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost_through_neighbor\n                best_parent = neighbor\n\n        new_node = Node(new_pos)\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors if better cost path through new_node\n        for neighbor in neighbors:\n            if neighbor is best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    except ValueError:\n                        pass\n                neighbor.update_parent(new_node, new_cost)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _incremental_connect_and_rewire(self, tree, target_pos, obstacles, is_3d, nodes, edges):\n        import math\n\n        curr_node = self._nearest(tree, target_pos)\n\n        while True:\n            new_pos = self._steer(curr_node.position, target_pos)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = self._near_nodes(tree, new_pos, self.neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost path through new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size:\n                return new_node\n\n            curr_node = new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -17.58671,
            "time_improvement": 41.0,
            "length_improvement": 19.0,
            "smoothness_improvement": 332.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01678287982940674,
                    "num_nodes_avg": 87.9,
                    "path_length_avg": 154.65701432242793,
                    "smoothness_avg": 0.021742381374455624,
                    "success_improvement": 0.0,
                    "time_improvement": 32.66098752086632,
                    "length_improvement": 15.230039752657998,
                    "smoothness_improvement": 240.31548284707682,
                    "objective_score": 14.04588162102688
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09976806640625,
                    "num_nodes_avg": 414.9,
                    "path_length_avg": 232.79162524315092,
                    "smoothness_avg": 0.01996574294575676,
                    "success_improvement": 0.0,
                    "time_improvement": 38.26927267049107,
                    "length_improvement": 22.28745495842487,
                    "smoothness_improvement": 413.73294673769124,
                    "objective_score": 18.00693752652075
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024541187286376952,
                    "num_nodes_avg": 194.0,
                    "path_length_avg": 122.07232543815732,
                    "smoothness_avg": 0.03474681379466849,
                    "success_improvement": 0.0,
                    "time_improvement": 50.707849290330984,
                    "length_improvement": 18.925373903457736,
                    "smoothness_improvement": 341.9769067251764,
                    "objective_score": 20.707314101416724
                }
            ],
            "success_rate": 1.0
        },
        "objective": 198.79999999999998,
        "analysis": "1. Summary of key changes:\n   - Introduced a structured `Node` class with explicit handling of parents, children, and costs.\n   - Implemented dual trees (`start_tree` and `goal_tree`) with alternating expansion and rewiring.\n   - Added sophisticated rewiring logic to optimize path costs by reconnecting nodes to better parents.\n   - Incorporated goal-biased sampling to improve sampling efficiency towards the goal.\n   - Introduced incremental connection and rewiring between the two trees to find a path faster.\n   - Included detailed collision checks for nodes and edges considering obstacles in both 2D and 3D.\n   - Encapsulated path extraction from root nodes after successful connection.\n\n2. Primary contributors to the performance improvement:\n   - Rewiring neighbors to minimize path costs, reducing overall path length.\n   - Dual-tree bidirectional approach alternating expansions, increasing search efficiency.\n   - Goal-biased sampling focusing exploration toward goal areas.\n   - Incremental connection strategy bridging start and goal trees effectively.\n   - Robust obstacle and edge collision checking preventing invalid paths.\n\n3. Expected mechanism of impact:\n   - Efficiently reduces redundant exploration via rewiring, improving path optimality.\n   - Bidirectional search decreases search space and accelerates convergence.\n   - Goal biasing guides sampling toward relevant regions, thus speeding up discovery of feasible paths.\n   - Incremental connection facilitates early path detection by connecting partial trees progressively.\n   - Accurate collision checking ensures safety and feasibility, preventing wasted computations on invalid routes."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            if self not in new_parent.children:\n                new_parent.children.append(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=5.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(src, tgt):\n            d = dist(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def collision_free_node(p):\n            return in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size/5)\n\n        def neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return 30.0\n            r = 30.0 * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(10.0, min(30.0, r))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius*radius\n            return [n for n in tree if (dist(n.position, pos)**2) <= radius_sq]\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_uniform()\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample):\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            r = neighbor_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                cost_thru = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                r = neighbor_radius(len(tree)+1)\n                neighbors = near_nodes(tree, new_pos, r)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path, iterations=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Rotation matrix for informed sampling\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx**2 + ky**2 + kz**2)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        all_edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n        grow_start_tree = True\n        start_time = time.perf_counter()\n\n        for _ in range(self.max_iter):\n            if (time.perf_counter() - start_time) > self.max_time_sec:\n                break\n\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < 0.2:\n                    sample = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample = sample_uniform()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(start_tree, sample)\n                if not new_node:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(goal_tree, new_node.position)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined\n                        informed_sampling = True\n                        # Update edges and nodes\n                        all_nodes = start_tree + goal_tree\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(goal_tree, sample)\n                if not new_node:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(start_tree, new_node.position)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined\n                        informed_sampling = True\n                        all_nodes = start_tree + goal_tree\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # timeout or no path found\n        if best_path:\n            smoothed = path_smoothing(best_path)\n            success_state = True\n        else:\n            smoothed = []\n            success_state = False\n\n        all_nodes = start_tree + goal_tree\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        rng = random.Random()\n        start_time = time.perf_counter()\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        tree_a, tree_b = start_tree, goal_tree  # alternate growth\n        success_state = False\n        extracted_path = []\n        best_connection = None\n        best_cost = float('inf')\n        c_best = math.dist(start_pos, goal_pos)\n        x_center = tuple((s + g) / 2 for s, g in zip(start_pos, goal_pos))\n        use_informed_sampling = False\n\n        def adaptive_radius(n):\n            if n <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n) / n) ** (1 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [n for n in tree if math.dist(n.position, point) <= radius]\n\n        def steer(from_pos, to_pos):\n            dist_ = math.dist(from_pos, to_pos)\n            if dist_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def ellipsoidal_sample(c_max):\n            if c_max == float('inf'):\n                return tuple(rng.uniform(0, bounds[d]) for d in range(dim))\n            a1 = np.array([(g - s) / c_max for s, g in zip(start_pos, goal_pos)])\n            M = np.outer(a1, np.array([1.0] + [0] * (dim - 1)))\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ Vt\n            while True:\n                z = np.random.normal(0, 1, dim)\n                norm_z = np.linalg.norm(z)\n                if norm_z > 1e-9:\n                    break\n            z_unit = z / norm_z\n            r = rng.random() ** (1 / dim)\n            r_vec = r * z_unit\n            r1 = c_max / 2.0\n            r2 = math.sqrt(max(c_max ** 2 - c_best ** 2, 0)) / 2.0\n            if dim == 2:\n                L = np.diag([r1, r2])\n            elif dim == 3:\n                L = np.diag([r1, r2, r2])\n            else:\n                L = np.diag([r1] + [r2] * (dim - 1))\n            sample_ball = C @ (L @ r_vec)\n            sample_pt = np.array(x_center) + sample_ball\n            sample_pt = np.clip(sample_pt, 0, bounds)\n            return tuple(float(x) for x in sample_pt)\n\n        def sample_free():\n            for _ in range(100):\n                if use_informed_sampling and best_cost < float('inf'):\n                    sample = ellipsoidal_sample(best_cost)\n                else:\n                    sample = tuple(rng.uniform(0, bounds[d]) for d in range(dim))\n                if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            # fallback if no free sample found\n            return tuple(rng.uniform(0, bounds[d]) for d in range(dim))\n\n        def try_extend_and_rewire(tree, sample):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                return None\n\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = adaptive_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                cost_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                if cost_nbr < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                    nbr.update_parent(new_node, new_cost)\n                    edges.append((new_node, nbr))\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                    except ValueError:\n                        pass\n\n            return new_node\n\n        def try_incremental_connect_and_rewire(tree, target_pos):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                return None\n\n            curr_node = nearest(tree, target_pos)\n            max_steps = int(math.dist(curr_node.position, target_pos) / self.step_size) + 2\n\n            for _ in range(max_steps):\n                new_pos = steer(curr_node.position, target_pos)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                radius = adaptive_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    cost_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                    if cost_nbr < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for nbr in neighbors:\n                    if nbr is best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if new_cost < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        nbr.update_parent(new_node, new_cost)\n                        edges.append((new_node, nbr))\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, target_pos, obstacles, is_3d):\n                        return new_node\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                curr_node = new_node\n            return None\n\n        def path_smoothing(path, max_attempts=100):\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_attempts):\n                if length <= 2:\n                    break\n                i = rng.randint(0, length - 3)\n                j = rng.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                    length = len(path)\n            return path\n\n        for _ in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            if rng.random() < self.goal_sample_rate:\n                sample = tree_b[0].position if tree_a is start_tree else tree_a[0].position\n            else:\n                sample = sample_free()\n\n            new_node_a = try_extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b:\n                connect_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if connect_cost < best_cost:\n                    best_cost = connect_cost\n                    best_connection = (new_node_a, new_node_b)\n                    c_best = best_cost\n                    x_center = tuple((s + g) / 2 for s, g in zip(start_pos, goal_pos))\n                    use_informed_sampling = True\n                    success_state = True\n\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    if path_b and path_b[0] == new_node_a.position:\n                        path_b = path_b[1:]\n                    combined_path = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined_path)\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            if path_b and path_b[0] == node_a.position:\n                path_b = path_b[1:]\n            combined_path = path_a + path_b[::-1]\n            extracted_path = path_smoothing(combined_path)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False"
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "This hybrid planner integrates bidirectional RRT* with adaptive informed sampling and dynamic neighbor radius rewiring. It combines efficient two-tree growth with incremental connection attempts and robust parent-child node management to ensure tree integrity and optimal cost paths. Incorporating goal biasing and ellipsoidal sampling directs exploration to promising regions, while collision checks and path smoothing guarantee feasible, smooth, and lower-cost solutions found within a strict 30-second time budget.",
            "planning_mechanism": "The algorithm grows two trees from start and goal positions alternately, sampling points biased towards the goal and within an informed ellipsoidal region after a feasible path is found. Each extension steers towards samples with step-size control, rewires neighbors in an adaptively scaled radius to optimize path cost, and tries incremental connections between trees for smoother path merging. Path smoothing via shortcutting is applied to improve smoothness before early return upon solution or after timeout, ensuring time-bounded, efficient planning with quality paths.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=5.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(src, tgt):\n            d = dist(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def collision_free_node(p):\n            return in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size/5)\n\n        def neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return 25.0\n            r = 25.0 * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(10.0, min(25.0, r))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (dist(n.position, pos)**2) <= radius_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx**2 + ky**2 + kz**2)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def informed_sample(c_best, c_min):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample):\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            r = neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                cost_through = nbr.cost + dist(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest_node\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                r = neighbor_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, r)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path, iterations=120):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        all_edges = []\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_active = False\n        grow_start_tree = True\n        start_time = time.perf_counter()\n\n        for _ in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            if informed_sampling_active:\n                sample = informed_sample(best_cost, c_min)\n            else:\n                if random.random() < 0.2:\n                    sample = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample = uniform_sample()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(start_tree, sample)\n                if not new_node:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(goal_tree, new_node.position)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        # update edges\n                        all_nodes = start_tree + goal_tree\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(goal_tree, sample)\n                if not new_node:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(start_tree, new_node.position)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        all_nodes = start_tree + goal_tree\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        if best_path:\n            smoothed = path_smoothing(best_path)\n            success_state = True\n        else:\n            smoothed = []\n            success_state = False\n\n        all_nodes = start_tree + goal_tree\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -27.23958,
            "time_improvement": 54.0,
            "length_improvement": 19.0,
            "smoothness_improvement": 1479.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019574189186096193,
                    "num_nodes_avg": 58.2,
                    "path_length_avg": 152.38929996848267,
                    "smoothness_avg": 0.04437404688511375,
                    "success_improvement": 0.0,
                    "time_improvement": 17.443942896618015,
                    "length_improvement": 16.473009924288867,
                    "smoothness_improvement": 594.550193537133,
                    "objective_score": 11.500535821528842
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04689369201660156,
                    "num_nodes_avg": 219.4,
                    "path_length_avg": 236.19734015051682,
                    "smoothness_avg": 0.10009819150676033,
                    "success_improvement": 0.0,
                    "time_improvement": 80.44907222594205,
                    "length_improvement": 21.15052929427784,
                    "smoothness_improvement": 2475.59856528207,
                    "objective_score": 40.74282035304853
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03852677345275879,
                    "num_nodes_avg": 198.3,
                    "path_length_avg": 122.88093794791548,
                    "smoothness_avg": 0.11543046768317515,
                    "success_improvement": 0.0,
                    "time_improvement": 63.187893395175486,
                    "length_improvement": 18.388331976466336,
                    "smoothness_improvement": 1368.2670287391436,
                    "objective_score": 29.475369557541633
                }
            ],
            "success_rate": 1.0
        },
        "objective": 833.0,
        "analysis": "1. Summary of key changes:\n   - The Node class in the offspring algorithm adopts a more comprehensive parent-child relationship management with `add_child`, `remove_child`, and `update_parent` methods ensuring consistent tree structure and dynamic cost updates including children's costs.\n   - Incorporation of bidirectional RRT with heuristics: the offspring planner grows two trees from start and goal, tries to connect them incrementally with rewiring.\n   - Use of adaptive neighbor radius scaling based on the number of nodes and dimensionality to balance exploration and exploitation.\n   - Use of informed sampling when a better solution is found, focusing sampling inside ellipsoidal subsets of the search space to accelerate convergence.\n   - Enhanced incremental connect and rewire procedure with parent reassignment and edge management to maintain an optimal cost tree structure.\n   - Improved and more rigorous collision checking for nodes and edges with resolution-based sampling.\n   - Path smoothing post-processing to reduce unnecessary intermediate waypoints and smooth the resulting path.\n   - Overall greater modularity, more explicit tree management, and robust timeout controls.\n\n2. Primary contributors to the performance improvement:\n   - Informed sampling focusing samples within prolate ellipsoids to accelerate convergence towards optimal paths.\n   - Incremental connect and rewiring with dynamic parent updates to continuously optimize the path cost.\n   - Bidirectional RRT growth alternating between start and goal trees, improving exploration efficiency.\n   - Adaptive neighbor radius controlling connection distances to balance path quality and computational effort.\n   - Post-planning path smoothing improving final path quality (smoothness metric).\n   - Detailed and robust collision checking avoiding invalid expansions.\n\n3. Expected mechanism of impact:\n   - Informed sampling restricts sampling to promising regions, reducing exploration overhead and time to find lower-cost paths.\n   - Rewiring and dynamic parent updates maintain globally lower path costs by locally optimizing tree connections.\n   - Bidirectional tree growth reduces the search space and time by attempting to connect from both ends, improving success rates.\n   - Adaptive neighbor radius prevents excessive connections (computationally expensive) while ensuring enough connectivity for path improvement.\n   - Smoothing removes redundant nodes and sharp turns, providing paths that are easier to follow and have better continuity.\n   - Efficient collision checking ensures that only feasible expansions are considered, reducing wasted iterations and improving reliability."
    }
]