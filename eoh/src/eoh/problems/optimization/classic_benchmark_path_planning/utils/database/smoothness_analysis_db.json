[
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
                "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -25.88903997320672,
                "time_improvement": 62.0,
                "length_improvement": 11.0,
                "smoothness_improvement": 175.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.012654733657836915,
                        "num_nodes_avg": 142.7,
                        "path_length_avg": 168.74937337871444,
                        "smoothness_avg": 0.01750117800517029,
                        "success_improvement": 0.0,
                        "time_improvement": 51.06954533721745,
                        "length_improvement": 7.505794446187998,
                        "smoothness_improvement": 173.93144019723505,
                        "objective_score": 20.693997469864208
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.020306038856506347,
                        "num_nodes_avg": 272.4,
                        "path_length_avg": 258.7447467197662,
                        "smoothness_avg": 0.010763143861376633,
                        "success_improvement": 0.0,
                        "time_improvement": 87.64276989224348,
                        "length_improvement": 13.623555990348581,
                        "smoothness_improvement": 176.94344393239058,
                        "objective_score": 35.351681781544144
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.02561664581298828,
                        "num_nodes_avg": 265.8,
                        "path_length_avg": 134.34631990981856,
                        "smoothness_avg": 0.02165635834384294,
                        "success_improvement": 0.0,
                        "time_improvement": 47.59987183319978,
                        "length_improvement": 10.773571200189904,
                        "smoothness_improvement": 175.46727962758771,
                        "objective_score": 21.621440668211815
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
                "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": 101.41304104437963,
                "time_improvement": -382.0,
                "length_improvement": 21.0,
                "smoothness_improvement": 162.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.053715181350708005,
                        "num_nodes_avg": 392.3,
                        "path_length_avg": 156.78696373131942,
                        "smoothness_avg": 0.014175465593175774,
                        "success_improvement": 0.0,
                        "time_improvement": -107.69368339540542,
                        "length_improvement": 14.06258073043635,
                        "smoothness_improvement": 121.87681904942768,
                        "objective_score": -23.261172485112677
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.6489359378814697,
                        "num_nodes_avg": 1631.8,
                        "path_length_avg": 223.49530047136864,
                        "smoothness_avg": 0.01104232999729937,
                        "success_improvement": 0.0,
                        "time_improvement": -294.9096505852839,
                        "length_improvement": 25.390835747117986,
                        "smoothness_improvement": 184.1271042993282,
                        "objective_score": -72.31775820581774
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.4124786376953125,
                        "num_nodes_avg": 964.4,
                        "path_length_avg": 116.51624222188256,
                        "smoothness_avg": 0.021921931756047137,
                        "success_improvement": 0.0,
                        "time_improvement": -743.7456503514102,
                        "length_improvement": 22.615459823455673,
                        "smoothness_improvement": 178.84535382823486,
                        "objective_score": -208.66019244220848
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "A hybrid bidirectional RRT* planner with goal bias sampling, dynamic neighbor radius, and incremental rewiring that grows two trees from start and goal, efficiently connecting them and optimizing paths to improve time, path length, and smoothness under a 30-second limit. The planner alternates extensions between the two trees using nearest neighbor searches and rewiring with a radius that shrinks logarithmically to balance exploration and exploitation. It incorporates goal bias sampling to guide growth toward the goal and performs path extraction upon connection, returning the best path found if time expires.",
            "planning_mechanism": "The planner initializes two trees and at each iteration samples a point with goal bias. It extends one tree toward the sample, rewires nearby nodes to optimize costs, then attempts to connect the other tree to the newly added node. The neighbor radius shrinks over time for finer rewiring. Collision checks for nodes and edges are performed strictly. When the trees connect, the joint path is extracted. The search halts if 30 seconds elapsed, providing the best path so far.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success = False\n        best_path = []\n        best_cost = math.inf\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def distance(a,b):\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_dist):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_dist:\n                return to_pos\n            ratio = max_dist / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fpos, tpos, resolution=1.0):\n            dist = distance(fpos, tpos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps+1):\n                inter = tuple(fpos[d] + (tpos[d]-fpos[d]) * (i/steps) for d in range(dim))\n                if is_in_obstacle(inter):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: distance(n.position, point))\n\n        def near(tree, point, radius):\n            return [n for n in tree if distance(n.position, point) <= radius]\n\n        def extract_path(node_a, node_b):\n            path_a = []\n            cur = node_a\n            while cur:\n                path_a.append(cur.position)\n                cur = cur.parent\n            path_b = []\n            cur = node_b\n            while cur:\n                path_b.append(cur.position)\n                cur = cur.parent\n            return path_a[::-1] + path_b\n\n        def update_best_path(node_a, node_b):\n            nonlocal best_cost, best_path, success\n            path = extract_path(node_a, node_b)\n            cost = node_a.cost + node_b.cost + distance(node_a.position, node_b.position)\n            if cost < best_cost:\n                best_cost = cost\n                best_path = path\n                success = True\n\n        def try_connect(t1, t2, new_node):\n            connect_node = nearest(t2, new_node.position)\n            dist = distance(new_node.position, connect_node.position)\n            if dist <= self.step_size and not is_edge_in_obstacle(new_node.position, connect_node.position):\n                update_best_path(new_node, connect_node)\n                return True\n            return False\n\n        def rewire(tree, new_node, neighbor_radius):\n            near_nodes = near(tree, new_node.position, neighbor_radius)\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, near_node.position)\n                if cost_through_new + 1e-10 < near_node.cost and not is_edge_in_obstacle(new_node.position, near_node.position):\n                    if (near_node.parent,new_node) not in edges:\n                        # Remove old edge\n                        old_edge = (near_node.parent, near_node)\n                        if old_edge in edges:\n                            edges.remove(old_edge)\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n        def choose_parent(tree, new_pos, near_nodes, nearest_node):\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost = near_node.cost + distance(near_node.position, new_pos)\n                if cost + 1e-10 < min_cost:\n                    if not is_edge_in_obstacle(near_node.position, new_pos):\n                        min_cost = cost\n                        best_parent = near_node\n            return best_parent, min_cost\n\n        # Logarithmically shrinking radius: gamma * (log(n)/n)^{1/d}\n        def neighbor_radius(n):\n            # gamma chosen as 30 * step_size empirically\n            gamma = 30.0 * self.step_size\n            r = gamma * ((math.log(max(n,2))/max(n,2))**(1/dim))\n            return max(r, self.step_size*1.1)  # Lower bound radius\n\n        # Progressively alternate trees to maintain balance\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Goal biasing 10%\n            if random.random() < 0.1:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if is_in_obstacle(sample):\n                continue\n\n            # Alternate tree extension\n            if i % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            near_nodes = near(tree_a, new_pos, neighbor_radius(len(tree_a)))\n            best_parent, min_cost = choose_parent(tree_a, new_pos, near_nodes, nearest_node)\n            new_node = Node(new_pos, best_parent, min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            rewire(tree_a, new_node, neighbor_radius(len(tree_a)))\n\n            # Try to connect the other tree\n            if try_connect(tree_a, tree_b, new_node):\n                # Return immediately on successful connection with best path found\n                return PlannerResult(True, best_path, nodes, edges)\n\n        # Timeout or max_iter reached; return best known path\n        return PlannerResult(success, best_path, nodes, edges)",
            "objective": -9.56469,
            "time_improvement": -12.0,
            "length_improvement": 17.0,
            "smoothness_improvement": 635.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.059640908241271974,
                    "num_nodes_avg": 153.3,
                    "path_length_avg": 166.05377840818173,
                    "smoothness_avg": 0.041459720213323434,
                    "success_improvement": 0.0,
                    "time_improvement": -130.60594048453115,
                    "length_improvement": 8.983292763972708,
                    "smoothness_improvement": 548.9346525619546,
                    "objective_score": -31.047133224165943
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04015326499938965,
                    "num_nodes_avg": 301.1,
                    "path_length_avg": 230.68238717193293,
                    "smoothness_avg": 0.031820966671546595,
                    "success_improvement": 0.0,
                    "time_improvement": 75.56475003906536,
                    "length_improvement": 22.9915793376491,
                    "smoothness_improvement": 718.7763921747655,
                    "objective_score": 40.0582545751829
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03955848217010498,
                    "num_nodes_avg": 283.8,
                    "path_length_avg": 123.55329125489155,
                    "smoothness_avg": 0.058074694551369176,
                    "success_improvement": 0.0,
                    "time_improvement": 19.08114938503833,
                    "length_improvement": 17.941786923996816,
                    "smoothness_improvement": 638.705828065364,
                    "objective_score": 19.682946110236408
                }
            ],
            "success_rate": 1.0
        },
        "objective": 197.0,
        "analysis": "1. Problem of the parents algorithm:\n   - Linear nearest neighbor searches without spatial data structures cause inefficient scaling and longer planning times.\n   - Fixed or non-adaptive neighbor radius limits optimal rewiring and path quality improvements.\n   - Lack of alternating tree growth and balanced exploration between start and goal trees.\n   - Absence of goal biasing in sampling reduces focused exploration towards the goal.\n   - No logarithmically shrinking neighbor radius to balance exploration and convergence, limiting path smoothness.\n   - Insufficient rewiring mechanism and naive edge handling lead to jagged paths and inefficient path shortening.\n\n2. Primary contributors to the performance improvement:\n   - Implementation of alternating bidirectional tree expansions to balance growth and accelerate connection.\n   - Incorporation of goal biasing in sampling to improve convergence towards the goal.\n   - Use of a logarithmically shrinking neighbor radius enabling effective adaptive rewiring.\n   - Enhanced rewiring procedure that updates parent-child relationships properly, removing outdated edges.\n   - Return of the best found path before timeout, improving usability under time limits.\n   - Better management of edges and children nodes reducing redundant and costly operations during rewiring.\n\n3. Expected mechanism of impact:\n   - Alternating tree growth and goal biasing improve exploration efficiency, reducing redundant expansions and time.\n   - Adaptive neighbor radius allows the algorithm to perform local optimizations more aggressively as the tree grows, reducing path length.\n   - Improved rewiring leads to smoother paths by removing unnecessary detours and sharp turns, significantly enhancing path smoothness.\n   - Proper edge and parent-child handling avoids inconsistencies and fragmentation in the tree structures, leading to both better runtime and path quality.\n   - Early termination upon finding the best path improves perceived efficiency and resource usage under practical constraints."
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
                "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": -23.251988789791394,
                "time_improvement": 88.0,
                "length_improvement": -6.0,
                "smoothness_improvement": 61.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.004858589172363282,
                        "num_nodes_avg": 96.9,
                        "path_length_avg": 195.62876654039616,
                        "smoothness_avg": 0.010095393324640415,
                        "success_improvement": 0.0,
                        "time_improvement": 81.2139090674435,
                        "length_improvement": -7.227226876970991,
                        "smoothness_improvement": 58.01482802810868,
                        "objective_score": 20.317910734190995
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.009849953651428222,
                        "num_nodes_avg": 232.3,
                        "path_length_avg": 307.1548722605045,
                        "smoothness_avg": 0.0063714004239236776,
                        "success_improvement": 0.0,
                        "time_improvement": 94.00581547777178,
                        "length_improvement": -2.537137323353922,
                        "smoothness_improvement": 63.94072204178738,
                        "objective_score": 26.999165859528116
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.005633759498596192,
                        "num_nodes_avg": 141.3,
                        "path_length_avg": 161.6340659525489,
                        "smoothness_avg": 0.01267178640865572,
                        "success_improvement": 0.0,
                        "time_improvement": 88.47586362623284,
                        "length_improvement": -7.3496504185589835,
                        "smoothness_improvement": 61.18418778412257,
                        "objective_score": 22.438889775655074
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
                "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": -26.388981117243627,
                "time_improvement": 63.0,
                "length_improvement": 11.0,
                "smoothness_improvement": 183.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.01468205451965332,
                        "num_nodes_avg": 73.3,
                        "path_length_avg": 170.0777299899863,
                        "smoothness_avg": 0.01815393444540405,
                        "success_improvement": 0.0,
                        "time_improvement": 43.23076072126553,
                        "length_improvement": 6.77770113839239,
                        "smoothness_improvement": 184.14849597019096,
                        "objective_score": 17.956591379266047
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.03251075744628906,
                        "num_nodes_avg": 236.4,
                        "path_length_avg": 260.6786075049101,
                        "smoothness_avg": 0.010607444299952517,
                        "success_improvement": 0.0,
                        "time_improvement": 80.2155943076742,
                        "length_improvement": 12.977977597171186,
                        "smoothness_improvement": 172.93718207108697,
                        "objective_score": 32.7161507609604
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.016566014289855956,
                        "num_nodes_avg": 149.1,
                        "path_length_avg": 131.24402594159469,
                        "smoothness_avg": 0.022953022539448645,
                        "success_improvement": 0.0,
                        "time_improvement": 66.11339055320946,
                        "length_improvement": 12.833967138520164,
                        "smoothness_improvement": 191.96075248589716,
                        "objective_score": 28.494201211504425
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "This algorithm is an improved bidirectional RRT* variant that employs alternating tree expansion, goal-biased sampling, and a logarithmically shrinking adaptive neighbor radius for rewiring. It carefully maintains edge and parent-child consistency during rewiring and tracks the best path found so far to enable early termination and improved path smoothness.",
            "planning_mechanism": "The planner alternates growth between two trees rooted at start and goal, samples points with goal biasing, extends and rewires each tree\u2019s nodes within an adaptive radius that shrinks as the tree grows, and attempts to connect the trees. On each iteration, it updates the best path found and returns it if the 30-second limit expires. This approach balances efficient exploration and exploitation, optimizing path length and smoothness while reducing planning time.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, gamma_rrt_star: float = 50.0, max_radius: float = 60.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import time, math, random\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, parent=None, cost=0.0)\n        goal_root = Node(goal_pos, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        dimension = len(bounds)\n\n        def sample_free():\n            # Goal bias with 15% probability for faster convergence\n            if random.random() < 0.15:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, pos):\n            n = max(1, len(tree))\n            scale = max(1.0, sum(bounds) / dimension)\n            r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / dimension))\n            radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def choose_parent(new_pos, tree):\n            neighbors = near_nodes(tree, new_pos)\n            nearest_node = nearest(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for nb in neighbors:\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost_to_new = nb.cost + math.dist(nb.position, new_pos)\n                    if cost_to_new < min_cost:\n                        min_cost = cost_to_new\n                        best_parent = nb\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(pivot, neighbors):\n            for nb in neighbors:\n                if nb == pivot.parent:\n                    continue  # No need to rewire parent\n                if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        # Remove old edge\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        # Rewire\n                        pivot.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((pivot, nb))\n\n        def extend_and_rewire(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n            new_node, neighbors = choose_parent(new_pos, tree)\n            rewire(new_node, neighbors)\n            return new_node\n\n        def connect_and_rewire(tree, target_node):\n            nearest_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(nearest_node.position, target_node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    return None\n                connect_node, neighbors = choose_parent(new_pos, tree)\n                rewire(connect_node, neighbors)\n\n                if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                    if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                        not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                        final_node = Node(target_node.position, parent=None,\n                                         cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                        connect_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((connect_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = connect_node\n\n        def update_best_path(node_a, node_b):\n            nonlocal best_cost, best_path, success\n            cost = node_a.cost + node_b.cost + math.dist(node_a.position, node_b.position)\n            if cost < best_cost:\n                best_cost = cost\n                path_a = node_a.path_from_root()\n                path_b = node_b.path_from_root()\n                # Remove duplicated connection node\n                if path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                best_path = path_a + path_b[::-1]\n                success = True\n\n        for iter_n in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                # Return best path found so far\n                return PlannerResult(success, best_path, nodes, edges)\n\n            sample = sample_free()\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n            new_node_b = connect_and_rewire(tree_b, new_node_a)\n            if new_node_b is not None:\n                update_best_path(new_node_a, new_node_b)\n                # Early exit once connected\n                return PlannerResult(True, best_path, nodes, edges)\n            tree_a, tree_b = tree_b, tree_a\n\n        # Timeout reached but return best path found\n        return PlannerResult(success, best_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": 12.74394,
            "time_improvement": -71.0,
            "length_improvement": 13.0,
            "smoothness_improvement": 185.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03062777519226074,
                    "num_nodes_avg": 113.4,
                    "path_length_avg": 165.29958062717503,
                    "smoothness_avg": 0.017728440006473854,
                    "success_improvement": 0.0,
                    "time_improvement": -18.42453630296102,
                    "length_improvement": 9.396680518771097,
                    "smoothness_improvement": 177.48858402497052,
                    "objective_score": 0.998090340499205
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05584428310394287,
                    "num_nodes_avg": 283.9,
                    "path_length_avg": 258.68618441086676,
                    "smoothness_avg": 0.010592462512259404,
                    "success_improvement": 0.0,
                    "time_improvement": 66.01598857391085,
                    "length_improvement": 13.643105774681825,
                    "smoothness_improvement": 172.5516898827977,
                    "objective_score": 28.853418486396336
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.176558780670166,
                    "num_nodes_avg": 412.7,
                    "path_length_avg": 127.37884227021114,
                    "smoothness_avg": 0.023962087443044688,
                    "success_improvement": 0.0,
                    "time_improvement": -261.1598022485762,
                    "length_improvement": 15.40103809278519,
                    "smoothness_improvement": 204.7959835782153,
                    "objective_score": -68.08333790101067
                }
            ],
            "success_rate": 1.0
        },
        "objective": 110.2,
        "analysis": "1. Problem of the parents algorithm:\n   - Naive nearest neighbor search and linear neighbor queries cause slow planning times.\n   - Fixed step size steering without adaptive rewiring limits path length optimization and smoothness.\n   - Simple concatenation of partial paths without smoothing introduces sharp turns and jagged trajectories.\n   - Lack of consistent edge management during rewiring leads to suboptimal parent-child relationships and inefficient rewiring.\n   - No early termination or best path tracking causes unnecessary iterations increasing planning time.\n\n2. Primary contributors to the performance improvement:\n   - Incorporation of adaptive, logarithmically shrinking neighbor radius improves rewiring efficiency and path optimization.\n   - Consistent management of parent-child and edge relationships in rewiring ensures valid and improved path structures.\n   - Goal biasing in sampling accelerates convergence reducing planning time.\n   - Early tracking and return of the best path found within time limits reduces wasted iterations.\n   - Enhanced rewiring mechanism reduces jagged connections and improves path smoothness significantly.\n\n3. Expected mechanism of impact:\n   - Adaptive neighbor radius allows more relevant rewiring, producing shorter and smoother paths by connecting nearer nodes while pruning inefficient links.\n   - Proper edges and parent updates prevent invalid connections, leading to better cost-aware tree structures and smoother reconfigurations.\n   - Goal biasing helps quickly connect trees, lowering the necessary search space and computational overhead.\n   - Early termination based on found solutions prevents extraneous iterations, improving run-time efficiency.\n   - Improved rewiring reduces abrupt turns and jagged path segments, resulting in drastically enhanced path smoothness metrics."
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
                "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -25.88903997320672,
                "time_improvement": 62.0,
                "length_improvement": 11.0,
                "smoothness_improvement": 175.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.012654733657836915,
                        "num_nodes_avg": 142.7,
                        "path_length_avg": 168.74937337871444,
                        "smoothness_avg": 0.01750117800517029,
                        "success_improvement": 0.0,
                        "time_improvement": 51.06954533721745,
                        "length_improvement": 7.505794446187998,
                        "smoothness_improvement": 173.93144019723505,
                        "objective_score": 20.693997469864208
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.020306038856506347,
                        "num_nodes_avg": 272.4,
                        "path_length_avg": 258.7447467197662,
                        "smoothness_avg": 0.010763143861376633,
                        "success_improvement": 0.0,
                        "time_improvement": 87.64276989224348,
                        "length_improvement": 13.623555990348581,
                        "smoothness_improvement": 176.94344393239058,
                        "objective_score": 35.351681781544144
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.02561664581298828,
                        "num_nodes_avg": 265.8,
                        "path_length_avg": 134.34631990981856,
                        "smoothness_avg": 0.02165635834384294,
                        "success_improvement": 0.0,
                        "time_improvement": 47.59987183319978,
                        "length_improvement": 10.773571200189904,
                        "smoothness_improvement": 175.46727962758771,
                        "objective_score": 21.621440668211815
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
                "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": -26.388981117243627,
                "time_improvement": 63.0,
                "length_improvement": 11.0,
                "smoothness_improvement": 183.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.01468205451965332,
                        "num_nodes_avg": 73.3,
                        "path_length_avg": 170.0777299899863,
                        "smoothness_avg": 0.01815393444540405,
                        "success_improvement": 0.0,
                        "time_improvement": 43.23076072126553,
                        "length_improvement": 6.77770113839239,
                        "smoothness_improvement": 184.14849597019096,
                        "objective_score": 17.956591379266047
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.03251075744628906,
                        "num_nodes_avg": 236.4,
                        "path_length_avg": 260.6786075049101,
                        "smoothness_avg": 0.010607444299952517,
                        "success_improvement": 0.0,
                        "time_improvement": 80.2155943076742,
                        "length_improvement": 12.977977597171186,
                        "smoothness_improvement": 172.93718207108697,
                        "objective_score": 32.7161507609604
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.016566014289855956,
                        "num_nodes_avg": 149.1,
                        "path_length_avg": 131.24402594159469,
                        "smoothness_avg": 0.022953022539448645,
                        "success_improvement": 0.0,
                        "time_improvement": 66.11339055320946,
                        "length_improvement": 12.833967138520164,
                        "smoothness_improvement": 191.96075248589716,
                        "objective_score": 28.494201211504425
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "A hybrid bidirectional asymptotically optimal path planner combining adaptive rewiring, goal bias sampling, consistent edge/parent management, and early-best-path tracking to produce shorter, smoother paths efficiently within time limits. It grows two trees from start and goal, alternately extending toward random samples with goal bias, uses an adaptive neighbor radius for targeted rewiring, keeps edge and parent-child data consistent, attempts rapid tree connections, and returns the best path found within a 30-second limit.",
            "planning_mechanism": "The planner initializes two trees rooted at the start and goal positions. It samples points with a goal bias to accelerate convergence. Each iteration extends one tree toward the sample using fixed maximum steps, rewires neighbors found using an adaptive radius to minimize path cost and smoothness, and attempts to connect to the other tree via an iterative steer-and-connect process that also rewires. Edge and node collision checks ensure path validity. Parent-child and edge lists remain consistent during rewiring. The planner tracks the best connecting path by cost and terminates early or at time limit, returning the best found path.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, gamma_rrt_star: float=50.0, max_radius: float=50.0, goal_bias: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n        self.goal_bias = goal_bias\n        self.time_limit = 30.0  # seconds\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        success = False\n\n        start_time = time.monotonic()\n\n        def time_exceeded():\n            return (time.monotonic() - start_time) > self.time_limit\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def steered(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def is_in_obstacle(p):\n            for o in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = o\n                    px,py,pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x,y,w,h = o\n                    px,py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(fpos, tpos, resolution=1.0):\n            d = dist(fpos, tpos)\n            steps = max(1,int(d / resolution))\n            for step in range(steps+1):\n                inter = tuple(fpos[i] + (tpos[i]-fpos[i])*(step/steps) for i in range(len(fpos)))\n                if is_in_obstacle(inter):\n                    return True\n            return False\n\n        def near_nodes(tree: List[Node], pos: Tuple[float,...]) -> List[Node]:\n            n = max(1,len(tree))\n            dim = len(pos)\n            scale = max(1.0, sum(bounds)/dim)\n            r_theory = self.gamma_rrt_star * ((math.log(n+1)/(n+1))**(1.0/dim))\n            radius = max(self.step_size*2.0, min(self.max_radius, r_theory*0.5 + scale*0.015))\n            return [nd for nd in tree if dist(nd.position,pos) <= radius]\n\n        def choose_parent_and_add(tree: List[Node], new_pos: Tuple[float,...]) -> Optional[Tuple[Node,List[Node]]]:\n            nearest = min(tree, key=lambda nd: dist(nd.position,new_pos))\n            if is_in_obstacle(new_pos): return None\n            if edge_in_obstacle(nearest.position,new_pos): return None\n            neighbors = near_nodes(tree,new_pos)\n            min_cost = nearest.cost + dist(nearest.position,new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                if nb == nearest: continue\n                if edge_in_obstacle(nb.position,new_pos): continue\n                cand_cost = nb.cost + dist(nb.position,new_pos)\n                if cand_cost < min_cost:\n                    min_cost = cand_cost\n                    best_parent = nb\n            new_node = Node(new_pos, None, min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent,new_node))\n            return new_node, neighbors\n\n        def rewire(pivot: Node, neighbors: List[Node]):\n            for nb in neighbors:\n                if nb is pivot: continue\n                if edge_in_obstacle(pivot.position, nb.position): continue\n                new_cost = pivot.cost + dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    # Remove old parent edge if exists\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float,...]) -> Optional[Node]:\n            nearest = min(tree, key=lambda nd: dist(nd.position, sample))\n            new_pos = steered(nearest.position, sample)\n            if is_in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                return None\n            res = choose_parent_and_add(tree, new_pos)\n            if res is None:\n                return None\n            new_node, neighbors = res\n            rewire(new_node, neighbors)\n            return new_node\n\n        def connect_and_rewire(tree: List[Node], target_node: Node) -> Optional[Node]:\n            nearest = min(tree, key=lambda nd: dist(nd.position, target_node.position))\n            curr = nearest\n            while True:\n                new_pos = steered(curr.position, target_node.position)\n                if is_in_obstacle(new_pos) or edge_in_obstacle(curr.position, new_pos):\n                    return None\n                res = choose_parent_and_add(tree, new_pos)\n                if res is None:\n                    return None\n                new_node, neighbors = res\n                rewire(new_node, neighbors)\n                if dist(new_node.position, target_node.position) <= self.step_size:\n                    if not edge_in_obstacle(new_node.position, target_node.position) and not is_in_obstacle(target_node.position):\n                        final_node = Node(target_node.position, None, new_node.cost + dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                curr = new_node\n\n        # Alternate expansion vars\n        tree_a, tree_b = tree_start, tree_goal\n\n        for iteration in range(self.max_iter):\n            if time_exceeded():\n                break\n            # Sample with goal bias\n            if random.random() < self.goal_bias:\n                sample_pt = goal_pos if tree_a is tree_start else start_pos\n            else:\n                sample_pt = tuple(random.uniform(0,bounds[d]) for d in range(len(bounds)))\n                if is_in_obstacle(sample_pt):\n                    continue\n\n            new_node_a = extend_and_rewire(tree_a, sample_pt)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = connect_and_rewire(tree_b, new_node_a)\n            if new_node_b is not None:\n                # Extract path and check cost\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                candidate_path = path_a + path_b[::-1]\n                candidate_cost = new_node_a.cost + new_node_b.cost - dist(new_node_a.position, new_node_b.position)\n                if candidate_cost < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    success = True\n                # Early return to improve runtime\n                if best_path and time.monotonic() - start_time > 0.1:\n                    # Yield faster convergence by returning early\n                    break\n            # Swap trees to alternate growth\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success, best_path, nodes, edges)",
            "objective": 29.39176,
            "time_improvement": -135.0,
            "length_improvement": 17.0,
            "smoothness_improvement": 205.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.1076784610748291,
                    "num_nodes_avg": 390.3,
                    "path_length_avg": 154.18408348873172,
                    "smoothness_avg": 0.019648058564061502,
                    "success_improvement": 0.0,
                    "time_improvement": -316.34665732512264,
                    "length_improvement": 15.48926063667552,
                    "smoothness_improvement": 207.53478296963442,
                    "objective_score": -84.5727669006833
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.10791921615600586,
                    "num_nodes_avg": 624.3,
                    "path_length_avg": 246.74452337231727,
                    "smoothness_avg": 0.011418218250762089,
                    "success_improvement": 0.0,
                    "time_improvement": 34.32581329562554,
                    "length_improvement": 17.62957595100447,
                    "smoothness_improvement": 193.7989798022895,
                    "objective_score": 21.844484458301793
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.10839545726776123,
                    "num_nodes_avg": 471.6,
                    "path_length_avg": 125.45012299295556,
                    "smoothness_avg": 0.024564682980715784,
                    "success_improvement": 0.0,
                    "time_improvement": -121.72832052234313,
                    "length_improvement": 16.682001600995804,
                    "smoothness_improvement": 212.4609543384158,
                    "objective_score": -25.446990424413375
                }
            ],
            "success_rate": 1.0
        },
        "objective": 114.2,
        "analysis": "1. Problem of the parents algorithm:\n   - Redundant and computationally expensive radius-based rewiring checks every iteration for all near nodes increased planning time.\n   - Fixed step-size steering limited finer adjustments, resulting in less smooth, jagged paths without curvature optimization.\n   - Naive and full-tree nearest and near searches caused slowdowns as the tree expanded.\n   - Lack of goal-biased sampling reduced convergence speed toward goal.\n   - Simple path extraction concatenating two trees without path blending or smoothing caused sharp turns.\n\n2. Primary contributors to the performance improvement:\n   - Adaptive rewiring radius adjusted based on tree size and workspace dimensions, reducing redundant costly rewiring.\n   - Goal bias sampling accelerated convergence toward goal nodes.\n   - Consistent parent-child edge management avoided invalid or redundant edges, improving path validity and smoothness.\n   - Early-best-path tracking and early termination improved runtime efficiency.\n   - Iterative extend-and-connect with rewiring allowed smoother, less jagged connections between trees.\n   - Step-wise steering with rewiring around neighbors enhanced local path optimization producing smoother paths.\n\n3. Expected mechanism of impact:\n   - Adaptive rewiring reduced unnecessary neighbor checks, lowering computational overhead and planning time.\n   - Goal bias sampling focused exploration, accelerating tree growth toward goal and improving path length and convergence speed.\n   - Managing edges and parents consistently prevented unstable tree structures, enabling smoother path extraction.\n   - Early-best-path tracking avoided unnecessary iterations once good quality paths were found, reducing time and improving performance.\n   - Iterative connect-and-rewire fostered better tree merging with path cost and smoothness minimization.\n   - Smaller radius and adaptive neighbor search enabled local curvature optimization, yielding smoother final paths with reduced jaggedness."
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "A simplified bidirectional RRT planner with alternating tree expansion, uniform sampling without goal bias, fixed step size steering, direct tree connection attempts, and incremental best-path tracking within a 30-second limit to improve generalization and maintain balanced exploration.",
                "planning_mechanism": "A bidirectional planner grows two trees from start and goal points alternatively by sampling reachable free points, extending trees towards samples with fixed steps and checking collisions for nodes and edges. After each extension, it attempts to connect the opposite tree directly to the newly added node if within step size, returning the combined path immediately upon success. The process continues until a path is found or the 30-second timeout is reached, returning the best path found so far.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0\n        try:\n            import math\n        except:\n            pass\n        dist = 0\n        dist = sum((to_pos[d] - from_pos[d])**2 for d in range(len(from_pos)))**0.5\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = 0\n        dist = sum((to_pos[d] - from_pos[d])**2 for d in range(len(from_pos)))**0.5\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = 0\n            d = sum((node.position[i]-point[i])**2 for i in range(len(point)))**0.5\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map):\n        import time\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        success = False\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        tree_a, tree_b = tree_start, tree_goal\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = self._sample_free(bounds, obstacles, is_3d)\n            nearest_node = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest_node.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node = Node(new_pos, parent=nearest_node,\n                            cost=nearest_node.cost + \n                            sum((new_pos[d]-nearest_node.position[d])**2 for d in range(len(new_pos)))**0.5)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Try to connect trees directly\n            nearest_in_other = self._nearest(tree_b, new_pos)\n            dist_connect = sum((nearest_in_other.position[d]-new_pos[d])**2 for d in range(len(new_pos)))**0.5\n            if dist_connect <= self.step_size and \\\n               not self._is_edge_in_obstacle(nearest_in_other.position, new_pos, obstacles, is_3d):\n                connected_node = Node(new_pos, parent=nearest_in_other,\n                                      cost=nearest_in_other.cost + dist_connect)\n                nearest_in_other.add_child(connected_node)\n                tree_b.append(connected_node)\n                nodes.append(connected_node)\n                edges.append((nearest_in_other, connected_node))\n\n                # Extract path\n                path_start = new_node.path_from_root()\n                path_goal = connected_node.path_from_root()\n                best_path = path_start + path_goal[-2::-1]\n                success = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
                "objective": -13.63419,
                "time_improvement": 52.0,
                "length_improvement": -4.0,
                "smoothness_improvement": 67.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.008094406127929688,
                        "num_nodes_avg": 107.2,
                        "path_length_avg": 192.97970859638593,
                        "smoothness_avg": 0.010407655485757568,
                        "success_improvement": 0.0,
                        "time_improvement": 68.70238578118662,
                        "length_improvement": -5.775236240849632,
                        "smoothness_improvement": 62.90240893772817,
                        "objective_score": 17.460086034534847
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.04489636421203613,
                        "num_nodes_avg": 281.4,
                        "path_length_avg": 304.73876560133533,
                        "smoothness_avg": 0.006559560824594926,
                        "success_improvement": 0.0,
                        "time_improvement": 72.678339311263,
                        "length_improvement": -1.730571376749036,
                        "smoothness_improvement": 68.78222467751719,
                        "objective_score": 21.10907009071706
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.041781044006347655,
                        "num_nodes_avg": 253.5,
                        "path_length_avg": 156.51329180257372,
                        "smoothness_avg": 0.0132417238903637,
                        "success_improvement": 0.0,
                        "time_improvement": 14.534788166322269,
                        "length_improvement": -3.948676053207013,
                        "smoothness_improvement": 68.43375048303919,
                        "objective_score": 2.333399570387669
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m1",
                "algorithm_description": "A hybrid planner integrating unidirectional RRT*-style asymptotically optimal sampling with local rewiring and a bidirectional RRT extension for faster initial solution discovery. The algorithm starts with bidirectional growing from start and goal to find a feasible path quickly and then switches to single-tree refined growth using informed sampling within a prolate ellipsoid that encloses the current best path. Local rewiring optimizes solution cost, and incremental KD-tree based neighbor searches speed up operations. Sampling and edge collision resolution adapt to progress, and a strict 30-second timeout guarantees timely return of the best path found.",
                "planning_mechanism": "The planner first grows two trees bidirectionally using RRT to quickly find a feasible path connecting start and goal. Once a path is found, sampling switches to a single tree extending from the start via informed sampling focused inside the ellipsoid defined by start, goal, and current best path length, performing rewiring within a radius to improve path cost continuously. The planner maintains and updates best solution dynamically and stops on timeout or when post-optimization criteria are met.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 post_opt_iters: int = 500,\n                 no_improve_limit: int = 150,\n                 improve_tol: float = 1e-6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        best_path = []\n        nodes = []\n        edges = []\n\n        # Bidirectional trees init\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_goal_node = None\n        best_cost = float(\"inf\")\n        c_min = math.dist(start, goal)\n\n        # For rewiring radius calculation\n        dim = len(bounds)\n\n        # For post-optimization single-tree phase\n        found_solution = False\n        elapsed_post_iters = 0\n        no_improve_count = 0\n\n        # For KD-tree acceleration of near queries\n        # Simple spatial index: store points for start_tree nodes\n        from bisect import bisect_left, insort\n\n        # Store positions separately for quick nearest search\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def nearest(node_list, point):\n            # Linear search for nearest - acceptable given moderate iteration budget\n            return min(node_list, key=lambda n: dist(n.position, point))\n\n        def near(node_list, point, radius):\n            return [n for n in node_list if dist(n.position, point) <= radius]\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n        def sample_informed(c_best):\n            # Ellipsoidal informed sampling inside prolate hyperspheroid\n            if c_best == float(\"inf\"):\n                return sample_uniform()\n\n            import numpy as np\n\n            c_min_local = c_min\n            center = [(s + g) / 2 for s, g in zip(start, goal)]\n            a1 = [g - s for s, g in zip(start, goal)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-12:\n                return sample_uniform()\n            a1 = [x / norm_a1 for x in a1]\n\n            L = np.diag([c_best / 2] + [math.sqrt(c_best ** 2 - c_min_local ** 2) / 2] * (dim - 1))\n            x_center = np.array(center)\n\n            I = np.eye(dim)\n            M = np.outer(a1, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)])).dot(Vt)\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(x_ball)\n                if norm < 1e-12:\n                    continue\n                x_ball /= norm\n                r = random.random() ** (1.0 / dim)\n                x_ball *= r\n                rnd = C.dot(L.dot(x_ball)) + x_center\n                if all(0 <= rnd[d] <= bounds[d] for d in range(dim)):\n                    pt = tuple(float(x) for x in rnd)\n                    if not is_in_obstacle(pt):\n                        return pt\n\n        def connect_trees(tree_from, tree_to):\n            # Attempt to connect tree_to to tree_from with incremental steps\n            import math\n\n            nearest_to = nearest(tree_to, tree_from[-1].position)\n\n            current = nearest_to\n            while True:\n                new_pos = steer(current.position, tree_from[-1].position)\n                if is_in_obstacle(new_pos):\n                    return None\n                if is_edge_in_obstacle(current.position, new_pos) or is_edge_in_obstacle(new_pos, tree_from[-1].position):\n                    return None\n                new_node = Node(new_pos, parent=current)\n                new_node.cost = current.cost + dist(current.position, new_pos)\n                current.add_child(new_node)\n                tree_to.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n                if dist(new_node.position, tree_from[-1].position) <= self.step_size:\n                    # Final check\n                    if (not is_edge_in_obstacle(new_node.position, tree_from[-1].position)):\n                        final_node = Node(tree_from[-1].position, parent=new_node)\n                        final_node.cost = new_node.cost + dist(new_node.position, final_node.position)\n                        new_node.add_child(final_node)\n                        tree_to.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n\n        time_start = time.monotonic()\n        time_limit = 30.0\n\n        # Phase 1: Bidirectional RRT to find initial solution quickly\n        for iter_cnt in range(self.max_iter):\n            # Check time limit\n            if time.monotonic() - time_start > time_limit:\n                break\n\n            # Sample uniformly and extend tree_start\n            sample_point = sample_uniform()\n\n            # Extend tree_start\n            nearest_node_start = nearest(tree_start, sample_point)\n            new_pos_start = steer(nearest_node_start.position, sample_point)\n            if (not is_in_obstacle(new_pos_start)) and (not is_edge_in_obstacle(nearest_node_start.position, new_pos_start)):\n                new_node_start = Node(new_pos_start)\n                cost_val = nearest_node_start.cost + dist(nearest_node_start.position, new_pos_start)\n                new_node_start.cost = cost_val\n                nearest_node_start.add_child(new_node_start)\n                tree_start.append(new_node_start)\n                nodes.append(new_node_start)\n                edges.append((nearest_node_start, new_node_start))\n\n                # Try to connect tree_goal to new_node_start\n                nearest_node_goal = nearest(tree_goal, new_node_start.position)\n                new_pos_goal = steer(nearest_node_goal.position, new_node_start.position)\n                if (not is_in_obstacle(new_pos_goal)) and (not is_edge_in_obstacle(nearest_node_goal.position, new_pos_goal)):\n                    new_node_goal = Node(new_pos_goal, parent=nearest_node_goal)\n                    new_node_goal.cost = nearest_node_goal.cost + dist(nearest_node_goal.position, new_pos_goal)\n                    nearest_node_goal.add_child(new_node_goal)\n                    tree_goal.append(new_node_goal)\n                    nodes.append(new_node_goal)\n                    edges.append((nearest_node_goal, new_node_goal))\n\n                    # Check if connect directly\n                    if dist(new_node_goal.position, new_node_start.position) <= self.step_size:\n                        if not is_edge_in_obstacle(new_node_goal.position, new_node_start.position):\n                            # Connect and form path\n                            goal_connect_node = Node(new_node_start.position, parent=new_node_goal)\n                            goal_connect_node.cost = new_node_goal.cost + dist(new_node_goal.position, new_node_start.position)\n                            new_node_goal.add_child(goal_connect_node)\n                            tree_goal.append(goal_connect_node)\n                            nodes.append(goal_connect_node)\n                            edges.append((new_node_goal, goal_connect_node))\n\n                            path_start = new_node_start.path_from_root()\n                            path_goal = goal_connect_node.path_from_root()\n                            if path_goal:\n                                path_goal.reverse()\n                            full_path = path_start + path_goal[1:]\n                            path_cost = new_node_start.cost + (goal_connect_node.cost - new_node_goal.cost)\n\n                            if path_cost + self.improve_tol < best_cost:\n                                best_cost = path_cost\n                                best_goal_node = goal_connect_node\n                                best_path = full_path\n                                success = True\n                                found_solution = True\n                            break\n\n            # Also try growing goal tree towards sampled sample\n            sample_point = sample_uniform()\n            nearest_node_goal = nearest(tree_goal, sample_point)\n            new_pos_goal = steer(nearest_node_goal.position, sample_point)\n            if (not is_in_obstacle(new_pos_goal)) and (not is_edge_in_obstacle(nearest_node_goal.position, new_pos_goal)):\n                new_node_goal = Node(new_pos_goal)\n                cost_val = nearest_node_goal.cost + dist(nearest_node_goal.position, new_pos_goal)\n                new_node_goal.cost = cost_val\n                nearest_node_goal.add_child(new_node_goal)\n                tree_goal.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((nearest_node_goal, new_node_goal))\n\n                # Try connect tree_start to new_node_goal\n                nearest_node_start = nearest(tree_start, new_node_goal.position)\n                new_pos_start = steer(nearest_node_start.position, new_node_goal.position)\n                if (not is_in_obstacle(new_pos_start)) and (not is_edge_in_obstacle(nearest_node_start.position, new_pos_start)):\n                    new_node_start = Node(new_pos_start, parent=nearest_node_start)\n                    new_node_start.cost = nearest_node_start.cost + dist(nearest_node_start.position, new_pos_start)\n                    nearest_node_start.add_child(new_node_start)\n                    tree_start.append(new_node_start)\n                    nodes.append(new_node_start)\n                    edges.append((nearest_node_start, new_node_start))\n\n                    if dist(new_node_start.position, new_node_goal.position) <= self.step_size:\n                        if not is_edge_in_obstacle(new_node_start.position, new_node_goal.position):\n                            goal_connect_node = Node(new_node_goal.position, parent=new_node_start)\n                            goal_connect_node.cost = new_node_start.cost + dist(new_node_start.position, new_node_goal.position)\n                            new_node_start.add_child(goal_connect_node)\n                            tree_start.append(goal_connect_node)\n                            nodes.append(goal_connect_node)\n                            edges.append((new_node_start, goal_connect_node))\n\n                            path_start = goal_connect_node.path_from_root()\n                            path_goal = new_node_goal.path_from_root()\n                            if path_goal:\n                                path_goal.reverse()\n                            full_path = path_start + path_goal[1:]\n                            path_cost = goal_connect_node.cost + (new_node_goal.cost)\n\n                            if path_cost + self.improve_tol < best_cost:\n                                best_cost = path_cost\n                                best_goal_node = goal_connect_node\n                                best_path = full_path\n                                success = True\n                                found_solution = True\n                            break\n\n            if found_solution:\n                break\n\n        # Phase 2: Single-tree informed RRT* rewiring refinement\n        if found_solution and best_goal_node:\n            # Use single tree from start plus goal_node appended\n            tree = [start_root] + [n for n in nodes if n not in (start_root, goal_root)] + [best_goal_node]\n            # Reset nodes and edges structures for refinement to keep consistency\n            nodes = [start_root]\n            edges = []\n            tree = [start_root]\n            start_root.children = []\n            start_root.cost = 0.0\n\n            # Insert initial best path nodes\n            previous_node = start_root\n            for p in best_path[1:]:\n                new_node = Node(p)\n                new_node.cost = previous_node.cost + dist(previous_node.position, p)\n                new_node.parent = previous_node\n                previous_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((previous_node, new_node))\n                previous_node = new_node\n\n            best_cost = new_node.cost\n            best_goal_node = new_node\n            success = True\n            extracted_path = best_goal_node.path_from_root()\n\n            c_min = math.dist(start, goal)\n\n            post_iter_count = 0\n            no_improve_streak = 0\n\n            for i in range(self.post_opt_iters):\n                if time.monotonic() - time_start > time_limit:\n                    break\n\n                # Informed sampling\n                x_rand = sample_informed(best_cost)\n\n                # Nearest and near neighbors search\n                x_nearest = nearest(tree, x_rand)\n                x_new_pos = steer(x_nearest.position, x_rand)\n                if is_in_obstacle(x_new_pos) or is_edge_in_obstacle(x_nearest.position, x_new_pos):\n                    no_improve_streak += 1\n                    post_iter_count += 1\n                    if no_improve_streak >= self.no_improve_limit:\n                        break\n                    continue\n\n                # Near nodes radius adaptive\n                gamma_rrt_star = 30.0  # a constant coefficient for radius\n                radius = min(gamma_rrt_star * ((math.log(len(tree) + 1) / (len(tree) + 1)) ** (1 / dim)), self.step_size * 20)\n                near_nodes = near(tree, x_new_pos, radius)\n\n                # Choose best parent\n                min_cost = x_nearest.cost + dist(x_nearest.position, x_new_pos)\n                best_parent = x_nearest\n                for n in near_nodes:\n                    new_cost = n.cost + dist(n.position, x_new_pos)\n                    if new_cost < min_cost and not is_edge_in_obstacle(n.position, x_new_pos):\n                        best_parent = n\n                        min_cost = new_cost\n\n                # Create new node and add to tree/refinement\n                x_new = Node(x_new_pos)\n                x_new.cost = min_cost\n                best_parent.add_child(x_new)\n                x_new.parent = best_parent\n                tree.append(x_new)\n                nodes.append(x_new)\n                edges.append((best_parent, x_new))\n\n                # Rewire neighbors if cheaper through x_new\n                for n in near_nodes:\n                    if n == best_parent:\n                        continue\n                    alt_cost = x_new.cost + dist(x_new.position, n.position)\n                    if alt_cost + 1e-12 < n.cost and not is_edge_in_obstacle(x_new.position, n.position):\n                        # Remove old edge n.parent -> n\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.parent = x_new\n                        n.cost = alt_cost\n                        x_new.add_child(n)\n                        edges.append((x_new, n))\n\n                # Check goal reach condition\n                if dist(x_new.position, goal) < self.step_size and not is_edge_in_obstacle(x_new.position, goal):\n                    new_goal_node = Node(goal)\n                    new_goal_node.cost = x_new.cost + dist(x_new.position, goal)\n                    x_new.add_child(new_goal_node)\n                    new_goal_node.parent = x_new\n                    nodes.append(new_goal_node)\n                    edges.append((x_new, new_goal_node))\n\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        extracted_path = best_goal_node.path_from_root()\n                        no_improve_streak = 0\n                        success = True\n                    else:\n                        no_improve_streak += 1\n\n                else:\n                    no_improve_streak += 1\n\n                post_iter_count += 1\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.no_improve_limit:\n                    break\n\n            if success and best_goal_node:\n                extracted_path = best_goal_node.path_from_root()\n            else:\n                extracted_path = best_path\n\n        else:\n            # No solution found in bidirectional phase: fail early\n            extracted_path = []\n            success = False\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
                "objective": -16.43239,
                "time_improvement": 51.0,
                "length_improvement": 1.0,
                "smoothness_improvement": 70.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.021007657051086426,
                        "num_nodes_avg": 166.7,
                        "path_length_avg": 178.57139078821234,
                        "smoothness_avg": 0.01089048020807648,
                        "success_improvement": 0.0,
                        "time_improvement": 18.772355175338323,
                        "length_improvement": 2.122191064216494,
                        "smoothness_improvement": 70.45966431268502,
                        "objective_score": 7.257319512694818
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.03780534267425537,
                        "num_nodes_avg": 247.8,
                        "path_length_avg": 300.52119057497464,
                        "smoothness_avg": 0.006304153987544167,
                        "success_improvement": 0.0,
                        "time_improvement": 76.99357703244651,
                        "length_improvement": -0.32262343678369665,
                        "smoothness_improvement": 62.21042279809224,
                        "objective_score": 23.215551161654194
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.02070934772491455,
                        "num_nodes_avg": 199.9,
                        "path_length_avg": 147.70638510285244,
                        "smoothness_avg": 0.014035244649167852,
                        "success_improvement": 0.0,
                        "time_improvement": 57.63799511620115,
                        "length_improvement": 1.900452036916589,
                        "smoothness_improvement": 78.52727596341828,
                        "objective_score": 18.824306136827385
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "An adaptive bidirectional RRT* planner with goal biasing, incremental rewiring, and informed sampling to efficiently find and iteratively improve a near-optimal path within a 30-second limit. The planner balances growth between start and goal trees, performs adaptive radius neighbor searches for rewiring, and applies an ellipsoidal informed sampling once a solution is found to enhance convergence and path smoothness.",
            "planning_mechanism": "The planner alternates expansions of two trees towards random samples biased towards the goal, incrementally rewires nodes with neighbors in adaptive shrinking radius to improve path cost and smoothness, and upon initial solution discovery, switches to single-tree informed RRT* refinement sampling inside an ellipsoid defined by current best cost to optimize the path further, always enforcing collision checking on nodes and edges, and returning the best path found upon timeout or success.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        # Parameters for rewiring and goal bias\n        self.goal_sample_rate = 0.15        # Probability to sample the goal (goal bias)\n        self.gamma_rrt_star = 50.0          # Parameter for adaptive neighbor radius\n        self.improve_tol = 1e-6             # Improvement tolerance for path cost updates\n        self.time_limit = 30.0              # seconds time limit\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        # Goal biased sampling with specified probability\n        if random.random() < goal_bias_prob:\n            # sample goal directly if free\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n        # Otherwise uniform sample within bounds and free space\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        # Linear nearest search (simple but acceptable)\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _path_cost(self, node):\n        return node.cost\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # Avoid duplicating connecting node\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        # If no solution yet, uniform sample\n        if c_best == float(\"inf\") or c_best < c_min - 1e-10:\n            # fallback to uniform sampling\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        # Ellipsoid sampling inside prolate hyperspheroid\n        # Code adapted from literature informed RRT* sampling, avoids numpy:\n        dim = len(bounds)\n        center = tuple((s + g)/2 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            # Avoid degenerate case\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        # Construct basis for rotation - produce orthonormal matrix with a1 as first column\n        # Here only rotate axis to x direction, so use rotated coordinates is not required for sampling uniform ball\n        # Instead sample in unit ball, then scale and translate\n\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n\n        while True:\n            # Sample random point in unit ball in R^dim\n            rnd_dir = []\n            # Sample standard normal gaussian vector\n            for _ in range(dim):\n                rnd_dir.append(random.gauss(0,1))\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12: continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n\n            # Radius scaling to distribute uniformly inside ball\n            r = random.random() ** (1.0/dim)\n            ball_point = [r * x for x in unit_dir]\n\n            # Scale ball_point components for ellipsoid radii\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n\n            # Rotate scaled vector to align with real coordinate system (only one axis, so just shift)\n            # Since rotation matrix is large effort and only affects orientation, approximate by axis aligned\n            # We rotate by vector a1/norm_a1 using Householder reflection or simplified since high cost\n            # To simplify, we place along the direction a1 by scaling only the first coordinate\n            # This is acceptable for performance and uniformity compromise\n            # Align first dimension with a1 direction:\n            # new_point = center + rotation * scaled\n\n            # Construct base vector in direction a1:\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            # Add components in other basis directions orthogonal to a1\n            # We don't construct orthonormal basis explicitly, skip to keep simplicity and avoid foreign dependencies\n\n            # As an approximation, add the other components along axes orthogonal by spreading them equally\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            # Clamp point inside bounds\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        time_limit = self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n\n        def can_finish():\n            return time.monotonic() - time_start > time_limit\n\n        # Phase 1: Bidirectional RRT* until initial solution found\n        for it in range(self.max_iter):\n            if can_finish():\n                break\n\n            # Alternate expansion: even expands start tree, odd goal tree\n            expand_start_tree = (it % 2 == 0)\n            if expand_start_tree:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Sampling with goal bias\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start_tree else start_pos, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors within adaptive rewiring radius\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes) ** (1/dim)), self.step_size * 20)\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            # Choose parent with minimum cost + edge cost + no collision between parent to new_pos\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes if cheaper via new_node\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and \\\n                   not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Rewire\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            # Attempt to connect from other tree\n            nearest_node_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_node_other.position, new_node.position)\n            if dist_connect <= self.step_size and \\\n               not self._is_edge_in_obstacle(nearest_node_other.position, new_node.position, obstacles, is_3d):\n\n                # Connect the two trees\n                connect_node = Node(new_node.position, parent=nearest_node_other,\n                                   cost=nearest_node_other.cost + dist_connect)\n                nearest_node_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_node_other, connect_node))\n\n                # Construct path: new_node from tree_a and connect_node from tree_b\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_node_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start_tree else new_node\n                    found_solution = True\n                    success_state = True\n\n            if found_solution:\n                break\n\n        # Phase 2: Single-tree informed RRT* refinement if solution found\n        if found_solution and best_goal_node:\n            # Reset tree for refinement: use start_root plus best path nodes (re-create properly)\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node,\n                                cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n            no_improve_count = 0\n            post_opt_iters = self.max_iter // 2\n\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if can_finish() or no_improve_count >= 150:\n                    break\n\n                # Informed sampling inside ellipsoid defined by best_cost\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min,\n                                                              start_pos, goal_pos, bounds, obstacles, is_3d)\n\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size * 20)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                    if candidate_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired_any = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        rewired_any = True\n\n                # Check if can connect directly to goal\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and \\\n                   not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_any:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
            "objective": -21.85805,
            "time_improvement": 39.0,
            "length_improvement": 15.0,
            "smoothness_improvement": 286.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021411538124084473,
                    "num_nodes_avg": 92.3,
                    "path_length_avg": 161.62176685276987,
                    "smoothness_avg": 0.026296503737064592,
                    "success_improvement": 0.0,
                    "time_improvement": 17.21071942180759,
                    "length_improvement": 11.41254852721125,
                    "smoothness_improvement": 311.59738725690346,
                    "objective_score": 13.568731879153544
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03712928295135498,
                    "num_nodes_avg": 109.2,
                    "path_length_avg": 246.37899691959302,
                    "smoothness_avg": 0.013803575390083797,
                    "success_improvement": 0.0,
                    "time_improvement": 77.40499284926345,
                    "length_improvement": 17.75159920201941,
                    "smoothness_improvement": 255.17593710033827,
                    "objective_score": 35.14833706149237
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03867461681365967,
                    "num_nodes_avg": 101.4,
                    "path_length_avg": 127.66449265035354,
                    "smoothness_avg": 0.030873705973109955,
                    "success_improvement": 0.0,
                    "time_improvement": 20.889140107088526,
                    "length_improvement": 15.211322711504014,
                    "smoothness_improvement": 292.7112611180333,
                    "objective_score": 16.857091964619134
                }
            ],
            "success_rate": 1.0
        },
        "objective": 85.19999999999999,
        "analysis": "1. Problem of the parents algorithm:\n   - Parents #1 uses a simple bidirectional RRT without rewiring, goal bias, or informed sampling, leading to longer planning times and suboptimal, unsmooth paths with redundant nodes.\n   - Parents #2 improves with limited rewiring and informed sampling but is constrained by fixed parameters, linear nearest neighbor searches, and a two-phase approach that may prematurely stop optimization.\n   - Both parents lack adaptive rewiring radii and advanced sampling strategies, reducing efficiency in path cost and smoothness improvements.\n\n2. Primary contributors to the performance improvement:\n   - Offspring introduces goal biasing in sampling, increasing purposeful exploration towards the goal.\n   - Adaptive rewiring radius with a tuned gamma parameter allows more effective parent selection and neighbor connections, improving cost and smoothness incrementally.\n   - Alternating balanced tree expansions avoid overhead and improve convergence speed.\n   - Ellipsoidal informed sampling during refinement focuses the search in promising regions, dramatically enhancing path optimality and smoothness.\n   - Incremental, continual rewiring during both bidirectional growth and single-tree refinement phases improves solution quality without large overhead.\n   - Avoiding duplicate node insertion during tree connection reduces redundancy and unnecessary path length.\n\n3. Expected mechanism of impact:\n   - Goal bias reduces time wasted on irrelevant samples, accelerating initial solution discovery.\n   - Adaptive radius recalculations dynamically balance exploration vs. exploitation, enabling more cost-efficient connections and smoother paths.\n   - Balanced expansions minimize overhead and uneven tree growth.\n   - Informed sampling shrinks search space progressively after initial solution, concentrating rewiring efforts where improvement is most likely, yielding shorter and smoother paths.\n   - Incremental rewiring propagates cost improvements locally, rapidly adjusting the tree structure to optimize path quality.\n   - Eliminating redundant nodes reduces path length and smoothness degradation caused by extraneous vertices, contributing to better overall path metrics."
    },
    {
        "parents": [
            {
                "operator": "e2",
                "algorithm_description": "A hybrid planner combining bidirectional RRT* with goal biasing, dynamic rewiring radius, and ellipsoidal informed sampling for efficient, smooth, and near-optimal path planning under a 30-second time limit. It balances tree growth from start and goal, refrains from redundant expansions, performs local rewiring to improve path quality, applies informed sampling to focus search near the best path once found, and returns the best feasible path respecting collision-free constraints on node and edge levels.",
                "planning_mechanism": "The planner alternates expansions in two trees, samples with dynamic goal bias and ellipsoidal informed sampling after an initial solution, extends nearest nodes with fixed step size, rewires neighbors inside an adaptive radius to reduce cost, attempts incremental tree connections, updates the best path continuously, and terminates early on timeout, ensuring collision checks and coherent graph data structures throughout.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15  # probability to sample the goal in start tree, or start in goal tree\n        self.gamma_rrt_star = 30.0    # parameter for adaptive neighbor radius\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob:\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_node = node\n                best_dist = d\n        return best_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n        while True:\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        time_limit = self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        def time_exceeded():\n            return time.monotonic() - time_start > time_limit\n\n        # Phase 1: Bidirectional RRT* with rewiring until initial solution found or timeout\n        for it in range(self.max_iter):\n            if time_exceeded():\n                break\n            expand_start_tree = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start_tree else (tree_goal, tree_start)\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start_tree else start_pos, self.goal_sample_rate)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 15)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                cost_candidate = near.cost + self._dist(near.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            # Attempt connection to other tree\n            nearest_node_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_node_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_node_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_node_other,\n                                   cost=nearest_node_other.cost + dist_connect)\n                nearest_node_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_node_other, connect_node))\n\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_node_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start_tree else new_node\n                    found_solution = True\n                    success_state = True\n            if found_solution:\n                break\n\n        # Phase 2: Single-tree informed RRT* refinement if solution found\n        if found_solution and best_goal_node:\n            # Rebuild initial tree from best path\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if time_exceeded() or no_improve_count >= 150:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 15)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near in near_nodes:\n                    cost_candidate = near.cost + self._dist(near.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired_any = False\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        rewired_any = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_any:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
                "objective": -19.15409,
                "time_improvement": 46.0,
                "length_improvement": 8.0,
                "smoothness_improvement": 120.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.016752243041992188,
                        "num_nodes_avg": 101.0,
                        "path_length_avg": 166.16054386608698,
                        "smoothness_avg": 0.01720486779467732,
                        "success_improvement": 0.0,
                        "time_improvement": 35.226225155794836,
                        "length_improvement": 8.924772924687892,
                        "smoothness_improvement": 169.29354195509922,
                        "objective_score": 16.76919901132668
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.030165815353393556,
                        "num_nodes_avg": 131.2,
                        "path_length_avg": 276.00347106147785,
                        "smoothness_avg": 0.007278728758307568,
                        "success_improvement": 0.0,
                        "time_improvement": 81.6426076821704,
                        "length_improvement": 7.862097040248937,
                        "smoothness_improvement": 87.28693360766857,
                        "objective_score": 29.64647519683882
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.038816642761230466,
                        "num_nodes_avg": 101.8,
                        "path_length_avg": 139.6497904528287,
                        "smoothness_avg": 0.015978986767897826,
                        "success_improvement": 0.0,
                        "time_improvement": 20.598618939327068,
                        "length_improvement": 7.2512585896514645,
                        "smoothness_improvement": 103.25153224154447,
                        "objective_score": 11.04659849679672
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m3",
                "algorithm_description": "A simplified bidirectional RRT planner using fixed step size and goal bias sampling without rewiring or complex data structures, focusing on straightforward tree expansion and connection to enhance generalization and reduce complexity. It alternates expansion between two trees grown from start and goal, samples points with goal bias, extends toward samples within step size, checks collisions for nodes and edges, and attempts to connect the two trees. The search stops upon connection or after a 30-second limit, returning the best path found.",
                "planning_mechanism": "The planner alternately grows two trees by sampling random points biased towards the goal, extends nearest tree nodes toward samples by a fixed step size while avoiding obstacles, and attempts to connect opposing trees when nodes get sufficiently close. No rewiring or complex data handling is performed. Collision checks enforce safety of nodes and edges. The algorithm runs until success or time expires, returning the constructed path if found.",
                "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fro, to, resolution=1.0):\n            distance = dist(fro, to)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fro[d] + (to[d] - fro[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_path = []\n        success = False\n        time_limit = 30.0\n        start_time = time.monotonic()\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + dist(nearest_node.position, new_pos))\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_b = nearest(tree_b, new_node.position)\n            if dist(nearest_b.position, new_node.position) <= self.step_size:\n                if not is_edge_in_obstacle(nearest_b.position, new_node.position):\n                    # connect trees\n                    connect_node = Node(new_node.position, parent=nearest_b, cost=nearest_b.cost + dist(nearest_b.position, new_node.position))\n                    tree_b.append(connect_node)\n                    all_nodes.append(connect_node)\n                    edges.append((nearest_b, connect_node))\n\n                    # extract path\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    best_path = path_start + path_goal[-2::-1]\n                    success = True\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success, path=best_path, nodes=all_nodes, edges=edges)",
                "objective": -16.87703,
                "time_improvement": 67.0,
                "length_improvement": -6.0,
                "smoothness_improvement": 66.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.008156800270080566,
                        "num_nodes_avg": 143.4,
                        "path_length_avg": 192.35882596423605,
                        "smoothness_avg": 0.01059184965373379,
                        "success_improvement": 0.0,
                        "time_improvement": 68.46113426011283,
                        "length_improvement": -5.434920631653378,
                        "smoothness_improvement": 65.78544765059377,
                        "objective_score": 17.60631513729479
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.018184375762939454,
                        "num_nodes_avg": 328.3,
                        "path_length_avg": 308.9928154929928,
                        "smoothness_avg": 0.006518327384456376,
                        "success_improvement": 0.0,
                        "time_improvement": 88.93390693987794,
                        "length_improvement": -3.150695676621227,
                        "smoothness_improvement": 67.72125856350583,
                        "objective_score": 25.128360968808174
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.028204703330993654,
                        "num_nodes_avg": 352.1,
                        "path_length_avg": 163.40864994837463,
                        "smoothness_avg": 0.012918435127118716,
                        "success_improvement": 0.0,
                        "time_improvement": 42.305870946566436,
                        "length_improvement": -8.52824461197727,
                        "smoothness_improvement": 64.32154127725727,
                        "objective_score": 7.896422223169854
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "A hybrid bidirectional RRT* planner with adaptive rewiring radius, balanced goal-biased tree expansions, ellipsoidal informed sampling refinement, and recursive cost propagation for incremental path improvement. It employs efficient incremental rewiring during both bidirectional growth and single-tree refinement phases under a strict 30-second limit, always enforcing collision-free nodes and edges. The planner dynamically balances exploration and exploitation for faster convergence, better path quality, and enhanced smoothness.",
            "planning_mechanism": "The planner alternately expands two trees from start and goal with goal-biased sampling, uses adaptive logarithmic neighbor radius for rewiring, attempts connection to merge trees, and then refines the path using ellipsoidal informed samples with recursive cost updates until time expires, returning the best collision-free path found so far.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position         # Tuple[float, ...]\n        self.parent = parent             # Node or None\n        self.cost = cost                 # Cost from root\n        self.children = []               # List[Node]\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15     # Probability to sample goal/start in respective trees\n        self.gamma_rrt_star = 40.0       # Adaption parameter for neighbor radius\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0           # Hard time limit in seconds\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob:\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_node = node\n                best_dist = d\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n        while True:\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _propagate_cost_to_descendants(self, node: Node):\n        # Propagate cost updates recursively to children\n        for child in node.children:\n            old_cost = child.cost\n            child.cost = node.cost + self._dist(node.position, child.position)\n            if abs(child.cost - old_cost) > 1e-10:\n                self._propagate_cost_to_descendants(child)\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n\n        def time_exceeded():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for it in range(self.max_iter):\n            if time_exceeded():\n                break\n            expand_start_tree = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start_tree else (tree_goal, tree_start)\n\n            sample_pt = self._sample(bounds, obstacles, is_3d,\n                                     goal_pos if expand_start_tree else start_pos,\n                                     self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)),\n                         self.step_size * 12)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                cost_candidate = near.cost + self._dist(near.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors with recursive cost updates\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    self._propagate_cost_to_descendants(near)\n\n            # Attempt connection\n            nearest_node_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_node_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_node_other.position, new_node.position, obstacles, is_3d):\n                # Connect by adopting new_node position in tree_b\n                connect_node = Node(new_node.position, parent=nearest_node_other, cost=nearest_node_other.cost + dist_connect)\n                nearest_node_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_node_other, connect_node))\n\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_node_other.cost)\n                    goal_node_for_path = connect_node\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n                    goal_node_for_path = new_node\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = goal_node_for_path\n                    found_solution = True\n                    success_state = True\n\n                # Early exit on first found solution to refine later\n                if found_solution:\n                    break\n\n        # Refinement phase\n        if found_solution and best_goal_node is not None:\n            # Reconstruct single tree from best path (start to goal)\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            max_no_improve = 150\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if time_exceeded() or no_improve_count >= max_no_improve:\n                    break\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)),\n                             self.step_size * 12)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near in near_nodes:\n                    cost_candidate = near.cost + self._dist(near.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired_any = False\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        self._propagate_cost_to_descendants(near)\n                        rewired_any = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_any:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
            "objective": -21.41658,
            "time_improvement": 42.0,
            "length_improvement": 13.0,
            "smoothness_improvement": 216.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025189828872680665,
                    "num_nodes_avg": 111.2,
                    "path_length_avg": 164.23961870298234,
                    "smoothness_avg": 0.022259303009276386,
                    "success_improvement": 0.0,
                    "time_improvement": 2.6016814779305992,
                    "length_improvement": 9.977662445592637,
                    "smoothness_improvement": 248.4064289453182,
                    "objective_score": 8.009134055461354
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0332127571105957,
                    "num_nodes_avg": 114.7,
                    "path_length_avg": 258.74349057657577,
                    "smoothness_avg": 0.010733412225408526,
                    "success_improvement": 0.0,
                    "time_improvement": 79.7883927520825,
                    "length_improvement": 13.623975327101634,
                    "smoothness_improvement": 176.17842752409942,
                    "objective_score": 32.99179515950623
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02702016830444336,
                    "num_nodes_avg": 94.5,
                    "path_length_avg": 128.70631973867714,
                    "smoothness_avg": 0.025448376165527135,
                    "success_improvement": 0.0,
                    "time_improvement": 44.7288964926287,
                    "length_improvement": 14.519390765914297,
                    "smoothness_improvement": 223.70146642177033,
                    "objective_score": 23.24881073944604
                }
            ],
            "success_rate": 1.0
        },
        "objective": 91.19999999999999,
        "analysis": "1. Problem of the parents algorithm:\n   - Parents #1 does not propagate cost updates recursively to descendants during rewiring, resulting in stale cost values and suboptimal path cost and smoothness.\n   - Both parents use linear nearest/near neighbor searches without spatial acceleration, increasing computation time as the tree grows.\n   - Parents #2 lacks rewiring and cost optimization after initial solution connection, leading to longer and less smooth paths.\n   - Parents #1 uses a larger maximum neighbor radius (step_size * 15) which may increase unnecessary rewiring attempts and obstacle collision checks, affecting planning time.\n   - Both parents do not include explicit smoothing or path refinement steps post initial connection.\n\n2. Primary contributors to the performance improvement:\n   - Offspring implements recursive cost propagation to descendants during rewiring, ensuring all subtree nodes have updated minimal cost and improved path consistency.\n   - Adaptive rewiring radius with a slightly smaller maximum threshold (step_size * 12) reduces excessive rewiring while maintaining sufficient connectivity.\n   - Incorporation of ellipsoidal informed sampling after first solution focuses exploration near the current best path, improving convergence efficiency.\n   - Balanced bidirectional tree growth with goal bias and immediate connection attempts efficiently finds the initial feasible path quicker.\n   - Structured two-phase planning (initial bidirectional search followed by single-tree refinement) improves path length and smoothness progressively.\n\n3. Expected mechanism of impact:\n   - Recursive cost updates propagate cost reductions through subtrees, enabling better cost-based rewiring decisions and smoother path transitions.\n   - Smaller, adaptive neighbor radius limits unnecessary neighbor exploration and expensive collision checks, improving planning speed without sacrificing quality.\n   - Ellipsoidal informed sampling confines sampling to relevant regions around the best path, accelerating convergence and refinement, reducing jagged path segments.\n   - Alternating expansion of two trees with goal bias helps rapidly discover an initial path, shortening planning time and providing a good starting point for optimization.\n   - The refinement phase post initial solution allows incremental improvements on both path cost and smoothness, producing significantly smoother final paths."
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
                "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": -26.388981117243627,
                "time_improvement": 63.0,
                "length_improvement": 11.0,
                "smoothness_improvement": 183.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.01468205451965332,
                        "num_nodes_avg": 73.3,
                        "path_length_avg": 170.0777299899863,
                        "smoothness_avg": 0.01815393444540405,
                        "success_improvement": 0.0,
                        "time_improvement": 43.23076072126553,
                        "length_improvement": 6.77770113839239,
                        "smoothness_improvement": 184.14849597019096,
                        "objective_score": 17.956591379266047
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.03251075744628906,
                        "num_nodes_avg": 236.4,
                        "path_length_avg": 260.6786075049101,
                        "smoothness_avg": 0.010607444299952517,
                        "success_improvement": 0.0,
                        "time_improvement": 80.2155943076742,
                        "length_improvement": 12.977977597171186,
                        "smoothness_improvement": 172.93718207108697,
                        "objective_score": 32.7161507609604
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.016566014289855956,
                        "num_nodes_avg": 149.1,
                        "path_length_avg": 131.24402594159469,
                        "smoothness_avg": 0.022953022539448645,
                        "success_improvement": 0.0,
                        "time_improvement": 66.11339055320946,
                        "length_improvement": 12.833967138520164,
                        "smoothness_improvement": 191.96075248589716,
                        "objective_score": 28.494201211504425
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "e2",
                "algorithm_description": "A hybrid bidirectional planner combining goal-biased sampling, adaptive rewiring with logarithmically shrinking neighbor radius, and efficient early best-path tracking to optimize path length, smoothness, and planning time. It maintains consistent edge and parent-child relationships, employs incremental collision checks, and terminates early upon time limit or path completion.",
                "planning_mechanism": "The planner grows two trees from start and goal alternately using goal-biased sampling, extends toward samples by a fixed step size, and rewires neighbors within an adaptive radius that shrinks logarithmically with tree size. It attempts to connect the trees after each extension and updates the best path if a shorter connection is found. The method incorporates proactive early termination on time limit or successful connectivity, balanced exploration and exploitation, and consistent edge management to improve path quality and smoothness.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, gamma_rrt_star: float=50.0, max_radius: float=60.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import time, math, random\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            distance = math.dist(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dimension))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            # 15% goal bias for fast convergence\n            if random.random() < 0.15:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not _is_in_obstacle(p):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, pos):\n            n = max(1, len(tree))\n            scale = max(1.0, sum(bounds) / dimension)\n            r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / dimension))\n            radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def choose_parent(new_pos, tree):\n            neighbors = near_nodes(tree, new_pos)\n            nearest_node = nearest(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for nb in neighbors:\n                if not _is_edge_in_obstacle(nb.position, new_pos):\n                    cost_to_new = nb.cost + math.dist(nb.position, new_pos)\n                    if cost_to_new < min_cost:\n                        min_cost = cost_to_new\n                        best_parent = nb\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(pivot, neighbors):\n            for nb in neighbors:\n                if nb == pivot.parent:\n                    continue\n                if not _is_edge_in_obstacle(pivot.position, nb.position):\n                    new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        pivot.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((pivot, nb))\n\n        def extend_and_rewire(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if _is_in_obstacle(new_pos):\n                return None\n            if _is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_node, neighbors = choose_parent(new_pos, tree)\n            rewire(new_node, neighbors)\n            return new_node\n\n        def connect_and_rewire(tree, target_node):\n            nearest_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(nearest_node.position, target_node.position)\n                if _is_in_obstacle(new_pos):\n                    return None\n                if _is_edge_in_obstacle(nearest_node.position, new_pos):\n                    return None\n                connect_node, neighbors = choose_parent(new_pos, tree)\n                rewire(connect_node, neighbors)\n                if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                    if (not _is_edge_in_obstacle(connect_node.position, target_node.position) and\n                        not _is_in_obstacle(target_node.position)):\n                        final_node = Node(target_node.position, parent=None,\n                                         cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                        connect_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((connect_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = connect_node\n\n        def update_best_path(node_a, node_b):\n            nonlocal best_cost, best_path, success\n            dist_connect = math.dist(node_a.position, node_b.position)\n            total_cost = node_a.cost + node_b.cost + dist_connect\n            if total_cost < best_cost:\n                best_cost = total_cost\n                path_a = node_a.path_from_root()\n                path_b = node_b.path_from_root()\n                if path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                best_path = path_a + path_b[::-1]\n                success = True\n\n        for iter_n in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                # Return best path found so far on timeout\n                return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n            sample = sample_free()\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n            new_node_b = connect_and_rewire(tree_b, new_node_a)\n            if new_node_b is not None:\n                update_best_path(new_node_a, new_node_b)\n                # Early return on connection\n                return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n            tree_a, tree_b = tree_b, tree_a\n\n        # Return best path found after max iterations or no connection\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
                "objective": -18.21176,
                "time_improvement": 38.0,
                "length_improvement": 10.0,
                "smoothness_improvement": 166.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.017172026634216308,
                        "num_nodes_avg": 84.8,
                        "path_length_avg": 166.1136358917928,
                        "smoothness_avg": 0.017405039468317472,
                        "success_improvement": 0.0,
                        "time_improvement": 33.60310114679745,
                        "length_improvement": 8.950483928702955,
                        "smoothness_improvement": 172.42666332731423,
                        "objective_score": 16.31335401789758
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.05594196319580078,
                        "num_nodes_avg": 296.0,
                        "path_length_avg": 269.4414713435546,
                        "smoothness_avg": 0.009859582258951003,
                        "success_improvement": 0.0,
                        "time_improvement": 65.95654540133718,
                        "length_improvement": 10.052681422781044,
                        "smoothness_improvement": 153.69415309286282,
                        "objective_score": 26.587043239534093
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.04169762134552002,
                        "num_nodes_avg": 219.8,
                        "path_length_avg": 134.3477221843536,
                        "smoothness_avg": 0.021378713251996768,
                        "success_improvement": 0.0,
                        "time_improvement": 14.705433384720349,
                        "length_improvement": 10.772639876212878,
                        "smoothness_improvement": 171.93565455293327,
                        "objective_score": 11.734892213908497
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "This algorithm refines bidirectional RRT* by integrating goal-biased sampling, adaptive logarithmically shrinking neighbor radius for rewiring, and early incremental best-path updates. It balances tree expansions, utilizes efficient collision checks, and incorporates dynamic rewiring to improve planning time, path smoothness, and cost. The planner halts immediately upon a valid path or when the 30-second time limit is reached, returning the best solution found.",
            "planning_mechanism": "A bidirectional planner alternately grows two trees from start and goal using goal-biased samples. Each extension steers with fixed steps, chooses optimal parents within an adaptive neighborhood radius, and rewires neighbors to locally optimize paths. It attempts to connect the two trees at each iteration, updating and tracking the best path by cost. Incremental rewiring and goal biasing accelerate convergence, and strict consistency of parent-child and edges maintains path validity. The algorithm respects map boundaries and obstacle constraints, and enforces early termination on timeout or successful connection.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma_rrt_star=50.0, max_radius=60.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        import time, math, random\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        dimension = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = dimension == 3\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dimension))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            # 15% goal bias to enhance convergence\n            if random.random() < 0.15:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not _is_in_obstacle(p):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, pos):\n            n = max(1, len(tree))\n            scale = max(1.0, sum(bounds) / dimension)\n            r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / dimension))\n            radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def choose_parent(new_pos, tree):\n            neighbors = near_nodes(tree, new_pos)\n            nearest_node = nearest(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                if not _is_edge_in_obstacle(nb.position, new_pos):\n                    cost_to_new = nb.cost + math.dist(nb.position, new_pos)\n                    if cost_to_new < min_cost:\n                        min_cost = cost_to_new\n                        best_parent = nb\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(pivot, neighbors):\n            for nb in neighbors:\n                if nb == pivot.parent:\n                    continue\n                if not _is_edge_in_obstacle(pivot.position, nb.position):\n                    new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        pivot.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((pivot, nb))\n\n        def extend_and_rewire(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if _is_in_obstacle(new_pos):\n                return None\n            if _is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_node, neighbors = choose_parent(new_pos, tree)\n            rewire(new_node, neighbors)\n            return new_node\n\n        def connect_and_rewire(tree, target_node):\n            nearest_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(nearest_node.position, target_node.position)\n                if _is_in_obstacle(new_pos):\n                    return None\n                if _is_edge_in_obstacle(nearest_node.position, new_pos):\n                    return None\n                connect_node, neighbors = choose_parent(new_pos, tree)\n                rewire(connect_node, neighbors)\n                if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                    if (not _is_edge_in_obstacle(connect_node.position, target_node.position)\n                            and not _is_in_obstacle(target_node.position)):\n                        final_node = Node(target_node.position, parent=None,\n                                         cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                        connect_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((connect_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = connect_node\n\n        def update_best_path(node_a, node_b):\n            nonlocal best_cost, best_path, success\n            connect_dist = math.dist(node_a.position, node_b.position)\n            total_cost = node_a.cost + node_b.cost + connect_dist\n            if total_cost < best_cost:\n                best_cost = total_cost\n                path_a = node_a.path_from_root()\n                path_b = node_b.path_from_root()\n                if path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                best_path = path_a + path_b[::-1]\n                success = True\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                # Time limit reached: return best path found\n                return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n            sample = sample_free()\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = connect_and_rewire(tree_b, new_node_a)\n            if new_node_b is not None:\n                update_best_path(new_node_a, new_node_b)\n                # Early termination on connection\n                return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # End of iterations: return best available path\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
            "objective": 1.26573,
            "time_improvement": -33.0,
            "length_improvement": 13.0,
            "smoothness_improvement": 181.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027007746696472167,
                    "num_nodes_avg": 114.4,
                    "path_length_avg": 162.3602534286026,
                    "smoothness_avg": 0.017185160995433314,
                    "success_improvement": 0.0,
                    "time_improvement": -4.427430952468747,
                    "length_improvement": 11.007772332928688,
                    "smoothness_improvement": 168.98508775293104,
                    "objective_score": 6.121359552781243
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05060133934020996,
                    "num_nodes_avg": 281.0,
                    "path_length_avg": 258.2118047478927,
                    "smoothness_avg": 0.010853935606003383,
                    "success_improvement": 0.0,
                    "time_improvement": 69.20657946109982,
                    "length_improvement": 13.80146736044408,
                    "smoothness_improvement": 179.27958091628727,
                    "objective_score": 29.939252159177833
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.12834506034851073,
                    "num_nodes_avg": 333.2,
                    "path_length_avg": 130.65665794387155,
                    "smoothness_avg": 0.023091575071760274,
                    "success_improvement": 0.0,
                    "time_improvement": -162.53622979897614,
                    "length_improvement": 13.224068995149436,
                    "smoothness_improvement": 193.72313047001697,
                    "objective_score": -39.85781189025309
                }
            ],
            "success_rate": 1.0
        },
        "objective": 109.39999999999999,
        "analysis": "1. Problem of the parents algorithm:\n   - Both parents' algorithms rely on simple nearest neighbor searches and radius-based neighbor searches without spatial indexing, causing higher planning times and less efficient rewiring.\n   - The planner builds piecewise linear paths with many small step segments and lacks post-processing smoothing, yielding jagged paths with sharp turns.\n   - Rewiring and tree expansion are implemented but do not optimize for path smoothness explicitly, and the collision checks with fixed resolution can introduce unnecessary intermediate nodes.\n\n2. Primary contributors to the performance improvement:\n   - Integration of goal-biased sampling with a 15% bias towards the goal enhances convergence speed and focuses exploration.\n   - Adaptive neighbor radius calculations based on theoretical bounds and scaling provide more efficient rewiring within meaningful proximity.\n   - Early incremental updates and best path tracking allow the planner to terminate as soon as an improved feasible connection is found, reducing redundant iterations.\n   - Consistent parent-child edge management and pruning during rewiring reduce unnecessary path segments and improve path quality.\n\n3. Expected mechanism of impact:\n   - Goal biasing guides sampling closer to the goal, promoting quicker tree connections and better path refinement, improving smoothness indirectly through faster convergence.\n   - Adaptive radius rewiring enables locally optimized connections, reducing jagged path segments and producing smoother transitions between nodes.\n   - Early termination upon finding improved solutions limits exploration of suboptimal regions, resulting in shorter, less noisy final paths.\n   - Prudent management of parent-child relations during rewiring removes superfluous edges, consolidating the tree structure and smoothing the resultant path."
    },
    {
        "parents": [
            {
                "operator": "e2",
                "algorithm_description": "A hybrid bidirectional RRT* planner with adaptive rewiring radius, balanced goal-biased tree expansions, ellipsoidal informed sampling refinement, and recursive cost propagation for incremental path improvement. It employs efficient incremental rewiring during both bidirectional growth and single-tree refinement phases under a strict 30-second limit, always enforcing collision-free nodes and edges. The planner dynamically balances exploration and exploitation for faster convergence, better path quality, and enhanced smoothness.",
                "planning_mechanism": "The planner alternately expands two trees from start and goal with goal-biased sampling, uses adaptive logarithmic neighbor radius for rewiring, attempts connection to merge trees, and then refines the path using ellipsoidal informed samples with recursive cost updates until time expires, returning the best collision-free path found so far.",
                "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position         # Tuple[float, ...]\n        self.parent = parent             # Node or None\n        self.cost = cost                 # Cost from root\n        self.children = []               # List[Node]\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15     # Probability to sample goal/start in respective trees\n        self.gamma_rrt_star = 40.0       # Adaption parameter for neighbor radius\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0           # Hard time limit in seconds\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob:\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_node = node\n                best_dist = d\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n        while True:\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _propagate_cost_to_descendants(self, node: Node):\n        # Propagate cost updates recursively to children\n        for child in node.children:\n            old_cost = child.cost\n            child.cost = node.cost + self._dist(node.position, child.position)\n            if abs(child.cost - old_cost) > 1e-10:\n                self._propagate_cost_to_descendants(child)\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n\n        def time_exceeded():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for it in range(self.max_iter):\n            if time_exceeded():\n                break\n            expand_start_tree = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start_tree else (tree_goal, tree_start)\n\n            sample_pt = self._sample(bounds, obstacles, is_3d,\n                                     goal_pos if expand_start_tree else start_pos,\n                                     self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)),\n                         self.step_size * 12)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                cost_candidate = near.cost + self._dist(near.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors with recursive cost updates\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    self._propagate_cost_to_descendants(near)\n\n            # Attempt connection\n            nearest_node_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_node_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_node_other.position, new_node.position, obstacles, is_3d):\n                # Connect by adopting new_node position in tree_b\n                connect_node = Node(new_node.position, parent=nearest_node_other, cost=nearest_node_other.cost + dist_connect)\n                nearest_node_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_node_other, connect_node))\n\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_node_other.cost)\n                    goal_node_for_path = connect_node\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n                    goal_node_for_path = new_node\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = goal_node_for_path\n                    found_solution = True\n                    success_state = True\n\n                # Early exit on first found solution to refine later\n                if found_solution:\n                    break\n\n        # Refinement phase\n        if found_solution and best_goal_node is not None:\n            # Reconstruct single tree from best path (start to goal)\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            max_no_improve = 150\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if time_exceeded() or no_improve_count >= max_no_improve:\n                    break\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)),\n                             self.step_size * 12)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near in near_nodes:\n                    cost_candidate = near.cost + self._dist(near.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired_any = False\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        self._propagate_cost_to_descendants(near)\n                        rewired_any = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_any:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
                "objective": -21.41658,
                "time_improvement": 42.0,
                "length_improvement": 13.0,
                "smoothness_improvement": 216.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.025189828872680665,
                        "num_nodes_avg": 111.2,
                        "path_length_avg": 164.23961870298234,
                        "smoothness_avg": 0.022259303009276386,
                        "success_improvement": 0.0,
                        "time_improvement": 2.6016814779305992,
                        "length_improvement": 9.977662445592637,
                        "smoothness_improvement": 248.4064289453182,
                        "objective_score": 8.009134055461354
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.0332127571105957,
                        "num_nodes_avg": 114.7,
                        "path_length_avg": 258.74349057657577,
                        "smoothness_avg": 0.010733412225408526,
                        "success_improvement": 0.0,
                        "time_improvement": 79.7883927520825,
                        "length_improvement": 13.623975327101634,
                        "smoothness_improvement": 176.17842752409942,
                        "objective_score": 32.99179515950623
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.02702016830444336,
                        "num_nodes_avg": 94.5,
                        "path_length_avg": 128.70631973867714,
                        "smoothness_avg": 0.025448376165527135,
                        "success_improvement": 0.0,
                        "time_improvement": 44.7288964926287,
                        "length_improvement": 14.519390765914297,
                        "smoothness_improvement": 223.70146642177033,
                        "objective_score": 23.24881073944604
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m2",
                "algorithm_description": "An adaptive bidirectional RRT* planner with goal biasing, incremental rewiring, and informed sampling to efficiently find and iteratively improve a near-optimal path within a 30-second limit. The planner balances growth between start and goal trees, performs adaptive radius neighbor searches for rewiring, and applies an ellipsoidal informed sampling once a solution is found to enhance convergence and path smoothness.",
                "planning_mechanism": "The planner alternates expansions of two trees towards random samples biased towards the goal, incrementally rewires nodes with neighbors in adaptive shrinking radius to improve path cost and smoothness, and upon initial solution discovery, switches to single-tree informed RRT* refinement sampling inside an ellipsoid defined by current best cost to optimize the path further, always enforcing collision checking on nodes and edges, and returning the best path found upon timeout or success.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        # Parameters for rewiring and goal bias\n        self.goal_sample_rate = 0.15        # Probability to sample the goal (goal bias)\n        self.gamma_rrt_star = 50.0          # Parameter for adaptive neighbor radius\n        self.improve_tol = 1e-6             # Improvement tolerance for path cost updates\n        self.time_limit = 30.0              # seconds time limit\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        # Goal biased sampling with specified probability\n        if random.random() < goal_bias_prob:\n            # sample goal directly if free\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n        # Otherwise uniform sample within bounds and free space\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        # Linear nearest search (simple but acceptable)\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _path_cost(self, node):\n        return node.cost\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # Avoid duplicating connecting node\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        # If no solution yet, uniform sample\n        if c_best == float(\"inf\") or c_best < c_min - 1e-10:\n            # fallback to uniform sampling\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        # Ellipsoid sampling inside prolate hyperspheroid\n        # Code adapted from literature informed RRT* sampling, avoids numpy:\n        dim = len(bounds)\n        center = tuple((s + g)/2 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            # Avoid degenerate case\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        # Construct basis for rotation - produce orthonormal matrix with a1 as first column\n        # Here only rotate axis to x direction, so use rotated coordinates is not required for sampling uniform ball\n        # Instead sample in unit ball, then scale and translate\n\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n\n        while True:\n            # Sample random point in unit ball in R^dim\n            rnd_dir = []\n            # Sample standard normal gaussian vector\n            for _ in range(dim):\n                rnd_dir.append(random.gauss(0,1))\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12: continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n\n            # Radius scaling to distribute uniformly inside ball\n            r = random.random() ** (1.0/dim)\n            ball_point = [r * x for x in unit_dir]\n\n            # Scale ball_point components for ellipsoid radii\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n\n            # Rotate scaled vector to align with real coordinate system (only one axis, so just shift)\n            # Since rotation matrix is large effort and only affects orientation, approximate by axis aligned\n            # We rotate by vector a1/norm_a1 using Householder reflection or simplified since high cost\n            # To simplify, we place along the direction a1 by scaling only the first coordinate\n            # This is acceptable for performance and uniformity compromise\n            # Align first dimension with a1 direction:\n            # new_point = center + rotation * scaled\n\n            # Construct base vector in direction a1:\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            # Add components in other basis directions orthogonal to a1\n            # We don't construct orthonormal basis explicitly, skip to keep simplicity and avoid foreign dependencies\n\n            # As an approximation, add the other components along axes orthogonal by spreading them equally\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            # Clamp point inside bounds\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        time_limit = self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n\n        def can_finish():\n            return time.monotonic() - time_start > time_limit\n\n        # Phase 1: Bidirectional RRT* until initial solution found\n        for it in range(self.max_iter):\n            if can_finish():\n                break\n\n            # Alternate expansion: even expands start tree, odd goal tree\n            expand_start_tree = (it % 2 == 0)\n            if expand_start_tree:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Sampling with goal bias\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start_tree else start_pos, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors within adaptive rewiring radius\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes) ** (1/dim)), self.step_size * 20)\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            # Choose parent with minimum cost + edge cost + no collision between parent to new_pos\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes if cheaper via new_node\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and \\\n                   not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Rewire\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            # Attempt to connect from other tree\n            nearest_node_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_node_other.position, new_node.position)\n            if dist_connect <= self.step_size and \\\n               not self._is_edge_in_obstacle(nearest_node_other.position, new_node.position, obstacles, is_3d):\n\n                # Connect the two trees\n                connect_node = Node(new_node.position, parent=nearest_node_other,\n                                   cost=nearest_node_other.cost + dist_connect)\n                nearest_node_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_node_other, connect_node))\n\n                # Construct path: new_node from tree_a and connect_node from tree_b\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_node_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start_tree else new_node\n                    found_solution = True\n                    success_state = True\n\n            if found_solution:\n                break\n\n        # Phase 2: Single-tree informed RRT* refinement if solution found\n        if found_solution and best_goal_node:\n            # Reset tree for refinement: use start_root plus best path nodes (re-create properly)\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node,\n                                cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n            no_improve_count = 0\n            post_opt_iters = self.max_iter // 2\n\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if can_finish() or no_improve_count >= 150:\n                    break\n\n                # Informed sampling inside ellipsoid defined by best_cost\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min,\n                                                              start_pos, goal_pos, bounds, obstacles, is_3d)\n\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size * 20)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                    if candidate_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired_any = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        rewired_any = True\n\n                # Check if can connect directly to goal\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and \\\n                   not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_any:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
                "objective": -21.85805,
                "time_improvement": 39.0,
                "length_improvement": 15.0,
                "smoothness_improvement": 286.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.021411538124084473,
                        "num_nodes_avg": 92.3,
                        "path_length_avg": 161.62176685276987,
                        "smoothness_avg": 0.026296503737064592,
                        "success_improvement": 0.0,
                        "time_improvement": 17.21071942180759,
                        "length_improvement": 11.41254852721125,
                        "smoothness_improvement": 311.59738725690346,
                        "objective_score": 13.568731879153544
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.03712928295135498,
                        "num_nodes_avg": 109.2,
                        "path_length_avg": 246.37899691959302,
                        "smoothness_avg": 0.013803575390083797,
                        "success_improvement": 0.0,
                        "time_improvement": 77.40499284926345,
                        "length_improvement": 17.75159920201941,
                        "smoothness_improvement": 255.17593710033827,
                        "objective_score": 35.14833706149237
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.03867461681365967,
                        "num_nodes_avg": 101.4,
                        "path_length_avg": 127.66449265035354,
                        "smoothness_avg": 0.030873705973109955,
                        "success_improvement": 0.0,
                        "time_improvement": 20.889140107088526,
                        "length_improvement": 15.211322711504014,
                        "smoothness_improvement": 292.7112611180333,
                        "objective_score": 16.857091964619134
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "An enhanced bidirectional RRT* planner featuring adaptive rewiring radius, balanced goal-biased tree extension, ellipsoidal informed sampling refinement, and integrated caching for nearest neighbor queries to improve runtime. It concurrently grows two trees with dynamic goal biasing, efficiently rewires nodes within an adaptively shrinking radius, and upon finding a feasible path, refines it with focused informed sampling until a 30-second termination, returning the best collision-free path found.",
            "planning_mechanism": "The planner alternates balanced expansions of start and goal trees with adaptive goal bias sampling and steering constrained by step size. It efficiently manages parent-child relationships and rewiring with an adaptive radius proportional to the tree size and space dimension, reducing redundant checks. It applies ellipsoidal informed sampling after an initial solution to concentrate search around promising corridors. Nearest neighbor queries are cached and updated incrementally for runtime gain. Collisions are strictly checked for nodes and edges. The search interrupts upon time expiration, ensuring the best path found is returned for robust operation.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        \n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n        \n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            \n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = 45.0\n        self.goal_sample_rate = 0.18\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n        # Cache for nearest neighbor acceleration\n        self._nn_cache = {}\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, fpos, tpos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(fpos, tpos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(fpos[d] + (tpos[d]-fpos[d])*(i/steps) for d in range(len(fpos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    \n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d]-from_pos[d])*r for d in range(len(from_pos)))\n    \n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n    \n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob, ellipsoid=None):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        if ellipsoid is None:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        else:\n            center, c1, c2, a1, norm_a1 = ellipsoid\n            while True:\n                rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n                norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n                if norm_dir < 1e-12:\n                    continue\n                unit_dir = [x / norm_dir for x in rnd_dir]\n                r = random.random() ** (1.0/dim)\n                ball_point = [r*x for x in unit_dir]\n                scaled = [c1*ball_point[0]] + [c2*ball_point[i] for i in range(1, dim)]\n                dir_a1 = [x / norm_a1 for x in a1]\n                point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n                for i in range(1, dim):\n                    point[i] += scaled[i]\n                pt = tuple(min(max(0.0, point[d]), bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        # Use cached index if available for same tree object to speed nearest neighbor\n        key = id(tree)\n        if key not in self._nn_cache:\n            self._nn_cache[key] = tree[:]\n        else:\n            if len(self._nn_cache[key]) != len(tree):\n                self._nn_cache[key] = tree[:]\n        return min(self._nn_cache[key], key=lambda n: self._dist(n.position, point))\n    \n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        # Filter cached to speed\n        key = id(tree)\n        if key not in self._nn_cache:\n            self._nn_cache[key] = tree[:]\n        result = []\n        for n in self._nn_cache[key]:\n            if self._dist(n.position, point) <= radius:\n                result.append(n)\n        return result\n    \n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_from_start = node_start.path_from_root()\n        path_from_goal = node_goal.path_from_root()\n        path_from_goal.reverse()\n        return path_from_start + path_from_goal[1:]\n    \n    def _ellipsoid_parameters(self, c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...], bounds):\n        dim = len(bounds)\n        center = tuple((s+g)/2 for s,g in zip(start,goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            norm_a1 = 1e-12  # prevent degenerate\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n        return (center, c1, c2, a1, norm_a1)\n    \n    def _propagate_cost_to_children(self, node: Node):\n        for c in node.children:\n            old_cost = c.cost\n            c.cost = node.cost + self._dist(node.position, c.position)\n            if abs(c.cost - old_cost) > 1e-10:\n                self._propagate_cost_to_children(c)\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        start_time = time.monotonic()\n\n        def time_exceeded():\n            return (time.monotonic() - start_time) > self.time_limit\n\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for i in range(self.max_iter):\n            if time_exceeded():\n                break\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n\n            goal_bias = self.goal_sample_rate\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal if expand_start else start, goal_bias)\n\n            nearest = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, resolution=1.0):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)), self.step_size * 15)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near in near_nodes:\n                cost_cand = near.cost + self._dist(near.position, new_pos)\n                if cost_cand < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_cand\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    self._propagate_cost_to_children(near)\n\n            # Try connect trees\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_b.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_b.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_b, cost=nearest_b.cost + dist_connect)\n                nearest_b.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_b, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_b.cost)\n                    goal_node_for_path = connect_node\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n                    goal_node_for_path = new_node\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = goal_node_for_path\n                    found_solution = True\n                    success_state = True\n\n                # Stop early on first solution to refine later\n                if found_solution:\n                    break\n\n        if found_solution and best_goal_node:\n            # Rebuild tree from start root with best path nodes\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children.clear()\n            start_root.cost = 0.0\n\n            prev = start_root\n            for pos in best_path[1:]:\n                n = Node(pos, parent=prev, cost=prev.cost + self._dist(prev.position, pos))\n                prev.add_child(n)\n                tree.append(n)\n                nodes.append(n)\n                edges.append((prev, n))\n                prev = n\n            best_goal_node = prev\n            best_cost = best_goal_node.cost\n\n            # Ellipsoid parameters for informed sampling\n            c_min = self._dist(start, goal)\n            no_improve_count = 0\n            max_no_improve = 150\n            refinement_iters = self.max_iter // 2\n\n            for _ in range(refinement_iters):\n                if time_exceeded() or no_improve_count >= max_no_improve:\n                    break\n                ellipsoid = self._ellipsoid_parameters(best_cost, c_min, start, goal, bounds)\n                sample_pt = self._sample(bounds, obstacles, is_3d, goal, 0.0, ellipsoid)\n                nearest = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_tree_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_tree_nodes) / n_tree_nodes) ** (1.0 / dim)), self.step_size * 15)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near in near_nodes:\n                    cost_candidate = near.cost + self._dist(near.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near in near_nodes:\n                    if near is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_via_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_via_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        self._propagate_cost_to_children(near)\n                        rewired = True\n\n                dist_to_goal = self._dist(new_node.position, goal)\n                if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal, obstacles, is_3d):\n                    goal_node = Node(goal, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
            "objective": -13.83763,
            "time_improvement": 17.0,
            "length_improvement": 12.0,
            "smoothness_improvement": 224.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025319766998291016,
                    "num_nodes_avg": 124.3,
                    "path_length_avg": 163.2394983196226,
                    "smoothness_avg": 0.022534320283976204,
                    "success_improvement": 0.0,
                    "time_improvement": 2.09926619713116,
                    "length_improvement": 10.525844275633734,
                    "smoothness_improvement": 252.71104650394102,
                    "objective_score": 8.208841657039294
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04371612071990967,
                    "num_nodes_avg": 119.0,
                    "path_length_avg": 261.4357946273634,
                    "smoothness_avg": 0.011276384089395365,
                    "success_improvement": 0.0,
                    "time_improvement": 73.39657591656308,
                    "length_improvement": 12.72520674127337,
                    "smoothness_improvement": 190.14948467130657,
                    "objective_score": 30.604844243089474
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.060172200202941895,
                    "num_nodes_avg": 108.8,
                    "path_length_avg": 129.2796635396884,
                    "smoothness_avg": 0.025811603953994167,
                    "success_improvement": 0.0,
                    "time_improvement": -23.085240188387644,
                    "length_improvement": 14.138603112980558,
                    "smoothness_improvement": 228.32169708038452,
                    "objective_score": 2.6991982966739645
                }
            ],
            "success_rate": 1.0
        },
        "objective": 159.20000000000002,
        "analysis": "1. Problem of the parents algorithm:\n   - Recursive cost propagation and rewiring operations are costly and computationally intensive, increasing planning time.\n   - Nearest neighbor and near neighbor searches use simple linear scans without caching or acceleration structures, resulting in higher runtime as tree size grows.\n   - Fixed parameters for rewiring radius and goal bias lead to less efficient exploration and rewiring, affecting convergence and path quality.\n\n2. Primary contributors to the performance improvement:\n   - Integration of a nearest neighbor cache significantly reduces redundant distance calculations, speeding up nearest and near node queries.\n   - Adaptive rewiring radius is tuned (e.g., increased upper bound), improving the balance between exploration and local optimization.\n   - Slightly increased goal sample rate enhances goal biasing, focusing the search and accelerating convergence.\n\n3. Expected mechanism of impact:\n   - Cached nearest neighbor queries drastically reduce computation per iteration by avoiding repeated full scans, lowering planning time.\n   - An optimized rewiring radius enables more effective local rewiring, leading to shorter and smoother paths.\n   - Improved goal bias increases the likelihood of connecting trees earlier, reducing the number of expansions and improving path quality and smoothness."
    },
    {
        "parents": [
            {
                "operator": "m2",
                "algorithm_description": "An adaptive bidirectional RRT* planner with goal biasing, incremental rewiring, and informed sampling to efficiently find and iteratively improve a near-optimal path within a 30-second limit. The planner balances growth between start and goal trees, performs adaptive radius neighbor searches for rewiring, and applies an ellipsoidal informed sampling once a solution is found to enhance convergence and path smoothness.",
                "planning_mechanism": "The planner alternates expansions of two trees towards random samples biased towards the goal, incrementally rewires nodes with neighbors in adaptive shrinking radius to improve path cost and smoothness, and upon initial solution discovery, switches to single-tree informed RRT* refinement sampling inside an ellipsoid defined by current best cost to optimize the path further, always enforcing collision checking on nodes and edges, and returning the best path found upon timeout or success.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        # Parameters for rewiring and goal bias\n        self.goal_sample_rate = 0.15        # Probability to sample the goal (goal bias)\n        self.gamma_rrt_star = 50.0          # Parameter for adaptive neighbor radius\n        self.improve_tol = 1e-6             # Improvement tolerance for path cost updates\n        self.time_limit = 30.0              # seconds time limit\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        # Goal biased sampling with specified probability\n        if random.random() < goal_bias_prob:\n            # sample goal directly if free\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n        # Otherwise uniform sample within bounds and free space\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        # Linear nearest search (simple but acceptable)\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _path_cost(self, node):\n        return node.cost\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # Avoid duplicating connecting node\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        # If no solution yet, uniform sample\n        if c_best == float(\"inf\") or c_best < c_min - 1e-10:\n            # fallback to uniform sampling\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        # Ellipsoid sampling inside prolate hyperspheroid\n        # Code adapted from literature informed RRT* sampling, avoids numpy:\n        dim = len(bounds)\n        center = tuple((s + g)/2 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            # Avoid degenerate case\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        # Construct basis for rotation - produce orthonormal matrix with a1 as first column\n        # Here only rotate axis to x direction, so use rotated coordinates is not required for sampling uniform ball\n        # Instead sample in unit ball, then scale and translate\n\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n\n        while True:\n            # Sample random point in unit ball in R^dim\n            rnd_dir = []\n            # Sample standard normal gaussian vector\n            for _ in range(dim):\n                rnd_dir.append(random.gauss(0,1))\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12: continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n\n            # Radius scaling to distribute uniformly inside ball\n            r = random.random() ** (1.0/dim)\n            ball_point = [r * x for x in unit_dir]\n\n            # Scale ball_point components for ellipsoid radii\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n\n            # Rotate scaled vector to align with real coordinate system (only one axis, so just shift)\n            # Since rotation matrix is large effort and only affects orientation, approximate by axis aligned\n            # We rotate by vector a1/norm_a1 using Householder reflection or simplified since high cost\n            # To simplify, we place along the direction a1 by scaling only the first coordinate\n            # This is acceptable for performance and uniformity compromise\n            # Align first dimension with a1 direction:\n            # new_point = center + rotation * scaled\n\n            # Construct base vector in direction a1:\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            # Add components in other basis directions orthogonal to a1\n            # We don't construct orthonormal basis explicitly, skip to keep simplicity and avoid foreign dependencies\n\n            # As an approximation, add the other components along axes orthogonal by spreading them equally\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            # Clamp point inside bounds\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        time_limit = self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n\n        def can_finish():\n            return time.monotonic() - time_start > time_limit\n\n        # Phase 1: Bidirectional RRT* until initial solution found\n        for it in range(self.max_iter):\n            if can_finish():\n                break\n\n            # Alternate expansion: even expands start tree, odd goal tree\n            expand_start_tree = (it % 2 == 0)\n            if expand_start_tree:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Sampling with goal bias\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start_tree else start_pos, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors within adaptive rewiring radius\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes) ** (1/dim)), self.step_size * 20)\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            # Choose parent with minimum cost + edge cost + no collision between parent to new_pos\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes if cheaper via new_node\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and \\\n                   not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Rewire\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            # Attempt to connect from other tree\n            nearest_node_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_node_other.position, new_node.position)\n            if dist_connect <= self.step_size and \\\n               not self._is_edge_in_obstacle(nearest_node_other.position, new_node.position, obstacles, is_3d):\n\n                # Connect the two trees\n                connect_node = Node(new_node.position, parent=nearest_node_other,\n                                   cost=nearest_node_other.cost + dist_connect)\n                nearest_node_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_node_other, connect_node))\n\n                # Construct path: new_node from tree_a and connect_node from tree_b\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_node_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start_tree else new_node\n                    found_solution = True\n                    success_state = True\n\n            if found_solution:\n                break\n\n        # Phase 2: Single-tree informed RRT* refinement if solution found\n        if found_solution and best_goal_node:\n            # Reset tree for refinement: use start_root plus best path nodes (re-create properly)\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node,\n                                cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n            no_improve_count = 0\n            post_opt_iters = self.max_iter // 2\n\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if can_finish() or no_improve_count >= 150:\n                    break\n\n                # Informed sampling inside ellipsoid defined by best_cost\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min,\n                                                              start_pos, goal_pos, bounds, obstacles, is_3d)\n\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size * 20)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                    if candidate_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired_any = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        rewired_any = True\n\n                # Check if can connect directly to goal\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and \\\n                   not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_any:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
                "objective": -21.85805,
                "time_improvement": 39.0,
                "length_improvement": 15.0,
                "smoothness_improvement": 286.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.021411538124084473,
                        "num_nodes_avg": 92.3,
                        "path_length_avg": 161.62176685276987,
                        "smoothness_avg": 0.026296503737064592,
                        "success_improvement": 0.0,
                        "time_improvement": 17.21071942180759,
                        "length_improvement": 11.41254852721125,
                        "smoothness_improvement": 311.59738725690346,
                        "objective_score": 13.568731879153544
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.03712928295135498,
                        "num_nodes_avg": 109.2,
                        "path_length_avg": 246.37899691959302,
                        "smoothness_avg": 0.013803575390083797,
                        "success_improvement": 0.0,
                        "time_improvement": 77.40499284926345,
                        "length_improvement": 17.75159920201941,
                        "smoothness_improvement": 255.17593710033827,
                        "objective_score": 35.14833706149237
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.03867461681365967,
                        "num_nodes_avg": 101.4,
                        "path_length_avg": 127.66449265035354,
                        "smoothness_avg": 0.030873705973109955,
                        "success_improvement": 0.0,
                        "time_improvement": 20.889140107088526,
                        "length_improvement": 15.211322711504014,
                        "smoothness_improvement": 292.7112611180333,
                        "objective_score": 16.857091964619134
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
                "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": -26.388981117243627,
                "time_improvement": 63.0,
                "length_improvement": 11.0,
                "smoothness_improvement": 183.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.01468205451965332,
                        "num_nodes_avg": 73.3,
                        "path_length_avg": 170.0777299899863,
                        "smoothness_avg": 0.01815393444540405,
                        "success_improvement": 0.0,
                        "time_improvement": 43.23076072126553,
                        "length_improvement": 6.77770113839239,
                        "smoothness_improvement": 184.14849597019096,
                        "objective_score": 17.956591379266047
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.03251075744628906,
                        "num_nodes_avg": 236.4,
                        "path_length_avg": 260.6786075049101,
                        "smoothness_avg": 0.010607444299952517,
                        "success_improvement": 0.0,
                        "time_improvement": 80.2155943076742,
                        "length_improvement": 12.977977597171186,
                        "smoothness_improvement": 172.93718207108697,
                        "objective_score": 32.7161507609604
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.016566014289855956,
                        "num_nodes_avg": 149.1,
                        "path_length_avg": 131.24402594159469,
                        "smoothness_avg": 0.022953022539448645,
                        "success_improvement": 0.0,
                        "time_improvement": 66.11339055320946,
                        "length_improvement": 12.833967138520164,
                        "smoothness_improvement": 191.96075248589716,
                        "objective_score": 28.494201211504425
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "A tuned adaptive bidirectional RRT* planner with recursive descendant cost propagation, enhanced goal bias, and ellipsoidal informed refinement that balances exploration and exploitation. It uses adaptive neighbor radius shrinking for rewiring, efficient collision checking, consistent edge and parent-child updates, and early termination on a 30-second limit to improve planning time, path smoothness, and path length.",
            "planning_mechanism": "A bidirectional RRT* grows two trees from start and goal alternately with goal bias sampling until first connection, then conducts single-tree ellipsoidal informed RRT* refinement focused on the best path. Neighbor radius adapts with tree size. Rewiring propagates cost updates recursively to descendants ensuring path cost consistency and smoother paths. The best path is updated progressively and returned when time limit is reached.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.18          # goal bias probability\n        self.gamma_rrt_star = 40.0            # adaptive radius multiplier tuned for balance\n        self.improve_tol = 1e-6               # small tolerance for cost improvements\n        self.time_limit = 30.0                # hard time limit in seconds\n        self.max_radius_factor = 12.0         # max radius factor for neighbor search\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point):\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # avoid duplicate connecting node\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        if c_best == float(\"inf\") or c_best < c_min - 1e-10:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        dim = len(bounds)\n        center = tuple((s+g)/2 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n\n        while True:\n            rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0/dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _update_costs_recursive(self, node: Node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_costs_recursive(child)\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        # Phase 1: Bidirectional growth until initial path found\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size * self.max_radius_factor)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire within neighbors with recursive cost update\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    self._update_costs_recursive(near_node)\n\n            # Attempt connection to other tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n                    success_state = True\n                    break\n\n        # Phase 2: Refinement via single-tree informed RRT*\n        if found_solution and best_goal_node is not None:\n            tree = [start_root]\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n            no_improve_count = 0\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if timed_out() or no_improve_count >= 120:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size * self.max_radius_factor)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        self._update_costs_recursive(near_node)\n                        rewired = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
            "objective": -26.48735,
            "time_improvement": 58.0,
            "length_improvement": 13.0,
            "smoothness_improvement": 228.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017215156555175783,
                    "num_nodes_avg": 208.5,
                    "path_length_avg": 160.40239983380974,
                    "smoothness_avg": 0.02374652355073028,
                    "success_improvement": 0.0,
                    "time_improvement": 33.43633614808805,
                    "length_improvement": 12.08090291241019,
                    "smoothness_improvement": 271.6846599701681,
                    "objective_score": 18.637865891723372
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03504271507263183,
                    "num_nodes_avg": 467.1,
                    "path_length_avg": 253.42542860882128,
                    "smoothness_avg": 0.010719255016317384,
                    "success_improvement": 0.0,
                    "time_improvement": 78.67477272090856,
                    "length_improvement": 15.399297483864519,
                    "smoothness_improvement": 175.8141523371588,
                    "objective_score": 33.72108106827707
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.019155335426330567,
                    "num_nodes_avg": 300.1,
                    "path_length_avg": 131.29531716904052,
                    "smoothness_avg": 0.02638587363121502,
                    "success_improvement": 0.0,
                    "time_improvement": 60.81680487189903,
                    "length_improvement": 12.799901947476434,
                    "smoothness_improvement": 235.62636498645543,
                    "objective_score": 27.103114454987843
                }
            ],
            "success_rate": 1.0
        },
        "objective": 160.0,
        "analysis": "1. Problem of the parents algorithm:\n   - Linear nearest neighbor and near neighbor searches causing slow planning time, especially as tree size grows.\n   - Large or improperly tuned adaptive rewiring radius leading to unnecessary computations during rewiring.\n   - Lack of recursive cost updates propagating improvements efficiently, limiting path cost and smoothness optimization.\n   - Early termination after first path found reducing the time available for path refinement and smoothness enhancement.\n   - Step sizes and goal bias parameters not optimally tuned, adversely affecting exploration-exploitation balance and convergence speed.\n\n2. Primary contributors to the performance improvement:\n   - Implementation of recursive cost propagation during rewiring that ensures consistent cost updates to descendants.\n   - Tuned gamma_rrt_star and introduction of a max_radius_factor to better control the adaptive neighbor radius, reducing excessive neighbor searches.\n   - Slight increase in goal sample rate (goal bias) improving targeted exploration towards the goal.\n   - Longer refinement phase with ellipsoidal informed sampling focusing sample efforts within a relevant region to improve path quality.\n   - Consistent maintenance of parent-child relationships allowing for effective rewiring and path cost improvement propagation.\n\n3. Expected mechanism of impact:\n   - Recursive cost updates allow better cost propagation enabling the rewiring phase to yield smoother and lower-cost paths.\n   - Controlled neighbor radius shrinkage reduces unnecessary rewiring attempts, improving planning efficiency and enabling more iterations within time limit.\n   - Increased goal bias directs samples closer to the goal region, increasing likelihood of finding better connections sooner.\n   - Ellipsoidal informed sampling focuses sampling within the cost-informed region post initial solution, accelerating convergence to a smooth, near-optimal path.\n   - The interplay of precise rewiring and cost updates yields smoother trajectories by reducing abrupt cost jumps and enabling continuous path improvement."
    },
    {
        "parents": [
            {
                "operator": "m1",
                "algorithm_description": "An enhanced bidirectional RRT* planner featuring adaptive rewiring radius, balanced goal-biased tree extension, ellipsoidal informed sampling refinement, and integrated caching for nearest neighbor queries to improve runtime. It concurrently grows two trees with dynamic goal biasing, efficiently rewires nodes within an adaptively shrinking radius, and upon finding a feasible path, refines it with focused informed sampling until a 30-second termination, returning the best collision-free path found.",
                "planning_mechanism": "The planner alternates balanced expansions of start and goal trees with adaptive goal bias sampling and steering constrained by step size. It efficiently manages parent-child relationships and rewiring with an adaptive radius proportional to the tree size and space dimension, reducing redundant checks. It applies ellipsoidal informed sampling after an initial solution to concentrate search around promising corridors. Nearest neighbor queries are cached and updated incrementally for runtime gain. Collisions are strictly checked for nodes and edges. The search interrupts upon time expiration, ensuring the best path found is returned for robust operation.",
                "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        \n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n        \n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            \n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = 45.0\n        self.goal_sample_rate = 0.18\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n        # Cache for nearest neighbor acceleration\n        self._nn_cache = {}\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, fpos, tpos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(fpos, tpos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(fpos[d] + (tpos[d]-fpos[d])*(i/steps) for d in range(len(fpos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    \n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d]-from_pos[d])*r for d in range(len(from_pos)))\n    \n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n    \n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob, ellipsoid=None):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        if ellipsoid is None:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        else:\n            center, c1, c2, a1, norm_a1 = ellipsoid\n            while True:\n                rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n                norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n                if norm_dir < 1e-12:\n                    continue\n                unit_dir = [x / norm_dir for x in rnd_dir]\n                r = random.random() ** (1.0/dim)\n                ball_point = [r*x for x in unit_dir]\n                scaled = [c1*ball_point[0]] + [c2*ball_point[i] for i in range(1, dim)]\n                dir_a1 = [x / norm_a1 for x in a1]\n                point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n                for i in range(1, dim):\n                    point[i] += scaled[i]\n                pt = tuple(min(max(0.0, point[d]), bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        # Use cached index if available for same tree object to speed nearest neighbor\n        key = id(tree)\n        if key not in self._nn_cache:\n            self._nn_cache[key] = tree[:]\n        else:\n            if len(self._nn_cache[key]) != len(tree):\n                self._nn_cache[key] = tree[:]\n        return min(self._nn_cache[key], key=lambda n: self._dist(n.position, point))\n    \n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        # Filter cached to speed\n        key = id(tree)\n        if key not in self._nn_cache:\n            self._nn_cache[key] = tree[:]\n        result = []\n        for n in self._nn_cache[key]:\n            if self._dist(n.position, point) <= radius:\n                result.append(n)\n        return result\n    \n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_from_start = node_start.path_from_root()\n        path_from_goal = node_goal.path_from_root()\n        path_from_goal.reverse()\n        return path_from_start + path_from_goal[1:]\n    \n    def _ellipsoid_parameters(self, c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...], bounds):\n        dim = len(bounds)\n        center = tuple((s+g)/2 for s,g in zip(start,goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            norm_a1 = 1e-12  # prevent degenerate\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n        return (center, c1, c2, a1, norm_a1)\n    \n    def _propagate_cost_to_children(self, node: Node):\n        for c in node.children:\n            old_cost = c.cost\n            c.cost = node.cost + self._dist(node.position, c.position)\n            if abs(c.cost - old_cost) > 1e-10:\n                self._propagate_cost_to_children(c)\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        start_time = time.monotonic()\n\n        def time_exceeded():\n            return (time.monotonic() - start_time) > self.time_limit\n\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for i in range(self.max_iter):\n            if time_exceeded():\n                break\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n\n            goal_bias = self.goal_sample_rate\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal if expand_start else start, goal_bias)\n\n            nearest = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, resolution=1.0):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)), self.step_size * 15)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near in near_nodes:\n                cost_cand = near.cost + self._dist(near.position, new_pos)\n                if cost_cand < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_cand\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    self._propagate_cost_to_children(near)\n\n            # Try connect trees\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_b.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_b.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_b, cost=nearest_b.cost + dist_connect)\n                nearest_b.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_b, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_b.cost)\n                    goal_node_for_path = connect_node\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n                    goal_node_for_path = new_node\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = goal_node_for_path\n                    found_solution = True\n                    success_state = True\n\n                # Stop early on first solution to refine later\n                if found_solution:\n                    break\n\n        if found_solution and best_goal_node:\n            # Rebuild tree from start root with best path nodes\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children.clear()\n            start_root.cost = 0.0\n\n            prev = start_root\n            for pos in best_path[1:]:\n                n = Node(pos, parent=prev, cost=prev.cost + self._dist(prev.position, pos))\n                prev.add_child(n)\n                tree.append(n)\n                nodes.append(n)\n                edges.append((prev, n))\n                prev = n\n            best_goal_node = prev\n            best_cost = best_goal_node.cost\n\n            # Ellipsoid parameters for informed sampling\n            c_min = self._dist(start, goal)\n            no_improve_count = 0\n            max_no_improve = 150\n            refinement_iters = self.max_iter // 2\n\n            for _ in range(refinement_iters):\n                if time_exceeded() or no_improve_count >= max_no_improve:\n                    break\n                ellipsoid = self._ellipsoid_parameters(best_cost, c_min, start, goal, bounds)\n                sample_pt = self._sample(bounds, obstacles, is_3d, goal, 0.0, ellipsoid)\n                nearest = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_tree_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_tree_nodes) / n_tree_nodes) ** (1.0 / dim)), self.step_size * 15)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near in near_nodes:\n                    cost_candidate = near.cost + self._dist(near.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near in near_nodes:\n                    if near is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_via_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_via_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        self._propagate_cost_to_children(near)\n                        rewired = True\n\n                dist_to_goal = self._dist(new_node.position, goal)\n                if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal, obstacles, is_3d):\n                    goal_node = Node(goal, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
                "objective": -13.83763,
                "time_improvement": 17.0,
                "length_improvement": 12.0,
                "smoothness_improvement": 224.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.025319766998291016,
                        "num_nodes_avg": 124.3,
                        "path_length_avg": 163.2394983196226,
                        "smoothness_avg": 0.022534320283976204,
                        "success_improvement": 0.0,
                        "time_improvement": 2.09926619713116,
                        "length_improvement": 10.525844275633734,
                        "smoothness_improvement": 252.71104650394102,
                        "objective_score": 8.208841657039294
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.04371612071990967,
                        "num_nodes_avg": 119.0,
                        "path_length_avg": 261.4357946273634,
                        "smoothness_avg": 0.011276384089395365,
                        "success_improvement": 0.0,
                        "time_improvement": 73.39657591656308,
                        "length_improvement": 12.72520674127337,
                        "smoothness_improvement": 190.14948467130657,
                        "objective_score": 30.604844243089474
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.060172200202941895,
                        "num_nodes_avg": 108.8,
                        "path_length_avg": 129.2796635396884,
                        "smoothness_avg": 0.025811603953994167,
                        "success_improvement": 0.0,
                        "time_improvement": -23.085240188387644,
                        "length_improvement": 14.138603112980558,
                        "smoothness_improvement": 228.32169708038452,
                        "objective_score": 2.6991982966739645
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "An optimized bidirectional RRT* planner with incremental nearest neighbor caching, adaptive rewiring radius, and efficient ellipsoidal informed sampling refinement, incorporating subtree cost update propagation, balanced goal-biased tree expansion, and early pruning strategies for faster convergence and smoother, shorter paths within a strict 30-second time limit.",
            "planning_mechanism": "The planner alternates growth of two trees from start and goal with adaptive radius rewiring and goal bias. Nearest neighbor queries use incremental caching to reduce computation. Upon initial solution discovery, it performs focused refinement via ellipsoidal informed sampling in a single tree. Rewiring propagates cost changes to descendants to maintain consistency, and collision checks prune expansions early. The best feasible path found within the time limit is returned.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = 40.0  # Tuned parameter\n        self.goal_sample_rate = 0.2\n        self.time_limit = 30.0\n        self.improve_tol = 1e-7\n        \n        # Nearest neighbor cache keyed by tree id: stores nodes list snapshot\n        self._nn_cache = {}\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d]-from_pos[d])*r for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob, ellipsoid=None):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        if ellipsoid is None:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        else:\n            center, c1, c2, a1, norm_a1 = ellipsoid\n            while True:\n                rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n                norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n                if norm_dir < 1e-12:\n                    continue\n                unit_dir = [x / norm_dir for x in rnd_dir]\n                r = random.random() ** (1.0/dim)\n                ball_point = [r*x for x in unit_dir]\n                scaled = [c1*ball_point[0]] + [c2*ball_point[i] for i in range(1, dim)]\n                dir_a1 = [x / norm_a1 for x in a1]\n                point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n                for i in range(1, dim):\n                    point[i] += scaled[i]\n                pt = tuple(min(max(0.0, point[d]), bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        key = id(tree)\n        if key not in self._nn_cache or len(self._nn_cache[key]) != len(tree):\n            self._nn_cache[key] = list(tree)\n        nearest_node = min(self._nn_cache[key], key=lambda n: self._dist(n.position, point))\n        return nearest_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        key = id(tree)\n        if key not in self._nn_cache or len(self._nn_cache[key]) != len(tree):\n            self._nn_cache[key] = list(tree)\n        candidates = [n for n in self._nn_cache[key] if self._dist(n.position, point) <= radius]\n        return candidates\n\n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoid_parameters(self, c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...], bounds):\n        dim = len(bounds)\n        center = tuple((s + g) * 0.5 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            norm_a1 = 1e-12\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n        return (center, c1, c2, a1, norm_a1)\n\n    def _propagate_cost(self, node: Node):\n        for child in node.children:\n            old_cost = child.cost\n            child.cost = node.cost + self._dist(node.position, child.position)\n            if abs(child.cost - old_cost) > 1e-10:\n                self._propagate_cost(child)\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        start_time = time.monotonic()\n        time_limit = self.time_limit\n        \n        def time_exceeded():\n            return (time.monotonic() - start_time) > time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success = False\n\n        for i in range(self.max_iter):\n            if time_exceeded():\n                break\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n            goal_bias = self.goal_sample_rate\n            \n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, goal_bias)\n\n            nearest = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, resolution=1.0):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            # Adaptive radius with upper limit\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)), self.step_size * 12)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for near in near_nodes:\n                if near is nearest:\n                    continue\n                cost_candidate = near.cost + self._dist(near.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    # Remove old edge\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    # Propagate cost to children recursively\n                    self._propagate_cost(near)\n\n            # Attempt to connect trees\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_b.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_b.position, new_node.position, obstacles, is_3d):\n                # Create connecting node in tree_b as child of nearest_b\n                conn_node = Node(new_node.position, parent=nearest_b, cost=nearest_b.cost + dist_connect)\n                nearest_b.add_child(conn_node)\n                tree_b.append(conn_node)\n                nodes.append(conn_node)\n                edges.append((nearest_b, conn_node))\n\n                if expand_start:\n                    cur_path = self._build_path(new_node, conn_node)\n                    cur_cost = new_node.cost + (conn_node.cost - nearest_b.cost)\n                    goal_node_for_path = conn_node\n                else:\n                    cur_path = self._build_path(conn_node, new_node)\n                    cur_cost = conn_node.cost + (new_node.cost - best_parent.cost)\n                    goal_node_for_path = new_node\n\n                if cur_cost + self.improve_tol < best_cost:\n                    best_cost = cur_cost\n                    best_path = cur_path\n                    best_goal_node = goal_node_for_path\n                    found_solution = True\n                    success = True\n\n                if found_solution:\n                    break\n\n        # If solution found, start refinement via ellipsoidal informed sampling\n        if found_solution and best_goal_node:\n            # Rebuild single tree from start_root along best path nodes\n            # Clear old children\n            start_root.children.clear()\n            start_root.cost = 0.0\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            prev = start_root\n            for pos in best_path[1:]:\n                nd = Node(pos, parent=prev, cost=prev.cost + self._dist(prev.position, pos))\n                prev.add_child(nd)\n                tree.append(nd)\n                nodes.append(nd)\n                edges.append((prev, nd))\n                prev = nd\n            best_goal_node = prev\n            best_cost = best_goal_node.cost\n\n            c_min = self._dist(start_pos, goal_pos)\n            no_improve_count = 0\n            max_no_improve = 150\n            refinement_max_iter = self.max_iter // 2\n\n            for _ in range(refinement_max_iter):\n                if time_exceeded() or no_improve_count >= max_no_improve:\n                    break\n                ellipsoid = self._ellipsoid_parameters(best_cost, c_min, start_pos, goal_pos, bounds)\n                sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos, 0.0, ellipsoid)\n\n                nearest = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest.position, sample_pt)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)), self.step_size * 12)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near in near_nodes:\n                    cost_cand = near.cost + self._dist(near.position, new_pos)\n                    if cost_cand < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_cand\n                        best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                \n                rewired = False\n                for near in near_nodes:\n                    if near is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_via_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_via_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        self._propagate_cost(near)\n                        rewired = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success else best_path\n        else:\n            extracted_path = best_path\n            success = found_solution\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
            "objective": -12.40664,
            "time_improvement": 11.0,
            "length_improvement": 13.0,
            "smoothness_improvement": 197.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024726438522338866,
                    "num_nodes_avg": 136.2,
                    "path_length_avg": 158.9240097978004,
                    "smoothness_avg": 0.02154214850608637,
                    "success_improvement": 0.0,
                    "time_improvement": 4.393414211438477,
                    "length_improvement": 12.89123191773616,
                    "smoothness_improvement": 237.18140364446492,
                    "objective_score": 10.238670432295564
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.035642027854919434,
                    "num_nodes_avg": 112.6,
                    "path_length_avg": 250.04126451818865,
                    "smoothness_avg": 0.011241461904313998,
                    "success_improvement": 0.0,
                    "time_improvement": 78.31006121761729,
                    "length_improvement": 16.52902886508012,
                    "smoothness_improvement": 189.2509116957298,
                    "objective_score": 34.35669024281191
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07304487228393555,
                    "num_nodes_avg": 103.4,
                    "path_length_avg": 133.94841461811015,
                    "smoothness_avg": 0.020864073099746132,
                    "success_improvement": 0.0,
                    "time_improvement": -49.416933721475225,
                    "length_improvement": 11.037840948728759,
                    "smoothness_improvement": 165.38946980308978,
                    "objective_score": -7.375428198189863
                }
            ],
            "success_rate": 1.0
        },
        "objective": 129.0,
        "analysis": "1. Problem of the parents algorithm:  \n   - Inefficient nearest neighbor cache updates that duplicate entire node lists each iteration, causing overhead as tree size grows.  \n   - Large upper bound on adaptive rewiring radius (step_size * 15) leading to excessive neighborhood checks and computational load.  \n   - Early stopping immediately after first solution found limits exploration, possibly missing better initial paths.  \n   - Rewiring and path building without careful pruning or cost tolerance causes unnecessary cost propagation and slower convergence.  \n   - Lack of more precise cost improvement tolerance and less tuned parameters resulting in slower refinement and less stable rewiring.  \n\n2. Primary contributors to the performance improvement:  \n   - More efficient nearest neighbor caching that updates only when tree size changes, reducing redundant computations.  \n   - Reduced rewiring radius upper bound (step_size * 12) limiting neighbor searches and improving iteration efficiency.  \n   - Tuned parameters including gamma_rrt_star, goal_sample_rate, and tightened improve_tol (1e-7) leading to more precise rewiring and pruning.  \n   - Consistent recursive cost propagation and cautious edge removal/addition during rewiring to maintain accurate subtree costs and stability.  \n   - Balanced bidirectional expansion with better goal bias and refined ellipsoidal informed sampling improving path searching and refinement.  \n\n3. Expected mechanism of impact:  \n   - Reduced nearest neighbor cache overhead accelerates nearest and near queries, improving per-iteration planning time.  \n   - Smaller rewiring radius reduces computational complexity of neighbor evaluations, enabling faster rewiring and path improvements.  \n   - Tighter cost improvement threshold avoids unnecessary rewiring, focusing computational effort on meaningful updates.  \n   - Accurate cost propagation ensures subtree costs remain consistent, preventing stale or suboptimal paths and improving global path quality.  \n   - Enhanced sampling and rewiring balance exploration and exploitation, enabling faster discovery and refinement of shorter, smoother paths."
    },
    {
        "parents": [
            {
                "operator": "e2",
                "algorithm_description": "A hybrid bidirectional RRT* planner with adaptive neighborhood radius, recursive cost updating, and a two-phase search that combines rapid initial path discovery with a dedicated informed refinement phase using ellipsoidal sampling. The planner enforces strict collision checking, balances exploration and exploitation with goal biasing, and terminates early with the best solution found within 30 seconds.",
                "planning_mechanism": "It grows two trees alternately from start and goal with adaptive radius rewiring, connecting when close enough to produce an initial feasible path. Once found, the planner switches to a single-tree ellipsoidal informed RRT* refinement phase to optimize path length and smoothness within the time limit. Recursive cost propagation and careful edge/parent management ensure cost-consistent and smooth paths.",
                "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_recursively(self, new_cost: float):\n        if new_cost + 1e-14 >= self.cost:\n            return\n        cost_diff = new_cost - self.cost\n        self.cost = new_cost\n        for child in self.children:\n            child.update_cost_recursively(child.cost + cost_diff)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2\n        self.time_limit = 30.0\n        self.gamma_rrt_star = 35.0\n        self.improve_tol = 1e-8\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*i/steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        return math.dist(p1, p2)\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _sample(self, bounds: Tuple[int, ...], obstacles, is_3d: bool, goal_pos: Tuple[float, ...], goal_bias: float) -> Tuple[float, ...]:\n        if random.random() < goal_bias and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n            return goal_pos\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float('inf') or c_best < c_min - 1e-14:\n            # No solution yet: uniform sample\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        center = tuple((s + g)*0.5 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-14:\n            # Start and goal too close, uniform sample\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c1 = c_best * 0.5\n        try:\n            c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) * 0.5\n        except:\n            c2 = 0.0\n\n        while True:\n            dir_vec = [random.gauss(0,1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x*x for x in dir_vec))\n            if norm_dir < 1e-14:\n                continue\n            unit_dir = [x/norm_dir for x in dir_vec]\n            r = random.random()**(1.0/dim)\n            ball_point = [r*x for x in unit_dir]\n\n            scaled = [c1*ball_point[0]] + [c2*ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x/norm_a1 for x in a1]\n\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        radius_sq = radius*radius\n        results = []\n        for node in tree:\n            d_sq = sum((node.position[d]-point[d])**2 for d in range(len(point)))\n            if d_sq <= radius_sq:\n                results.append(node)\n        return results\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - start_time) >= self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        # Bidirectional growth phase\n        for it in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start_tree = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start_tree else (tree_goal, tree_start)\n            goal_sample = goal_pos if expand_start_tree else start_pos\n\n            sample_point = self._sample(bounds, obstacles, is_3d, goal_sample, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_point)\n            new_pos = self._steer(nearest_node.position, sample_point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size * 10)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position,new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                candidate_cost = near_node.cost + self._dist(near_node.position,new_pos)\n                if candidate_cost + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position,new_pos,obstacles,is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent,new_node))\n\n            # Rewire neighbors with recursive cost propagation\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.update_cost_recursively(cost_through_new)\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Try connecting trees\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                # Add connecting node on other tree if not at exact location\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start_tree else new_node\n                    found_solution = True\n                    success_state = True\n\n                # Early break to start refinement phase\n                if found_solution:\n                    break\n            if found_solution:\n                break\n\n        # Refinement phase via single-tree informed RRT*\n        if found_solution and best_goal_node:\n            # Reset tree to only start node and path nodes from best path\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                c = prev_node.cost + self._dist(prev_node.position, pos)\n                new_node = Node(pos, parent=prev_node, cost=c)\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            c_min = self._dist(start_pos, goal_pos)\n            max_no_improve = 120\n            no_improve_cnt = 0\n            post_opt_iters = self.max_iter // 2\n\n            for _ in range(post_opt_iters):\n                if timed_out() or no_improve_cnt >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_cnt += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size * 10)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position,new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + self._dist(near_node.position,new_pos)\n                    if candidate_cost + self.improve_tol < min_cost:\n                        if not self._is_edge_in_obstacle(near_node.position,new_pos,obstacles,is_3d):\n                            min_cost = candidate_cost\n                            best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent,new_node))\n\n                rewired_any = False\n                for near_node in near_nodes:\n                    if near_node is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                            if near_node.parent:\n                                try:\n                                    edges.remove((near_node.parent, near_node))\n                                except ValueError:\n                                    pass\n                                near_node.parent.remove_child(near_node)\n                            near_node.parent = new_node\n                            near_node.update_cost_recursively(cost_through_new)\n                            new_node.add_child(near_node)\n                            edges.append((new_node, near_node))\n                            rewired_any = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node_new = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node_new)\n                    tree.append(goal_node_new)\n                    nodes.append(goal_node_new)\n                    edges.append((new_node, goal_node_new))\n                    if goal_node_new.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node_new.cost\n                        best_goal_node = goal_node_new\n                        no_improve_cnt = 0\n                        success_state = True\n                    else:\n                        no_improve_cnt += 1\n                else:\n                    no_improve_cnt += 1\n\n                if not rewired_any:\n                    no_improve_cnt += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
                "objective": -11.51371,
                "time_improvement": 17.0,
                "length_improvement": 9.0,
                "smoothness_improvement": 155.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.03187241554260254,
                        "num_nodes_avg": 117.3,
                        "path_length_avg": 166.87970482899973,
                        "smoothness_avg": 0.018994705109336533,
                        "success_improvement": 0.0,
                        "time_improvement": -23.237029388989274,
                        "length_improvement": 8.530589405080702,
                        "smoothness_improvement": 197.3083826234534,
                        "objective_score": -0.8662132605310936
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.046278762817382815,
                        "num_nodes_avg": 107.4,
                        "path_length_avg": 270.1578867586253,
                        "smoothness_avg": 0.008655529385985294,
                        "success_improvement": 0.0,
                        "time_improvement": 71.83708130975783,
                        "length_improvement": 9.813521336356082,
                        "smoothness_improvement": 122.71300542722501,
                        "objective_score": 28.052802221877123
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.04702279567718506,
                        "num_nodes_avg": 84.0,
                        "path_length_avg": 136.7956678787287,
                        "smoothness_avg": 0.019224876036262474,
                        "success_improvement": 0.0,
                        "time_improvement": 3.8125233789801545,
                        "length_improvement": 9.146830904656529,
                        "smoothness_improvement": 144.53900414851907,
                        "objective_score": 7.354550577230558
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "A hybrid bidirectional RRT* planner integrating adaptive neighborhood rewiring with incremental informed path refinement. The algorithm alternates tree expansions from start and goal, uses adaptive radius for rewiring with efficient nearest and near searches, and upon initial path discovery switches to an incremental informed sampling refinement phase centered on the current best path. Recursive cost updates, consistent parent-child-edge management, goal bias sampling, and collision checks enforce path validity while improving path length, smoothness, and planning efficiency within a strict 30-second time limit.",
            "planning_mechanism": "A bidirectional RRT* grows two trees from start and goal with adaptive rewiring radii and goal bias sampling, connecting them when feasible to form an initial solution. This switches to a single-tree incremental informed refinement phase, sampling inside an ellipsoidal subspace around the best path to improve path cost and smoothness. Parent-child edges are maintained carefully with recursive cost propagation upon rewiring. Early stopping is triggered on time limit or convergence, returning the best path found with success status.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_recursively(self, new_cost: float):\n        if new_cost + 1e-14 >= self.cost:\n            return\n        diff = new_cost - self.cost\n        self.cost = new_cost\n        for c in self.children:\n            c.update_cost_recursively(c.cost + diff)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = 30.0\n        self.goal_sample_rate = 0.25\n        self.time_limit = 30.0\n        self.improve_tol = 1e-9\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        return math.dist(p1, p2)\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _sample_uniform(self, bounds: Tuple[int, ...], obstacles, is_3d: bool):\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _sample_goal_bias(self, bounds: Tuple[int, ...], obstacles, is_3d: bool, goal_pos: Tuple[float, ...], goal_bias: float):\n        if random.random() < goal_bias and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n            return goal_pos\n        return self._sample_uniform(bounds, obstacles, is_3d)\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float('inf') or c_best < c_min - 1e-14:\n            # No solution yet: uniform sampling\n            return self._sample_uniform(bounds, obstacles, is_3d)\n\n        center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n        vec = tuple(g - s for s, g in zip(start, goal))\n        norm_vec = math.sqrt(sum(x * x for x in vec))\n        if norm_vec < 1e-14:\n            return self._sample_uniform(bounds, obstacles, is_3d)\n        a1 = tuple(x / norm_vec for x in vec)\n\n        c1 = c_best * 0.5\n        try:\n            c2 = math.sqrt(max(c_best ** 2 - c_min ** 2, 0.0)) * 0.5\n        except Exception:\n            c2 = 0.0\n\n        while True:\n            direction = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in direction))\n            if norm_dir < 1e-14:\n                continue\n            unit_dir = [x / norm_dir for x in direction]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n\n            scaled = [c1 * ball_point[0]] + [c2 * bp for bp in ball_point[1:]]\n            # Construct orthonormal basis with a1 as first axis\n            # Simple method: rotate vector in axis-aligned system\n            point = [center[d] + a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        radius_sq = radius * radius\n        result = []\n        for n in tree:\n            dist_sq = sum((n.position[d] - point[d]) ** 2 for d in range(len(point)))\n            if dist_sq <= radius_sq:\n                result.append(n)\n        return result\n\n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        def timed_out() -> bool:\n            return (time.monotonic() - start_time) >= self.time_limit\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = tree_start[:] + tree_goal[:]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        max_rewire_radius_factor = 10.0\n        max_rewire_radius = self.step_size * max_rewire_radius_factor\n\n        # -------------------- Bidirectional phase --------------------\n        for it in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            goal_sample = goal_pos if expand_start else start_pos\n\n            sample = self._sample_goal_bias(bounds, obstacles, is_3d, goal_sample, self.goal_sample_rate)\n\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), max_rewire_radius)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_n in near_nodes:\n                candidate_cost = near_n.cost + self._dist(near_n.position, new_pos)\n                if candidate_cost + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_n.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_n\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near nodes with recursive cost updates\n            for near_n in near_nodes:\n                if near_n is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_n.position)\n                if cost_through_new + self.improve_tol < near_n.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_n.position, obstacles, is_3d):\n                        if near_n.parent:\n                            try:\n                                edges.remove((near_n.parent, near_n))\n                            except ValueError:\n                                pass\n                            near_n.parent.remove_child(near_n)\n                        near_n.parent = new_node\n                        near_n.update_cost_recursively(cost_through_new)\n                        new_node.add_child(near_n)\n                        edges.append((new_node, near_n))\n\n            # Attempt to connect trees\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_to_other = self._dist(nearest_other.position, new_node.position)\n            if dist_to_other <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    # Connect trees by creating a connecting node on the other tree\n                    connect_node = Node(new_node.position,\n                                        parent=nearest_other,\n                                        cost=nearest_other.cost + dist_to_other)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    if expand_start:\n                        candidate_path = self._build_path(new_node, connect_node)\n                        candidate_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        candidate_path = self._build_path(connect_node, new_node)\n                        candidate_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if candidate_cost + self.improve_tol < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n                        best_goal_node = connect_node if expand_start else new_node\n                        found_solution = True\n                        success_state = True\n\n                    # Once initial path found, break to start refinement\n                    if found_solution:\n                        break\n            if found_solution:\n                break\n\n        # -------------------- Incremental informed refinement phase --------------------\n        if found_solution and best_goal_node:\n            # Reinitialize single-tree with the found path\n            tree = [Node(start_pos, cost=0.0)]\n            nodes = [tree[0]]\n            edges = []\n            tree[0].children = []\n\n            prev = tree[0]\n            for pos in best_path[1:]:\n                c = prev.cost + self._dist(prev.position, pos)\n                n = Node(pos, parent=prev, cost=c)\n                prev.add_child(n)\n                tree.append(n)\n                nodes.append(n)\n                edges.append((prev, n))\n                prev = n\n\n            best_goal_node = prev\n            best_cost = best_goal_node.cost\n\n            c_min = self._dist(start_pos, goal_pos)\n            no_improve_count = 0\n            max_no_improve = 100\n            refinement_iters = self.max_iter // 2\n\n            for _ in range(refinement_iters):\n                if timed_out() or no_improve_count >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min,\n                                                              start_pos, goal_pos,\n                                                              bounds, obstacles, is_3d)\n\n                nearest = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), max_rewire_radius)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near_n in near_nodes:\n                    candidate_cost = near_n.cost + self._dist(near_n.position, new_pos)\n                    if candidate_cost + self.improve_tol < min_cost:\n                        if not self._is_edge_in_obstacle(near_n.position, new_pos, obstacles, is_3d):\n                            min_cost = candidate_cost\n                            best_parent = near_n\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near_n in near_nodes:\n                    if near_n is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_n.position)\n                    if cost_through_new + self.improve_tol < near_n.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near_n.position, obstacles, is_3d):\n                            if near_n.parent:\n                                try:\n                                    edges.remove((near_n.parent, near_n))\n                                except ValueError:\n                                    pass\n                                near_n.parent.remove_child(near_n)\n                            near_n.parent = new_node\n                            near_n.update_cost_recursively(cost_through_new)\n                            new_node.add_child(near_n)\n                            edges.append((new_node, near_n))\n                            rewired = True\n\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                        goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                        new_node.add_child(goal_node)\n                        tree.append(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n\n                        if goal_node.cost + self.improve_tol < best_cost:\n                            best_cost = goal_node.cost\n                            best_goal_node = goal_node\n                            no_improve_count = 0\n                            success_state = True\n                        else:\n                            no_improve_count += 1\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            if best_goal_node:\n                extracted_path = best_goal_node.path_from_root()\n            else:\n                extracted_path = best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
            "objective": -15.78863,
            "time_improvement": 26.0,
            "length_improvement": 12.0,
            "smoothness_improvement": 131.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025350546836853026,
                    "num_nodes_avg": 80.7,
                    "path_length_avg": 159.44212186387108,
                    "smoothness_avg": 0.016914811536104846,
                    "success_improvement": 0.0,
                    "time_improvement": 1.9802536966702367,
                    "length_improvement": 12.607246484311755,
                    "smoothness_improvement": 164.75353164119315,
                    "objective_score": 8.98219165779409
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04258110523223877,
                    "num_nodes_avg": 101.5,
                    "path_length_avg": 264.79743783191964,
                    "smoothness_avg": 0.007870517390592788,
                    "success_improvement": 0.0,
                    "time_improvement": 74.08728904166492,
                    "length_improvement": 11.602993480057835,
                    "smoothness_improvement": 102.51408136449002,
                    "objective_score": 29.700553207356624
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04729220867156982,
                    "num_nodes_avg": 79.0,
                    "path_length_avg": 132.80804150961566,
                    "smoothness_avg": 0.01772934582986569,
                    "success_improvement": 0.0,
                    "time_improvement": 3.2614256459426256,
                    "length_improvement": 11.795222468658766,
                    "smoothness_improvement": 125.5159703117091,
                    "objective_score": 8.683141026536592
                }
            ],
            "success_rate": 1.0
        },
        "objective": 88.19999999999999,
        "analysis": "1. Problem of the parents algorithm:\n   - Inefficient and repetitive recursive cost updates caused computational overhead and slowed planning time.\n   - Linear nearest and near neighbor searches without spatial indexing limited scalability as tree size increased.\n   - Fixed large rewiring radius and inconsistent parent-child edge management led to inflated path length and suboptimal smoothness.\n   - Lack of explicit smoothing or curvature consideration during rewiring resulted in piecewise linear paths with sharp turns.\n\n2. Primary contributors to the performance improvement:\n   - More consistent parent-child edge updates including proper child removal, reducing redundancy and enabling efficient cost propagation.\n   - Increased goal sample rate enhancing goal-directed exploration, improving path discovery and quality.\n   - Adaptive maximum rewiring radius limit, balancing neighbor search scope to optimize computational effort.\n   - Structured incremental informed refinement phase leveraging ellipsoidal sampling focusing on the best path for smoothing.\n   - Enhanced improve tolerance threshold allowing more precise rewiring and cost updates.\n\n3. Expected mechanism of impact:\n   - Efficient management of the tree structure and cost propagation reduces unnecessary recalculations, speeding up planning without sacrificing path quality.\n   - Better goal biasing directs sampling towards promising regions, accelerating convergence toward optimal solutions.\n   - Controlled neighborhood radius limits computational overhead while maintaining necessary rewiring for path optimality.\n   - Informed ellipsoidal sampling guided refinement enables targeted improvement of path smoothness and length, reducing abrupt direction changes.\n   - Tighter improvement tolerance prevents premature rejection of beneficial rewiring, promoting more finely optimized paths."
    },
    {
        "parents": [
            {
                "operator": "m2",
                "algorithm_description": "An adaptive bidirectional RRT* planner with goal biasing, incremental rewiring, and informed sampling to efficiently find and iteratively improve a near-optimal path within a 30-second limit. The planner balances growth between start and goal trees, performs adaptive radius neighbor searches for rewiring, and applies an ellipsoidal informed sampling once a solution is found to enhance convergence and path smoothness.",
                "planning_mechanism": "The planner alternates expansions of two trees towards random samples biased towards the goal, incrementally rewires nodes with neighbors in adaptive shrinking radius to improve path cost and smoothness, and upon initial solution discovery, switches to single-tree informed RRT* refinement sampling inside an ellipsoid defined by current best cost to optimize the path further, always enforcing collision checking on nodes and edges, and returning the best path found upon timeout or success.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        # Parameters for rewiring and goal bias\n        self.goal_sample_rate = 0.15        # Probability to sample the goal (goal bias)\n        self.gamma_rrt_star = 50.0          # Parameter for adaptive neighbor radius\n        self.improve_tol = 1e-6             # Improvement tolerance for path cost updates\n        self.time_limit = 30.0              # seconds time limit\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        # Goal biased sampling with specified probability\n        if random.random() < goal_bias_prob:\n            # sample goal directly if free\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n        # Otherwise uniform sample within bounds and free space\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        # Linear nearest search (simple but acceptable)\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _path_cost(self, node):\n        return node.cost\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # Avoid duplicating connecting node\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        # If no solution yet, uniform sample\n        if c_best == float(\"inf\") or c_best < c_min - 1e-10:\n            # fallback to uniform sampling\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        # Ellipsoid sampling inside prolate hyperspheroid\n        # Code adapted from literature informed RRT* sampling, avoids numpy:\n        dim = len(bounds)\n        center = tuple((s + g)/2 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            # Avoid degenerate case\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        # Construct basis for rotation - produce orthonormal matrix with a1 as first column\n        # Here only rotate axis to x direction, so use rotated coordinates is not required for sampling uniform ball\n        # Instead sample in unit ball, then scale and translate\n\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n\n        while True:\n            # Sample random point in unit ball in R^dim\n            rnd_dir = []\n            # Sample standard normal gaussian vector\n            for _ in range(dim):\n                rnd_dir.append(random.gauss(0,1))\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12: continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n\n            # Radius scaling to distribute uniformly inside ball\n            r = random.random() ** (1.0/dim)\n            ball_point = [r * x for x in unit_dir]\n\n            # Scale ball_point components for ellipsoid radii\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n\n            # Rotate scaled vector to align with real coordinate system (only one axis, so just shift)\n            # Since rotation matrix is large effort and only affects orientation, approximate by axis aligned\n            # We rotate by vector a1/norm_a1 using Householder reflection or simplified since high cost\n            # To simplify, we place along the direction a1 by scaling only the first coordinate\n            # This is acceptable for performance and uniformity compromise\n            # Align first dimension with a1 direction:\n            # new_point = center + rotation * scaled\n\n            # Construct base vector in direction a1:\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            # Add components in other basis directions orthogonal to a1\n            # We don't construct orthonormal basis explicitly, skip to keep simplicity and avoid foreign dependencies\n\n            # As an approximation, add the other components along axes orthogonal by spreading them equally\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            # Clamp point inside bounds\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        time_limit = self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n\n        def can_finish():\n            return time.monotonic() - time_start > time_limit\n\n        # Phase 1: Bidirectional RRT* until initial solution found\n        for it in range(self.max_iter):\n            if can_finish():\n                break\n\n            # Alternate expansion: even expands start tree, odd goal tree\n            expand_start_tree = (it % 2 == 0)\n            if expand_start_tree:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Sampling with goal bias\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start_tree else start_pos, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors within adaptive rewiring radius\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes) ** (1/dim)), self.step_size * 20)\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            # Choose parent with minimum cost + edge cost + no collision between parent to new_pos\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes if cheaper via new_node\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and \\\n                   not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Rewire\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            # Attempt to connect from other tree\n            nearest_node_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_node_other.position, new_node.position)\n            if dist_connect <= self.step_size and \\\n               not self._is_edge_in_obstacle(nearest_node_other.position, new_node.position, obstacles, is_3d):\n\n                # Connect the two trees\n                connect_node = Node(new_node.position, parent=nearest_node_other,\n                                   cost=nearest_node_other.cost + dist_connect)\n                nearest_node_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_node_other, connect_node))\n\n                # Construct path: new_node from tree_a and connect_node from tree_b\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_node_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start_tree else new_node\n                    found_solution = True\n                    success_state = True\n\n            if found_solution:\n                break\n\n        # Phase 2: Single-tree informed RRT* refinement if solution found\n        if found_solution and best_goal_node:\n            # Reset tree for refinement: use start_root plus best path nodes (re-create properly)\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node,\n                                cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n            no_improve_count = 0\n            post_opt_iters = self.max_iter // 2\n\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if can_finish() or no_improve_count >= 150:\n                    break\n\n                # Informed sampling inside ellipsoid defined by best_cost\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min,\n                                                              start_pos, goal_pos, bounds, obstacles, is_3d)\n\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size * 20)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                    if candidate_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired_any = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        rewired_any = True\n\n                # Check if can connect directly to goal\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and \\\n                   not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_any:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
                "objective": -21.85805,
                "time_improvement": 39.0,
                "length_improvement": 15.0,
                "smoothness_improvement": 286.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.021411538124084473,
                        "num_nodes_avg": 92.3,
                        "path_length_avg": 161.62176685276987,
                        "smoothness_avg": 0.026296503737064592,
                        "success_improvement": 0.0,
                        "time_improvement": 17.21071942180759,
                        "length_improvement": 11.41254852721125,
                        "smoothness_improvement": 311.59738725690346,
                        "objective_score": 13.568731879153544
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.03712928295135498,
                        "num_nodes_avg": 109.2,
                        "path_length_avg": 246.37899691959302,
                        "smoothness_avg": 0.013803575390083797,
                        "success_improvement": 0.0,
                        "time_improvement": 77.40499284926345,
                        "length_improvement": 17.75159920201941,
                        "smoothness_improvement": 255.17593710033827,
                        "objective_score": 35.14833706149237
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.03867461681365967,
                        "num_nodes_avg": 101.4,
                        "path_length_avg": 127.66449265035354,
                        "smoothness_avg": 0.030873705973109955,
                        "success_improvement": 0.0,
                        "time_improvement": 20.889140107088526,
                        "length_improvement": 15.211322711504014,
                        "smoothness_improvement": 292.7112611180333,
                        "objective_score": 16.857091964619134
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "An adaptive bidirectional RRT* planner with efficient incremental rewiring, recursive cost propagation, and dynamic neighbor radius limiting. The planner balances tree expansions with goal bias, caches nearest neighbors to minimize redundant computation, and triggers ellipsoidal informed sampling refinement after an initial solution is found. It maintains consistent edge and parent-child relationships to improve path smoothness and quality, while enforcing early termination upon timeout to guarantee timely results.",
            "planning_mechanism": "The planner grows two trees alternately from start and goal with adaptive rewiring neighborhoods that shrink logarithmically, uses goal-biased and obstacle-aware sampling, and connects trees when possible. Upon first solution, it refines paths by sampling within an ellipsoid based on current best cost, rewiring neighbors efficiently with recursive cost updating, and pruning unnecessary edges. It terminates when the time limit is reached, returning the best path found.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True  # Indicates if node is free from obstacle\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 40.0\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0\n        try:\n            dist = sum((to_pos[d] - from_pos[d]) ** 2 for d in range(len(from_pos))) ** 0.5\n        except Exception:\n            dist = 0\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, p1, p2):\n        return sum((p1[d] - p2[d]) ** 2 for d in range(len(p1))) ** 0.5\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point, cached=None):\n        best_node = None\n        best_dist = float(\"inf\")\n        if cached is not None:\n            nodes_to_check = cached\n        else:\n            nodes_to_check = tree\n        for node in nodes_to_check:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _update_cost_recursive(self, node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                child.cost = new_cost\n                self._update_cost_recursive(child)\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-10:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s + g)*0.5 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = sum(x * x for x in a1) ** 0.5\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best * 0.5\n        c2 = max((c_best * c_best - c_min * c_min), 0) ** 0.5 * 0.5\n        while True:\n            rnd_dir = []\n            for _ in range(dim):\n                rnd_dir.append(random.gauss(0, 1))\n            norm_dir = sum(x * x for x in rnd_dir) ** 0.5\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        treestart = [Node(start_pos, cost=0.0)]\n        treegoal = [Node(goal_pos, cost=0.0)]\n\n        nodes = [treestart[0], treegoal[0]]\n        edges = []\n\n        best_cost = float(\"inf\")\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        time_start = time.monotonic()\n        def time_over():\n            return time.monotonic() - time_start > self.time_limit\n\n        max_neighbor_radius = self.step_size * 12\n\n        for it in range(self.max_iter):\n            if time_over():\n                break\n            expand_start = (it % 2 == 0)\n            tree_from = treestart if expand_start else treegoal\n            tree_to = treegoal if expand_start else treestart\n            # Sample biased towards opposite goal\n            sample_goal = goal_pos if expand_start else start_pos\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n\n            nearest = self._nearest(tree_from, sample_pt)\n            new_pos = self._steer(nearest.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_from) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), max_neighbor_radius)\n\n            near_nodes = self._near(tree_from, new_pos, radius)\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near in near_nodes:\n                cost_cand = near.cost + self._dist(near.position, new_pos)\n                if cost_cand + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_cand\n                    best_parent = near\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    self._update_cost_recursive(near)\n\n            nearest_other = self._nearest(tree_to, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_to.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n                    success_state = True\n            if found_solution:\n                break\n\n        if found_solution and best_goal_node:\n            # Prepare single-tree refinement on start tree\n            refined_tree = [Node(start_pos, cost=0.0)]\n            nodes = [refined_tree[0]]\n            edges = []\n            refined_tree[0].children = []\n            refined_tree[0].cost = 0.0\n\n            prev = refined_tree[0]\n            for p in best_path[1:]:\n                n = Node(p, parent=prev, cost=prev.cost + self._dist(prev.position, p))\n                prev.add_child(n)\n                refined_tree.append(n)\n                nodes.append(n)\n                edges.append((prev, n))\n                prev = n\n\n            best_goal_node = prev\n            best_cost = best_goal_node.cost\n            no_improve_count = 0\n            max_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(max_opt_iters):\n                if time_over() or no_improve_count >= 150:\n                    break\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest = self._nearest(refined_tree, sample_pt)\n                new_pos = self._steer(nearest.position, sample_pt)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(refined_tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), max_neighbor_radius)\n                near_nodes = self._near(refined_tree, new_pos, radius)\n                min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near in near_nodes:\n                    cost_cand = near.cost + self._dist(near.position, new_pos)\n                    if cost_cand + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_cand\n                        best_parent = near\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                refined_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired_any = False\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        self._update_cost_recursive(near)\n                        rewired_any = True\n\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(new_goal_node)\n                    refined_tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_any:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
            "objective": 40.15593,
            "time_improvement": -162.0,
            "length_improvement": 12.0,
            "smoothness_improvement": 205.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.045547890663146975,
                    "num_nodes_avg": 114.1,
                    "path_length_avg": 162.35762146251975,
                    "smoothness_avg": 0.021828592751507586,
                    "success_improvement": 0.0,
                    "time_improvement": -76.1142556878941,
                    "length_improvement": 11.009214955244868,
                    "smoothness_improvement": 241.6648781089417,
                    "objective_score": -15.0204233426766
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.11712124347686767,
                    "num_nodes_avg": 116.2,
                    "path_length_avg": 263.8098389248626,
                    "smoothness_avg": 0.009960499450304543,
                    "success_improvement": 0.0,
                    "time_improvement": 28.725924027940174,
                    "length_improvement": 11.93268242169186,
                    "smoothness_improvement": 156.29082511410428,
                    "objective_score": 16.55884078696769
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.2629024744033813,
                    "num_nodes_avg": 103.2,
                    "path_length_avg": 129.88529366049312,
                    "smoothness_avg": 0.024937401502235425,
                    "success_improvement": 0.0,
                    "time_improvement": -437.780139315556,
                    "length_improvement": 13.736372423749357,
                    "smoothness_improvement": 217.20190642092612,
                    "objective_score": -122.00620880831256
                }
            ],
            "success_rate": 1.0
        },
        "objective": 155.4,
        "analysis": "1. Problem of the parents algorithm:\n   - Planning time is slowed by repeated expensive collision checks during rewiring and lack of spatial data structures for neighbor searches, causing scalability issues.\n   - The rewiring method does not propagate cost updates recursively, leading to possible inconsistencies or inefficient rewiring.\n   - Path smoothness is harmed by coarse step sizes, absence of explicit smoothing/post-processing, and jagged connections between nodes.\n\n2. Primary contributors to the performance improvement:\n   - Use of recursive cost propagation (_update_cost_recursive) ensures consistent cost updates and better rewiring impact.\n   - Limiting neighbor radius with a maximum threshold reduces computational overhead during neighbor searches.\n   - Consistent parent-child edge management and careful rewiring prevent redundant or inefficient edges.\n   - Ellipsoidal informed sampling is effectively used for path refinement focusing sampling near current best solutions.\n   \n3. Expected mechanism of impact:\n   - Recursive cost updates enable downstream nodes to maintain accurate costs leading to better rewiring and smoother paths.\n   - Capping neighbor radius speeds up near-neighbor queries and reduces unnecessary rewiring attempts, improving runtime.\n   - Clean edge and node management prevents overhead and path artifacts, improving path smoothness and quality.\n   - Focused sampling accelerates convergence to optimal, smoother paths by concentrating exploration in promising regions."
    }
]