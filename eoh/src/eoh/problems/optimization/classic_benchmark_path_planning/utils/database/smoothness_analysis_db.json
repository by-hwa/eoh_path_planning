[
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
                "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -25.55920467510175,
                "time_improvement": 63.0,
                "length_improvement": 10.0,
                "smoothness_improvement": 176.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.014884471893310547,
                        "num_nodes_avg": 153.9,
                        "path_length_avg": 181.20650545577854,
                        "smoothness_avg": 0.016247501944913933,
                        "success_improvement": 0.0,
                        "time_improvement": 40.64522998903796,
                        "length_improvement": 0.6778429588594594,
                        "smoothness_improvement": 154.30868745308464,
                        "objective_score": 13.371818209292485
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.021590757369995116,
                        "num_nodes_avg": 259.1,
                        "path_length_avg": 257.4249299952159,
                        "smoothness_avg": 0.011235144968856237,
                        "success_improvement": 0.0,
                        "time_improvement": 86.3708570141139,
                        "length_improvement": 14.064148801821547,
                        "smoothness_improvement": 189.0883723964969,
                        "objective_score": 35.29518824730958
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.018825721740722657,
                        "num_nodes_avg": 244.6,
                        "path_length_avg": 129.17761068765506,
                        "smoothness_avg": 0.022490528334836384,
                        "success_improvement": 0.0,
                        "time_improvement": 61.85463070719426,
                        "length_improvement": 14.206381758066511,
                        "smoothness_improvement": 186.07786034100033,
                        "objective_score": 28.010607568703183
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a sampling-based path planning algorithm that incrementally builds a space-filling tree rooted at the start position by randomly sampling the configuration space and extending the nearest existing node toward the sample. It continues this process until the goal is reached or a maximum number of iterations is exceeded.",
                "planning_mechanism": "The planner randomly samples free configurations, finds the nearest node in the current tree, attempts to extend toward the sample by a fixed step size, and adds the new node if the move is valid. This repeats until the goal is reached or iteration limit is hit.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, length) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_position))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": 24.489738643611418,
                "time_improvement": -81.0,
                "length_improvement": -1.0,
                "smoothness_improvement": -1.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.03660638332366943,
                        "num_nodes_avg": 519.1,
                        "path_length_avg": 184.27099402447058,
                        "smoothness_avg": 0.006345352709066497,
                        "success_improvement": 0.0,
                        "time_improvement": -45.975179951531196,
                        "length_improvement": -1.0018517855695122,
                        "smoothness_improvement": -0.6814509491585846,
                        "objective_score": -14.397072311546859
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.18704893589019775,
                        "num_nodes_avg": 1595.6,
                        "path_length_avg": 301.0153705673976,
                        "smoothness_avg": 0.003871167880560516,
                        "success_improvement": 0.0,
                        "time_improvement": -18.074444954309996,
                        "length_improvement": -0.48759494243688517,
                        "smoothness_improvement": -0.3920621436570614,
                        "objective_score": -5.716850762473415
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.13703949451446534,
                        "num_nodes_avg": 919.7,
                        "path_length_avg": 150.69180850920162,
                        "smoothness_avg": 0.007805700734243347,
                        "success_improvement": 0.0,
                        "time_improvement": -177.6744603977687,
                        "length_improvement": -0.08232403899462033,
                        "smoothness_improvement": -0.7120628173203281,
                        "objective_score": -53.35529285681398
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "A single-tree RRT* with adaptive sampling and dynamic radius rewiring combined with path shortcutting to enhance planning speed, path length, and smoothness. The planner uses informed sampling biased towards the ellipsoidal region between start and goal after an initial solution is found, and dynamically adjusts rewiring radius based on node count to better optimize paths. Post-processing shortcutting is applied to the final path to reduce unnecessary detours.",
            "planning_mechanism": "The planner grows a single RRT* tree rooted at the start, uses goal biasing and informed elliptical sampling to concentrate search after an initial path is found, rewires neighbors within a radius that shrinks with tree size to optimize cost, and performs path shortcutting after planning to improve smoothness and length. It consistently checks node and edge validity against obstacles and respects map boundaries.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=7.0, goal_sample_rate=0.1, gamma_rrt_star=50.0, resolution=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star  # parameter controlling rewiring radius\n        self.resolution = resolution  # for edge collision checking\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        nodes = []\n        edges = []\n        root = Node(start)\n        nodes.append(root)\n        success = False\n        goal_node = None\n\n        # For ellipsoid informed sampling after first solution\n        c_best = float('inf')  # cost of best solution found\n        c_min = self._distance(start, goal)\n        x_center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n\n        # Helper to generate uniform random point in unit n-ball\n        def sample_unit_ball():\n            while True:\n                point = tuple(random.uniform(-1, 1) for _ in range(dim))\n                norm = math.sqrt(sum([p * p for p in point]))\n                if 0 < norm <= 1:\n                    return tuple(p / norm for p in point)\n\n        def informed_sample():\n            # If no solution yet, uniform sample\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Sample from ellipsoid defined by start and goal\n            # Following approach from Informed RRT*\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))  # unit vector from start to goal\n            # Compute rotation matrix C that rotates first axis to a1\n            # Done via Householder reflection\n            e1 = [1.0] + [0.0] * (dim - 1)\n            v = [a1[d] - e1[d] for d in range(dim)]\n            s = math.sqrt(sum([vi * vi for vi in v]))\n            if s < 1e-10:\n                C = [[1.0 if i == j else 0.0 for j in range(dim)] for i in range(dim)]\n            else:\n                v = [vi / s for vi in v]\n                C = [[-2 * v[i] * v[j] if i != j else 1 - 2 * v[i] * v[j] for j in range(dim)] for i in range(dim)]\n            r1 = c_best / 2.0  # major axis radius\n            if dim >= 2:\n                r_others = math.sqrt(c_best * c_best - c_min * c_min) / 2.0\n            else:\n                r_others = 0.0\n            # Radii vector for axes\n            L = [r1] + [r_others] * (dim - 1)\n\n            # Sample random point in unit ball, scale and rotate\n            sample_ball = sample_unit_ball()\n            # Scale point\n            scaled = [sample_ball[i] * L[i] for i in range(dim)]\n            # Rotate point by C\n            rotated = [0.0] * dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += C[i][j] * scaled[j]\n                rotated[i] = s\n            # Translate to ellipsoid center\n            p = tuple(rotated[i] + x_center[i] for i in range(dim))\n            # Clamp to bounds if out of range\n            p_clamped = tuple(min(max(0.0, p[i]), bounds[i]) for i in range(dim))\n            return p_clamped\n\n        for iter in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                sample = goal\n            else:\n                sample = informed_sample()\n\n            nearest = self._nearest(nodes, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n\n            # Check bounds\n            if any(new_pos[d] < 0.0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.resolution):\n                continue\n\n            # Create new node and initialize cost and parent using RRT* logic\n            new_node = Node(new_pos)\n            neighbors = self._near(nodes, new_pos, self._rewiring_radius(len(nodes), dim))\n            # Choose parent giving lowest cost path to new_node\n            min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n            min_parent = nearest\n            for node in neighbors:\n                dist_to_new = self._distance(node.position, new_pos)\n                cost = node.cost + dist_to_new\n                if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, self.resolution):\n                    min_cost = cost\n                    min_parent = node\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors if this new_node provides lower cost path\n            for node in neighbors:\n                if node == min_parent:\n                    continue\n                dist = self._distance(new_node.position, node.position)\n                new_cost = new_node.cost + dist\n                if new_cost < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, self.resolution):\n                        # Update parent-child relationships\n                        if node.parent:\n                            try:\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                            if node in node.parent.children:\n                                node.parent.children.remove(node)\n                        node.parent = new_node\n                        node.cost = new_cost\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n            # Check if we can connect to goal directly for solution\n            dist_to_goal = self._distance(new_node.position, goal)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal, obstacles, is_3d, self.resolution) and not self._is_in_obstacle(goal, obstacles, is_3d):\n                    goal_node = Node(goal, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success = True\n                    if goal_node.cost < c_best:\n                        c_best = goal_node.cost\n                    break\n\n        path = []\n        if success and goal_node is not None:\n            # Extract path from goal to start\n            current = goal_node\n            while current:\n                path.append(current.position)\n                current = current.parent\n            path = path[::-1]\n            path = self._shortcut_path(path, obstacles, is_3d)\n\n        return PlannerResult(success, path, nodes, edges)\n\n    def _nearest(self, nodes, point):\n        import math\n        return min(nodes, key=lambda node: math.dist(node.position, point))\n\n    def _near(self, nodes, point, radius):\n        import math\n        radsq = radius * radius\n        results = []\n        px, py = None, None\n        # Optimization to avoid repeated len, distance calls\n        for node in nodes:\n            # Early pruning with squared distance\n            d_sq = sum((node.position[i] - point[i]) ** 2 for i in range(len(point)))\n            if d_sq <= radsq:\n                results.append(node)\n        return results\n\n    def _steer(self, from_p, to_p, step_size):\n        import math\n        dist = self._distance(from_p, to_p)\n        if dist <= step_size:\n            return to_p\n        ratio = step_size / dist\n        return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n    def _distance(self, a, b):\n        import math\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, start_p, end_p, obstacles, is_3d, resolution):\n        import math\n        dist = self._distance(start_p, end_p)\n        steps = max(int(dist / resolution), 1)\n        for i in range(steps + 1):\n            interp = tuple(start_p[d] + (end_p[d] - start_p[d]) * (i / steps) for d in range(len(start_p)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _rewiring_radius(self, n, dim):\n        import math\n        # RRT* radius formula using gamma * (log(n)/n)^(1/d)\n        if n <= 1:\n            return float('inf')\n        from math import log\n        radius = min(self.gamma_rrt_star * (log(n) / n) ** (1 / dim), self.step_size * 5.0)\n        return radius\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        # Repeatedly try to shortcut between two nodes to remove intermediate points\n        if len(path) < 3:\n            return path\n        import random\n        max_attempts = max(50, len(path) * 5)\n        for _ in range(max_attempts):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.resolution):\n                # Shortcut possible, remove intermediate nodes\n                path = path[:i + 1] + path[j:]\n        return path",
            "objective": 54.41329,
            "time_improvement": -238.0,
            "length_improvement": 17.0,
            "smoothness_improvement": 1404.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.043636131286621097,
                    "num_nodes_avg": 217.2,
                    "path_length_avg": 168.666527582117,
                    "smoothness_avg": 0.05273332461113374,
                    "success_improvement": 0.0,
                    "time_improvement": -68.95031459545683,
                    "length_improvement": 7.55120354007871,
                    "smoothness_improvement": 725.3910424114681,
                    "objective_score": -12.527417042532482
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2019017219543457,
                    "num_nodes_avg": 679.5,
                    "path_length_avg": 227.977801536768,
                    "smoothness_avg": 0.08916900951698452,
                    "success_improvement": 0.0,
                    "time_improvement": -24.0749292915322,
                    "length_improvement": 23.89444786984831,
                    "smoothness_improvement": 2194.3828407135384,
                    "objective_score": 18.086104138017017
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.3562834978103638,
                    "num_nodes_avg": 559.7,
                    "path_length_avg": 122.89733612085618,
                    "smoothness_avg": 0.10939128752428735,
                    "success_improvement": 0.0,
                    "time_improvement": -620.9409236715871,
                    "length_improvement": 18.37744109079621,
                    "smoothness_improvement": 1291.449102884001,
                    "objective_score": -168.79856693257838
                }
            ],
            "success_rate": 1.0
        },
        "objective": 351.19999999999993,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - The use of dual-tree exploration with redundant nearest neighbor searches increased planning time.\n   - Fixed-radius neighborhood rewiring limited path optimization potential.\n   - Simple path extraction without post-processing led to jagged, less smooth paths.\n   - Collision checking was performed at a fixed low resolution causing excessive computations.\n   - Lack of adaptive or informed sampling reduced sampling efficiency in solution refinement."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Incorporation of informed sampling focused search within ellipsoidal regions after initial solution.\n   - Dynamic rewiring radius based on node count enabled more effective path cost optimization.\n   - Post-planning path shortcutting significantly enhanced path smoothness and reduced length.\n   - Single-tree planning avoided redundant computations inherent in multiple tree approaches.\n2. Expected mechanism of impact:\n   - Informed sampling concentrates sampling efforts to promising areas, improving convergence speed and quality.\n   - Adaptive rewiring radius allows balancing exploration and exploitation for better path cost improvement.\n   - Shortcutting removes unnecessary detours resulting in smoother trajectories and shorter paths.\n   - Efficient collision checking resolution and pruning decrease computational overhead, reducing planning time despite algorithmic complexity."
        }
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
                "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": -23.447058026189307,
                "time_improvement": 84.0,
                "length_improvement": -3.0,
                "smoothness_improvement": 63.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.005141925811767578,
                        "num_nodes_avg": 71.0,
                        "path_length_avg": 188.50593648297183,
                        "smoothness_avg": 0.01022712864457189,
                        "success_improvement": 0.0,
                        "time_improvement": 79.58020055464503,
                        "node_improvement": 82.12037270209015,
                        "length_improvement": -3.323090854031675,
                        "smoothness_improvement": 60.076771852862166,
                        "objective_score": 22.180589513238814
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.009163379669189453,
                        "num_nodes_avg": 235.9,
                        "path_length_avg": 311.58771803297293,
                        "smoothness_avg": 0.006204052828764862,
                        "success_improvement": 0.0,
                        "time_improvement": 94.34577843672264,
                        "node_improvement": 84.14970100114225,
                        "length_improvement": -4.0169488345949,
                        "smoothness_improvement": 59.63474788275035,
                        "objective_score": 26.191737969673603
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.010863351821899413,
                        "num_nodes_avg": 214.4,
                        "path_length_avg": 154.45353829743092,
                        "smoothness_avg": 0.013251058126888485,
                        "success_improvement": 0.0,
                        "time_improvement": 77.24831899750035,
                        "node_improvement": 72.73998728544183,
                        "length_improvement": -2.580685850013132,
                        "smoothness_improvement": 68.55248128265279,
                        "objective_score": 21.968846595655492
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
                "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": -19.97024133522918,
                "time_improvement": 43.0,
                "length_improvement": 10.0,
                "smoothness_improvement": 178.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.023417735099792482,
                        "num_nodes_avg": 90.8,
                        "path_length_avg": 170.0993330770054,
                        "smoothness_avg": 0.01785947083643084,
                        "success_improvement": 0.0,
                        "time_improvement": 7.002653926305494,
                        "node_improvement": 77.13422311760262,
                        "length_improvement": 6.765860144074392,
                        "smoothness_improvement": 179.5395010517988,
                        "objective_score": 7.058009769595277
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.03253569602966309,
                        "num_nodes_avg": 243.7,
                        "path_length_avg": 262.3589577030142,
                        "smoothness_avg": 0.010517095021903119,
                        "success_improvement": 0.0,
                        "time_improvement": 79.92399739959359,
                        "node_improvement": 83.62561311563529,
                        "length_improvement": 12.417028334845316,
                        "smoothness_improvement": 170.61243007092136,
                        "objective_score": 32.28047837113988
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.027997255325317383,
                        "num_nodes_avg": 199.1,
                        "path_length_avg": 132.3775577752777,
                        "smoothness_avg": 0.02223895551615294,
                        "success_improvement": 0.0,
                        "time_improvement": 41.36389647041905,
                        "node_improvement": 74.68531468531468,
                        "length_improvement": 12.081129267573441,
                        "smoothness_improvement": 182.87787265652085,
                        "objective_score": 20.572235864952386
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "This algorithm is an enhanced bidirectional RRT* with path post-processing for smoothing. It combines two trees grown from start and goal with cost-aware rewiring and adds an efficient path shortcutting step after a solution is found to reduce zigzag and improve curvature, resulting in faster convergence, shorter, and smoother paths.",
            "planning_mechanism": "The planner grows two optimized trees from start and goal in bidirectional RRT* style, rewires nodes locally to minimize cost, and when a connecting path is found, performs path shortcut smoothing by attempting to connect non-adjacent waypoints directly while ensuring collision-free edges, yielding smoother and shorter solutions efficiently.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma_rrt_star=50.0, max_radius=60.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, parent=None, cost=0.0)\n        goal_root = Node(goal_pos, parent=None, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(len(from_p)))\n\n        def near_nodes(tree, position):\n            n = max(1, len(tree))\n            d = len(position)\n            scale = max(1.0, sum(bounds) / d)\n            r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n            radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def is_collision_free(from_p, to_p):\n            if self._is_in_obstacle(to_p, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d):\n                return False\n            return True\n\n        def choose_parent(tree, new_pos):\n            nearest_node = nearest(tree, new_pos)\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                if is_collision_free(nb.position, new_pos):\n                    cost_cand = nb.cost + dist(nb.position, new_pos)\n                    if cost_cand < min_cost:\n                        min_cost = cost_cand\n                        best_parent = nb\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire_from(pivot, neighbors):\n            for nb in neighbors:\n                if is_collision_free(pivot.position, nb.position):\n                    new_cost = pivot.cost + dist(pivot.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        pivot.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((pivot, nb))\n\n        def extend_and_rewire(tree, sample_p):\n            nearest_node = nearest(tree, sample_p)\n            new_pos = steer(nearest_node.position, sample_p)\n            if not is_collision_free(nearest_node.position, new_pos):\n                return None\n            new_node, neighbors = choose_parent(tree, new_pos)\n            rewire_from(new_node, neighbors)\n            return new_node\n\n        def connect_and_rewire(tree, target_node):\n            nearest_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(nearest_node.position, target_node.position)\n                if not is_collision_free(nearest_node.position, new_pos):\n                    return None\n                connect_node, neighbors = choose_parent(tree, new_pos)\n                rewire_from(connect_node, neighbors)\n                if dist(connect_node.position, target_node.position) <= self.step_size:\n                    if is_collision_free(connect_node.position, target_node.position) and not self._is_in_obstacle(target_node.position, obstacles, is_3d):\n                        final_node = Node(target_node.position, parent=None, cost=connect_node.cost + dist(connect_node.position, target_node.position))\n                        connect_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((connect_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = connect_node\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            import random\n            smoothed = path[:]\n            for _ in range(200):\n                if len(smoothed) <= 2:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) -1)\n                p_i = smoothed[i]\n                p_j = smoothed[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    # shortcut possible, remove intermediate nodes\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        success = False\n        path = []\n        for _ in range(self.max_iter):\n            rand_p = sample_free()\n            new_a = extend_and_rewire(tree_a, rand_p)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = connect_and_rewire(tree_b, new_a)\n            if new_b:\n                success = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                # Remove duplicate connection node\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                raw_path = path_a + path_b[::-1]\n                path = shortcut_path(raw_path)\n                break\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -23.33681,
            "time_improvement": 20.0,
            "length_improvement": 16.0,
            "smoothness_improvement": 1517.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024225378036499025,
                    "num_nodes_avg": 70.4,
                    "path_length_avg": 165.27293783448243,
                    "smoothness_avg": 0.04876837243675059,
                    "success_improvement": 0.0,
                    "time_improvement": 3.7953134482957775,
                    "node_improvement": 82.27146814404432,
                    "length_improvement": 9.411283855627978,
                    "smoothness_improvement": 663.3309308509168,
                    "objective_score": 10.102019002120105
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.044183778762817386,
                    "num_nodes_avg": 245.6,
                    "path_length_avg": 239.05510817474592,
                    "smoothness_avg": 0.10604751432289401,
                    "success_improvement": 0.0,
                    "time_improvement": 72.73660116170906,
                    "node_improvement": 83.49795068198617,
                    "length_improvement": 20.19652407149841,
                    "smoothness_improvement": 2628.6789264652084,
                    "objective_score": 47.082289423737805
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05563676357269287,
                    "num_nodes_avg": 268.0,
                    "path_length_avg": 121.72798255614921,
                    "smoothness_avg": 0.10677056044821978,
                    "success_improvement": 0.0,
                    "time_improvement": -16.52295880407895,
                    "node_improvement": 65.92498410680228,
                    "length_improvement": 19.15407004984152,
                    "smoothness_improvement": 1258.1136479183722,
                    "objective_score": 12.826122628273087
                }
            ],
            "success_rate": 1.0
        },
        "objective": 374.5999999999999,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Redundant and inefficient sampling and collision checking leading to longer planning times.\n   - Limited or no path post-processing causing longer and less smooth paths.\n   - Rewiring and connection strategies that do not fully optimize path cost and curvature, resulting in suboptimal and jagged paths."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Integration of a comprehensive path shortcutting post-processing step that aggressively removes unnecessary waypoints.\n   - Enhanced rewiring and parent selection with cost-aware decisions during tree expansion.\n2. Expected mechanism of impact:\n   - Shortcutting significantly reduces path length and smooths transitions, improving path curvature and reducing sharp turns.\n   - Cost-based rewiring creates more optimal connection topology, shortening path and reducing redundant detours.\n   - More effective balancing of tree growth and connection steps lowers unnecessary computations, improving overall runtime despite occasionally variable planning times."
        }
    }
]