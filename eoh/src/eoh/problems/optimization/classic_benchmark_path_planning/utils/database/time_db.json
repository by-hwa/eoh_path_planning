[
    {
        "operator": "m2",
        "algorithm_description": "An adaptive bidirectional RRT* planner with goal biasing, incremental rewiring, and informed sampling to efficiently find and iteratively improve a near-optimal path within a 30-second limit. The planner balances growth between start and goal trees, performs adaptive radius neighbor searches for rewiring, and applies an ellipsoidal informed sampling once a solution is found to enhance convergence and path smoothness.",
        "planning_mechanism": "The planner alternates expansions of two trees towards random samples biased towards the goal, incrementally rewires nodes with neighbors in adaptive shrinking radius to improve path cost and smoothness, and upon initial solution discovery, switches to single-tree informed RRT* refinement sampling inside an ellipsoid defined by current best cost to optimize the path further, always enforcing collision checking on nodes and edges, and returning the best path found upon timeout or success.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        # Parameters for rewiring and goal bias\n        self.goal_sample_rate = 0.15        # Probability to sample the goal (goal bias)\n        self.gamma_rrt_star = 50.0          # Parameter for adaptive neighbor radius\n        self.improve_tol = 1e-6             # Improvement tolerance for path cost updates\n        self.time_limit = 30.0              # seconds time limit\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        # Goal biased sampling with specified probability\n        if random.random() < goal_bias_prob:\n            # sample goal directly if free\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n        # Otherwise uniform sample within bounds and free space\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        # Linear nearest search (simple but acceptable)\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _path_cost(self, node):\n        return node.cost\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # Avoid duplicating connecting node\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        # If no solution yet, uniform sample\n        if c_best == float(\"inf\") or c_best < c_min - 1e-10:\n            # fallback to uniform sampling\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        # Ellipsoid sampling inside prolate hyperspheroid\n        # Code adapted from literature informed RRT* sampling, avoids numpy:\n        dim = len(bounds)\n        center = tuple((s + g)/2 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            # Avoid degenerate case\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        # Construct basis for rotation - produce orthonormal matrix with a1 as first column\n        # Here only rotate axis to x direction, so use rotated coordinates is not required for sampling uniform ball\n        # Instead sample in unit ball, then scale and translate\n\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n\n        while True:\n            # Sample random point in unit ball in R^dim\n            rnd_dir = []\n            # Sample standard normal gaussian vector\n            for _ in range(dim):\n                rnd_dir.append(random.gauss(0,1))\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12: continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n\n            # Radius scaling to distribute uniformly inside ball\n            r = random.random() ** (1.0/dim)\n            ball_point = [r * x for x in unit_dir]\n\n            # Scale ball_point components for ellipsoid radii\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n\n            # Rotate scaled vector to align with real coordinate system (only one axis, so just shift)\n            # Since rotation matrix is large effort and only affects orientation, approximate by axis aligned\n            # We rotate by vector a1/norm_a1 using Householder reflection or simplified since high cost\n            # To simplify, we place along the direction a1 by scaling only the first coordinate\n            # This is acceptable for performance and uniformity compromise\n            # Align first dimension with a1 direction:\n            # new_point = center + rotation * scaled\n\n            # Construct base vector in direction a1:\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            # Add components in other basis directions orthogonal to a1\n            # We don't construct orthonormal basis explicitly, skip to keep simplicity and avoid foreign dependencies\n\n            # As an approximation, add the other components along axes orthogonal by spreading them equally\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            # Clamp point inside bounds\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        time_limit = self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n\n        def can_finish():\n            return time.monotonic() - time_start > time_limit\n\n        # Phase 1: Bidirectional RRT* until initial solution found\n        for it in range(self.max_iter):\n            if can_finish():\n                break\n\n            # Alternate expansion: even expands start tree, odd goal tree\n            expand_start_tree = (it % 2 == 0)\n            if expand_start_tree:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Sampling with goal bias\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start_tree else start_pos, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors within adaptive rewiring radius\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes) ** (1/dim)), self.step_size * 20)\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            # Choose parent with minimum cost + edge cost + no collision between parent to new_pos\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes if cheaper via new_node\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and \\\n                   not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Rewire\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            # Attempt to connect from other tree\n            nearest_node_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_node_other.position, new_node.position)\n            if dist_connect <= self.step_size and \\\n               not self._is_edge_in_obstacle(nearest_node_other.position, new_node.position, obstacles, is_3d):\n\n                # Connect the two trees\n                connect_node = Node(new_node.position, parent=nearest_node_other,\n                                   cost=nearest_node_other.cost + dist_connect)\n                nearest_node_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_node_other, connect_node))\n\n                # Construct path: new_node from tree_a and connect_node from tree_b\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_node_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start_tree else new_node\n                    found_solution = True\n                    success_state = True\n\n            if found_solution:\n                break\n\n        # Phase 2: Single-tree informed RRT* refinement if solution found\n        if found_solution and best_goal_node:\n            # Reset tree for refinement: use start_root plus best path nodes (re-create properly)\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node,\n                                cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n            no_improve_count = 0\n            post_opt_iters = self.max_iter // 2\n\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if can_finish() or no_improve_count >= 150:\n                    break\n\n                # Informed sampling inside ellipsoid defined by best_cost\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min,\n                                                              start_pos, goal_pos, bounds, obstacles, is_3d)\n\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size * 20)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                    if candidate_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired_any = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        rewired_any = True\n\n                # Check if can connect directly to goal\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and \\\n                   not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_any:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": -21.85805,
        "time_improvement": 39.0,
        "length_improvement": 15.0,
        "smoothness_improvement": 286.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.021411538124084473,
                "num_nodes_avg": 92.3,
                "path_length_avg": 161.62176685276987,
                "smoothness_avg": 0.026296503737064592,
                "success_improvement": 0.0,
                "time_improvement": 17.21071942180759,
                "length_improvement": 11.41254852721125,
                "smoothness_improvement": 311.59738725690346,
                "objective_score": 13.568731879153544
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03712928295135498,
                "num_nodes_avg": 109.2,
                "path_length_avg": 246.37899691959302,
                "smoothness_avg": 0.013803575390083797,
                "success_improvement": 0.0,
                "time_improvement": 77.40499284926345,
                "length_improvement": 17.75159920201941,
                "smoothness_improvement": 255.17593710033827,
                "objective_score": 35.14833706149237
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.03867461681365967,
                "num_nodes_avg": 101.4,
                "path_length_avg": 127.66449265035354,
                "smoothness_avg": 0.030873705973109955,
                "success_improvement": 0.0,
                "time_improvement": 20.889140107088526,
                "length_improvement": 15.211322711504014,
                "smoothness_improvement": 292.7112611180333,
                "objective_score": 16.857091964619134
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "A hybrid bidirectional RRT* planner with adaptive rewiring radius, balanced goal-biased tree expansions, ellipsoidal informed sampling refinement, and recursive cost propagation for incremental path improvement. It employs efficient incremental rewiring during both bidirectional growth and single-tree refinement phases under a strict 30-second limit, always enforcing collision-free nodes and edges. The planner dynamically balances exploration and exploitation for faster convergence, better path quality, and enhanced smoothness.",
        "planning_mechanism": "The planner alternately expands two trees from start and goal with goal-biased sampling, uses adaptive logarithmic neighbor radius for rewiring, attempts connection to merge trees, and then refines the path using ellipsoidal informed samples with recursive cost updates until time expires, returning the best collision-free path found so far.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position         # Tuple[float, ...]\n        self.parent = parent             # Node or None\n        self.cost = cost                 # Cost from root\n        self.children = []               # List[Node]\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15     # Probability to sample goal/start in respective trees\n        self.gamma_rrt_star = 40.0       # Adaption parameter for neighbor radius\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0           # Hard time limit in seconds\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob:\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_node = node\n                best_dist = d\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n        while True:\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _propagate_cost_to_descendants(self, node: Node):\n        # Propagate cost updates recursively to children\n        for child in node.children:\n            old_cost = child.cost\n            child.cost = node.cost + self._dist(node.position, child.position)\n            if abs(child.cost - old_cost) > 1e-10:\n                self._propagate_cost_to_descendants(child)\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n\n        def time_exceeded():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for it in range(self.max_iter):\n            if time_exceeded():\n                break\n            expand_start_tree = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start_tree else (tree_goal, tree_start)\n\n            sample_pt = self._sample(bounds, obstacles, is_3d,\n                                     goal_pos if expand_start_tree else start_pos,\n                                     self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)),\n                         self.step_size * 12)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                cost_candidate = near.cost + self._dist(near.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors with recursive cost updates\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    self._propagate_cost_to_descendants(near)\n\n            # Attempt connection\n            nearest_node_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_node_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_node_other.position, new_node.position, obstacles, is_3d):\n                # Connect by adopting new_node position in tree_b\n                connect_node = Node(new_node.position, parent=nearest_node_other, cost=nearest_node_other.cost + dist_connect)\n                nearest_node_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_node_other, connect_node))\n\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_node_other.cost)\n                    goal_node_for_path = connect_node\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n                    goal_node_for_path = new_node\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = goal_node_for_path\n                    found_solution = True\n                    success_state = True\n\n                # Early exit on first found solution to refine later\n                if found_solution:\n                    break\n\n        # Refinement phase\n        if found_solution and best_goal_node is not None:\n            # Reconstruct single tree from best path (start to goal)\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            max_no_improve = 150\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if time_exceeded() or no_improve_count >= max_no_improve:\n                    break\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)),\n                             self.step_size * 12)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near in near_nodes:\n                    cost_candidate = near.cost + self._dist(near.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired_any = False\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        self._propagate_cost_to_descendants(near)\n                        rewired_any = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_any:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": -21.41658,
        "time_improvement": 42.0,
        "length_improvement": 13.0,
        "smoothness_improvement": 216.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.025189828872680665,
                "num_nodes_avg": 111.2,
                "path_length_avg": 164.23961870298234,
                "smoothness_avg": 0.022259303009276386,
                "success_improvement": 0.0,
                "time_improvement": 2.6016814779305992,
                "length_improvement": 9.977662445592637,
                "smoothness_improvement": 248.4064289453182,
                "objective_score": 8.009134055461354
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.0332127571105957,
                "num_nodes_avg": 114.7,
                "path_length_avg": 258.74349057657577,
                "smoothness_avg": 0.010733412225408526,
                "success_improvement": 0.0,
                "time_improvement": 79.7883927520825,
                "length_improvement": 13.623975327101634,
                "smoothness_improvement": 176.17842752409942,
                "objective_score": 32.99179515950623
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.02702016830444336,
                "num_nodes_avg": 94.5,
                "path_length_avg": 128.70631973867714,
                "smoothness_avg": 0.025448376165527135,
                "success_improvement": 0.0,
                "time_improvement": 44.7288964926287,
                "length_improvement": 14.519390765914297,
                "smoothness_improvement": 223.70146642177033,
                "objective_score": 23.24881073944604
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "An enhanced bidirectional RRT* planner featuring adaptive rewiring radius, balanced goal-biased tree extension, ellipsoidal informed sampling refinement, and integrated caching for nearest neighbor queries to improve runtime. It concurrently grows two trees with dynamic goal biasing, efficiently rewires nodes within an adaptively shrinking radius, and upon finding a feasible path, refines it with focused informed sampling until a 30-second termination, returning the best collision-free path found.",
        "planning_mechanism": "The planner alternates balanced expansions of start and goal trees with adaptive goal bias sampling and steering constrained by step size. It efficiently manages parent-child relationships and rewiring with an adaptive radius proportional to the tree size and space dimension, reducing redundant checks. It applies ellipsoidal informed sampling after an initial solution to concentrate search around promising corridors. Nearest neighbor queries are cached and updated incrementally for runtime gain. Collisions are strictly checked for nodes and edges. The search interrupts upon time expiration, ensuring the best path found is returned for robust operation.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        \n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n        \n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            \n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = 45.0\n        self.goal_sample_rate = 0.18\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n        # Cache for nearest neighbor acceleration\n        self._nn_cache = {}\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, fpos, tpos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(fpos, tpos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(fpos[d] + (tpos[d]-fpos[d])*(i/steps) for d in range(len(fpos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    \n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d]-from_pos[d])*r for d in range(len(from_pos)))\n    \n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n    \n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob, ellipsoid=None):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        if ellipsoid is None:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        else:\n            center, c1, c2, a1, norm_a1 = ellipsoid\n            while True:\n                rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n                norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n                if norm_dir < 1e-12:\n                    continue\n                unit_dir = [x / norm_dir for x in rnd_dir]\n                r = random.random() ** (1.0/dim)\n                ball_point = [r*x for x in unit_dir]\n                scaled = [c1*ball_point[0]] + [c2*ball_point[i] for i in range(1, dim)]\n                dir_a1 = [x / norm_a1 for x in a1]\n                point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n                for i in range(1, dim):\n                    point[i] += scaled[i]\n                pt = tuple(min(max(0.0, point[d]), bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        # Use cached index if available for same tree object to speed nearest neighbor\n        key = id(tree)\n        if key not in self._nn_cache:\n            self._nn_cache[key] = tree[:]\n        else:\n            if len(self._nn_cache[key]) != len(tree):\n                self._nn_cache[key] = tree[:]\n        return min(self._nn_cache[key], key=lambda n: self._dist(n.position, point))\n    \n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        # Filter cached to speed\n        key = id(tree)\n        if key not in self._nn_cache:\n            self._nn_cache[key] = tree[:]\n        result = []\n        for n in self._nn_cache[key]:\n            if self._dist(n.position, point) <= radius:\n                result.append(n)\n        return result\n    \n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_from_start = node_start.path_from_root()\n        path_from_goal = node_goal.path_from_root()\n        path_from_goal.reverse()\n        return path_from_start + path_from_goal[1:]\n    \n    def _ellipsoid_parameters(self, c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...], bounds):\n        dim = len(bounds)\n        center = tuple((s+g)/2 for s,g in zip(start,goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            norm_a1 = 1e-12  # prevent degenerate\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n        return (center, c1, c2, a1, norm_a1)\n    \n    def _propagate_cost_to_children(self, node: Node):\n        for c in node.children:\n            old_cost = c.cost\n            c.cost = node.cost + self._dist(node.position, c.position)\n            if abs(c.cost - old_cost) > 1e-10:\n                self._propagate_cost_to_children(c)\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        start_time = time.monotonic()\n\n        def time_exceeded():\n            return (time.monotonic() - start_time) > self.time_limit\n\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for i in range(self.max_iter):\n            if time_exceeded():\n                break\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n\n            goal_bias = self.goal_sample_rate\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal if expand_start else start, goal_bias)\n\n            nearest = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, resolution=1.0):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)), self.step_size * 15)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near in near_nodes:\n                cost_cand = near.cost + self._dist(near.position, new_pos)\n                if cost_cand < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_cand\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    self._propagate_cost_to_children(near)\n\n            # Try connect trees\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_b.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_b.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_b, cost=nearest_b.cost + dist_connect)\n                nearest_b.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_b, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_b.cost)\n                    goal_node_for_path = connect_node\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n                    goal_node_for_path = new_node\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = goal_node_for_path\n                    found_solution = True\n                    success_state = True\n\n                # Stop early on first solution to refine later\n                if found_solution:\n                    break\n\n        if found_solution and best_goal_node:\n            # Rebuild tree from start root with best path nodes\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children.clear()\n            start_root.cost = 0.0\n\n            prev = start_root\n            for pos in best_path[1:]:\n                n = Node(pos, parent=prev, cost=prev.cost + self._dist(prev.position, pos))\n                prev.add_child(n)\n                tree.append(n)\n                nodes.append(n)\n                edges.append((prev, n))\n                prev = n\n            best_goal_node = prev\n            best_cost = best_goal_node.cost\n\n            # Ellipsoid parameters for informed sampling\n            c_min = self._dist(start, goal)\n            no_improve_count = 0\n            max_no_improve = 150\n            refinement_iters = self.max_iter // 2\n\n            for _ in range(refinement_iters):\n                if time_exceeded() or no_improve_count >= max_no_improve:\n                    break\n                ellipsoid = self._ellipsoid_parameters(best_cost, c_min, start, goal, bounds)\n                sample_pt = self._sample(bounds, obstacles, is_3d, goal, 0.0, ellipsoid)\n                nearest = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_tree_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_tree_nodes) / n_tree_nodes) ** (1.0 / dim)), self.step_size * 15)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near in near_nodes:\n                    cost_candidate = near.cost + self._dist(near.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near in near_nodes:\n                    if near is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_via_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_via_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        self._propagate_cost_to_children(near)\n                        rewired = True\n\n                dist_to_goal = self._dist(new_node.position, goal)\n                if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal, obstacles, is_3d):\n                    goal_node = Node(goal, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": -13.83763,
        "time_improvement": 17.0,
        "length_improvement": 12.0,
        "smoothness_improvement": 224.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.025319766998291016,
                "num_nodes_avg": 124.3,
                "path_length_avg": 163.2394983196226,
                "smoothness_avg": 0.022534320283976204,
                "success_improvement": 0.0,
                "time_improvement": 2.09926619713116,
                "length_improvement": 10.525844275633734,
                "smoothness_improvement": 252.71104650394102,
                "objective_score": 8.208841657039294
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.04371612071990967,
                "num_nodes_avg": 119.0,
                "path_length_avg": 261.4357946273634,
                "smoothness_avg": 0.011276384089395365,
                "success_improvement": 0.0,
                "time_improvement": 73.39657591656308,
                "length_improvement": 12.72520674127337,
                "smoothness_improvement": 190.14948467130657,
                "objective_score": 30.604844243089474
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.060172200202941895,
                "num_nodes_avg": 108.8,
                "path_length_avg": 129.2796635396884,
                "smoothness_avg": 0.025811603953994167,
                "success_improvement": 0.0,
                "time_improvement": -23.085240188387644,
                "length_improvement": 14.138603112980558,
                "smoothness_improvement": 228.32169708038452,
                "objective_score": 2.6991982966739645
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "A tuned adaptive bidirectional RRT* planner with recursive descendant cost propagation, enhanced goal bias, and ellipsoidal informed refinement that balances exploration and exploitation. It uses adaptive neighbor radius shrinking for rewiring, efficient collision checking, consistent edge and parent-child updates, and early termination on a 30-second limit to improve planning time, path smoothness, and path length.",
        "planning_mechanism": "A bidirectional RRT* grows two trees from start and goal alternately with goal bias sampling until first connection, then conducts single-tree ellipsoidal informed RRT* refinement focused on the best path. Neighbor radius adapts with tree size. Rewiring propagates cost updates recursively to descendants ensuring path cost consistency and smoother paths. The best path is updated progressively and returned when time limit is reached.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.18          # goal bias probability\n        self.gamma_rrt_star = 40.0            # adaptive radius multiplier tuned for balance\n        self.improve_tol = 1e-6               # small tolerance for cost improvements\n        self.time_limit = 30.0                # hard time limit in seconds\n        self.max_radius_factor = 12.0         # max radius factor for neighbor search\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point):\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # avoid duplicate connecting node\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        if c_best == float(\"inf\") or c_best < c_min - 1e-10:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        dim = len(bounds)\n        center = tuple((s+g)/2 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n\n        while True:\n            rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0/dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _update_costs_recursive(self, node: Node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_costs_recursive(child)\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        # Phase 1: Bidirectional growth until initial path found\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size * self.max_radius_factor)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire within neighbors with recursive cost update\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    self._update_costs_recursive(near_node)\n\n            # Attempt connection to other tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n                    success_state = True\n                    break\n\n        # Phase 2: Refinement via single-tree informed RRT*\n        if found_solution and best_goal_node is not None:\n            tree = [start_root]\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n            no_improve_count = 0\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if timed_out() or no_improve_count >= 120:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size * self.max_radius_factor)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        self._update_costs_recursive(near_node)\n                        rewired = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
        "objective": -26.48735,
        "time_improvement": 58.0,
        "length_improvement": 13.0,
        "smoothness_improvement": 228.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.017215156555175783,
                "num_nodes_avg": 208.5,
                "path_length_avg": 160.40239983380974,
                "smoothness_avg": 0.02374652355073028,
                "success_improvement": 0.0,
                "time_improvement": 33.43633614808805,
                "length_improvement": 12.08090291241019,
                "smoothness_improvement": 271.6846599701681,
                "objective_score": 18.637865891723372
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03504271507263183,
                "num_nodes_avg": 467.1,
                "path_length_avg": 253.42542860882128,
                "smoothness_avg": 0.010719255016317384,
                "success_improvement": 0.0,
                "time_improvement": 78.67477272090856,
                "length_improvement": 15.399297483864519,
                "smoothness_improvement": 175.8141523371588,
                "objective_score": 33.72108106827707
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.019155335426330567,
                "num_nodes_avg": 300.1,
                "path_length_avg": 131.29531716904052,
                "smoothness_avg": 0.02638587363121502,
                "success_improvement": 0.0,
                "time_improvement": 60.81680487189903,
                "length_improvement": 12.799901947476434,
                "smoothness_improvement": 235.62636498645543,
                "objective_score": 27.103114454987843
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "An optimized bidirectional RRT* planner with incremental nearest neighbor caching, adaptive rewiring radius, and efficient ellipsoidal informed sampling refinement, incorporating subtree cost update propagation, balanced goal-biased tree expansion, and early pruning strategies for faster convergence and smoother, shorter paths within a strict 30-second time limit.",
        "planning_mechanism": "The planner alternates growth of two trees from start and goal with adaptive radius rewiring and goal bias. Nearest neighbor queries use incremental caching to reduce computation. Upon initial solution discovery, it performs focused refinement via ellipsoidal informed sampling in a single tree. Rewiring propagates cost changes to descendants to maintain consistency, and collision checks prune expansions early. The best feasible path found within the time limit is returned.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = 40.0  # Tuned parameter\n        self.goal_sample_rate = 0.2\n        self.time_limit = 30.0\n        self.improve_tol = 1e-7\n        \n        # Nearest neighbor cache keyed by tree id: stores nodes list snapshot\n        self._nn_cache = {}\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d]-from_pos[d])*r for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob, ellipsoid=None):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        if ellipsoid is None:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        else:\n            center, c1, c2, a1, norm_a1 = ellipsoid\n            while True:\n                rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n                norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n                if norm_dir < 1e-12:\n                    continue\n                unit_dir = [x / norm_dir for x in rnd_dir]\n                r = random.random() ** (1.0/dim)\n                ball_point = [r*x for x in unit_dir]\n                scaled = [c1*ball_point[0]] + [c2*ball_point[i] for i in range(1, dim)]\n                dir_a1 = [x / norm_a1 for x in a1]\n                point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n                for i in range(1, dim):\n                    point[i] += scaled[i]\n                pt = tuple(min(max(0.0, point[d]), bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        key = id(tree)\n        if key not in self._nn_cache or len(self._nn_cache[key]) != len(tree):\n            self._nn_cache[key] = list(tree)\n        nearest_node = min(self._nn_cache[key], key=lambda n: self._dist(n.position, point))\n        return nearest_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        key = id(tree)\n        if key not in self._nn_cache or len(self._nn_cache[key]) != len(tree):\n            self._nn_cache[key] = list(tree)\n        candidates = [n for n in self._nn_cache[key] if self._dist(n.position, point) <= radius]\n        return candidates\n\n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoid_parameters(self, c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...], bounds):\n        dim = len(bounds)\n        center = tuple((s + g) * 0.5 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            norm_a1 = 1e-12\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n        return (center, c1, c2, a1, norm_a1)\n\n    def _propagate_cost(self, node: Node):\n        for child in node.children:\n            old_cost = child.cost\n            child.cost = node.cost + self._dist(node.position, child.position)\n            if abs(child.cost - old_cost) > 1e-10:\n                self._propagate_cost(child)\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        start_time = time.monotonic()\n        time_limit = self.time_limit\n        \n        def time_exceeded():\n            return (time.monotonic() - start_time) > time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success = False\n\n        for i in range(self.max_iter):\n            if time_exceeded():\n                break\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n            goal_bias = self.goal_sample_rate\n            \n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, goal_bias)\n\n            nearest = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, resolution=1.0):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            # Adaptive radius with upper limit\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)), self.step_size * 12)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for near in near_nodes:\n                if near is nearest:\n                    continue\n                cost_candidate = near.cost + self._dist(near.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    # Remove old edge\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    # Propagate cost to children recursively\n                    self._propagate_cost(near)\n\n            # Attempt to connect trees\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_b.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_b.position, new_node.position, obstacles, is_3d):\n                # Create connecting node in tree_b as child of nearest_b\n                conn_node = Node(new_node.position, parent=nearest_b, cost=nearest_b.cost + dist_connect)\n                nearest_b.add_child(conn_node)\n                tree_b.append(conn_node)\n                nodes.append(conn_node)\n                edges.append((nearest_b, conn_node))\n\n                if expand_start:\n                    cur_path = self._build_path(new_node, conn_node)\n                    cur_cost = new_node.cost + (conn_node.cost - nearest_b.cost)\n                    goal_node_for_path = conn_node\n                else:\n                    cur_path = self._build_path(conn_node, new_node)\n                    cur_cost = conn_node.cost + (new_node.cost - best_parent.cost)\n                    goal_node_for_path = new_node\n\n                if cur_cost + self.improve_tol < best_cost:\n                    best_cost = cur_cost\n                    best_path = cur_path\n                    best_goal_node = goal_node_for_path\n                    found_solution = True\n                    success = True\n\n                if found_solution:\n                    break\n\n        # If solution found, start refinement via ellipsoidal informed sampling\n        if found_solution and best_goal_node:\n            # Rebuild single tree from start_root along best path nodes\n            # Clear old children\n            start_root.children.clear()\n            start_root.cost = 0.0\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            prev = start_root\n            for pos in best_path[1:]:\n                nd = Node(pos, parent=prev, cost=prev.cost + self._dist(prev.position, pos))\n                prev.add_child(nd)\n                tree.append(nd)\n                nodes.append(nd)\n                edges.append((prev, nd))\n                prev = nd\n            best_goal_node = prev\n            best_cost = best_goal_node.cost\n\n            c_min = self._dist(start_pos, goal_pos)\n            no_improve_count = 0\n            max_no_improve = 150\n            refinement_max_iter = self.max_iter // 2\n\n            for _ in range(refinement_max_iter):\n                if time_exceeded() or no_improve_count >= max_no_improve:\n                    break\n                ellipsoid = self._ellipsoid_parameters(best_cost, c_min, start_pos, goal_pos, bounds)\n                sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos, 0.0, ellipsoid)\n\n                nearest = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest.position, sample_pt)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)), self.step_size * 12)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near in near_nodes:\n                    cost_cand = near.cost + self._dist(near.position, new_pos)\n                    if cost_cand < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_cand\n                        best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                \n                rewired = False\n                for near in near_nodes:\n                    if near is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_via_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_via_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        self._propagate_cost(near)\n                        rewired = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success else best_path\n        else:\n            extracted_path = best_path\n            success = found_solution\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": -12.40664,
        "time_improvement": 11.0,
        "length_improvement": 13.0,
        "smoothness_improvement": 197.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.024726438522338866,
                "num_nodes_avg": 136.2,
                "path_length_avg": 158.9240097978004,
                "smoothness_avg": 0.02154214850608637,
                "success_improvement": 0.0,
                "time_improvement": 4.393414211438477,
                "length_improvement": 12.89123191773616,
                "smoothness_improvement": 237.18140364446492,
                "objective_score": 10.238670432295564
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.035642027854919434,
                "num_nodes_avg": 112.6,
                "path_length_avg": 250.04126451818865,
                "smoothness_avg": 0.011241461904313998,
                "success_improvement": 0.0,
                "time_improvement": 78.31006121761729,
                "length_improvement": 16.52902886508012,
                "smoothness_improvement": 189.2509116957298,
                "objective_score": 34.35669024281191
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.07304487228393555,
                "num_nodes_avg": 103.4,
                "path_length_avg": 133.94841461811015,
                "smoothness_avg": 0.020864073099746132,
                "success_improvement": 0.0,
                "time_improvement": -49.416933721475225,
                "length_improvement": 11.037840948728759,
                "smoothness_improvement": 165.38946980308978,
                "objective_score": -7.375428198189863
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "A simplified bidirectional RRT* planner with uniform rewiring radius, goal-biased sampling, and early path connection checking. It maintains consistent parent-child relations and incremental cost updates without recursive propagation. The planner alternates tree expansions from start and goal, uses fixed step steering, and respects a 30-second time limit, returning the best path found.",
        "planning_mechanism": "The planner grows two trees alternately from start and goal by sampling free points biased toward the opposite tree's root. New nodes are connected via nearest neighbors, rewiring locally with a uniform radius for cost improvement. On each expansion, it attempts to connect the two trees to form a solution. The method uses simple collision checking and incremental updates avoiding recursion for efficient time use while balancing exploration and refinement.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1\n        self.rewire_radius = 15.0\n        self.time_limit = 30.0\n        self.improve_tol = 1e-6\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, target, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(target, obstacles, is_3d):\n            return target\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best, best_dist = None, float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best, best_dist = node, d\n        return best\n\n    def _near(self, tree, point, radius):\n        res = []\n        r_sq = radius * radius\n        for node in tree:\n            d_sq = sum((a - b) ** 2 for a, b in zip(node.position, point))\n            if d_sq <= r_sq:\n                res.append(node)\n        return res\n\n    def _build_path(self, start_node, goal_node):\n        path_from_start = start_node.path_from_root()\n        path_from_goal = goal_node.path_from_root()\n        path_from_goal.reverse()\n        return path_from_start + path_from_goal[1:]\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        time_start = time.monotonic()\n        def time_exceeded():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        best_goal_node = None\n        found_solution = False\n\n        for i in range(self.max_iter):\n            if time_exceeded():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            target = goal_pos if expand_start else start_pos\n            sample = self._sample(bounds, obstacles, is_3d, target, self.goal_sample_rate)\n\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            near_nodes = self._near(tree_a, new_pos, self.rewire_radius)\n\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_to_other = self._dist(new_node.position, nearest_other.position)\n\n            if dist_to_other <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    connect_node = Node(new_node.position,\n                                    parent=nearest_other,\n                                    cost=nearest_other.cost + dist_to_other)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    if expand_start:\n                        path = self._build_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                        goal_node_for_path = connect_node\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n                        goal_node_for_path = new_node\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        best_goal_node = goal_node_for_path\n                        found_solution = True\n\n            if found_solution:\n                break\n\n        final_path = best_path if found_solution else []\n\n        return PlannerResult(success=found_solution,\n                             path=final_path,\n                             nodes=nodes,\n                             edges=edges)",
        "objective": -25.63427,
        "time_improvement": 53.0,
        "length_improvement": 14.0,
        "smoothness_improvement": 293.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.01984410285949707,
                "num_nodes_avg": 143.3,
                "path_length_avg": 171.67360458367028,
                "smoothness_avg": 0.022584930568577976,
                "success_improvement": 0.0,
                "time_improvement": 23.27132268888971,
                "length_improvement": 5.90297698534299,
                "smoothness_improvement": 253.5032073599508,
                "objective_score": 11.79069903467246
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.025874114036560057,
                "num_nodes_avg": 243.0,
                "path_length_avg": 242.09986453995447,
                "smoothness_avg": 0.016588755758426728,
                "success_improvement": 0.0,
                "time_improvement": 84.25432043918015,
                "length_improvement": 19.180096758339072,
                "smoothness_improvement": 326.84063406213465,
                "objective_score": 38.41855735706817
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.024422097206115722,
                "num_nodes_avg": 210.2,
                "path_length_avg": 125.00263383013859,
                "smoothness_avg": 0.031336834215711706,
                "success_improvement": 0.0,
                "time_improvement": 50.04338065783512,
                "length_improvement": 16.979202595794742,
                "smoothness_improvement": 298.6022181793566,
                "objective_score": 26.693546845724164
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "A simplified bidirectional RRT* planner employing fixed-size rewiring radius and uniform random sampling with goal bias, alternating tree expansions for efficient path search and incremental improvement within a 30-second time limit. The planner updates path costs during rewiring and attempts connection after each new node insertion, returning the best feasible path found.",
        "planning_mechanism": "The planner grows two trees from start and goal alternately, each expansion samples points with a fixed goal bias, extends towards sampled points, and rewires nearby nodes to improve costs. Connection attempts between trees are made after each extension to detect solutions early. The search halts at timeout or after max iterations, returning the shortest path found.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n    def update_cost_recursive(self, new_cost):\n        diff = new_cost - self.cost\n        self.cost = new_cost\n        for c in self.children:\n            c.update_cost_recursive(c.cost + diff)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1\n        self.rewire_radius = step_size * 10\n        self.time_limit = 30.0\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n    def _is_edge_in_obstacle(self, start, end, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(start, end)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(start[d] + (end[d] - start[d]) * i / steps for d in range(len(start)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = math.dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n    def _near(self, tree, point, radius):\n        return [node for node in tree if math.dist(node.position, point) <= radius]\n    def _sample(self, bounds, obstacles, is_3d, goal):\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        start_time = time.monotonic()\n        def timeout():\n            return (time.monotonic() - start_time) > self.time_limit\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n        success = False\n        for i in range(self.max_iter):\n            if timeout():\n                break\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_point = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start else start_pos)\n            nearest = self._nearest(tree_a, sample_point)\n            new_pos = self._steer(nearest.position, sample_point)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n            near_nodes = self._near(tree_a, new_pos, self.rewire_radius)\n            best_parent = nearest\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            for node in near_nodes:\n                cost_candidate = node.cost + math.dist(node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    best_parent = node\n                    min_cost = cost_candidate\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            for node in near_nodes:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, node.position)\n                if new_cost < node.cost and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                    # Rewire\n                    if node.parent:\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.parent.remove_child(node)\n                    node.parent = new_node\n                    node.update_cost_recursive(new_cost)\n                    new_node.add_child(node)\n                    edges.append((new_node, node))\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = math.dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n                path = new_node.path_from_root() if expand_start else connect_node.path_from_root()\n                other_path = connect_node.path_from_root() if expand_start else new_node.path_from_root()\n                other_path.reverse()\n                full_path = path + other_path[1:]\n                total_cost = new_node.cost + (connect_node.cost - nearest_other.cost) if expand_start else connect_node.cost + (new_node.cost - best_parent.cost)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = full_path\n                    success = True\n                break\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
        "objective": -17.96073,
        "time_improvement": 11.0,
        "length_improvement": 18.0,
        "smoothness_improvement": 806.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.03704488277435303,
                "num_nodes_avg": 106.1,
                "path_length_avg": 162.29479791024076,
                "smoothness_avg": 0.040998061084489654,
                "success_improvement": 0.0,
                "time_improvement": -43.23675283011911,
                "length_improvement": 11.04364953975187,
                "smoothness_improvement": 541.708684686862,
                "objective_score": -3.6362927017502993
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.05155603885650635,
                "num_nodes_avg": 265.8,
                "path_length_avg": 229.77182972861425,
                "smoothness_avg": 0.04415501560611849,
                "success_improvement": 0.0,
                "time_improvement": 68.62559753301403,
                "length_improvement": 23.295549621171688,
                "smoothness_improvement": 1036.14035511766,
                "objective_score": 39.745710808195525
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.04517831802368164,
                "num_nodes_avg": 262.8,
                "path_length_avg": 122.22274461411057,
                "smoothness_avg": 0.07392879965380451,
                "success_improvement": 0.0,
                "time_improvement": 7.585494522429914,
                "length_improvement": 18.82547264898104,
                "smoothness_improvement": 840.3688747400313,
                "objective_score": 17.772776319817755
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "A hybrid bidirectional RRT* planner with fixed-radius rewiring, goal-biased sampling, and incremental path cost updating, designed for efficient exploration and rapid convergence to short, smooth paths. It alternates expansions from start and goal trees, connects trees with collision-free edges, and maintains best path tracking with early stopping under a 30-second time limit. Edge and node collision checks, consistent tree updates, and pruning ensure high path quality and robustness.",
        "planning_mechanism": "The planner samples with goal bias, extends trees via fixed step size steer functions, uses a fixed-radius neighborhood for parent selection and rewiring to optimize path costs, alternates between start and goal expansions, attempts immediate connections, keeps track of best path found, and stops early either on timeout or solution stabilization, thus improving planning time, path length, and smoothness.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15  # Goal bias probability\n        self.fixed_radius = 15.0       # Fixed rewiring/neighbor radius\n        self.time_limit = 30.0         # Hard time limit in seconds\n        self.improve_tol = 1e-9        # Small tolerance for cost comparison\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for itr in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (itr % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            near_nodes = self._near(tree_a, new_pos, self.fixed_radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper paths exist through new_node\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        self._update_costs_recursive(near_node, edges)\n\n            # Attempt to connect trees\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    # Build combined path\n                    if expand_start:\n                        path = self._build_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        best_goal_node = connect_node if expand_start else new_node\n                        found_solution = True\n                        success_state = True\n\n            if found_solution:\n                # Early stop on improvement for efficiency\n                break\n\n        extracted_path = best_path if found_solution else []\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _update_costs_recursive(self, node: Node, edges: List[Tuple[Node, Node]]):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                if child.parent:\n                    try:\n                        edges.remove((child.parent, child))\n                    except ValueError:\n                        pass\n                    child.parent.remove_child(child)\n                child.parent = node\n                child.cost = new_cost\n                edges.append((node, child))\n                self._update_costs_recursive(child, edges)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        return math.dist(p1, p2)\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # Remove duplicated connection node position to avoid double count\n        combined = path_start + path_goal[1:]\n        return combined\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -29.79261,
        "time_improvement": 64.0,
        "length_improvement": 15.0,
        "smoothness_improvement": 286.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.014900636672973634,
                "num_nodes_avg": 124.9,
                "path_length_avg": 159.47130040463088,
                "smoothness_avg": 0.02276354128553975,
                "success_improvement": 0.0,
                "time_improvement": 42.38559681404182,
                "length_improvement": 12.591253263757743,
                "smoothness_improvement": 256.29885293978236,
                "objective_score": 21.5519252671661
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03198549747467041,
                "num_nodes_avg": 320.0,
                "path_length_avg": 240.61799786727897,
                "smoothness_avg": 0.01613382883159849,
                "success_improvement": 0.0,
                "time_improvement": 80.53524100891183,
                "length_improvement": 19.674786506845358,
                "smoothness_improvement": 315.1350365642233,
                "objective_score": 37.541119389601874
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.015687036514282226,
                "num_nodes_avg": 203.9,
                "path_length_avg": 129.30542997382435,
                "smoothness_avg": 0.03047932298139177,
                "success_improvement": 0.0,
                "time_improvement": 67.91138348452755,
                "length_improvement": 14.121490274293217,
                "smoothness_improvement": 287.69473857370235,
                "objective_score": 30.284782902802707
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "An enhanced bidirectional RRT* planner employing goal bias sampling, adaptive neighbor radius, and an incremental rewiring strategy with non-recursive cost updates for efficient planning. The planner starts with bidirectional tree growth and switches to single-tree informed sampling around the current best path for faster convergence and path improvement. Collision checks are performed at all stages, and a strict 30-second timeout ensures timely termination with the best found solution. It balances exploration and exploitation to minimize planning time while improving path length and smoothness.",
        "planning_mechanism": "The planner alternates expansions from start and goal trees using goal-biased sampling, employs an adaptive radius for neighbor search to limit rewiring overhead, keeps track of the best path found to switch to an informed sampling refinement phase that samples within an ellipsoid around the best path, all while maintaining consistent, non-recursive path cost updates and performing comprehensive collision checks, stopping immediately on timeout or upon solution refinement convergence.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 50.0\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob:\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best = node\n        return best\n\n    def _near(self, tree, point, radius):\n        near_nodes = []\n        r_sq = radius * radius\n        for node in tree:\n            # compare squared distance for speed\n            d_sq = sum((a - b) ** 2 for a, b in zip(node.position, point))\n            if d_sq <= r_sq:\n                near_nodes.append(node)\n        return near_nodes\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        if path_start[-1] == path_goal[0]:\n            return path_start + path_goal[1:]\n        else:\n            return path_start + path_goal\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-10:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n        while True:\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        time_limit = self.time_limit\n\n        def timeout():\n            return time.monotonic() - time_start >= time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        # === Bidirectional Phase ===\n        for it in range(self.max_iter):\n            if timeout():\n                break\n            expand_start = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n\n            sample = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start else start_pos, self.goal_sample_rate)\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 20)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_node in near_nodes:\n                c = near_node.cost + self._dist(near_node.position, new_pos)\n                if c < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = c\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors (non-recursive)\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_thru_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_thru_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_thru_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            nearest_opposite = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_opposite.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_opposite.position, new_node.position, obstacles, is_3d):\n                # Connect trees by linking new node with nearest opposite\n                connect_node = Node(new_node.position, parent=nearest_opposite, cost=nearest_opposite.cost + dist_connect)\n                nearest_opposite.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_opposite, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_opposite.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n                    success_state = True\n\n            if found_solution:\n                break\n\n        # === Single-Tree Refinement Phase ===\n        if not found_solution:\n            return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n        # Build tree from best path for refinement\n        tree = [start_root]\n        start_root.children = []\n        start_root.cost = 0.0\n        nodes = [start_root]\n        edges = []\n\n        prev_node = start_root\n        for p in best_path[1:]:\n            n = Node(p, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, p))\n            prev_node.add_child(n)\n            tree.append(n)\n            nodes.append(n)\n            edges.append((prev_node, n))\n            prev_node = n\n        best_goal_node = prev_node\n        best_cost = best_goal_node.cost\n\n        no_improve_count = 0\n        max_no_improve = 150\n        refinement_iters = self.max_iter // 2\n        c_min = self._dist(start_pos, goal_pos)\n\n        for _ in range(refinement_iters):\n            if timeout() or no_improve_count >= max_no_improve:\n                break\n            sample = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n            nearest = self._nearest(tree, sample)\n            new_pos = self._steer(nearest.position, sample)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                no_improve_count += 1\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                no_improve_count += 1\n                continue\n\n            n_nodes = len(tree) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 20)\n            near_nodes = self._near(tree, new_pos, radius)\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_node in near_nodes:\n                c = near_node.cost + self._dist(near_node.position, new_pos)\n                if c < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = c\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewired = False\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_thru_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_thru_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_thru_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    rewired = True\n\n            # Check connecting new node directly to goal\n            dist_goal = self._dist(new_node.position, goal_pos)\n            if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                new_node.add_child(goal_node)\n                tree.append(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                if goal_node.cost + self.improve_tol < best_cost:\n                    best_cost = goal_node.cost\n                    best_goal_node = goal_node\n                    no_improve_count = 0\n                    success_state = True\n                else:\n                    no_improve_count += 1\n            else:\n                no_improve_count += 1\n\n            if not rewired:\n                no_improve_count += 1\n\n        final_path = best_goal_node.path_from_root() if success_state else best_path\n\n        return PlannerResult(\n            success=success_state,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": -12.53849,
        "time_improvement": 7.0,
        "length_improvement": 15.0,
        "smoothness_improvement": 296.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.030045223236083985,
                "num_nodes_avg": 95.4,
                "path_length_avg": 160.81581401172727,
                "smoothness_avg": 0.025708202112380618,
                "success_improvement": 0.0,
                "time_improvement": -16.17205649175855,
                "length_improvement": 11.854304050526727,
                "smoothness_improvement": 302.3891893131739,
                "objective_score": 3.7729114293543407
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.052814698219299315,
                "num_nodes_avg": 108.9,
                "path_length_avg": 250.64860418056378,
                "smoothness_avg": 0.01342185084909307,
                "success_improvement": 0.0,
                "time_improvement": 67.85964098761269,
                "length_improvement": 16.326281404476397,
                "smoothness_improvement": 245.35388971557333,
                "objective_score": 31.38043058754751
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.06383750438690186,
                "num_nodes_avg": 90.5,
                "path_length_avg": 125.65242145575378,
                "smoothness_avg": 0.0347233803394253,
                "success_improvement": 0.0,
                "time_improvement": -30.582802922086017,
                "length_improvement": 16.54764459442284,
                "smoothness_improvement": 341.67883490416074,
                "objective_score": 2.4621400545487035
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "A simplified bidirectional RRT* planner that uses fixed radius rewiring with consistent parent-child relationship updates, goal-biased sampling, and early stopping upon finding a solution to balance exploration and planning efficiency. The algorithm avoids recursive cost propagation by incremental cost updates during rewiring and maintains a time limit for robust real-time performance.",
        "planning_mechanism": "The planner grows two trees alternately from start and goal positions by sampling points biased toward their opposite root, extends toward samples with fixed step size, locally rewires neighbors within a constant radius to improve path cost, and attempts connection of the two trees. Collision checks ensure feasibility of nodes and edges. Upon connecting trees, the planner extracts the path and terminates early, returning the best path found within the time limit.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1\n        self.rewire_radius = 15.0\n        self.time_limit = 30.0\n        self.improve_tol = 1e-8\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, target, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(target, obstacles, is_3d):\n            return target\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        nearest_node = None\n        min_dist = float('inf')\n        for node in tree:\n            dist = self._dist(node.position, point)\n            if dist < min_dist:\n                min_dist = dist\n                nearest_node = node\n        return nearest_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        radius_sq = radius * radius\n        result = []\n        for node in tree:\n            d_sq = sum((a - b) ** 2 for a, b in zip(node.position, point))\n            if d_sq <= radius_sq:\n                result.append(node)\n        return result\n\n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def plan(self, map) -> PlannerResult:\n        import time\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        time_start = time.monotonic()\n        def time_exceeded() -> bool:\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        found_solution = False\n\n        for i in range(self.max_iter):\n            if time_exceeded():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            target_sample = goal_pos if expand_start else start_pos\n            sample = self._sample(bounds, obstacles, is_3d, target_sample, self.goal_sample_rate)\n\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            near_nodes = self._near(tree_a, new_pos, self.rewire_radius)\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_to_other = self._dist(new_node.position, nearest_other.position)\n            if dist_to_other <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_to_other)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    if expand_start:\n                        path = self._build_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        found_solution = True\n                        break\n\n            if found_solution:\n                break\n\n        success_state = found_solution\n        extracted_path = best_path if found_solution else []\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
        "objective": -23.64699,
        "time_improvement": 42.0,
        "length_improvement": 16.0,
        "smoothness_improvement": 312.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.012988829612731933,
                "num_nodes_avg": 105.7,
                "path_length_avg": 158.0716475211238,
                "smoothness_avg": 0.02391556040922841,
                "success_improvement": 0.0,
                "time_improvement": 49.77773885467754,
                "length_improvement": 13.35842518812721,
                "smoothness_improvement": 274.3304538750773,
                "objective_score": 24.32002903865497
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02958998680114746,
                "num_nodes_avg": 266.1,
                "path_length_avg": 243.47383404946873,
                "smoothness_avg": 0.017303870387007696,
                "success_improvement": 0.0,
                "time_improvement": 81.99302786864814,
                "length_improvement": 18.72142618854365,
                "smoothness_improvement": 345.24104853177045,
                "objective_score": 37.55696931637948
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.05162415504455566,
                "num_nodes_avg": 288.1,
                "path_length_avg": 127.56547078962936,
                "smoothness_avg": 0.03266774598713309,
                "success_improvement": 0.0,
                "time_improvement": -5.599786973902844,
                "length_improvement": 15.27708831648271,
                "smoothness_improvement": 315.53131767414845,
                "objective_score": 9.063973486089514
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "A streamlined bidirectional RRT* planner employing fixed-radius neighbor rewiring, goal-biased sampling, early termination on first solution discovery, and incremental cost updates without recursive propagation. It balances simplicity and efficiency by alternating tree expansions, efficiently searching neighbors within a constant radius, ensuring collision-free connections, and promptly returning the best path found within a hard time limit.",
        "planning_mechanism": "The planner grows two trees from start and goal with goal bias sampling, extends towards sampled points in fixed steps, rewires neighbors within a fixed radius by incremental cost comparison and updates parents, attempts to connect the trees upon proximity, and stops early once a solution is found or time limit is exceeded.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"] = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1\n        self.rewire_radius = 15.0\n        self.time_limit = 30.0\n        self.improve_tol = 1e-8\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, target, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(target, obstacles, is_3d):\n            return target\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        nearest_node = None\n        min_dist = float('inf')\n        for node in tree:\n            dist = self._dist(node.position, point)\n            if dist < min_dist:\n                min_dist = dist\n                nearest_node = node\n        return nearest_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        radius_sq = radius * radius\n        result = []\n        for node in tree:\n            d_sq = sum((a - b) ** 2 for a, b in zip(node.position, point))\n            if d_sq <= radius_sq:\n                result.append(node)\n        return result\n\n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        time_start = time.monotonic()\n        def time_exceeded() -> bool:\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        found_solution = False\n\n        for i in range(self.max_iter):\n            if time_exceeded():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            target_sample = goal_pos if expand_start else start_pos\n\n            sample = self._sample(bounds, obstacles, is_3d, target_sample, self.goal_sample_rate)\n\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            near_nodes = self._near(tree_a, new_pos, self.rewire_radius)\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_to_other = self._dist(new_node.position, nearest_other.position)\n            if dist_to_other <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_to_other)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    if expand_start:\n                        path = self._build_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        found_solution = True\n                        break\n\n            if found_solution:\n                break\n\n        success_state = found_solution\n        extracted_path = best_path if found_solution else []\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
        "objective": -12.4748,
        "time_improvement": 6.0,
        "length_improvement": 15.0,
        "smoothness_improvement": 286.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.01651873588562012,
                "num_nodes_avg": 129.1,
                "path_length_avg": 163.696358168807,
                "smoothness_avg": 0.022814818291193716,
                "success_improvement": 0.0,
                "time_improvement": 36.129097680592935,
                "length_improvement": 10.275432152888191,
                "smoothness_improvement": 257.1014494280669,
                "objective_score": 18.289495843051128
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.039663839340209964,
                "num_nodes_avg": 320.7,
                "path_length_avg": 238.93700042108193,
                "smoothness_avg": 0.0164025145196386,
                "success_improvement": 0.0,
                "time_improvement": 75.86258978683014,
                "length_improvement": 20.235951839214646,
                "smoothness_improvement": 322.048512843974,
                "objective_score": 36.510590603797695
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.09480364322662353,
                "num_nodes_avg": 406.5,
                "path_length_avg": 126.96902650618938,
                "smoothness_avg": 0.029844050747926298,
                "success_improvement": 0.0,
                "time_improvement": -93.92558619973246,
                "length_improvement": 15.673218209918826,
                "smoothness_improvement": 279.61412265494016,
                "objective_score": -17.375674320693744
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e1",
        "algorithm_description": "An advanced bidirectional RRT* planner with adaptive fixed-radius rewiring, recursive cost propagation, goal-biased and informed sampling, and post-planning shortcut path smoothing to ensure efficient exploration, improved path length, and smoothness within a hard 30-second time limit.",
        "planning_mechanism": "The planner grows two trees alternately from start and goal with a fixed radius for neighbor rewiring and goal bias sampling, connects them upon feasible edges, then refines the best path through informed sampling and shortcut smoothing before termination or timeout, maintaining consistent cost propagation and collision-free constraints throughout.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # Cost from root to this node\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n\n        # Fixed radius for neighbor search (tuned empirically)\n        self.fixed_radius = 15.0\n\n        # Probability of sampling the goal (goal bias)\n        self.goal_sample_rate = 0.2\n\n        # Small tolerance for cost improvement\n        self.improve_tol = 1e-6\n\n        # Resolution for collision checking along edges\n        self.check_resolution = 1.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d):\n        dist = 0.0\n        try:\n            dist = math.dist(from_pos, to_pos)\n        except:\n            # fallback if math.dist unavailable\n            dist = sum((f - t) ** 2 for f, t in zip(from_pos, to_pos)) ** 0.5\n        steps = max(1, int(dist / self.check_resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = 0.0\n        try:\n            dist = math.dist(from_pos, to_pos)\n        except:\n            dist = sum((f - t) ** 2 for f, t in zip(from_pos, to_pos)) ** 0.5\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        try:\n            return math.dist(p1, p2)\n        except:\n            return sum((a - b) ** 2 for a, b in zip(p1, p2)) ** 0.5\n\n    def _sample(self, bounds, obstacles, is_3d, goal):\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        res = []\n        r2 = radius * radius\n        for node in tree:\n            d = 0.0\n            if hasattr(math, 'dist'):\n                d = math.dist(node.position, point)\n            else:\n                d = sum((a - b) ** 2 for a,b in zip(node.position, point)) ** 0.5\n            if d <= radius:\n                res.append(node)\n        return res\n\n    def _update_costs_recursive(self, node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_costs_recursive(child)\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # avoid duplicate connecting node position\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        if c_best == float('inf') or c_best < c_min - 1e-10:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        dim = len(bounds)\n        center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = sum(x * x for x in a1) ** 0.5\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c1 = c_best * 0.5\n        c2 = (max(c_best * c_best - c_min * c_min, 0.0) ** 0.5) * 0.5\n\n        while True:\n            # Sample unit ball in dim dimension\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = sum(x*x for x in rnd_dir) ** 0.5\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            # Scale sample to ellipsoid axes:\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            # Rotation aligns first axis with a1 vector (approximate)\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _try_shortcut(self, path, obstacles, is_3d):\n        if len(path) <= 2:\n            return path[:]\n        smoothed_path = [path[0]]\n        idx = 0\n        n = len(path)\n        while idx < n - 1:\n            next_idx = n - 1\n            while next_idx > idx + 1:\n                if not self._is_edge_in_obstacle(path[idx], path[next_idx], obstacles, is_3d):\n                    break\n                next_idx -= 1\n            smoothed_path.append(path[next_idx])\n            idx = next_idx\n        return smoothed_path\n\n    def plan(self, map):\n        import time, math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        time_start = time.monotonic()\n\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        # Alternate expansions\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            expanding_start = (i % 2 == 0)\n            tree_a = tree_start if expanding_start else tree_goal\n            tree_b = tree_goal if expanding_start else tree_start\n            sample_goal = goal_pos if expanding_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = self.fixed_radius\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Update edge and parent-child relations\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    # Recursively update costs of descendants\n                    self._update_costs_recursive(near_node)\n\n            # Attempt connection to opposite tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                # Connect trees by adding a connecting node\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expanding_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expanding_start else new_node\n                    found_solution = True\n                    success_state = True\n                    break\n\n        # Refinement phase if solution found\n        if found_solution and best_goal_node is not None:\n            # Build a tree rooted at start for informed RRT*\n            tree = [start_root]\n            start_root.children = []\n            start_root.cost = 0.0\n\n            # Copy best path into tree\n            prev_node = start_root\n            for pos in best_path[1:]:\n                n_cost = prev_node.cost + self._dist(prev_node.position, pos)\n                new_node = Node(pos, parent=prev_node, cost=n_cost)\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            max_no_improve = 120\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if timed_out() or no_improve_count >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                near_nodes = self._near(tree, new_pos, self.fixed_radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                    if cost_candidate + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        self._update_costs_recursive(near_node)\n                        rewired = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n            # Post-process path shortcutting for smoothness\n            if len(extracted_path) > 2:\n                extracted_path = self._try_shortcut(extracted_path, obstacles, is_3d)\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
        "objective": -31.02063,
        "time_improvement": 46.0,
        "length_improvement": 17.0,
        "smoothness_improvement": 1385.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.02439420223236084,
                "num_nodes_avg": 210.6,
                "path_length_avg": 166.9287719242713,
                "smoothness_avg": 0.04447081982954099,
                "success_improvement": 0.0,
                "time_improvement": 5.678030163354109,
                "length_improvement": 8.503694952644477,
                "smoothness_improvement": 596.0649002632317,
                "objective_score": 9.785950521909077
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.0319866418838501,
                "num_nodes_avg": 379.0,
                "path_length_avg": 229.74939855856366,
                "smoothness_avg": 0.09565426382163486,
                "success_improvement": 0.0,
                "time_improvement": 80.53454457926001,
                "length_improvement": 23.303037791380007,
                "smoothness_improvement": 2361.2531051120586,
                "objective_score": 49.9484515741663
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.024246406555175782,
                "num_nodes_avg": 322.2,
                "path_length_avg": 119.89049793872327,
                "smoothness_avg": 0.1019188821406457,
                "success_improvement": 0.0,
                "time_improvement": 50.40276465737084,
                "length_improvement": 20.374439841120928,
                "smoothness_improvement": 1196.4006579596712,
                "objective_score": 33.32749659168216
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "A bidirectional RRT* planner with adaptive fixed-radius rewiring, goal-biased and informed sampling, early solution detection with incremental local refinement, and progressive shortcut smoothing to balance fast convergence and high-quality smooth paths within a strict 30-second limit. The planner alternates growing trees from start and goal, performs rewiring without costly recursive subtree updates, employs ellipsoidal informed sampling after initial solution, and uses multiple passes of efficient local shortcut smoothing to enhance path smoothness and reduce length.",
        "planning_mechanism": "The algorithm maintains two RRT* trees grown alternately towards sampled points with goal bias; neighbors are searched within an adaptively computed fixed radius based on node count and environment dimension. Rewiring updates costs locally without recursive cascades. Upon first connection of the two trees, the best path is recorded and a shorter refinement phase using ellipsoidal sampling improves the path incrementally. After planning or timeout, the final path undergoes multiple iterative shortcut smoothing passes, reducing sharp turns and unnecessary waypoints for smoothness improvements. The time limit is enforced strictly to stop planning and return the current best path if exceeded.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = parent          # Node or None\n        self.cost = cost              # Cost from root\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n        self.goal_sample_rate = 0.15\n        self.time_limit = 30.0\n        self.improve_tol = 1e-8\n        self.check_resolution = 1.0\n\n    def plan(self, map):\n        import time, math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / self.check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample(goal):\n            if random.random() < self.goal_sample_rate and not is_in_obstacle(goal):\n                return goal\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d_ = dist(node.position, point)\n                if d_ < best_dist:\n                    best_dist = d_\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            res = []\n            r2 = radius * radius\n            for node in tree:\n                d_ = dist(node.position, point)\n                if d_ <= radius:\n                    res.append(node)\n            return res\n\n        def rewiring_radius(n):\n            if n <= 1:\n                return self.step_size * 2.0\n            gamma = 20.0  # Tuned constant\n            r = gamma * (math.log(n)/n) ** (1/dim)\n            return max(r, self.step_size)\n\n        def build_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            path_goal.reverse()\n            return path_start + path_goal[1:]\n\n        def shortcut_path(path):\n            # Multiple passes of shortcutting for smoother curves\n            if len(path) <= 2:\n                return path[:]\n            for _ in range(3):  # Iteratively improve smoothness\n                new_path = [path[0]]\n                i = 0\n                n = len(path)\n                while i < n - 1:\n                    j = n - 1\n                    while j > i + 1:\n                        if not is_edge_in_obstacle(path[i], path[j]):\n                            break\n                        j -= 1\n                    new_path.append(path[j])\n                    i = j\n                path = new_path\n            return path\n\n        # Initialize trees\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        best_goal_node = None\n\n        for iter_ in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (iter_ % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = sample(sample_goal)\n            nearest_node = nearest(tree_a, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            radius = rewiring_radius(len(tree_a))\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nnode in near_nodes:\n                cc = nnode.cost + dist(nnode.position, new_pos)\n                if cc + self.improve_tol < min_cost and not is_edge_in_obstacle(nnode.position, new_pos):\n                    min_cost = cc\n                    best_parent = nnode\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Local rewiring (no recursive cost update for speed)\n            for nnode in near_nodes:\n                if nnode is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nnode.position)\n                if cost_through_new + self.improve_tol < nnode.cost and not is_edge_in_obstacle(new_node.position, nnode.position):\n                    if nnode.parent:\n                        try:\n                            edges.remove((nnode.parent, nnode))\n                        except ValueError:\n                            pass\n                        nnode.parent.remove_child(nnode)\n                    nnode.parent = new_node\n                    nnode.cost = cost_through_new\n                    new_node.add_child(nnode)\n                    edges.append((new_node, nnode))\n\n            # Try connecting trees\n            nearest_other = nearest(tree_b, new_node.position)\n            dist_connect = dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not is_edge_in_obstacle(nearest_other.position, new_node.position):\n                # Connect trees by adding a node in tree_b\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path = build_path(new_node, connect_node)\n                    path_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = build_path(connect_node, new_node)\n                    path_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if path_cost + self.improve_tol < best_cost:\n                    best_cost = path_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n\n            if found_solution:\n                # Early stop after first solution to save time\n                break\n\n        # Incremental Refinement via ellipsoidal informed sampling to improve path\n        if found_solution and best_goal_node:\n            c_min = dist(start_pos, goal_pos)\n            c_best = best_cost\n            tree = [start_root]\n            start_root.children.clear()\n            start_root.cost = 0.0\n\n            # Insert best path nodes into new tree (no duplicates)\n            prev_node = start_root\n            for pos in best_path[1:]:\n                n_cost = prev_node.cost + dist(prev_node.position, pos)\n                n_node = Node(pos, parent=prev_node, cost=n_cost)\n                prev_node.add_child(n_node)\n                tree.append(n_node)\n                nodes.append(n_node)\n                edges.append((prev_node, n_node))\n                prev_node = n_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            max_no_improve = 100\n            refinement_iters = min(self.max_iter//3, 1000)\n\n            def ellipsoidal_sample():\n                if c_best == float('inf') or c_best < c_min - 1e-12:\n                    while True:\n                        pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if not is_in_obstacle(pt):\n                            return pt\n                center = tuple((s+g)*0.5 for s,g in zip(start_pos, goal_pos))\n                a1 = tuple(g - s for s,g in zip(start_pos, goal_pos))\n                norm_a1 = math.sqrt(sum(x*x for x in a1))\n                if norm_a1 < 1e-12:\n                    while True:\n                        pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if not is_in_obstacle(pt):\n                            return pt\n                c1 = c_best * 0.5\n                c2 = 0.5 * math.sqrt(max(c_best*c_best - c_min*c_min, 0))\n                while True:\n                    rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n                    norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n                    if norm_dir < 1e-12:\n                        continue\n                    unit_dir = [x / norm_dir for x in rnd_dir]\n                    r = random.random() ** (1.0/dim)\n                    ball_point = [r * x for x in unit_dir]\n                    scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n                    dir_a1 = [x / norm_a1 for x in a1]\n                    point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n                    for i in range(1, dim):\n                        point[i] += scaled[i]\n                    pt = tuple(max(0, min(bounds[d], point[d])) for d in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n\n            for _ in range(refinement_iters):\n                if timed_out() or no_improve_count >= max_no_improve:\n                    break\n                s_pt = ellipsoidal_sample()\n                n_node = nearest(tree, s_pt)\n                new_pos = steer(n_node.position, s_pt)\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(n_node.position, new_pos):\n                    no_improve_count += 1\n                    continue\n                near_nodes = near(tree, new_pos, rewiring_radius(len(tree)))\n                min_cost = n_node.cost + dist(n_node.position, new_pos)\n                best_parent = n_node\n                for n_ in near_nodes:\n                    c_cand = n_.cost + dist(n_.position, new_pos)\n                    if c_cand + self.improve_tol < min_cost and not is_edge_in_obstacle(n_.position, new_pos):\n                        min_cost = c_cand\n                        best_parent = n_\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                rewired_flag = False\n                for n_ in near_nodes:\n                    if n_ is best_parent: \n                        continue\n                    cost_th = new_node.cost + dist(new_node.position, n_.position)\n                    if cost_th + self.improve_tol < n_.cost and not is_edge_in_obstacle(new_node.position, n_.position):\n                        if n_.parent:\n                            try:\n                                edges.remove((n_.parent, n_))\n                            except Exception:\n                                pass\n                            n_.parent.remove_child(n_)\n                        n_.parent = new_node\n                        n_.cost = cost_th\n                        new_node.add_child(n_)\n                        edges.append((new_node, n_))\n                        rewired_flag = True\n                dist_to_goal = dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        found_solution = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n                if not rewired_flag:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if found_solution else best_path\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            extracted_path = best_path\n\n        success_state = bool(extracted_path)\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
        "objective": -36.43867,
        "time_improvement": 60.0,
        "length_improvement": 17.0,
        "smoothness_improvement": 1653.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.017981839179992676,
                "num_nodes_avg": 185.9,
                "path_length_avg": 162.59923720922134,
                "smoothness_avg": 0.05228999958836421,
                "success_improvement": 0.0,
                "time_improvement": 30.471901618791254,
                "length_improvement": 10.87678153583121,
                "smoothness_improvement": 718.4520431094295,
                "objective_score": 19.25989962268325
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.022843813896179198,
                "num_nodes_avg": 366.6,
                "path_length_avg": 235.69548545844145,
                "smoothness_avg": 0.1106068428399279,
                "success_improvement": 0.0,
                "time_improvement": 86.09840812141438,
                "length_improvement": 21.318062835578978,
                "smoothness_improvement": 2745.9937331600827,
                "objective_score": 52.35032880357211
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.018364214897155763,
                "num_nodes_avg": 319.3,
                "path_length_avg": 121.68574565278978,
                "smoothness_avg": 0.12525212938789504,
                "success_improvement": 0.0,
                "time_improvement": 62.43508141859384,
                "length_improvement": 19.182121789947647,
                "smoothness_improvement": 1493.1978406635246,
                "objective_score": 37.705786702864366
            }
        ],
        "success_rate": 1.0
    }
]