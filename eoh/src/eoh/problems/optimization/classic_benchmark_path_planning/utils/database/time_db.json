[
    {
        "operator": "m3",
        "algorithm_description": "This algorithm implements a simplified, unified bidirectional RRT* planner that balances exploration efficiency and path quality. It grows two trees from the start and goal positions alternately, samples points with adaptive goal biasing, extends nearest nodes towards samples using a fixed step size, and employs local rewiring around new nodes to improve path cost and smoothness. Rigorous collision and edge feasibility checks ensure safety. Upon connection of the trees, the shortest path is reconstructed by merging paths from both connected nodes. The planner avoids excessive complexity while maintaining robustness, smoothness, and efficient convergence.",
        "planning_mechanism": "The planner alternates growth between start and goal trees, samples points with goal bias to encourage connections, extends the nearest node towards samples with a capped step size, rewires neighbors within a radius inversely related to tree size to reduce path cost, and verifies collision-free conditions for nodes and edges. When the trees connect, the optimal path is extracted by backtracking and merged. This approach balances exploration and exploitation to find shorter, smoother feasible paths efficiently.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position              # Tuple[float, ...] (2D or 3D)\n        self.parent = parent                  # Parent node or None\n        self.cost = cost                      # Cost from root\n        self.children = []\n        self.valid = True                     # For collision or validity checks\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.1, radius_constant: float=20.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Probability to sample goal\n        self.radius_constant = radius_constant      # For rewiring radius calculation\n        self.radius_min = radius_min                  # Minimum radius for rewiring\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free() -> Tuple[float, ...]:\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes: int) -> float:\n            if n_nodes == 0:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, r)\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...]) -> Node or None:\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-6 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node) -> Node or None:\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Balance tree sizes, extend smaller first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -23.735083,
        "time_improvement": 44.0,
        "length_improvement": 8.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.0039825916290283205,
                "num_nodes_avg": 76.2,
                "path_length_avg": 172.59475061003724,
                "success_improvement": 0.0,
                "time_improvement": 57.770648626374324,
                "length_improvement": 13.738802538996584,
                "objective_score": 20.078955095711613
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.013543009757995605,
                "num_nodes_avg": 249.1,
                "path_length_avg": 290.1072272486077,
                "success_improvement": 0.0,
                "time_improvement": 8.077960621600676,
                "length_improvement": 3.732607234605092,
                "objective_score": 3.169909633401221
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.009406518936157227,
                "num_nodes_avg": 162.7,
                "path_length_avg": 149.7826015352379,
                "success_improvement": 0.0,
                "time_improvement": 67.54128112795729,
                "length_improvement": 8.02445960163917,
                "objective_score": 21.86727625871502
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "This improved planner implements a bidirectional RRT* algorithm incorporating adaptive goal/start bias sampling with dynamic neighbor radius rewiring to minimize path cost. It balances growth by always extending the smaller tree, rigorously applies collision and edge feasibility checks, and optimizes the found path with iterative shortcut smoothing. Additionally, it performs periodic pruning of dead-end nodes to keep tree sizes manageable and improves convergence speed and path quality. The rewiring step carefully updates parents to ensure minimal-cost routes, enhancing path optimality and robustness.",
        "planning_mechanism": "The planner grows two trees rooted at start and goal, alternately extending the smaller tree towards biased random samples favoring start or goal positions. It uses a dynamic neighbor radius for local rewiring to improve path costs continuously. Periodic pruning removes dead-end nodes to maintain efficiency, while shortcut smoothing is applied after path connection to reduce length and improve smoothness. This combination balances exploration versus exploitation, leading to faster convergence, increased success rate, and shorter, smoother paths.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=20.0,\n                 radius_min: float=5.0, prune_interval: int=150,\n                 prune_threshold: int=150, smoothing_iterations: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        import random\n        import math\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            # Adaptive bias towards goal and start to promote faster connections\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < 0.6 else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            if not in_bounds(pos) or self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            to_remove = [node for node in nodes if node not in (start_root, goal_root) and not node.children]\n            for node in to_remove:\n                try:\n                    if node.parent:\n                        node.parent.children.remove(node)\n                    nodes.remove(node)\n                    edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                    removed.append(node)\n                except Exception:\n                    continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend smaller tree to balance exploration/exploitation\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed_path = shortcut_smoothing(raw_path)\n                if path_length(smoothed_path) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -27.232483,
        "time_improvement": 1.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.004982614517211914,
                "num_nodes_avg": 68.5,
                "path_length_avg": 157.43983697259313,
                "success_improvement": 0.0,
                "time_improvement": 50.6125400561495,
                "length_improvement": 21.313082713587217,
                "objective_score": 19.44637855956229
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.026825737953186036,
                "num_nodes_avg": 179.7,
                "path_length_avg": 240.30043302847486,
                "success_improvement": 0.0,
                "time_improvement": -87.53956546741006,
                "length_improvement": 20.260186595686807,
                "objective_score": -22.209832321085653
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.01701357364654541,
                "num_nodes_avg": 144.0,
                "path_length_avg": 127.59148971666832,
                "success_improvement": 0.0,
                "time_improvement": 40.70229786583415,
                "length_improvement": 21.651139073308062,
                "objective_score": 16.540917174411856
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "This enhanced bidirectional RRT* planner grows two trees simultaneously from start and goal positions, employing adaptive goal biasing for efficient exploration. At each iteration, a sampled free point guides tree extension using a steering function respecting a fixed step size. Newly added nodes attempt local rewiring by connecting to neighbors within a dynamically adjusted radius based on the number of nodes, improving path cost and smoothness. When trees connect, the shortest cost path is reconstructed by backtracking from both connection nodes. Collision and edge feasibility checks ensure safety, while pruning suboptimal rewires and minimizing path length boost planning efficiency, robustness, and path quality.",
        "planning_mechanism": "The planner alternates tree growth between start and goal, sampling free points with goal bias. It extends the nearest nodes towards samples, rewires neighbors within a radius inversely proportional to the tree size for incremental optimization, and checks collision-free connections. Upon tree connection, it generates the optimal path by merging extensions from both trees. This combination of bidirectional search and incremental RRT* rewiring achieves faster convergence to shorter and smoother paths.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1, radius_constant: float = 30.0, radius_min: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < 0.7 else start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def radius_by_nodes(n_nodes):\n            # Radius shrinks as more nodes are added (typical for RRT*), with a minimum radius\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + distance(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire around new_node to improve paths locally\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-6 < neighbor.cost:  # Strict improvement with epsilon\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    # Check final edge feasibility before return\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        # Alternate growth direction, keep track of trees accordingly\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n            # Always extend the smaller tree first to balance growths\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                # Merge and avoid duplicate connection node\n                extracted_path = path_from_start + path_from_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -21.871099,
        "time_improvement": 23.0,
        "length_improvement": 13.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.0053680181503295895,
                "num_nodes_avg": 68.2,
                "path_length_avg": 168.24816019864105,
                "success_improvement": 0.0,
                "time_improvement": 43.08029901986809,
                "length_improvement": 15.911186649372569,
                "objective_score": 16.106327035834944
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.01864187717437744,
                "num_nodes_avg": 256.6,
                "path_length_avg": 287.4569206517525,
                "success_improvement": 0.0,
                "time_improvement": -26.530173006684965,
                "length_improvement": 4.612068627304342,
                "objective_score": -7.036638176544621
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.013377833366394042,
                "num_nodes_avg": 183.6,
                "path_length_avg": 134.76801275171147,
                "success_improvement": 0.0,
                "time_improvement": 53.83761673112537,
                "length_improvement": 17.24432160877036,
                "objective_score": 19.600149341091683
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "This planner is an enhanced bidirectional RRT* variant combining adaptive informed sampling with balanced tree growth, dynamic radius rewiring, dead-end pruning, and iterative shortcut smoothing. It carefully tunes sampling bias and radius parameters for faster convergence and higher path quality while maintaining rigorous collision checking and map-bound enforcement.",
        "planning_mechanism": "The planner grows two trees from start and goal nodes alternately extending the smaller tree. Sampling is adaptively biased toward start and goal to accelerate connection. Each extension rewires neighbors within a dynamically shrinking radius to locally optimize path cost. Upon connection, the combined path undergoes iterative shortcut smoothing to improve path length and smoothness. Periodic pruning of dead-end nodes reduces computational overhead and maintains tree efficiency, resulting in faster, more reliable, and smoother path generation.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=6.0,\n                 goal_sample_rate: float=0.12, radius_constant: float=25.0,\n                 radius_min: float=6.0, prune_interval: int=150,\n                 prune_threshold: int=150, smoothing_iterations: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle rects/cuboids\n\n        import random\n        import math\n\n        is_3d = (len(bounds) == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            p_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                # Bias sampling: 75% goal, 25% start\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n <= 1:\n                return self.radius_constant\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            for d in range(len(pos)):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not can_connect(p1, p2):\n                    continue\n                path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend the smaller tree first to balance search\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -10.57241,
        "time_improvement": 23.0,
        "length_improvement": 18.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.007777166366577148,
                "num_nodes_avg": 80.3,
                "path_length_avg": 171.23724890700797,
                "success_improvement": 0.0,
                "time_improvement": 17.534931577843007,
                "length_improvement": 14.417268842547337,
                "objective_score": 8.143933241862369
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.016112327575683594,
                "num_nodes_avg": 189.3,
                "path_length_avg": 245.16595802095776,
                "success_improvement": 0.0,
                "time_improvement": -9.361067912931885,
                "length_improvement": 18.645640795144555,
                "objective_score": 0.9208077851493459
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.011360478401184083,
                "num_nodes_avg": 122.6,
                "path_length_avg": 126.91888301133925,
                "success_improvement": 0.0,
                "time_improvement": 60.79882715607561,
                "length_improvement": 22.064160108889748,
                "objective_score": 22.652480168600633
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This planner integrates a bidirectional anytime informed RRT* framework combining adaptive ellipsoidal sampling, KD-tree accelerated neighbor search, lazy collision checking with caching, dynamic neighbor radius adjustment, and incremental multi-step connection attempts. It prioritizes extending the smaller tree and aggressively prunes nodes unlikely to improve the current best solution. Path quality is enhanced through iterative shortcut smoothing of the best path, minimizing length and improving smoothness. These strategies collectively reduce search time, improve path optimality, increase success rates, and maintain robustness in both 2D and 3D environments.",
        "planning_mechanism": "The planner grows two trees rooted at start and goal, alternately extending the smaller tree by sampling within an evolving informed ellipsoidal domain biased by the current best path cost, or adaptively near the best path with Gaussian noise for focused exploration. It uses a KD-tree-based neighbor search for efficient rewiring and lazy collision checking with caching to minimize redundant computations. Incremental multi-step connection attempts link the two trees, while periodic pruning removes nodes that cannot lead to better solutions. Once a path is found, iterative shortcut smoothing refines it for minimal length and smoothness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_trials: int = 100, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)  # Householder reflection\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r2]*(dim-1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.power(np.random.uniform(0,1), 1/dim)\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size*0.5, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth)-3)\n                j = random.randint(i+2, len(smooth)-1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i+1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(nodes_list, best_cost, root_s, root_g):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialize roots and data structures\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new node for cost improvement\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Incremental multi-step connection from tree_b towards new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic aggressive pruning to maintain efficiency and focus\n            if (it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf')):\n                removed_s = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_g = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -26.86472,
        "time_improvement": 54.0,
        "length_improvement": 19.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.014759683609008789,
                "num_nodes_avg": 60.3,
                "path_length_avg": 157.31274397795977,
                "smoothness_avg": 0.037706714453848114,
                "success_improvement": 0.0,
                "time_improvement": 41.3743271550924,
                "length_improvement": 13.774392245731606,
                "smoothness_improvement": 490.1919626437174,
                "objective_score": 17.618136408892628
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.059581637382507324,
                "num_nodes_avg": 252.9,
                "path_length_avg": 231.24957894505343,
                "smoothness_avg": 0.0959050568562929,
                "success_improvement": 0.0,
                "time_improvement": 63.89609038708946,
                "length_improvement": 22.80223439807149,
                "smoothness_improvement": 2367.7061905327314,
                "objective_score": 35.5678049484048
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.021940040588378906,
                "num_nodes_avg": 117.9,
                "path_length_avg": 121.80944976052179,
                "smoothness_avg": 0.10924039422725276,
                "success_improvement": 0.0,
                "time_improvement": 57.135271200114765,
                "length_improvement": 19.099963411748654,
                "smoothness_improvement": 1289.5297512835057,
                "objective_score": 27.408222798801688
            }
        ],
        "smoothness_improvement": 1382.0,
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This planner implements a hybrid bidirectional informed RRT* algorithm enhanced with dynamically adaptive ellipsoidal sampling, efficient nearest neighbor searches via KD-tree, collision caching to avoid redundant checks, incremental rewiring for cost improvements, and aggressive pruning of non-promising nodes. It emphasizes path quality through multiple shortcut smoothing iterations and ensures nodes and edges validity through rigorous obstacle and boundary checks. The planner alternates growth between start and goal trees and progressively shrinks the ellipsoidal sampling region as better paths are found, improving efficiency, success rate, and smoothness in both 2D and 3D environments.",
        "planning_mechanism": "The planner grows two trees rooted at start and goal, alternately sampling informed points within a shrinking ellipsoid guided by the current best path cost. Nearest neighbors and radius queries utilize a KD-tree structure to accelerate rewiring and extension. Collision checks for nodes and edges are cached to reduce computation. Pruning periodically removes nodes unlikely to contribute to better paths. Upon successfully connecting the two trees, the planner applies shortcut smoothing to the final path for improved smoothness and shorter length, returning the best found solution within max iterations.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = 5.0\n        self.max_neighbor_radius = 30.0\n        self.prune_interval = 200\n        self.prune_threshold = 300\n        self.smoothing_iterations = 150\n        self.collision_check_resolution = 1.0\n        self.goal_sample_rate = 0.15\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle boxes\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                # Uniform sampling with retries for free space\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if i == 0 else 0 for i in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2)**2, 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    radius_factor = np.random.uniform(0,1) ** (1/dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    sample = rot @ (x_scaled * radii) + np.array(center)\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # Fallback uniform sampling if ellipsoid sampling fails\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            coll = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = coll\n            return not coll\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Balanced growth between two trees\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper and collision free\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connection from opposite tree to new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    smoothed_path = shortcut_path(merged_path)\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = smoothed_path\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning\n            if iteration > 0 and iteration % self.prune_interval == 0 \\\n               and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -27.14286,
        "time_improvement": 51.0,
        "length_improvement": 18.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.015091204643249511,
                "num_nodes_avg": 52.7,
                "path_length_avg": 156.05146269834086,
                "smoothness_avg": 0.04973613979534058,
                "success_improvement": 0.0,
                "time_improvement": 40.05752090033372,
                "length_improvement": 14.46572050137159,
                "smoothness_improvement": 678.4785915533056,
                "objective_score": 18.30279332814096
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.05079507827758789,
                "num_nodes_avg": 215.2,
                "path_length_avg": 237.17997973032212,
                "smoothness_avg": 0.1171984471414971,
                "success_improvement": 0.0,
                "time_improvement": 69.22036728965143,
                "length_improvement": 20.822495918826757,
                "smoothness_improvement": 2915.6004595801314,
                "objective_score": 39.508611668561436
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.02931373119354248,
                "num_nodes_avg": 130.6,
                "path_length_avg": 122.02606881850924,
                "smoothness_avg": 0.11803849126325175,
                "success_improvement": 0.0,
                "time_improvement": 42.72913340053325,
                "length_improvement": 18.956095347724464,
                "smoothness_improvement": 1401.4408961734418,
                "objective_score": 23.617163570572078
            }
        ],
        "smoothness_improvement": 1665.0,
        "success_rate": 1.0
    },
    {
        "operator": "e1",
        "algorithm_description": "This algorithm implements a Bidirectional Informed RRT* with Progressive Region Refinement and Adaptive Tree Balancing. It combines dynamic ellipsoidal informed sampling focusing on increasingly narrower corridors as the path improves, aggressive yet efficient local rewiring using KD-tree approximations, and adaptive step sizing to balance exploration and exploitation. The planner includes lazy collision checks with caching, incremental multi-step tree connection attempts, and iterative post-processing shortcut smoothing to optimize path quality and smoothness. It prunes unpromising nodes periodically to maintain manageable tree sizes, enhancing robustness and reducing planning time while improving success rate and path optimality.",
        "planning_mechanism": "The planner alternately grows two RRT* trees from start and goal, using an adapting informed ellipsoid that shrinks with the current best path cost to bias sampling. Adaptive step sizes allow faster exploration early on, slowing near solutions for refinement. KD-trees accelerate neighbor queries for rewiring. Multi-step incremental connections attempt to link the trees with lazy collision checks to reduce overhead. Periodic pruning removes nodes unlikely to improve the solution, preventing bloated search. Upon connection, iterative shortcut smoothing refines the path for smoothness and shortened length.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...] (2D or 3D)\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from root\n        self.children = []\n        self.valid = True                 # For marking validity / pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, \n                 step_size: float = 5.0,\n                 min_step_size: float = 1.0,\n                 max_step_size: float = 10.0,\n                 neighbor_min_radius: float = 5.0,\n                 neighbor_max_radius: float = 30.0,\n                 pruning_interval: int = 250,\n                 pruning_threshold: int = 400,\n                 shortcut_trials: int = 150,\n                 collision_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_step_size = min_step_size\n        self.max_step_size = max_step_size\n        self.neighbor_min_radius = neighbor_min_radius\n        self.neighbor_max_radius = neighbor_max_radius\n        self.pruning_interval = pruning_interval\n        self.pruning_threshold = pruning_threshold\n        self.shortcut_trials = shortcut_trials\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                new_p = to_p\n            else:\n                ratio = step / d\n                new_p = tuple(from_p[d] + ratio*(to_p[d]-from_p[d]) for d in range(dim))\n            # clamp inside bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        # Radius function with decay and node-count dependence\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.neighbor_max_radius\n            r_iter = self.neighbor_max_radius * (1 - (iteration/self.max_iter)**0.95)\n            r_nodes = self.neighbor_min_radius + (self.neighbor_max_radius-self.neighbor_min_radius)*math.sqrt(math.log(n_nodes + 1)/n_nodes)\n            return max(self.neighbor_min_radius, min(r_iter, r_nodes))\n\n        # KD-tree brute force wrapper\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(p, pt)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius*radius\n                result = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0\n                    for d in range(dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(n)\n                return result\n\n        node_collision_cache = {}\n        edge_collision_cache = {}\n\n        def is_in_obstacle_cached(pos):\n            if pos in node_collision_cache:\n                return node_collision_cache[pos]\n            val = self._is_in_obstacle(pos, obstacles, is_3d)\n            node_collision_cache[pos] = val\n            return val\n\n        def is_edge_colliding_cached(a, b):\n            key = (a, b) if a < b else (b, a)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            val = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n            edge_collision_cache[key] = val\n            return val\n\n        # Adaptive ellipsoidal informed sampling with progressive narrowing\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min*1.00001:\n                # Uniform sampling fallback\n                for _ in range(25):\n                    sp = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(sp):\n                        return sp\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            unit_vec = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            I = np.eye(dim)\n            u = unit_vec - I[:,0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = I - 2 * np.outer(u, u)\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r2]*(dim-1))\n\n            for _ in range(200):\n                x_ball = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if 1e-10 < norm_x <= 1.0:\n                    x_ball = x_ball / norm_x * (random.uniform(0,1) ** (1.0/dim))\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle_cached(p):\n                        return p\n            # Fallback uniform\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle_cached(p):\n                    return p\n            return p\n\n        # Adaptive step size decreases as iterations progress and path improves\n        def adaptive_step(iteration, c_best, c_min):\n            if c_best == float('inf'):\n                return self.max_step_size\n            ratio = max(0.0, min(1.0, (c_best - c_min) / c_best))  # normalized gap\n            decayed = self.min_step_size + (self.max_step_size - self.min_step_size) * (ratio ** 1.5)\n            # also decay with iteration\n            iter_decay = self.min_step_size + (decayed - self.min_step_size) * (1 - iteration/self.max_iter)\n            return max(self.min_step_size, min(self.max_step_size, iter_decay))\n\n        # Shortcut smoothing with lazy collision checking\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(self.shortcut_trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if not is_edge_colliding_cached(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        # Prune nodes unlikely to improve cost using heuristic\n        def prune_tree(tree_nodes, best_cost, root_start, root_goal):\n            h = lambda pos: dist(pos, goal)\n            to_remove = []\n            for node in tree_nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + h(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    tree_nodes.remove(node)\n                except ValueError:\n                    pass\n            return len(to_remove)\n\n        # Initialize roots and trees\n        root_start = Node(start, cost=0.0)\n        root_goal = Node(goal, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        all_nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start, goal)\n        c_best = float('inf')\n        best_path = []\n        success = False\n\n        for iter_id in range(self.max_iter):\n            step = adaptive_step(iter_id, c_best, c_min)\n\n            # Alternate tree with fewer nodes to balance growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n                grow_from_start = True\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n                grow_from_start = False\n\n            # Build KD-tree for near queries in tree_a\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n\n            q_rand = informed_sample(c_best, c_min, start, goal)\n\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand, step)\n\n            if is_in_obstacle_cached(new_pos) or is_edge_colliding_cached(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(len(all_nodes), iter_id)\n            near_nodes_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n\n            # Lazy rewiring: select best parent\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and not is_edge_colliding_cached(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cheaper cost\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and not is_edge_colliding_cached(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Build KD-tree for tree_b incremental connection attempts\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            dist_b_new = dist(nearest_b.position, new_node.position)\n            max_steps = max(1, int(dist_b_new / step))\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position, step)\n                if is_in_obstacle_cached(next_pos_b) or is_edge_colliding_cached(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                all_nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                r_b = neighbor_radius(len(all_nodes), iter_id)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, r_b)\n\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    c_new = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if c_new + 1e-12 < nbr_b.cost and not is_edge_colliding_cached(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, c_new)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= step and not is_edge_colliding_cached(new_node_b.position, new_node.position):\n                    cost_conn = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_conn)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    all_nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success = True\n\n                    if grow_from_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_conn + 1e-12 < c_best:\n                        c_best = cost_conn\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                # Additional refinement through iterative shortcut smoothing\n                best_path = shortcut_path(best_path)\n                # Aggressive pruning of unpromising nodes if tree grows large\n                if len(all_nodes) > self.pruning_threshold:\n                    removed_start = prune_tree(tree_start, c_best, root_start, root_goal)\n                    removed_goal = prune_tree(tree_goal, c_best, root_start, root_goal)\n                    # Clear edge cache after pruning to avoid stale info\n                    edge_collision_cache.clear()\n                break\n\n            # Periodic pruning when trees grow large and a solution exists\n            if (iter_id > 0 and iter_id % self.pruning_interval == 0 and \n                len(all_nodes) > self.pruning_threshold and c_best < float('inf')):\n                removed_start = prune_tree(tree_start, c_best, root_start, root_goal)\n                removed_goal = prune_tree(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success else []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -27.21631,
        "time_improvement": 56.0,
        "length_improvement": 13.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.02291569709777832,
                "num_nodes_avg": 71.8,
                "path_length_avg": 167.41125213292193,
                "smoothness_avg": 0.04959706276165424,
                "success_improvement": 0.0,
                "time_improvement": 8.978525783075938,
                "length_improvement": 8.23923990489491,
                "smoothness_improvement": 676.301733965502,
                "objective_score": 7.722914385729273
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.01910278797149658,
                "num_nodes_avg": 108.4,
                "path_length_avg": 246.19192172859,
                "smoothness_avg": 0.10896772519235394,
                "success_improvement": 0.0,
                "time_improvement": 88.42453211129788,
                "length_improvement": 17.814050285437038,
                "smoothness_improvement": 2703.8180554792834,
                "objective_score": 43.609259967873186
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.015497398376464844,
                "num_nodes_avg": 82.1,
                "path_length_avg": 130.51260754238822,
                "smoothness_avg": 0.11377552512159901,
                "success_improvement": 0.0,
                "time_improvement": 69.72239974511233,
                "length_improvement": 13.319740412871662,
                "smoothness_improvement": 1347.2162815110482,
                "objective_score": 30.316749413663274
            }
        ],
        "smoothness_improvement": 1576.0,
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This enhanced bidirectional informed RRT* planner integrates adaptive ellipsoidal sampling focused on the current best path to minimize unnecessary exploration, employs a KD-tree for efficient nearest neighbor and radius queries, caches collision checks to reduce redundant computations, incrementally rewires for path cost improvement, prunes nodes unlikely to improve the solution periodically, and applies shortcut-based path smoothing to produce shorter and smoother paths quickly. The planner ensures valid node states and collision-free edges throughout, balances bidirectional growth with dynamic radius adjustment, and carefully manages adding/removing nodes and edges to maintain robustness and efficiency in both 2D and 3D environments.",
        "planning_mechanism": "The planner grows start and goal trees alternately, samples within an adaptive ellipsoid around the best known path to bias towards promising regions, uses KD-tree for fast neighbor lookups, adds new nodes after collision tests, rewires neighbors to minimize path cost, attempts to connect trees incrementally checking collisions, prunes nodes that cannot yield better solutions to reduce search space, and smooths the final path by shortcutting segments while preserving feasibility. This combination achieves faster convergence to shorter, smooth, and feasible paths with efficient computation.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start root\n        self.children = []\n        self.valid = True               # Collision valid flag\n    \n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n    \n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n    \n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_radius: float = 5.0, max_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_iters: int = 100, collision_res: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iters = smoothing_iters\n        self.collision_res = collision_res\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n        \n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # clamp inside bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def radius(it, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_radius * (1.0 - (it / self.max_iter) ** 0.9)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_res)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n        \n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # Uniform random sampling fallback\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            \n            center = np.array([(start[d]+goal[d])/2 for d in range(dim)])\n            a1 = np.array([(goal[d]-start[d])/c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            v = a1 - np.array([1.] + [0.]*(dim-1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_mat - 2*np.outer(v,v)\n            else:\n                rot = id_mat\n            \n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r_others]*(dim-1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1,1,dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            \n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback\n\n        edge_collision_cache = {}\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n        \n        def prune_nodes(best_cost_val):\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost_val:\n                    to_remove.append(node)\n            for rm in to_remove:\n                if rm.parent:\n                    try:\n                        rm.parent.children.remove(rm)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm)\n                except ValueError:\n                    pass\n                if rm in tree_start:\n                    tree_start.remove(rm)\n                if rm in tree_goal:\n                    tree_goal.remove(rm)\n            return len(to_remove)\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growing smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors for better cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n\n            max_step_cnt = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            connected = False\n            for _ in range(max_step_cnt):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Compose path from start to goal depending on which tree is which\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Prune unpromising nodes to reduce search space periodically\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -26.86188,
        "time_improvement": 56.0,
        "length_improvement": 17.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.011800003051757813,
                "num_nodes_avg": 54.4,
                "path_length_avg": 153.69296191885746,
                "smoothness_avg": 0.0361555731901661,
                "success_improvement": 0.0,
                "time_improvement": 53.13022034842096,
                "length_improvement": 15.758452151442883,
                "smoothness_improvement": 465.9132335099274,
                "objective_score": 21.4203227023645
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.04355149269104004,
                "num_nodes_avg": 199.2,
                "path_length_avg": 236.42757570091013,
                "smoothness_avg": 0.09479691689277514,
                "success_improvement": 0.0,
                "time_improvement": 73.60966860426899,
                "length_improvement": 21.07367004059368,
                "smoothness_improvement": 2339.192951110466,
                "objective_score": 37.99359934495176
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.03035130500793457,
                "num_nodes_avg": 153.4,
                "path_length_avg": 127.34649230063846,
                "smoothness_avg": 0.10026194584538484,
                "success_improvement": 0.0,
                "time_improvement": 40.70200314137881,
                "length_improvement": 15.422523402235353,
                "smoothness_improvement": 1175.3245505862683,
                "objective_score": 21.171728375792057
            }
        ],
        "smoothness_improvement": 1327.0,
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "This improved planner implements a bidirectional informed RRT* with enhanced path shortening and rewiring strategies to minimize path length while efficiently using heuristic insights. It includes adaptive neighbor radius, KD-tree accelerated nearest neighbor and radius search for rewiring, collision caching for reducing redundant checks, and aggressive shortcut smoothing applied immediately upon path improvement and periodically through search. Periodic pruning removes nodes unlikely to improve the solution, increasing efficiency and robustness in both 2D and 3D environments. The planner balances exploration and exploitation by sampling within an ellipsoidal informed domain defined by the current best path cost, ensuring fast convergence with higher quality and smoother paths.",
        "planning_mechanism": "The planner grows two trees from start and goal alternatively, biased towards informed sampling within an ellipsoid constrained by the best path found. KD-trees accelerate neighbor searches to rewire the tree for lower cost paths efficiently. Collision checks on edges and nodes are cached to avoid repeated costly computations. When a connection between trees is made, it shortcuts the path aggressively to reduce unnecessary segments. Periodic pruning discards nodes that cannot contribute to better solutions, improving computation time. This combined approach yields shorter, smoother paths with improved planning performance and success rates.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_iterations: int = 150,\n                 collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle tuples\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                # Uniform sampling with rejection inside obstacles\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) * (c_min / 2), 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    radius_factor = np.random.uniform(0, 1) ** (1 / dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Balance tree extension: smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            # Find best parent for new_node minimizing cost + collision free edges\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node to improve paths where possible\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt to connect opposite tree to new_node incrementally\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                # Rewire neighbors of new_node_b on opposite tree side\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n\n            # Periodic aggressive shortcut smoothing to improve best path found so far\n            if success_state and it % (self.prune_interval // 4) == 0 and best_path:\n                best_path = shortcut_path(best_path)\n                extracted_path = best_path\n\n            # Periodic pruning of nodes unlikely to improve solution\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n            if connected and it > 50:\n                # After initial convergence, allow early termination for efficiency\n                break\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -26.64886,
        "time_improvement": 54.0,
        "length_improvement": 17.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.019661450386047365,
                "num_nodes_avg": 78.5,
                "path_length_avg": 161.7334849982918,
                "smoothness_avg": 0.04865967656128557,
                "success_improvement": 0.0,
                "time_improvement": 21.90443992408831,
                "length_improvement": 11.351314041363377,
                "smoothness_improvement": 661.6296043630177,
                "objective_score": 12.149742807314258
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.04556558132171631,
                "num_nodes_avg": 214.0,
                "path_length_avg": 238.2034281214635,
                "smoothness_avg": 0.09430069377697495,
                "success_improvement": 0.0,
                "time_improvement": 72.38921752120298,
                "length_improvement": 20.480839387535188,
                "smoothness_improvement": 2326.424772925863,
                "objective_score": 37.44505699849725
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.017021965980529786,
                "num_nodes_avg": 112.2,
                "path_length_avg": 121.44569662679608,
                "smoothness_avg": 0.10943981553903548,
                "success_improvement": 0.0,
                "time_improvement": 66.74381925333563,
                "length_improvement": 19.3415509231064,
                "smoothness_improvement": 1292.0663756496317,
                "objective_score": 30.351787838870127
            }
        ],
        "smoothness_improvement": 1427.0,
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This planner is an enhanced Bidirectional Informed RRT* algorithm integrating dynamic ellipsoidal informed sampling, adaptive step sizing, incremental multi-step tree connection, KD-tree accelerated neighbor searches, lazy collision checking with caching, heuristic-based pruning to remove unpromising nodes, and iterative shortcut smoothing for path refinement. It balances exploration and exploitation efficiently to quickly find and improve a collision-free, minimal-length, and smooth path in 2D or 3D environments.",
        "planning_mechanism": "The planner alternately grows two RRT* trees rooted at start and goal within a gradually shrinking informed ellipsoid guided by the current best path cost. Adaptive step size scales down as solutions approach optimality. New nodes are connected and rewired through efficient radius-based neighbors queried via KD-trees. Lazy collision checks with caching limit expensive computations. Incremental multi-step attempts bridge the trees when possible. Periodic pruning discards nodes unlikely to yield better paths. Finally, shortcut smoothing iteratively improves the final path smoothness and length.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision and pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, \n                 step_size: float=5.0,\n                 min_step_size: float=1.0,\n                 max_step_size: float=10.0,\n                 neighbor_min_radius: float=5.0,\n                 neighbor_max_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=400,\n                 smoothing_trials: int=150,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_step_size = min_step_size\n        self.max_step_size = max_step_size\n        self.neighbor_min_radius = neighbor_min_radius\n        self.neighbor_max_radius = neighbor_max_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                new_p = to_p\n            else:\n                ratio = step / d\n                new_p = tuple(from_p[d] + ratio*(to_p[d]-from_p[d]) for d in range(dim))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.neighbor_max_radius\n            r_iter = self.neighbor_max_radius * (1 - (iteration/self.max_iter)**0.95)\n            r_nodes = self.neighbor_min_radius + (self.neighbor_max_radius - self.neighbor_min_radius) * math.sqrt(math.log(n_nodes + 1)/n_nodes)\n            return max(self.neighbor_min_radius, min(r_iter, r_nodes))\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_dist = float('inf')\n                best_node = None\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(p, pt)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius**2\n                result = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0\n                    for d in range(dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(n)\n                return result\n\n        node_collision_cache = {}\n        edge_collision_cache = {}\n\n        def is_in_obstacle_cached(pos):\n            if pos in node_collision_cache:\n                return node_collision_cache[pos]\n            val = self._is_in_obstacle(pos, obstacles, is_3d)\n            node_collision_cache[pos] = val\n            return val\n\n        def is_edge_in_obstacle_cached(a, b):\n            key = (a, b) if a < b else (b, a)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            val = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = val\n            return val\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min*1.00001:\n                for _ in range(25):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            unit_vec = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            I = np.eye(dim)\n            v = unit_vec - I[:,0]\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = I - 2 * np.outer(v, v)\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1**2 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r_others]*(dim-1))\n\n            for _ in range(200):\n                x_ball = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if 1e-10 < norm_x <= 1.0:\n                    x_ball = x_ball / norm_x * (random.uniform(0,1) ** (1.0/dim))\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle_cached(p):\n                        return p\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle_cached(p):\n                    return p\n            return p\n\n        def adaptive_step(iteration, c_best, c_min):\n            if c_best == float('inf'):\n                return self.max_step_size\n            ratio = max(0.0, min(1.0, (c_best - c_min) / c_best))\n            decayed = self.min_step_size + (self.max_step_size - self.min_step_size) * (ratio ** 1.5)\n            iter_decay = self.min_step_size + (decayed - self.min_step_size) * (1 - iteration / self.max_iter)\n            return max(self.min_step_size, min(self.max_step_size, iter_decay))\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if not is_edge_in_obstacle_cached(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        def prune_tree(tree_nodes, best_cost):\n            h = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in tree_nodes:\n                if node.position == start_pos or node.position == goal_pos:\n                    continue\n                if node.cost + h(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    tree_nodes.remove(node)\n                except ValueError:\n                    pass\n            return len(to_remove)\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        all_nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success = False\n\n        for iter_id in range(self.max_iter):\n            step = adaptive_step(iter_id, c_best, c_min)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n                grow_from_start = True\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n                grow_from_start = False\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand, step)\n\n            if is_in_obstacle_cached(new_pos) or is_edge_in_obstacle_cached(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(len(all_nodes), iter_id)\n            near_nodes_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n\n            for nbr in near_nodes_a:\n                cost_candidate = nbr.cost + dist(nbr.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and not is_edge_in_obstacle_cached(nbr.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = nbr\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire for cheaper paths\n            for nbr in near_nodes_a:\n                if nbr is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_via_new + 1e-12 < nbr.cost and not is_edge_in_obstacle_cached(new_node.position, nbr.position):\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                    except ValueError:\n                        pass\n                    nbr.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, nbr))\n\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = max(1, int(dist(nearest_b.position, new_node.position) / step))\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position, step)\n                if is_in_obstacle_cached(next_pos_b) or is_edge_in_obstacle_cached(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                all_nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                r_b = neighbor_radius(len(all_nodes), iter_id)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, r_b)\n\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if cost_via_new_b + 1e-12 < nbr_b.cost and not is_edge_in_obstacle_cached(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= step and not is_edge_in_obstacle_cached(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    all_nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success = True\n\n                    if grow_from_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                # Further smooth path\n                best_path = shortcut_path(best_path)\n                # Prune unpromising nodes if too large\n                if len(all_nodes) > self.prune_threshold:\n                    prune_tree(tree_start, c_best)\n                    prune_tree(tree_goal, c_best)\n                    edge_collision_cache.clear()\n                break\n\n            # Periodic pruning\n            if (iter_id > 0 and iter_id % self.prune_interval == 0 and \n                len(all_nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_tree(tree_start, c_best)\n                prune_tree(tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success else []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -27.34324,
        "time_improvement": 57.0,
        "length_improvement": 12.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.019286251068115233,
                "num_nodes_avg": 62.3,
                "path_length_avg": 170.0446530578725,
                "smoothness_avg": 0.04756445407772096,
                "success_improvement": 0.0,
                "time_improvement": 23.394736941789684,
                "length_improvement": 6.7958311290214946,
                "smoothness_improvement": 644.4869941815424,
                "objective_score": 11.600022279248918
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.018376803398132323,
                "num_nodes_avg": 116.1,
                "path_length_avg": 248.60570602124525,
                "smoothness_avg": 0.10081996030792365,
                "success_improvement": 0.0,
                "time_improvement": 88.86444753773773,
                "length_improvement": 17.008259611620097,
                "smoothness_improvement": 2494.1701964050562,
                "objective_score": 42.53183716567062
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.02121129035949707,
                "num_nodes_avg": 95.7,
                "path_length_avg": 130.93253720566926,
                "smoothness_avg": 0.12927711153915894,
                "success_improvement": 0.0,
                "time_improvement": 58.559046183485584,
                "length_improvement": 13.04084312542214,
                "smoothness_improvement": 1544.3953165343232,
                "objective_score": 27.897859062801718
            }
        ],
        "smoothness_improvement": 1561.0,
        "success_rate": 1.0
    }
]