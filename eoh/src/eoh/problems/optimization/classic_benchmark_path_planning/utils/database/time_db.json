[
    {
        "operator": "m1",
        "algorithm_description": "This algorithm is an improved RRT* variant that combines bidirectional tree growth with goal biasing and adaptive rewiring. It incrementally builds two trees from start and goal, samples the space with increased focus near the goal, rewires neighbors within a dynamic radius to optimize the path cost, and performs shortcut smoothing to improve path quality and reduce length.",
        "planning_mechanism": "The planner grows two trees progressively closer, rewiring nodes within a radius that shrinks over iterations to balance exploration and exploitation, uses goal-biased sampling to enhance success rate, connects the trees when possible, and finally extracts and smooths the path to provide a high-quality solution efficiently.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_radius_constant: float=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_constant = neighbor_radius_constant  # Used to scale rewiring radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        dim = len(bounds)\n        free_space_volume = 1\n        for b in bounds:\n            free_space_volume *= b\n        # Neighbor radius shrink function: r = r0 * (log(n)/n)^(1/d)\n        def neighbor_radius(n):\n            if n <= 1:\n                return self.neighbor_radius_constant\n            return min(self.neighbor_radius_constant,\n                       self.neighbor_radius_constant * (math.log(n) / n) ** (1.0 / dim))\n\n        def sample():\n            # Goal biasing sampling with probability\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def collision_free(from_pos, to_pos):\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n                return False\n            return True\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and collision_free(new_node.position, neighbor.position):\n                    # Remove edge from old parent\n                    if neighbor.parent:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        if neighbor in neighbor.parent.children:\n                            neighbor.parent.children.remove(neighbor)\n                    # Rewire\n                    neighbor.parent = new_node\n                    neighbor.cost = potential_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n        def extend(tree_a, point):\n            nearest_node = nearest(tree_a, point)\n            new_pos = steer(nearest_node.position, point)\n            if not collision_free(nearest_node.position, new_pos):\n                return None\n            new_node = Node(new_pos)\n            neighbors = near_nodes(tree_a, new_pos, neighbor_radius(len(tree_a)))\n            # Choose best parent minimizing cost + collision check\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                c = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if c < min_cost and collision_free(neighbor.position, new_pos):\n                    min_cost = c\n                    best_parent = neighbor\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n            return new_node\n\n        def connect_trees(new_node_a, tree_b):\n            nearest_node_b = nearest(tree_b, new_node_a.position)\n            current_node = nearest_node_b\n            while True:\n                next_pos = steer(current_node.position, new_node_a.position)\n                if not collision_free(current_node.position, next_pos):\n                    return None\n                new_node_b = Node(next_pos)\n                neighbors = near_nodes(tree_b, next_pos, neighbor_radius(len(tree_b)))\n\n                min_cost = current_node.cost + math.dist(current_node.position, next_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    c = neighbor.cost + math.dist(neighbor.position, next_pos)\n                    if c < min_cost and collision_free(neighbor.position, next_pos):\n                        min_cost = c\n                        best_parent = neighbor\n\n                best_parent.add_child(new_node_b)\n                new_node_b.cost = min_cost\n                new_node_b.parent = best_parent\n\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((best_parent, new_node_b))\n\n                rewire(tree_b, new_node_b, neighbors)\n\n                if math.dist(new_node_b.position, new_node_a.position) <= self.step_size:\n                    return new_node_b\n\n                current_node = new_node_b\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            full_path = path_start + path_goal[::-1][1:]  # remove duplicate connection node\n\n            # Perform simple shortcut smoothing on path\n            smooth_path = [full_path[0]]\n            i = 0\n            while i < len(full_path) - 1:\n                j = len(full_path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(smooth_path[-1], full_path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smooth_path.append(full_path[j])\n                i = j\n            return smooth_path\n\n        for iter_num in range(self.max_iter):\n            rnd = sample()\n            new_node_start = extend(tree_start, rnd)\n            if not new_node_start:\n                continue\n            new_node_goal = connect_trees(new_node_start, tree_goal)\n            if new_node_goal:\n                success_state = True\n                extracted_path = extract_path(new_node_start, new_node_goal)\n                break\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 47.57608,
        "time_improvement": -144.0,
        "length_improvement": 27.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.023780679702758788,
                "num_nodes_avg": 76.3,
                "path_length_avg": 157.68258133234144,
                "success_improvement": 0.0,
                "time_improvement": -199.68812345263564,
                "length_improvement": 21.191761415721647,
                "objective_score": -55.66808475264636
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.0432955265045166,
                "num_nodes_avg": 280.9,
                "path_length_avg": 243.4860629831869,
                "success_improvement": 0.0,
                "time_improvement": -210.2902906665801,
                "length_improvement": 19.203086802055434,
                "objective_score": -59.246469839562934
            },
            {
                "map_id": 2,
                "success_rate": 0.4,
                "time_avg": 0.034473729133605954,
                "num_nodes_avg": 182.5,
                "path_length_avg": 94.76986278983743,
                "success_improvement": -60.0,
                "time_improvement": -20.58264296710426,
                "length_improvement": 41.80559521445381,
                "objective_score": -27.813673847240516
            }
        ]
    }
]