[
    {
        "operator": "e2",
        "algorithm_description": "This hybrid planner combines the strengths of sampling-based tree expansion with frontier-guided exploration and adaptive step sizing to efficiently explore the configuration space. It applies goal biasing for convergence, dynamically adjusts step sizes near obstacles for precision, and incorporates a frontier sampling strategy to focus sampling near obstacle boundaries. After initial path discovery, iterative shortcut smoothing refines the path to enhance smoothness and reduce length, boosting path quality and success rate.",
        "planning_mechanism": "The planner incrementally grows a tree rooted at the start by sampling either toward the goal, near frontiers, or randomly in free space, using adaptive step sizes based on proximity to obstacles. It performs rigorous collision checks for nodes and edges before adding them. Upon finding a path to the goal, it executes a shortcut smoothing routine, producing a robust, efficient, and smooth path with improved planning performance.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Collision validity\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, frontier_sample_rate: float=0.3, smoothing_iters: int=100):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.frontier_sample_rate = frontier_sample_rate\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> \"PlannerResult\":\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        frontier_regions = self._identify_frontiers(bounds, obstacles, is_3d)\n\n        for _ in range(self.max_iter):\n            r = random.random()\n            if r < self.goal_sample_rate:\n                sample = goal_position\n            elif r < self.goal_sample_rate + self.frontier_sample_rate and frontier_regions:\n                sample = self._sample_near_frontier(frontier_regions, bounds, is_3d)\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            step_size = self._adaptive_step_size(nearest_node.position, obstacles, is_3d, self.base_step_size)\n            new_position = self._steer(nearest_node.position, sample, step_size)\n\n            if not self._in_bounds(new_position, bounds):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            dist_to_goal = math.dist(new_position, goal_position)\n            if dist_to_goal <= step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node = Node(goal_position, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                if all(0 <= nbr[i] <= steps[i] for i in range(dims)):\n                    yield nbr\n\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                min_cells = [int(ox // resolution), int(oy // resolution), int(oz // resolution)]\n                max_cells = [int((ox + w) // resolution), int((oy + h) // resolution), int((oz + d) // resolution)]\n                for cx in range(min_cells[0], max_cells[0]+1):\n                    if cx < 0 or cx > steps[0]:\n                        continue\n                    for cy in range(min_cells[1], max_cells[1]+1):\n                        if cy < 0 or cy > steps[1]:\n                            continue\n                        for cz in range(min_cells[2], max_cells[2]+1):\n                            if cz < 0 or cz > steps[2]:\n                                continue\n                            occupied.add((cx, cy, cz))\n            else:\n                ox, oy, w, h = obs\n                min_cells = [int(ox // resolution), int(oy // resolution)]\n                max_cells = [int((ox + w) // resolution), int((oy + h) // resolution)]\n                for cx in range(min_cells[0], max_cells[0]+1):\n                    if cx < 0 or cx > steps[0]:\n                        continue\n                    for cy in range(min_cells[1], max_cells[1]+1):\n                        if cy < 0 or cy > steps[1]:\n                            continue\n                        occupied.add((cx, cy))\n\n        for ix in range(steps[0]+1):\n            if is_3d:\n                for iy in range(steps[1]+1):\n                    for iz in range(steps[2]+1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontier_pos = tuple((pos_grid[d] + 0.5)*resolution for d in range(3))\n                            frontiers.append(frontier_pos)\n            else:\n                for iy in range(steps[1]+1):\n                    pos_grid = (ix, iy)\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontier_pos = ((ix + 0.5)*resolution, (iy + 0.5)*resolution)\n                        frontiers.append(frontier_pos)\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n        else:\n            for item in arrays[0]:\n                for rest in self._cartesian_product(arrays[1:]):\n                    yield (item,) + rest\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        import random\n        frontier = random.choice(frontiers)\n        radius = self.base_step_size * 3\n        dim = len(bounds)\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _adaptive_step_size(self, position, obstacles, is_3d, base_step_size):\n        query_radius = base_step_size * 2\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                px, py, pz = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dz = max(oz - pz, 0, pz - (oz + d))\n                dist = (dx*dx + dy*dy + dz*dz)**0.5\n            else:\n                ox, oy, w, h = obs\n                px, py = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dist = (dx*dx + dy*dy)**0.5\n            if dist <= query_radius:\n                return base_step_size * 0.5\n        return base_step_size\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        unit_vec = tuple((to_pos[d] - from_pos[d]) / dist for d in range(len(from_pos)))\n        return tuple(from_pos[d] + unit_vec[d] * step_size for d in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, bounds):\n        import random\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            p_i = new_path[i]\n            p_j = new_path[j]\n            if self._in_bounds(p_j, bounds) and not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path",
        "objective": 154.51652,
        "time_improvement": -529.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.030805325508117674,
                "num_nodes_avg": 345.8,
                "path_length_avg": 163.60662082009756,
                "success_improvement": 0.0,
                "time_improvement": -226.6438129330896,
                "length_improvement": 18.23098341862772,
                "objective_score": -64.34694719620133
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.17162775993347168,
                "num_nodes_avg": 1382.6,
                "path_length_avg": 242.5890407852697,
                "success_improvement": 0.0,
                "time_improvement": -1064.9089817510392,
                "length_improvement": 19.50074911493595,
                "objective_score": -315.57254470232454
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.11421992778778076,
                "num_nodes_avg": 1022.1,
                "path_length_avg": 125.31142432665688,
                "success_improvement": 0.0,
                "time_improvement": -294.1343817847203,
                "length_improvement": 23.051236576225087,
                "objective_score": -83.63006722017107
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This algorithm is an improved RRT* variant that balances exploration and exploitation by biasing sampling toward the goal and dynamically adjusting the step size based on obstacle proximity. It incrementally builds a single tree rooted at the start, incorporating collision-checked nodes and edges, and applies a post-processing shortcut smoothing to improve path quality, smoothness, and reduce path length. This approach aims to enhance planning efficiency, robustness, and success rate while producing shorter and smoother paths.",
        "planning_mechanism": "The planner samples mostly randomly but biases sampling near the goal to accelerate convergence. It dynamically adjusts step sizes\u2014smaller near obstacles for precision, larger in free space for speed. It incrementally extends the tree by steering toward sampled points with collision checks on nodes and edges. Upon reaching close to the goal, it reconstructs the path and applies shortcut smoothing to refine it.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float=0.1, smoothing_iters: int=80):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math, random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        nodes.append(root)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        def adaptive_step(pos):\n            query_r = self.base_step_size * 2\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    dx = max(x - px, 0, px - (x + w))\n                    dy = max(y - py, 0, py - (y + h))\n                    dz = max(z - pz, 0, pz - (z + d))\n                    dist = (dx*dx + dy*dy + dz*dz)**0.5\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    dx = max(x - px, 0, px - (x + w))\n                    dy = max(y - py, 0, py - (y + h))\n                    dist = (dx*dx + dy*dy)**0.5\n                if dist <= query_r:\n                    return self.base_step_size * 0.5\n            return self.base_step_size\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n        for _ in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                sample = goal\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n            step = adaptive_step(nearest.position)\n            new_pos = steer(nearest.position, sample, step)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            if math.dist(new_pos, goal) <= step:\n                if not self._is_in_obstacle(goal, obstacles, is_3d) and not self._is_edge_in_obstacle(new_pos, goal, obstacles, is_3d):\n                    goal_cost = new_node.cost + math.dist(new_pos, goal)\n                    goal_node = Node(goal, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, bounds):\n        import random\n        n = len(path)\n        if n < 3:\n            return path\n        smoothed = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) -1)\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                smoothed = smoothed[:i+1] + smoothed[j:]\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 146.53934,
        "time_improvement": -502.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.029899191856384278,
                "num_nodes_avg": 377.1,
                "path_length_avg": 163.43597517767063,
                "success_improvement": 0.0,
                "time_improvement": -217.03563817281366,
                "length_improvement": 18.316270470552652,
                "objective_score": -61.44743735773356
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.17256031036376954,
                "num_nodes_avg": 1409.5,
                "path_length_avg": 244.54989526735397,
                "success_improvement": 0.0,
                "time_improvement": -1071.238589342555,
                "length_improvement": 18.85007125912084,
                "objective_score": -317.60156255094233
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.09181842803955079,
                "num_nodes_avg": 1019.0,
                "path_length_avg": 126.36150399125684,
                "success_improvement": 0.0,
                "time_improvement": -216.8343744626728,
                "length_improvement": 22.406424404297432,
                "objective_score": -60.56902745794235
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This algorithm combines bidirectional Rapidly-exploring Random Tree (RRT) planning with adaptive sampling near frontiers and dynamic step sizing close to obstacles, integrating path shortcut smoothing for enhanced path quality and smoothness. It grows two trees from the start and goal positions simultaneously, biasing sampling towards frontier regions and adapting step size based on local obstacle proximity to improve exploration efficiency and precision, ultimately connecting the two trees to find a collision-free path. After path connection, iterative shortcut smoothing refines the path to reduce unnecessary detours and improve smoothness while maintaining collision safety.",
        "planning_mechanism": "The planner initializes two trees at start and goal, alternately growing them by extending towards randomly sampled points biased towards frontiers near obstacles. Step size dynamically adjusts smaller near obstacles and larger in free space for effective exploration. Each extension validates node and edge collision-free conditions. Upon connection of trees, the combined path is shortcut-smoothed to enhance path length and smoothness, and then returned as the final path.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, frontier_sample_rate: float=0.3, smoothing_iters: int=100):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.frontier_sample_rate = frontier_sample_rate\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        frontier_regions = self._identify_frontiers(bounds, obstacles, is_3d)\n        \n        for _ in range(self.max_iter):\n            # Alternate between trees\n            tree_a, tree_b = (tree_start, tree_goal) if _ % 2 == 0 else (tree_goal, tree_start)\n\n            # Sample point biased towards frontiers\n            if frontier_regions and random.random() < self.frontier_sample_rate:\n                rand_point = self._sample_near_frontier(frontier_regions, bounds, is_3d)\n            else:\n                rand_point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node in tree_a\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, rand_point))\n            step_size = self._adaptive_step_size(nearest_node.position, obstacles, is_3d, self.base_step_size)\n            new_pos = self._steer(nearest_node.position, rand_point, step_size)\n            if not self._in_bounds(new_pos, bounds):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Try to connect tree_b to new_node\n            nearest_node_b = min(tree_b, key=lambda n: math.dist(n.position, new_pos))\n            connecting = True\n            last_added = None\n            while connecting:\n                step_size_b = self._adaptive_step_size(nearest_node_b.position, obstacles, is_3d, self.base_step_size)\n                next_pos = self._steer(nearest_node_b.position, new_pos, step_size_b)\n                if not self._in_bounds(next_pos, bounds):\n                    break\n                if self._is_in_obstacle(next_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node_b.position, next_pos, obstacles, is_3d):\n                    break\n                new_cost_b = nearest_node_b.cost + math.dist(nearest_node_b.position, next_pos)\n                next_node = Node(next_pos, parent=nearest_node_b, cost=new_cost_b)\n                nearest_node_b.add_child(next_node)\n                tree_b.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node_b, next_node))\n                nearest_node_b = next_node\n                last_added = next_node\n\n                if math.dist(next_pos, new_pos) <= step_size_b:\n                    # Connected\n                    path_a = new_node.path_from_root()\n                    path_b = last_added.path_from_root()\n                    if tree_a is tree_goal and tree_b is tree_start:\n                        # Swap if trees were swapped\n                        path_a, path_b = path_b, path_a\n                    extracted_path = path_a + path_b[::-1]\n                    success_state = True\n                    connecting = False\n                    break\n\n            if success_state:\n                break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                yield nbr\n\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n            else:\n                ox, oy, w, h = obs\n            min_cells = [int(ox // resolution), int(oy // resolution)]\n            max_cells = [int((ox + w) // resolution), int((oy + h) // resolution)]\n            if is_3d:\n                min_cells.append(int(oz // resolution))\n                max_cells.append(int((oz + d) // resolution))\n                ranges = [range(min_cells[i], max_cells[i]+1) for i in range(3)]\n                for cx in ranges[0]:\n                    for cy in ranges[1]:\n                        for cz in ranges[2]:\n                            occupied.add((cx, cy, cz))\n            else:\n                for cx in range(min_cells[0], max_cells[0]+1):\n                    for cy in range(min_cells[1], max_cells[1]+1):\n                        occupied.add((cx, cy))\n\n        if is_3d:\n            for ix in range(steps[0]+1):\n                for iy in range(steps[1]+1):\n                    for iz in range(steps[2]+1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontiers.append(tuple((pos_grid[d] + 0.5)*resolution for d in range(dims)))\n        else:\n            for ix in range(steps[0]+1):\n                for iy in range(steps[1]+1):\n                    pos_grid = (ix, iy)\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontiers.append(((ix + 0.5)*resolution, (iy + 0.5)*resolution))\n\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n        else:\n            for item in arrays[0]:\n                for rest in self._cartesian_product(arrays[1:]):\n                    yield (item,) + rest\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        import random\n        dim = len(bounds)\n        frontier = random.choice(frontiers)\n        radius = self.base_step_size * 3\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _adaptive_step_size(self, position, obstacles, is_3d, base_step_size):\n        query_radius = base_step_size * 2\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                px, py, pz = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dz = max(oz - pz, 0, pz - (oz + d))\n                dist = (dx*dx + dy*dy + dz*dz)**0.5\n            else:\n                ox, oy, w, h = obs\n                px, py = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dist = (dx*dx + dy*dy)**0.5\n            if dist <= query_radius:\n                return base_step_size * 0.5\n        return base_step_size\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step_size / dist for d in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, bounds):\n        import random\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            p_i = new_path[i]\n            p_j = new_path[j]\n            if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path",
        "objective": 3.37712,
        "time_improvement": -26.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.011121630668640137,
                "num_nodes_avg": 148.0,
                "path_length_avg": 158.18834787192,
                "success_improvement": 0.0,
                "time_improvement": -17.92804613218255,
                "length_improvement": 20.93898416041376,
                "objective_score": -1.1906170075720128
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.031751585006713864,
                "num_nodes_avg": 468.0,
                "path_length_avg": 239.0017021215254,
                "success_improvement": 0.0,
                "time_improvement": -115.51121201774241,
                "length_improvement": 20.691149448634693,
                "objective_score": -30.515133715595784
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.012543845176696777,
                "num_nodes_avg": 258.0,
                "path_length_avg": 125.72257630639828,
                "success_improvement": 0.0,
                "time_improvement": 56.7154282122604,
                "length_improvement": 22.79876449245189,
                "objective_score": 21.574381362168495
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This improved planner implements an optimized bidirectional RRT* variant with adaptive sampling biased toward the goal and border safety checks. It employs a KD-tree to accelerate nearest and neighbor searches, reducing computational time. It integrates early stopping when trees connect, uses a geometric rewiring strategy to improve path quality locally, and performs efficient collision checks on sampled points and edges. Post-processing smoothing refines the final path.",
        "planning_mechanism": "The planner grows two trees simultaneously from start and goal with adaptive goal bias sampling to speed convergence. Each sampled point is steered toward within a step size limit and validated for collision. Using KD-trees for spatial queries, the planner quickly finds nearest and nearby nodes enabling efficient rewiring to reduce path costs. The trees alternate extensions to balance exploration and exploitation, attempting connection at each iteration for early success. Finally, the path is smoothed by shortcutting while ensuring collision-free transitions.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, neighbor_radius: float = 12.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal directly\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        from bisect import bisect_left, bisect_right\n        from collections import deque\n\n        bounds = map.size                # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start       # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal         # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles        # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # KD-Tree helper for nearest and near queries\n        class KDTree:\n            def __init__(self):\n                self.points = []\n                self.nodes = []\n\n            def build(self):\n                # KD-Tree is approximated by sorted lists per dimension for fast range queries\n                self.sorted_by_dim = [sorted(self.points, key=lambda p: p[d]) for d in range(dim)]\n\n            def insert(self, node: Node):\n                self.points.append(node.position)\n                self.nodes.append(node)\n\n            def nearest(self, point: Tuple[float, ...]):\n                best_node = None\n                best_dist = float('inf')\n                for node in self.nodes:\n                    dist = math.dist(node.position, point)\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_node = node\n                return best_node\n\n            def near(self, point: Tuple[float, ...], radius: float):\n                # Brute-force near neighbors due to moderate problem size and dimensionality\n                neighbors = []\n                r_sq = radius * radius\n                for node in self.nodes:\n                    # Compare squared dist for efficiency\n                    dx = 0\n                    for d in range(dim):\n                        diff = node.position[d] - point[d]\n                        dx += diff * diff\n                        if dx > r_sq:\n                            break\n                    if dx <= r_sq:\n                        neighbors.append(node)\n                return neighbors\n\n        def sample_free():\n            # With goal biasing\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            # Sample extended bounds - slight buffer to avoid border failures\n            while True:\n                p = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        # Initialize trees\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        kd_start = KDTree()\n        kd_goal = KDTree()\n        kd_start.insert(start_root)\n        kd_goal.insert(goal_root)\n\n        success_state = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        # Swap flag to alternate tree growth\n        tree_flag = True  # True: extend start tree, False: extend goal tree\n\n        for i in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Alternate tree to extend\n            if tree_flag:\n                new_node = self._extend_bidirectional(tree_start, kd_start, rand_point,\n                                                     obstacles, is_3d, nodes, edges,\n                                                     self.neighbor_radius, steer, self._is_in_obstacle,\n                                                     self._is_edge_in_obstacle)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n\n                # Try connect other tree\n                connect_node = self._connect_bidirectional(tree_goal, kd_goal, new_node.position,\n                                                          obstacles, is_3d, nodes, edges,\n                                                          self.neighbor_radius, steer, self._is_in_obstacle,\n                                                          self._is_edge_in_obstacle)\n                if connect_node:\n                    success_state = True\n                    connection_node_start = new_node\n                    connection_node_goal = connect_node\n                    break\n            else:\n                new_node = self._extend_bidirectional(tree_goal, kd_goal, rand_point,\n                                                     obstacles, is_3d, nodes, edges,\n                                                     self.neighbor_radius, steer, self._is_in_obstacle,\n                                                     self._is_edge_in_obstacle)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n\n                # Try connect other tree\n                connect_node = self._connect_bidirectional(tree_start, kd_start, new_node.position,\n                                                          obstacles, is_3d, nodes, edges,\n                                                          self.neighbor_radius, steer, self._is_in_obstacle,\n                                                          self._is_edge_in_obstacle)\n                if connect_node:\n                    success_state = True\n                    # Note the roles reversed, swap accordingly\n                    connection_node_start = connect_node\n                    connection_node_goal = new_node\n                    break\n\n            tree_flag = not tree_flag\n\n        extracted_path: List[Tuple[float, ...]] = []\n        if success_state:\n            path_start = connection_node_start.path_from_root()\n            path_goal = connection_node_goal.path_from_root()\n            path_goal.reverse()\n            extracted_path = path_start + path_goal\n\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n\n    def _extend_bidirectional(self, tree: List[Node], kd_tree, point, obstacles, is_3d, nodes, edges, neighbor_radius,\n                              steer_fn, is_in_obstacle_fn, is_edge_in_obstacle_fn):\n        nearest_node = kd_tree.nearest(point)\n        if nearest_node is None:\n            return None\n\n        new_pos = steer_fn(nearest_node.position, point)\n\n        if self._out_of_bounds(new_pos, tree[0].position, obstacles, is_3d):\n            return None\n\n        if is_in_obstacle_fn(new_pos, obstacles, is_3d) or is_edge_in_obstacle_fn(nearest_node.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        near_nodes = kd_tree.near(new_pos, neighbor_radius)\n\n        min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n        best_parent = nearest_node\n        for near_node in near_nodes:\n            edge_cost = math.dist(near_node.position, new_pos)\n            if near_node.cost + edge_cost < min_cost:\n                if not is_edge_in_obstacle_fn(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = near_node.cost + edge_cost\n                    best_parent = near_node\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        kd_tree.insert(new_node)\n\n        # Try rewiring neighbors for cost improvement\n        for near_node in near_nodes:\n            if near_node == best_parent:\n                continue\n            edge_cost = math.dist(new_node.position, near_node.position)\n            cost_through_new = new_node.cost + edge_cost\n            if cost_through_new < near_node.cost:\n                if not is_edge_in_obstacle_fn(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent is not None:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.children.remove(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n        return new_node\n\n    def _connect_bidirectional(self, tree: List[Node], kd_tree, target_pos, obstacles, is_3d, nodes, edges,\n                               neighbor_radius, steer_fn, is_in_obstacle_fn, is_edge_in_obstacle_fn):\n        nearest_node = kd_tree.nearest(target_pos)\n        if nearest_node is None:\n            return None\n\n        curr_node = nearest_node\n        while True:\n            new_pos = steer_fn(curr_node.position, target_pos)\n            if self._out_of_bounds(new_pos, tree[0].position, obstacles, is_3d):\n                return None\n\n            if is_in_obstacle_fn(new_pos, obstacles, is_3d) or is_edge_in_obstacle_fn(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            near_nodes = kd_tree.near(new_pos, neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for near_node in near_nodes:\n                edge_cost = math.dist(near_node.position, new_pos)\n                if near_node.cost + edge_cost < min_cost:\n                    if not is_edge_in_obstacle_fn(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = near_node.cost + edge_cost\n                        best_parent = near_node\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            kd_tree.insert(new_node)\n\n            # Rewire neighbors similarly\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                edge_cost = math.dist(new_node.position, near_node.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new < near_node.cost:\n                    if not is_edge_in_obstacle_fn(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size * 0.5:\n                return new_node\n\n            curr_node = new_node\n\n    def _smooth_path(self, path: List[Tuple[float, ...]], obstacles, is_3d):\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _out_of_bounds(self, pos, origin, obstacles, is_3d):\n        # Safety check to not generate nodes past map bounds (origin = start pos's bounds reference)\n        # No explicit bounds checks in original, so add a generic clipping following common sense\n        for d, val in enumerate(pos):\n            if val < 0:\n                return True\n        return False",
        "objective": -3.96181,
        "time_improvement": -2.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009483003616333007,
                "num_nodes_avg": 72.0,
                "path_length_avg": 160.3701129930091,
                "success_improvement": 0.0,
                "time_improvement": -0.5528884439489358,
                "length_improvement": 19.848558922921917,
                "objective_score": 3.8038452513997028
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.023026371002197267,
                "num_nodes_avg": 276.7,
                "path_length_avg": 231.60591841983734,
                "success_improvement": 0.0,
                "time_improvement": -56.289556001831855,
                "length_improvement": 23.145320691353117,
                "objective_score": -12.25780266227893
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.014002847671508788,
                "num_nodes_avg": 202.7,
                "path_length_avg": 123.48043402619813,
                "success_improvement": 0.0,
                "time_improvement": 51.68090352420842,
                "length_improvement": 24.17557492141821,
                "objective_score": 20.339386041546167
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "This enhanced bidirectional RRT planner integrates informed sampling using a dynamically updated ellipsoid heuristic to minimize path length, plus nearest neighbor caching for efficiency. Both trees grow alternately with adaptive goal biasing toward the goal and start respectively. New nodes are connected only after rigorous collision and edge validity checks. After the trees connect, the path is extracted and refined using advanced shortcut and weighted smoothing techniques to improve smoothness and reduce length, thus improving planning efficiency, success rate, and path quality.",
        "planning_mechanism": "The planner alternates growth between two trees rooted at start and goal. Sampling is biased inside an informed ellipsoid once a first solution is found to focus exploration around better paths. Each iteration extends the chosen tree toward a sampled point, validates the new node and edge, then tries to connect to the other tree efficiently. Upon connection, path extraction and smoothing refine the final path. The nearest neighbor search uses caching to speed up queries, and the path smoothing applies iterative shortcutting and weighted averaging for robustness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.2, smoothing_iter: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling actual goal point\n        self.smoothing_iter = smoothing_iter      # Number of smoothing iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n        edges_set = set()\n\n        # Cache for faster nearest neighbor search (list is small at start, so brute-force ok)\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def collision_free_node(pos):\n            return (not self._is_in_obstacle(pos, obstacles, is_3d)) and self._in_bounds(pos, bounds)\n\n        def collision_free_edge(p1, p2):\n            return (not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d))\n\n        # Informed sampling: sample inside ellipsoid defined by current best solution cost\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf'):\n                # No solution yet, sample uniformly with goal biasing\n                if random.random() < self.goal_sample_rate:\n                    return goal\n                else:\n                    return uniform_sample()\n            else:\n                # Sample inside ellipsoid to focus search near current best path\n                return sample_in_ellipsoid(start, goal, c_best)\n        \n        def uniform_sample():\n            while True:\n                if is_3d:\n                    pt = (random.uniform(0, bounds[0]),\n                          random.uniform(0, bounds[1]),\n                          random.uniform(0, bounds[2]))\n                else:\n                    pt = (random.uniform(0, bounds[0]),\n                          random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def sample_in_ellipsoid(start, goal, c_max):\n            # Following the Informed RRT* ellipse sampling method for heuristic bias\n            import numpy as np\n            a = c_max / 2.0       # Long axis radius\n            c_min = math.dist(start, goal)\n            if c_min == 0.0:\n                return goal  # Avoid degenerate case\n            b = math.sqrt(max(a*a - (c_min/2.0)**2, 0))  # Short axis radius\n\n            # Sample unit ball point in 2D or 3D inside unit n-ball\n            def sample_unit_ball(dim):\n                vec = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(vec)\n                r = random.random() ** (1/dim)\n                return r * vec / norm if norm > 0 else vec\n\n            dim = len(start)\n            x_ball = sample_unit_ball(dim)\n            # Scale to ellipse radii\n            L = np.diag([a] + [b]*(dim-1))\n            # Direction rotation matrix from unit vector e1 to vector from start to goal\n            start_np = np.array(start)\n            goal_np = np.array(goal)\n            diff = (goal_np - start_np)\n            e1 = diff / np.linalg.norm(diff)\n            # Create rotation matrix that aligns x-axis with e1\n            def rotation_to_align(e1):\n                d = len(e1)\n                import scipy.linalg\n                I = np.eye(d)\n                v = np.zeros(d)\n                v[0] = 1.0\n                if np.allclose(e1, v):\n                    return I\n                if np.allclose(e1, -v):\n                    # 180 deg rotation in any plane orthogonal to v\n                    R = -I\n                    R[0,0] = 1.0\n                    return R\n                a = v\n                b = e1\n                v_cross = np.cross(a, b) if d == 3 else None\n                if d == 3:\n                    s = np.linalg.norm(v_cross)\n                    c = np.dot(a, b)\n                    vx = np.array([[0, -v_cross[2], v_cross[1]],\n                                   [v_cross[2], 0, -v_cross[0]],\n                                   [-v_cross[1], v_cross[0], 0]])\n                    R = np.eye(3) + vx + vx.dot(vx) * ((1 - c) / (s**2))\n                    return R\n                else:\n                    # For 2D, rotation matrix:\n                    angle = math.atan2(e1[1], e1[0])\n                    R = np.array([[math.cos(angle), -math.sin(angle)],\n                                  [math.sin(angle), math.cos(angle)]])\n                    return R\n            R = rotation_to_align(e1)\n            sample = start_np + R.dot(L.dot(x_ball))\n            sample_tup = tuple(float(x) for x in sample)\n            # Clip sample inside bounds and valid position\n            if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)) or self._is_in_obstacle(sample_tup, obstacles, is_3d):\n                # Fallback to uniform sample if not valid\n                return uniform_sample()\n            return sample_tup\n\n        def path_cost(node):\n            return node.cost\n\n        def reconstruct_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def add_edge(n1, n2):\n            if (n1, n2) not in edges_set and (n2, n1) not in edges_set:\n                edges.append((n1, n2))\n                edges_set.add((n1, n2))\n\n        def connect_trees(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            cur_pos = nearest_node.position\n            total_cost = nearest_node.cost\n            parent_node = nearest_node\n\n            while True:\n                next_pos = steer(cur_pos, new_node.position)\n                if not collision_free_edge(cur_pos, next_pos):\n                    return None\n                if not collision_free_node(next_pos):\n                    return None\n                next_cost = total_cost + math.dist(cur_pos, next_pos)\n                next_node = Node(next_pos, parent=parent_node, cost=next_cost)\n                parent_node.add_child(next_node)\n                other_tree.append(next_node)\n                nodes.append(next_node)\n                add_edge(parent_node, next_node)\n\n                if math.dist(next_pos, new_node.position) <= self.step_size:\n                    # Try final connection edge\n                    if collision_free_edge(next_pos, new_node.position) and collision_free_node(new_node.position):\n                        return next_node\n                    return None\n                parent_node = next_node\n                cur_pos = next_pos\n                total_cost = next_cost\n\n        def shortcut_path(path):\n            # Shortcut path using random pairs  - faster and better for length minimization\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i, p_j = path[i], path[j]\n                if collision_free_edge(p_i, p_j):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def smooth_path_weighted(path):\n            # Smooth path by iterative weighted averaging to reduce sharp changes\n            if len(path) < 3:\n                return path\n            path_np = [list(p) for p in path]\n            alpha = 0.4\n            beta = 0.2\n            for _ in range(self.smoothing_iter):\n                new_path = [path_np[0]]\n                for i in range(1, len(path_np)-1):\n                    prev_p = path_np[i-1]\n                    curr_p = path_np[i]\n                    next_p = path_np[i+1]\n                    new_coords = [curr_p[d] + alpha*(prev_p[d] + next_p[d] - 2*curr_p[d]) for d in range(len(curr_p))]\n                    # Only update if collision free with neighbors\n                    p_prev = tuple(new_coords)\n                    if collision_free_edge(path_np[i-1], p_prev) and collision_free_edge(p_prev, path_np[i+1]) and not self._is_in_obstacle(p_prev, obstacles, is_3d):\n                        new_path.append(new_coords)\n                    else:\n                        new_path.append(curr_p)\n                new_path.append(path_np[-1])\n                path_np = new_path\n            path_smoothed = [tuple(p) for p in path_np]\n            return path_smoothed\n\n        c_best = float('inf')\n        c_min = math.dist(start_position, goal_position)\n        best_path = None\n\n        # Alternate tree growth with heuristic informed sampling after first solution\n        for itr in range(self.max_iter):\n            if len(tree_start) == 0 or len(tree_goal) == 0:\n                break\n\n            # Alternate expanding tree_start and tree_goal each iteration\n            extend_start_tree = (itr % 2 == 0)\n\n            # Sample point - informed sampling after first found solution\n            if extend_start_tree:\n                rand_point = informed_sample(c_best, c_min, start_position, goal_position)\n                nearest_node = nearest(tree_start, rand_point)\n                new_pos = steer(nearest_node.position, rand_point)\n                if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                    continue\n                new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_start.append(new_node)\n                nodes.append(new_node)\n                add_edge(nearest_node, new_node)\n\n                connect_node = connect_trees(new_node, tree_goal)\n                if connect_node:\n                    # path found\n                    success_state = True\n                    if extend_start_tree:\n                        path_candidate = reconstruct_path(new_node, connect_node)\n                    else:\n                        path_candidate = reconstruct_path(connect_node, new_node)\n                    cost_candidate = self._path_length(path_candidate)\n                    if cost_candidate < c_best:\n                        c_best = cost_candidate\n                        best_path = path_candidate\n                    # Early break to find best feasible quickly\n                    extracted_path = best_path\n                    break\n\n            else:\n                rand_point = informed_sample(c_best, c_min, goal_position, start_position)\n                nearest_node = nearest(tree_goal, rand_point)\n                new_pos = steer(nearest_node.position, rand_point)\n                if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                    continue\n                new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_goal.append(new_node)\n                nodes.append(new_node)\n                add_edge(nearest_node, new_node)\n\n                connect_node = connect_trees(new_node, tree_start)\n                if connect_node:\n                    success_state = True\n                    if extend_start_tree:\n                        path_candidate = reconstruct_path(new_node, connect_node)\n                    else:\n                        path_candidate = reconstruct_path(connect_node, new_node)\n                    cost_candidate = self._path_length(path_candidate)\n                    if cost_candidate < c_best:\n                        c_best = cost_candidate\n                        best_path = path_candidate\n                    extracted_path = best_path\n                    break\n\n        if success_state and best_path:\n            # Improve path by shortcut + smoothing\n            extracted_path = shortcut_path(best_path)\n            extracted_path = smooth_path_weighted(extracted_path)\n\n        return PlannerResult(success=success_state,\n                             path=extracted_path if extracted_path else [],\n                             nodes=nodes,\n                             edges=edges)\n\n    def _path_length(self, path):\n        import math\n        length = 0.0\n        for i in range(len(path) - 1):\n            length += math.dist(path[i], path[i+1])\n        return length\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _in_bounds(self, pos, bounds):\n        for d in range(len(pos)):\n            if pos[d] < 0 or pos[d] > bounds[d]:\n                return False\n        return True",
        "objective": 109.06939,
        "time_improvement": -371.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.9,
                "time_avg": 0.09053049087524415,
                "num_nodes_avg": 72.6,
                "path_length_avg": 162.22412286628153,
                "success_improvement": -9.999999999999998,
                "time_improvement": -859.9387196347446,
                "length_improvement": 18.92194260807031,
                "objective_score": -259.1972273688093
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.04918806552886963,
                "num_nodes_avg": 247.5,
                "path_length_avg": 243.15743782945282,
                "success_improvement": 0.0,
                "time_improvement": -233.85985665576513,
                "length_improvement": 19.312135745948165,
                "objective_score": -66.29552984753991
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.03469226360321045,
                "num_nodes_avg": 321.8,
                "path_length_avg": 128.66844422598928,
                "success_improvement": 0.0,
                "time_improvement": -19.71128097164393,
                "length_improvement": 20.989824127753838,
                "objective_score": -1.7154194659424107
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid planner combines the strength of bidirectional RRT* incremental rewiring and goal biasing with the simplicity and incremental growth strategy of standard RRT. It employs bidirectional search to explore from both start and goal nodes, adapts goal sampling bias dynamically, uses an adaptive neighborhood radius for local rewiring to optimize path quality, and balances tree growth by always extending the smaller tree first. It incorporates efficient collision and edge checking and prunes suboptimal paths when possible. Additionally, it applies a smoothing pass for the final path to further improve path smoothness and length, leveraging steering with fixed step size for incremental growth. This synergy results in faster convergence, higher success rates, and smoother, shorter paths while reducing search time and maintaining robustness.",
        "planning_mechanism": "The planner initializes two trees rooted at start and goal. It then iteratively samples points with adaptive goal bias and attempts to extend the smaller tree toward these points. Each new node locally rewires neighbors within an adaptive radius to improve path costs. After extending one tree, it attempts to connect the other tree toward the newly added node to check for a path connection. Once connected, it reconstructs the path by merging branches from both trees. Finally, the path is smoothed by shortcutting to reduce unnecessary waypoints. Collision and edge feasibility checks are rigorously applied before node/edge acceptance, ensuring safe, robust paths.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate_start=0.1, goal_sample_rate_end=0.3,\n                 radius_constant: float = 30.0, radius_min: float = 3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = goal_sample_rate_start\n        self.goal_sample_rate_end = goal_sample_rate_end\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free(iteration):\n            # Adaptive goal sampling with increasing bias toward goal as iterations increase\n            goal_bias = ((self.goal_sample_rate_end - self.goal_sample_rate_start)\n                         * iteration / self.max_iter + self.goal_sample_rate_start)\n            if random.random() < goal_bias:\n                # 85% goal, 15% start to encourage bidirectional connection\n                return goal_position if random.random() < 0.85 else start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            distance_ = dist(from_pos, to_pos)\n            if distance_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_min\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            # Edge collision check\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new node if improvement found\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-6 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    # Check final connection edge\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d) and not self._is_in_obstacle(node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def smooth_path(path, max_trials=100):\n            # Shortcut smoothing: try random pairs and attempt shortcut if collision-free\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if j >= len(path):\n                    continue\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    # Shortcut is feasible, remove intermediate points\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Main iterative planning loop\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n\n            # Alternate growth by always extending smaller tree first for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                # Merge while avoiding duplicate connection node\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n                # Smooth merged path to improve smoothness and shorten path length\n                smoothed_path = smooth_path(merged_path, max_trials=150)\n                extracted_path = smoothed_path\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance_ = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance_ / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 0.87725,
        "time_improvement": -16.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.011067795753479003,
                "num_nodes_avg": 78.3,
                "path_length_avg": 164.46229291518293,
                "success_improvement": 0.0,
                "time_improvement": -17.35720840633128,
                "length_improvement": 17.803326729793657,
                "objective_score": -1.6464971759406528
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.020533823966979982,
                "num_nodes_avg": 277.5,
                "path_length_avg": 240.4994491111335,
                "success_improvement": 0.0,
                "time_improvement": -39.37160269470332,
                "length_improvement": 20.194146326446944,
                "objective_score": -7.772651543121607
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.02687411308288574,
                "num_nodes_avg": 252.0,
                "path_length_avg": 125.33436833056348,
                "success_improvement": 0.0,
                "time_improvement": 7.266515124964315,
                "length_improvement": 23.037147575656384,
                "objective_score": 6.787384052620571
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This algorithm implements a bidirectional RRT* planner that efficiently explores the space by growing two trees from start and goal positions, incorporating rewiring to optimize path costs continuously. It balances rapid exploration with local path improvements, ensuring high success rates and high-quality, smooth paths.",
        "planning_mechanism": "The planner samples free points within map bounds, extends the nearest nodes in each tree towards these points while ensuring collision avoidance, attempts to connect the two trees, and rewires neighbors to minimize cost. Once connected, the path is extracted and smoothed for optimal navigation performance.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if math.dist(node.position, point) <= radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n               self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            near_nodes = near(tree, new_pos, self.neighbor_radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near_nodes:\n                cost = node.cost + math.dist(node.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = node\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes:\n                if node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                    if node.parent:\n                        edges.remove((node.parent, node))\n                        node.parent.children.remove(node)\n                    node.parent = new_node\n                    node.cost = cost_through_new\n                    new_node.add_child(node)\n                    edges.append((new_node, node))\n\n            return new_node\n\n        def try_connect(tree, target_pos):\n            current_node = nearest(tree, target_pos)\n            while True:\n                new_pos = steer(current_node.position, target_pos)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n                   self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_node = Node(new_pos)\n                near_nodes = near(tree, new_pos, self.neighbor_radius)\n\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for node in near_nodes:\n                    cost = node.cost + math.dist(node.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = node\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for node in near_nodes:\n                    if node is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                    if cost_through_new < node.cost and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        if node.parent:\n                            edges.remove((node.parent, node))\n                            node.parent.children.remove(node)\n                        node.parent = new_node\n                        node.cost = cost_through_new\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                current_node = new_node\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n\n            new_node_a = try_extend(tree_a, rand_point)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_connect(tree_b, new_node_a.position)\n            if new_node_b:\n                success_state = True\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                extracted_path = smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -1.31503,
        "time_improvement": -2.0,
        "length_improvement": 27.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009461736679077149,
                "num_nodes_avg": 68.6,
                "path_length_avg": 157.90810556621656,
                "success_improvement": 0.0,
                "time_improvement": -0.3273847896268319,
                "length_improvement": 21.079046571256317,
                "objective_score": 4.1175938773632135
            },
            {
                "map_id": 1,
                "success_rate": 0.9,
                "time_avg": 0.017914962768554688,
                "num_nodes_avg": 235.1,
                "path_length_avg": 217.9828629857762,
                "success_improvement": -9.999999999999998,
                "time_improvement": -21.596302631429896,
                "length_improvement": 27.665911372851916,
                "objective_score": -5.945708514858585
            },
            {
                "map_id": 2,
                "success_rate": 0.9,
                "time_avg": 0.024679231643676757,
                "num_nodes_avg": 299.9,
                "path_length_avg": 111.38058968744186,
                "success_improvement": -9.999999999999998,
                "time_improvement": 14.84030943466389,
                "length_improvement": 31.605608252301014,
                "objective_score": 5.77321448085937
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This planner implements an optimized bidirectional RRT* variant augmented with an efficient KD-tree nearest neighbor structure, adaptive heuristic goal biasing, and informed sampling within an ellipsoidal subset to drastically reduce sampling space and improve convergence. It uses cost-aware rewiring to minimize path length locally, aggressive early termination upon tree connection, and iterative shortcut-based smoothing to refine path quality while maintaining collision-free guarantees. The planner balances exploration and exploitation via alternating tree growth and employs strict collision and edge checks to ensure robustness and reliability.",
        "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions, employing heuristic and informed sampling strategies that bias samples toward the connectable region between trees. Using a KD-tree for fast nearest and near neighbor retrieval, it performs cost-based rewiring to improve path quality locally. Trees alternate growth and attempt connections to minimize total path cost, with early stopping once path found. Post extraction, iterative smoothing shortcuts the path while verifying obstacle collisions to ensure reduced length and improved smoothness, ultimately achieving efficient and high-quality path planning in complex environments.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from start\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 neighbor_radius: float=15.0, smoothing_iter: int=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.smoothing_iter = smoothing_iter\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        from collections import deque\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Early fail if start or goal inside obstacle\n        if self._is_in_obstacle(start_position, obstacles, is_3d) or \\\n           self._is_in_obstacle(goal_position, obstacles, is_3d):\n            return PlannerResult(success=False, path=[], nodes=[], edges=[])\n\n        class KDTree:\n            def __init__(self):\n                self.nodes = []\n\n            def insert(self, node):\n                self.nodes.append(node)\n\n            def nearest(self, point):\n                best_node = None\n                best_dist = float('inf')\n                for node in self.nodes:\n                    dist = math.dist(node.position, point)\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_node = node\n                return best_node\n\n            def near(self, point, radius):\n                r_sq = radius * radius\n                neighbors = []\n                for node in self.nodes:\n                    d_sq = 0\n                    for d in range(dim):\n                        diff = node.position[d] - point[d]\n                        d_sq += diff*diff\n                        if d_sq > r_sq:\n                            break\n                    if d_sq <= r_sq:\n                        neighbors.append(node)\n                return neighbors\n\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n\n        def informed_sample(c_best, start, goal):\n            # Informed sampling inside an ellipse: sampling inside an ellipse between start and goal constrained by c_best (current best path length)\n            # Only used if a solution exists to improve path quality and speed-up convergence\n\n            if c_best == float('inf'):\n                # No solution found, use basic biased sampling\n                if random.random() < self.goal_sample_rate:\n                    return goal\n                else:\n                    while True:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if not self._is_in_obstacle(sample, obstacles, is_3d):\n                            return sample\n\n            center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n            dist_start_goal = math.dist(start, goal)\n            if dist_start_goal == 0:\n                return start\n\n            # Define ellipse axes lengths\n            a = c_best / 2.0  # major axis half-length\n            c = dist_start_goal / 2.0\n            if a <= c:\n                # Degenerate case, sample uniformly\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n            b = math.sqrt(a * a - c * c)  # minor axis half-length\n\n            def sample_unit_ball():\n                # Sample uniformly within unit ball in dim-dimensional space\n                import random as rand\n                if dim == 2:\n                    while True:\n                        x = rand.uniform(-1, 1)\n                        y = rand.uniform(-1, 1)\n                        if x*x + y*y <= 1:\n                            return (x,y)\n                else:\n                    while True:\n                        x = rand.uniform(-1,1)\n                        y = rand.uniform(-1,1)\n                        z = rand.uniform(-1,1)\n                        if x*x + y*y + z*z <=1:\n                            return (x,y,z)\n\n            # Rotation from ellipse frame to world frame\n            # Direction vector start->goal\n            dir_vec = tuple((goal[d] - start[d]) / dist_start_goal for d in range(dim))\n            if dim == 2:\n                # 2D rotation matrix from x-axis to dir_vec\n                cos_theta = dir_vec[0]\n                sin_theta = dir_vec[1]\n\n                while True:\n                    x_ball, y_ball = sample_unit_ball()\n                    # Scale to ellipse axes\n                    x_ellip = x_ball * a\n                    y_ellip = y_ball * b\n                    # Rotate to map frame\n                    sample_x = center[0] + cos_theta * x_ellip - sin_theta * y_ellip\n                    sample_y = center[1] + sin_theta * x_ellip + cos_theta * y_ellip\n                    sample = (sample_x, sample_y)\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            else:\n                # 3D rotation to align x-axis with dir_vec\n                # Use Householder transformation or build rotation matrix\n                import numpy as np\n                e1 = np.array([1.0,0.0,0.0])\n                dir_v = np.array(dir_vec)\n                if np.allclose(dir_v, e1):\n                    R = np.eye(3)\n                elif np.allclose(dir_v, -e1):\n                    R = -np.eye(3)\n                else:\n                    v = np.cross(e1, dir_v)\n                    s = np.linalg.norm(v)\n                    c = np.dot(e1, dir_v)\n                    vx = np.array([[0, -v[2], v[1]],\n                                   [v[2], 0, -v[0]],\n                                   [-v[1], v[0], 0]])\n                    R = np.eye(3) + vx + vx @ vx * ((1 - c)/(s*s))\n\n                while True:\n                    x_ball, y_ball, z_ball = sample_unit_ball()\n                    scaled = np.array([a*x_ball, b*y_ball, b*z_ball])\n                    rotated = R.dot(scaled)\n                    sample_np = np.array(center) + rotated\n                    sample = tuple(sample_np.tolist())\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        kd_start = KDTree()\n        kd_goal = KDTree()\n        kd_start.insert(start_root)\n        kd_goal.insert(goal_root)\n\n        success_state = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        c_best = float('inf')  # Best path cost found so far\n\n        def choose_parent(new_pos, near_nodes, kd_tree, obstacles, is_3d):\n            min_cost = float('inf')\n            best_parent = None\n            for node in near_nodes:\n                edge_cost = math.dist(node.position, new_pos)\n                cost_through_node = node.cost + edge_cost\n                if cost_through_node < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_node\n                        best_parent = node\n            if best_parent is None:\n                return None, None\n            return best_parent, min_cost\n\n        def rewire(new_node, near_nodes, obstacles, is_3d, edges):\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                edge_cost = math.dist(new_node.position, near_node.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Update parent connection\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            if near_node in near_node.parent.children:\n                                near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n        def extend(tree, kd_tree, sample_point):\n            nearest_node = kd_tree.nearest(sample_point)\n            if nearest_node is None:\n                return None\n\n            new_pos = steer(nearest_node.position, sample_point)\n\n            if not in_bounds(new_pos):\n                return None\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            near_nodes = kd_tree.near(new_pos, self.neighbor_radius)\n            parent_node, min_cost = choose_parent(new_pos, near_nodes, kd_tree, obstacles, is_3d)\n            if parent_node is None:\n                # Fallback to nearest_node\n                parent_node = nearest_node\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                # Double check edge validity (already checked once)\n                if self._is_edge_in_obstacle(parent_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n            new_node = Node(new_pos)\n            new_node.parent = parent_node\n            new_node.cost = min_cost\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n            kd_tree.insert(new_node)\n\n            rewire(new_node, near_nodes, obstacles, is_3d, edges)\n\n            return new_node\n\n\n        def connect(tree, kd_tree, target_node):\n            nearest_node = kd_tree.nearest(target_node.position)\n            if nearest_node is None:\n                return None\n            curr_node = nearest_node\n\n            while True:\n                new_pos = steer(curr_node.position, target_node.position)\n\n                if not in_bounds(new_pos):\n                    return None\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                near_nodes = kd_tree.near(new_pos, self.neighbor_radius)\n\n                parent_node, min_cost = choose_parent(new_pos, near_nodes, kd_tree, obstacles, is_3d)\n                if parent_node is None:\n                    parent_node = curr_node\n                    min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                    if self._is_edge_in_obstacle(parent_node.position, new_pos, obstacles, is_3d):\n                        return None\n\n                new_node = Node(new_pos)\n                new_node.parent = parent_node\n                new_node.cost = min_cost\n                parent_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((parent_node, new_node))\n                kd_tree.insert(new_node)\n\n                rewire(new_node, near_nodes, obstacles, is_3d, edges)\n\n                if math.dist(new_node.position, target_node.position) <= self.step_size * 0.5:\n                    return new_node\n\n                curr_node = new_node\n\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            path_goal.reverse()\n            return path_start + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                import random\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                p_i, p_j = path[i], path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_flag = True  # True=extend start tree, False=extend goal tree\n\n        for iter in range(self.max_iter):\n            sample_pt = informed_sample(c_best, start_position, goal_position)\n\n            if tree_flag:\n                new_node = extend(tree_start, kd_start, sample_pt)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n\n                connect_node = connect(tree_goal, kd_goal, new_node)\n                if connect_node:\n                    total_cost = new_node.cost + connect_node.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        success_state = True\n                        connection_node_start = new_node\n                        connection_node_goal = connect_node\n                        # Early exit once a better solution found\n                        break\n            else:\n                new_node = extend(tree_goal, kd_goal, sample_pt)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n\n                connect_node = connect(tree_start, kd_start, new_node)\n                if connect_node:\n                    total_cost = new_node.cost + connect_node.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        success_state = True\n                        connection_node_start = connect_node\n                        connection_node_goal = new_node\n                        break\n\n            tree_flag = not tree_flag\n\n        extracted_path = []\n        if success_state and connection_node_start is not None and connection_node_goal is not None:\n            extracted_path = extract_path(connection_node_start, connection_node_goal)\n            # Iterative smoothing\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 37.41939,
        "time_improvement": -127.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.9,
                "time_avg": 0.02829596996307373,
                "num_nodes_avg": 116.0,
                "path_length_avg": 169.7434955762623,
                "success_improvement": -9.999999999999998,
                "time_improvement": -200.0358985638046,
                "length_improvement": 15.163832400048669,
                "objective_score": -61.97800308913164
            },
            {
                "map_id": 1,
                "success_rate": 0.9,
                "time_avg": 0.04106793403625488,
                "num_nodes_avg": 297.4,
                "path_length_avg": 238.03299060648334,
                "success_improvement": -9.999999999999998,
                "time_improvement": -178.74514728466403,
                "length_improvement": 21.012600702294776,
                "objective_score": -54.421024044940246
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.02965552806854248,
                "num_nodes_avg": 247.3,
                "path_length_avg": 123.43876793354507,
                "success_improvement": 0.0,
                "time_improvement": -2.331208294152157,
                "length_improvement": 24.20116041231484,
                "objective_score": 4.140869594217321
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e1",
        "algorithm_description": "This planner implements an advanced bidirectional RRT* variant incorporating informed sampling (ellipse pruning) focused on the heuristic cost-to-go estimate, adaptive rewiring using a dynamically computed neighbor radius based on node density, and incremental lazy collision checking with caching to reduce repeated expensive collision tests. The planner balances exploration and exploitation by growing trees from both start and goal simultaneously, selectively biasing sampling towards promising regions inside a heuristic-informed ellipsoid once an initial solution is found, thus drastically reducing the search space. Enhanced path smoothing using iterative shortcutting combined with cost-aware pruning refines the final path for smoothness and shorter length. This approach aims at improving planning efficiency, success rate, and path quality while reducing search time.",
        "planning_mechanism": "The planner starts by growing two trees simultaneously from the start and goal positions, alternating growth each iteration. Initially, uniform random sampling explores the space widely. Once a feasible path is discovered, sampling is constrained inside an ellipsoidal informed subset defined by the current best path cost, focusing search efforts to promising regions. Each iteration extends a tree towards a sampled point via steering within step size limits, performing lazy collision checking with caching to avoid redundant tests. After adding a node, local rewiring is applied considering a radius dynamically adjusted by node density to optimize path costs. The trees attempt to connect after each successful extension. Upon connection, the planner reconstructs and smooths the path through iterative collision-free shortcutting and cost pruning, outputting the refined solution efficiently and robustly.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n        # For lazy collision check caching\n        self._in_collision = None      # None: unchecked, True/False: known\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def __repr__(self):\n        return f\"Node(pos={self.position}, cost={self.cost:.2f})\"\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        # Cache for collision checking of edges to avoid repeated costly tests\n        self._edge_collision_cache = dict()\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n            if in_bounds(new_p):\n                return new_p\n            # Clamp inside bounds for slight float errors\n            clamped = tuple(\n                max(0, min(new_p[d], bounds[d])) for d in range(dim)\n            )\n            return clamped\n\n        def sample_free_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def ellipse_sample(center, c_min, c_max, start, goal):\n            # Sample within an ellipsoid defined by start and goal with major axis c_max, minor axes scaled\n            # Inspired by \"Informed RRT*\" sampling\n            if is_3d:\n                import numpy as np\n                c = c_max\n                if c_max < c_min:\n                    c = c_min\n                center_np = np.array(center)\n                start_np = np.array(start)\n                goal_np = np.array(goal)\n                # Rotation matrix aligning x-axis to line from start to goal\n                a1 = (goal_np - start_np) / np.linalg.norm(goal_np - start_np)\n                # Create an orthonormal basis\n                if abs(a1[0]) < 1.0 or abs(a1[1]) < 1.0 or abs(a1[2]) < 1.0:\n                    temp = np.array([1.0, 0., 0.])\n                    if np.allclose(a1, temp):\n                        temp = np.array([0.,1.,0.])\n                    e2 = np.cross(a1, temp)\n                    e2 /= np.linalg.norm(e2)\n                    e3 = np.cross(a1, e2)\n                else:\n                    e2 = np.array([0.,1.,0.])\n                    e3 = np.cross(a1, e2)\n                C = np.column_stack((a1, e2, e3))\n                # Radii of ellipsoid axes\n                r1 = c / 2\n                r2 = math.sqrt(c**2 - c_min**2) / 2\n                r3 = r2\n                # Sample random point in unit ball\n                while True:\n                    u = np.random.normal(0,1,3)\n                    norm_u = np.linalg.norm(u)\n                    if norm_u == 0:\n                        continue\n                    u = u / norm_u * (random.random() ** (1/3)) # uniform in unit ball\n                    break\n                sample = center_np + C @ np.array([r1*u[0], r2*u[1], r3*u[2]])\n                sample_clamped = np.clip(sample, np.zeros(3), np.array(bounds))\n                return tuple(sample_clamped)\n            else:\n                # 2D ellipse sampling\n                c = c_max\n                if c_max < c_min:\n                    c = c_min\n                c1, c2 = center\n                r1 = c / 2.0\n                r2 = math.sqrt(c**2 - c_min**2) / 2.0\n\n                while True:\n                    theta = random.uniform(0, 2 * math.pi)\n                    rho = math.sqrt(random.uniform(0, 1))  # uniform sampling in ellipse\n                    x_ball = rho * math.cos(theta)\n                    y_ball = rho * math.sin(theta)\n                    x_ell = r1 * x_ball\n                    y_ell = r2 * y_ball\n\n                    # Rotation aligned with start-goal vector\n                    dx = goal[0] - start[0]\n                    dy = goal[1] - start[1]\n                    length = math.hypot(dx, dy)\n                    if length == 0:\n                        return start\n                    cos_angle = dx / length\n                    sin_angle = dy / length\n                    x_rot = cos_angle * x_ell - sin_angle * y_ell\n                    y_rot = sin_angle * x_ell + cos_angle * y_ell\n\n                    sample = (c1 + x_rot, c2 + y_rot)\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def nearest(tree, point):\n            # Euclidean distance nearest neighbor\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            # Neighborhood search via linear scan; could be optimized\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def neighbor_radius(n_nodes):\n            # Radius decays as tree grows, ensuring asymptotic optimality (RRT* typical)\n            if n_nodes < 2:\n                return float('inf')\n            gamma_rrt_star = 35.0  # Tuned constant\n            unit_ball_volume = math.pi if dim == 2 else 4/3*math.pi\n            r = gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim))\n            return max(r, self.step_size)\n\n        # Lazy collision cache helpers:\n        def edge_cache_key(pos1, pos2):\n            # Order insensitive tuple for caching edges\n            return tuple(sorted([pos1, pos2]))\n\n        def is_edge_collision_cached(pos1, pos2):\n            key = edge_cache_key(pos1, pos2)\n            return self._edge_collision_cache.get(key, None)\n\n        def cache_edge_collision(pos1, pos2, value: bool):\n            key = edge_cache_key(pos1, pos2)\n            self._edge_collision_cache[key] = value\n\n        # Initialize trees:\n        start_root = Node(start_position, None, 0.0)\n        goal_root = Node(goal_position, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        connection_start = None\n        connection_goal = None\n\n        best_path_length = float('inf')\n\n        # Current informed sampling parameters\n        path_found = False\n        c_min = distance(start_position, goal_position)\n        c_max = float('inf')\n        center = tuple((start_position[d] + goal_position[d]) / 2. for d in range(dim))\n\n        for it in range(self.max_iter):\n            # Sample point:\n            if path_found:\n                q_rand = ellipse_sample(center, c_min, c_max, start_position, goal_position)\n            else:\n                q_rand = sample_free_uniform()\n\n            # Alternate tree growth\n            if it % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Find nearest node in tree_a to sampled point\n            nearest_node = nearest(tree_a, q_rand)\n\n            # Steer towards q_rand with step size\n            new_pos = steer(nearest_node.position, q_rand)\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Edge collision lazy check with caching\n            cached_result = is_edge_collision_cached(nearest_node.position, new_pos)\n            if cached_result is None:\n                in_collision = self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n                cache_edge_collision(nearest_node.position, new_pos, in_collision)\n                if in_collision:\n                    continue\n            else:\n                if cached_result:\n                    continue\n\n            # Add new node with cost update from parent:\n            new_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Local rewiring within neighbor radius\n            r = neighbor_radius(len(tree_a))\n            near = near_nodes(tree_a, new_pos, r)\n\n            for node in near:\n                if node == nearest_node:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, node.position)\n\n                if cost_through_new + 1e-8 < node.cost:\n                    # Check edge collision (lazy)\n                    cached_rewire = is_edge_collision_cached(new_node.position, node.position)\n                    if cached_rewire is None:\n                        in_collision = self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d)\n                        cache_edge_collision(new_node.position, node.position, in_collision)\n                    else:\n                        in_collision = cached_rewire\n\n                    if not in_collision:\n                        try:\n                            # Remove old edge\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n            # Try connect tree_b to new_node with incremental steps capped by step_size\n            connect_node_b = nearest(tree_b, new_node.position)\n            prev_node_b = connect_node_b\n\n            while True:\n                next_pos_b = steer(prev_node_b.position, new_node.position)\n                if self._is_in_obstacle(next_pos_b, obstacles, is_3d):\n                    break\n\n                # Edge collision lazy check for edge prev_node_b->next_pos_b\n                cached_conn = is_edge_collision_cached(prev_node_b.position, next_pos_b)\n                if cached_conn is None:\n                    collides = self._is_edge_in_obstacle(prev_node_b.position, next_pos_b, obstacles, is_3d)\n                    cache_edge_collision(prev_node_b.position, next_pos_b, collides)\n                    if collides:\n                        break\n                else:\n                    if cached_conn:\n                        break\n\n                cost_b = prev_node_b.cost + distance(prev_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=prev_node_b, cost=cost_b)\n                prev_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((prev_node_b, new_node_b))\n\n                # Local rewiring in tree_b\n                r_b = neighbor_radius(len(tree_b))\n                near_b = near_nodes(tree_b, next_pos_b, r_b)\n\n                for nb_node in near_b:\n                    if nb_node == prev_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + distance(new_node_b.position, nb_node.position)\n\n                    if cost_via_new_b + 1e-8 < nb_node.cost:\n                        cached_rewire_b = is_edge_collision_cached(new_node_b.position, nb_node.position)\n                        if cached_rewire_b is None:\n                            in_col_b = self._is_edge_in_obstacle(new_node_b.position, nb_node.position, obstacles, is_3d)\n                            cache_edge_collision(new_node_b.position, nb_node.position, in_col_b)\n                        else:\n                            in_col_b = cached_rewire_b\n\n                        if not in_col_b:\n                            try:\n                                edges.remove((nb_node.parent, nb_node))\n                            except ValueError:\n                                pass\n                            nb_node.update_parent(new_node_b, cost_via_new_b)\n                            edges.append((new_node_b, nb_node))\n\n                # Check connection proximity\n                if distance(new_node_b.position, new_node.position) <= self.step_size:\n                    # Final edge check from new_node_b to new_node\n                    cached_final = is_edge_collision_cached(new_node_b.position, new_node.position)\n                    if cached_final is None:\n                        col_final = self._is_edge_in_obstacle(new_node_b.position, new_node.position, obstacles, is_3d)\n                        cache_edge_collision(new_node_b.position, new_node.position, col_final)\n                    else:\n                        col_final = cached_final\n                    if not col_final:\n                        # Link final connection node\n                        final_cost = new_node_b.cost + distance(new_node_b.position, new_node.position)\n                        connect_node_goal = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                        new_node_b.children.append(connect_node_goal)\n                        tree_b.append(connect_node_goal)\n                        nodes.append(connect_node_goal)\n                        edges.append((new_node_b, connect_node_goal))\n                        connection_start = new_node if tree_a is tree_start else connect_node_goal\n                        connection_goal = connect_node_goal if tree_b is tree_goal else new_node\n                        success_state = True\n                    break\n\n                prev_node_b = new_node_b\n\n            if success_state:\n                # Extract and merge path from start and goal trees without duplication at connection node\n                path_start = connection_start.path_from_root()\n                path_goal = connection_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n\n                # Update informed sampling parameters for smoothing and pruning:\n                best_path_length = 0.0\n                for i in range(len(merged_path) -1):\n                    best_path_length += distance(merged_path[i], merged_path[i+1])\n                c_max = best_path_length + 1e-6\n                center = tuple((start_position[d] + goal_position[d]) / 2.0 for d in range(dim))\n                path_found = True\n\n                # Path smoothing by iterative shortcutting\n                def path_smooth(path, max_trials=200):\n                    path = path[:]\n                    length = len(path)\n                    if length < 3:\n                        return path\n                    for _ in range(max_trials):\n                        if len(path) < 3:\n                            break\n                        i = random.randint(0, len(path)-3)\n                        j = random.randint(i+2, len(path)-1)\n                        if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                            path = path[:i+1] + path[j:]\n                    return path\n\n                merged_path = path_smooth(merged_path)\n\n                return PlannerResult(\n                    success=True,\n                    path=merged_path,\n                    nodes=nodes,\n                    edges=edges,\n                )\n\n        # Failed to find path within max_iter\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 10.13753,
        "time_improvement": -42.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.9,
                "time_avg": 0.019363903999328615,
                "num_nodes_avg": 84.6,
                "path_length_avg": 164.8760985022105,
                "success_improvement": -9.999999999999998,
                "time_improvement": -105.32486936209264,
                "length_improvement": 17.596510674688346,
                "objective_score": -33.07815867369012
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.026968622207641603,
                "num_nodes_avg": 247.7,
                "path_length_avg": 236.66509524297686,
                "success_improvement": 0.0,
                "time_improvement": -83.04725440284294,
                "length_improvement": 21.466514661865986,
                "objective_score": -20.620873388479684
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.01109619140625,
                "num_nodes_avg": 126.7,
                "path_length_avg": 123.98448793085234,
                "success_improvement": 0.0,
                "time_improvement": 61.71079228667543,
                "length_improvement": 23.86605545924244,
                "objective_score": 23.286448777851117
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid planner combines the adaptive goal biasing and dynamic neighbor radius rewiring from Algorithm 1 with the streamlined bidirectional growth and efficient local rewiring of Algorithm 2. It incorporates heuristic sampling towards the goal, balanced bidirectional expansions, lazy collision checks, and enhanced path smoothing through shortcutting. This integration targets improved planning efficiency, robustness, shorter and smoother paths, and higher success rates with optimized computational overhead.",
        "planning_mechanism": "Planning mechanism: The planner grows two bidirectional RRT* trees from start and goal alternately, adaptively biasing sampling towards the goal and start. It dynamically adjusts neighbor radius based on iteration for local rewiring optimization. New nodes are added with rigorous collision and edge validation. Trees attempt connection via iterative steering and rewiring. Upon connection, path extraction merges both trees\u2019 segments, followed by iterative shortcut-based smoothing to improve path quality and smoothness while retaining efficiency.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 min_neighbor_radius: float=8.0,\n                 max_neighbor_radius: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free(iteration, last_tree_toggle):\n            # Adaptive goal biasing that alternates bias target between start and goal \n            bias_rate = min(self.goal_sample_rate + (iteration / self.max_iter) * 0.25, 0.35)\n            if random.random() < bias_rate:\n                # Alternate bias targets each iteration to break symmetry\n                return start_position if last_tree_toggle else goal_position\n            else:\n                for _ in range(100):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # Fallback in rare case\n                return start_position if last_tree_toggle else goal_position\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            if in_bounds(new_p):\n                return new_p\n            # Clamp inside bounds in case of float error\n            clamped = tuple(max(0, min(new_p[d], bounds[d])) for d in range(len(bounds)))\n            return clamped\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def neighbor_radius(iteration):\n            # Shrinking radius for rewiring balancing exploration and refinement\n            factor = (1.0 - (iteration / self.max_iter)**0.9)\n            return max(self.min_neighbor_radius, self.max_neighbor_radius * factor)\n\n        def near_nodes(tree, pos, radius):\n            # Linear search neighbor filtering, could be improved to spatial indexing\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        # Initialize trees\n        start_root = Node(start_position, None, 0.0)\n        goal_root = Node(goal_position, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        connection_start = None\n        connection_goal = None\n\n        toggle_tree = True  # True for start tree growth, False for goal tree growth\n\n        for iteration in range(self.max_iter):\n            q_rand = sample_free(iteration, toggle_tree)\n\n            tree_a = tree_start if toggle_tree else tree_goal\n            tree_b = tree_goal if toggle_tree else tree_start\n\n            r = neighbor_radius(iteration)\n\n            nearest_node = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_node.position, q_rand)\n\n            # Check node and edge collision before proceeding\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                toggle_tree = not toggle_tree\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                toggle_tree = not toggle_tree\n                continue\n\n            near = near_nodes(tree_a, new_pos, r)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                cost_through_node = node.cost + math.dist(node.position, new_pos)\n                if cost_through_node < min_cost and \\\n                   not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through_node\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cost improves\n            for node in near:\n                if node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost and \\\n                   not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, node))\n\n            # Attempt to connect tree_b to new_node incrementally\n            curr_node_b = nearest(tree_b, new_node.position)\n            connected = False\n            while True:\n                new_pos_b = steer(curr_node_b.position, new_node.position)\n\n                if self._is_in_obstacle(new_pos_b, obstacles, is_3d) or \\\n                   self._is_edge_in_obstacle(curr_node_b.position, new_pos_b, obstacles, is_3d):\n                    break\n\n                cost_b = curr_node_b.cost + math.dist(curr_node_b.position, new_pos_b)\n                new_node_b = Node(new_pos_b)\n                new_node_b.cost = cost_b\n                new_node_b.parent = curr_node_b\n                curr_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((curr_node_b, new_node_b))\n\n                near_b = near_nodes(tree_b, new_pos_b, r)\n                for node in near_b:\n                    if node == curr_node_b:\n                        continue\n                    cost_through_new_b = new_node_b.cost + math.dist(new_node_b.position, node.position)\n                    if cost_through_new_b < node.cost and \\\n                       not self._is_edge_in_obstacle(new_node_b.position, node.position, obstacles, is_3d):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node_b, cost_through_new_b)\n                        edges.append((new_node_b, node))\n\n                if math.dist(new_node_b.position, new_node.position) <= self.step_size:\n                    connected = True\n                    break\n\n                curr_node_b = new_node_b\n\n            if connected:\n                success_state = True\n\n                connection_start = new_node if toggle_tree else new_node_b\n                connection_goal = new_node_b if toggle_tree else new_node\n\n                # Extract and merge paths avoiding duplication at connection node\n                path_start = connection_start.path_from_root()\n                path_goal = connection_goal.path_from_root()\n\n                merged_path = path_start + path_goal[::-1][1:]  # skip duplicated connection node\n\n                # Path smoothing by iterative shortcutting\n                merged_path = self._path_smooth(merged_path, obstacles, is_3d, max_trials=150)\n\n                return PlannerResult(\n                    success=True,\n                    path=merged_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            toggle_tree = not toggle_tree  # Alternate tree growth\n\n        # Failed to find path within max_iter\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smooth(self, path, obstacles, is_3d, max_trials=150):\n        import random\n\n        if len(path) < 3:\n            return path[:]\n\n        path = path[:]\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 16.63481,
        "time_improvement": -56.0,
        "length_improvement": 26.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.014208674430847168,
                "num_nodes_avg": 91.4,
                "path_length_avg": 158.17544701993134,
                "success_improvement": 0.0,
                "time_improvement": -50.66146895911861,
                "length_improvement": 20.945431882241195,
                "objective_score": -11.009354311287343
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.033472204208374025,
                "num_nodes_avg": 323.9,
                "path_length_avg": 228.63627045600987,
                "success_improvement": 0.0,
                "time_improvement": -127.18977009578398,
                "length_improvement": 24.13075035341303,
                "objective_score": -33.330780958052586
            },
            {
                "map_id": 2,
                "success_rate": 0.7,
                "time_avg": 0.026104116439819337,
                "num_nodes_avg": 242.9,
                "path_length_avg": 110.26078622637422,
                "success_improvement": -30.000000000000004,
                "time_improvement": 9.92351339811288,
                "length_improvement": 32.29323503549198,
                "objective_score": -5.564298973467742
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "This planner builds upon the bidirectional RRT* framework with enhanced parameter tuning. Key improvements include adaptive and tighter neighborhood radius for rewiring based on the number of nodes to improve path quality and efficiency, dynamic goal biasing to accelerate convergence, balanced tree growth by always extending the smaller tree, rigorous node and edge collision checks, and a robust shortcut smoothing step to improve path smoothness and reduce length. The planner thus achieves higher success rates and faster planning times while producing shorter and smoother paths.",
        "planning_mechanism": "The planner initializes two trees growing from start and goal. Each iteration, it samples a random point with adaptive goal biasing, extends the smaller tree incrementally towards this sample, locally rewires neighbors within an adaptively computed radius, then attempts to connect the other tree to the new node using incremental steering. Upon successful connection, it merges paths and applies shortcut smoothing to optimize the result. The process repeats until max iterations or a path is found, ensuring collision-free, optimal, and smooth solutions.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 4000,\n                 step_size: float = 4.0,\n                 goal_sample_rate_start: float = 0.15,\n                 goal_sample_rate_end: float = 0.35,\n                 radius_constant: float = 25.0,\n                 radius_min: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = goal_sample_rate_start\n        self.goal_sample_rate_end = goal_sample_rate_end\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free(iteration):\n            goal_bias = ((self.goal_sample_rate_end - self.goal_sample_rate_start) * iteration / self.max_iter +\n                         self.goal_sample_rate_start)\n            if random.random() < goal_bias:\n                return goal_position if random.random() < 0.85 else start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                        return p\n\n        def steer(from_pos, to_pos):\n            distance_ = dist(from_pos, to_pos)\n            if distance_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_min\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d) and \\\n                       not self._is_in_obstacle(node.position, obstacles, is_3d) and in_bounds(node.position):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def smooth_path(path, max_trials=150):\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if j >= len(path):\n                    continue\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n\n            # Balance growth: extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n                smoothed_path = smooth_path(merged_path, max_trials=150)\n                extracted_path = smoothed_path\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 39.1053,
        "time_improvement": -139.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.9,
                "time_avg": 0.018609237670898438,
                "num_nodes_avg": 89.9,
                "path_length_avg": 161.17663693205085,
                "success_improvement": -9.999999999999998,
                "time_improvement": -97.32277612189331,
                "length_improvement": 19.4454660100911,
                "objective_score": -30.307739634549772
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03994755744934082,
                "num_nodes_avg": 373.4,
                "path_length_avg": 238.2910829642812,
                "success_improvement": 0.0,
                "time_improvement": -171.14068545666095,
                "length_improvement": 20.926956926324376,
                "objective_score": -47.15681425173341
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.07212278842926026,
                "num_nodes_avg": 463.2,
                "path_length_avg": 123.68433565654122,
                "success_improvement": 0.0,
                "time_improvement": -148.8713763063479,
                "length_improvement": 24.05036703714668,
                "objective_score": -39.851339484475034
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This planner implements a simplified bidirectional RRT* that incrementally grows trees from start and goal positions, using adaptive goal biasing and rewiring in a reduced and generalized manner. It balances exploration efficiency and path quality by always extending the smaller tree first, verifying collision-free nodes and edges strictly, and smoothing the final path with shortcut attempts. The adaptive neighborhood radius for rewiring adjusts with the size of the trees to optimize connections. This approach aims to improve planning success, path smoothness, and computational efficiency while maintaining robustness in arbitrary 2D or 3D environments.",
        "planning_mechanism": "The planner initializes two trees at start and goal. At each iteration, it samples points biased towards the goal, extends the smaller tree towards the sample while avoiding obstacles, and rewires locally to reduce path cost. Then it attempts connecting the other tree to the newly added node for path completion. On success, the path is extracted and smoothed using random shortcutting to reduce unnecessary waypoints and improve smoothness and length. Collision checks for nodes and edges are enforced throughout, and node expansions respect map bounds.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate_start: float = 0.1, goal_sample_rate_end: float = 0.3,\n                 radius_constant: float = 30.0, radius_min: float = 3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = goal_sample_rate_start\n        self.goal_sample_rate_end = goal_sample_rate_end\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        def sample_free(iteration: int) -> Tuple[float, ...]:\n            goal_bias = ((self.goal_sample_rate_end - self.goal_sample_rate_start) * iteration / self.max_iter\n                         + self.goal_sample_rate_start)\n            if random.random() < goal_bias:\n                # Bias towards goal mostly, sometimes towards start to aid connection\n                return goal_position if random.random() < 0.85 else start_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            distance_ = dist(from_pos, to_pos)\n            if distance_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_min\n            return max(self.radius_min, self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1)))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost + 1e-6 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-6 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, target_node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if (not self._is_edge_in_obstacle(new_pos, target_node.position, obstacles, is_3d)\n                        and not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                        final_node = Node(target_node.position, parent=new_node,\n                                         cost=new_node.cost + dist(new_pos, target_node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def smooth_path(path: List[Tuple[float, ...]], max_trials=150) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i, p_j = path[i], path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n            # Always extend smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n                extracted_path = smooth_path(merged_path, max_trials=150)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -1.98626,
        "time_improvement": -7.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.0128068208694458,
                "num_nodes_avg": 87.7,
                "path_length_avg": 163.7379014655171,
                "success_improvement": 0.0,
                "time_improvement": -35.79693547612365,
                "length_improvement": 18.165370613850538,
                "objective_score": -7.1060065200669875
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.021283459663391114,
                "num_nodes_avg": 248.8,
                "path_length_avg": 242.37439342685926,
                "success_improvement": 0.0,
                "time_improvement": -44.45969191831741,
                "length_improvement": 19.57197637029986,
                "objective_score": -9.42351230143525
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.011657309532165528,
                "num_nodes_avg": 151.5,
                "path_length_avg": 125.7536583199623,
                "success_improvement": 0.0,
                "time_improvement": 59.77456320695808,
                "length_improvement": 22.779678263711585,
                "objective_score": 22.48830461482974
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This improved planner integrates bidirectional RRT* with adaptive shrinking neighbor radius, dynamic goal biasing, and informed sampling focused within an ellipsoidal heuristic around the current best path to reduce search space. It performs incremental rewiring for local path cost optimization, shortcut smoothing post path extraction, and balanced tree expansion to rapidly converge to near-optimal, collision-free and smoother paths while maintaining computational efficiency.",
        "planning_mechanism": "The planner grows two trees simultaneously from start and goal points with alternated expansions, employing heuristic-informed sampling towards the goal region to limit random exploration. It adaptively adjusts rewiring radius based on node count for balanced optimization, reconnects nodes with lower cost parents, checks collisions meticulously, and merges trees upon connection to generate refined shortest paths. Path smoothing is applied at the end to improve path quality and reduce length further, all aimed at improving success rate and minimizing planning time.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.12, radius_constant: float = 35.0, radius_min: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Heuristic for informed sampling: Ellipse parameters initialization\n        best_path_length = float('inf')\n        c_best = float('inf')\n        c_min = math.dist(start_position, goal_position)\n\n        def sample_informed():\n            # Informed sampling in ellipsoidal region: \n            # When we have a solution, sample inside ellipse centered between start and goal to focus search\n            if best_path_length == float('inf'):\n                # Uniform goal bias sampling like before\n                if random.random() < self.goal_sample_rate:\n                    return goal_position\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            # If path found: sample inside ellipse defined by start, goal and current best cost\n            center = tuple((start_position[d] + goal_position[d]) / 2.0 for d in range(dim))\n            a1 = tuple(goal_position[d] - start_position[d] for d in range(dim))\n            length_a1 = math.dist(start_position, goal_position)\n            if length_a1 == 0:\n                length_a1 = 1e-6\n\n            # Orthogonal basis (first normalized vector along start-goal line)\n            e1 = tuple((goal_position[d] - start_position[d]) / length_a1 for d in range(dim))\n\n            # Generate random sample inside unit n-ball\n            while True:\n                # Sample inside unit n-ball\n                vec = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x*x for x in vec))\n                unit_vec = [x / norm for x in vec]\n                radius = random.uniform(0, 1) ** (1.0 / dim)  # scale radius for uniform distribution in n-ball\n                ball_point = [radius * x for x in unit_vec]\n\n                # Scale ellipse axes:\n                # The ellipse axis lengths: c_best/2 along e1, and sqrt(c_best^2 - c_min^2)/2 for others\n                if c_best == float('inf'):\n                    c_ = 1e6\n                else:\n                    c_ = c_best\n\n                r1 = c_ / 2.0\n                if c_**2 - c_min**2 > 0:\n                    r2 = math.sqrt(c_**2 - c_min**2) / 2.0\n                else:\n                    r2 = 0.0\n\n                # Construct transformation: \n                # Sample point = center + r1 * (ball_point projected on e1) + r2 * (ball_point orthogonal components)\n                # We orthogonalize ball_point w.r.t e1\n                dot = sum(ball_point[d]*e1[d] for d in range(dim))\n                proj_e1 = [dot * e1[d] for d in range(dim)]\n                ortho = [ball_point[d] - proj_e1[d] for d in range(dim)]\n\n                sample = tuple(center[d] + r1 * proj_e1[d] + r2 * ortho[d] for d in range(dim))\n\n                # Check bounds\n                inside_bounds = all(0 <= sample[d] <= bounds[d] for d in range(dim))\n                if inside_bounds and not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            # Use squared distance for speed if desired, here math.dist is fast enough\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            # Shrinking radius with min bound for rewiring neighborhood (RRT* heuristic)\n            if n_nodes == 0:\n                return self.radius_constant\n            return max(self.radius_min, self.radius_constant * (math.log(n_nodes + 1) / (n_nodes + 1)) ** (1.0 / dim))\n\n        def collision_free(from_pos, to_pos):\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n                return False\n            return True\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                new_cost = new_node.cost + distance(new_node.position, neighbor.position)\n                if new_cost + 1e-7 < neighbor.cost and collision_free(new_node.position, neighbor.position):\n                    # Remove edge from old parent\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        if neighbor in neighbor.parent.children:\n                            neighbor.parent.children.remove(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend(tree, point) -> Node or None:\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not collision_free(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            # Choose best parent based on cost\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                c = node.cost + distance(node.position, new_pos)\n                if c < min_cost and collision_free(node.position, new_pos):\n                    min_cost = c\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        def try_connect(tree, node) -> Node or None:\n            # Greedy attempt to connect tree nodes to node\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not collision_free(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    # Verify final edge\n                    if collision_free(new_pos, node.position):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def extract_path(node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            full_path = path_start + path_goal[::-1][1:]  # remove duplicate connection node\n\n            # Shortcut smoothing\n            smooth_path = [full_path[0]]\n            i = 0\n            while i < len(full_path) - 1:\n                j = len(full_path) -1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(smooth_path[-1], full_path[j], obstacles, is_3d):\n                        break\n                    j -=1\n                smooth_path.append(full_path[j])\n                i = j\n            return smooth_path\n\n        for itr in range(self.max_iter):\n            rnd = sample_informed()\n\n            # Alternate tree expansion: expand smaller tree for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = extend(tree_start, rnd)\n            if new_node_start is None:\n                continue\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                # Path found\n                success_state = True\n\n                extracted_path = extract_path(new_node_start, new_node_goal)\n                # Update best path length and informed sampling radius parameters\n                best_path_length = sum(math.dist(extracted_path[i], extracted_path[i+1]) for i in range(len(extracted_path)-1))\n                c_best = best_path_length\n\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 8.61314,
        "time_improvement": -38.0,
        "length_improvement": 23.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.01772456169128418,
                "num_nodes_avg": 84.5,
                "path_length_avg": 156.9038684609896,
                "success_improvement": 0.0,
                "time_improvement": -87.9421274702383,
                "length_improvement": 21.58095462422703,
                "objective_score": -22.066447316226082
            },
            {
                "map_id": 1,
                "success_rate": 0.9,
                "time_avg": 0.023399209976196288,
                "num_nodes_avg": 270.6,
                "path_length_avg": 237.62067056042392,
                "success_improvement": -9.999999999999998,
                "time_improvement": -58.820169171441826,
                "length_improvement": 21.149422442985273,
                "objective_score": -18.416166262835493
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.019869160652160645,
                "num_nodes_avg": 224.4,
                "path_length_avg": 120.41397496273541,
                "success_improvement": 0.0,
                "time_improvement": 31.43823935197411,
                "length_improvement": 26.05856551298623,
                "objective_score": 14.643184908189479
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This improved planner refines the bidirectional RRT* framework focusing on reducing planning time and improving path quality by introducing an adaptive step size that shrinks near obstacles and goals, a more aggressive dynamic goal biasing schedule, and efficient rewiring radius updates leveraging node counts and dimension. It balances tree extension strictly by smaller tree nodes to maintain uniform growth, leverages spatial hashing for faster nearest neighbor queries, and introduces early termination conditions. The smoothing step uses a focused shortcut approach constrained by obstacles and incremental rewiring for maintaining topological consistency. The obstacle checking resolution adapts according to the environment scale for computational efficiency. Overall, these optimizations yield faster convergence, smoother shorter paths, and higher success rates.",
        "planning_mechanism": "The planner initializes two trees from start and goal. Each iteration, it samples a point using adaptive goal biasing that increases bias to goal over time to accelerate convergence. The smaller tree is always extended first towards the sample using an adaptive, possibly reduced step size to better navigate tight spaces. After extension, neighbors within an adaptive radius are rewired to reduce path costs. The other tree then attempts incremental connection to the new node. On successful connection, the paths are merged and a shortcut smoothing routine is applied to remove unnecessary waypoints while ensuring collision-free edges. The process repeats until a path is found or maximum iterations are reached, guaranteeing balanced growth, optimized rewiring, and smooth, near-optimal paths.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        from collections import defaultdict\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Precompute environment diagonal for step size adaption and radius limits\n        env_diag = math.dist((0,) * dim, bounds)\n        step_size_min = max(0.5, self.step_size * 0.2)\n        step_size_max = self.step_size\n\n        # Spatial hashing grid cell size for faster neighbor queries\n        grid_cell_size = self.step_size * 2.5\n        def _hash_pos(p):\n            return tuple(int(c // grid_cell_size) for c in p)\n\n        # Spatial hash maps for start and goal trees\n        tree_start_grid = defaultdict(list)\n        tree_goal_grid = defaultdict(list)\n\n        def add_node_to_grid(tree_grid, node):\n            tree_grid[_hash_pos(node.position)].append(node)\n\n        add_node_to_grid(tree_start_grid, start_root)\n        add_node_to_grid(tree_goal_grid, goal_root)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d_ in range(dim):\n                if pos[d_] < 0 or pos[d_] > bounds[d_]:\n                    return False\n            return True\n\n        def sample_free(iteration):\n            # Adaptive aggressive goal biasing: start low then rapidly grow bias\n            goal_bias = self._interpolate_goal_bias(iteration, self.max_iter)\n            r = random.random()\n            if r < goal_bias:\n                # Mostly goal, occasionally start to maintain exploration near start\n                if random.random() < 0.85:\n                    return goal_pos\n                else:\n                    return start_pos\n            # Uniform random sample inside bounds and free of obstacles\n            while True:\n                p = tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                    return p\n\n        def steer(from_pos, to_pos, adaptive=True):\n            # Adaptive step size: shrink near goal to increase precision and around obstacles (detected via proximity)\n            vec = tuple(to_pos[d_] - from_pos[d_] for d_ in range(dim))\n            distance_ = dist(from_pos, to_pos)\n            if distance_ <= step_size_min:\n                return to_pos  # Close enough, direct connection\n\n            step = step_size_max\n            # Shrink step closer to goal for better accuracy\n            goal_dist = dist(to_pos, goal_pos)\n            start_dist = dist(to_pos, start_pos)\n            close_to_goal = goal_dist < step_size_max * 3\n            close_to_start = start_dist < step_size_max * 3\n            if adaptive and (close_to_goal or close_to_start):\n                step = max(step_size_min, step_size_max * 0.3)\n\n            # Shrink step near obstacles to avoid skipping narrow spaces (heuristic)\n            # We'll check current position proximity to obstacles quickly:\n            prox_threshold = step_size_max * 1.5\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    px, py, pz = from_pos\n                    # Simple bounding box proximity check (min distance to box)\n                    dx = max(ox - px, 0, px - (ox + ow))\n                    dy = max(oy - py, 0, py - (oy + oh))\n                    dz = max(oz - pz, 0, pz - (oz + od))\n                    dist_to_box = math.sqrt(dx * dx + dy * dy + dz * dz)\n                else:\n                    ox, oy, ow, oh = obs\n                    px, py = from_pos\n                    dx = max(ox - px, 0, px - (ox + ow))\n                    dy = max(oy - py, 0, py - (oy + oh))\n                    dist_to_box = math.sqrt(dx * dx + dy * dy)\n                if 0 < dist_to_box < prox_threshold:\n                    step = max(step_size_min, step * 0.5)\n                    break\n\n            ratio = step / distance_\n            if ratio > 1.0:\n                return to_pos\n            return tuple(from_pos[d_] + vec[d_] * ratio for d_ in range(dim))\n\n        def nearest(tree_grid, point):\n            # Search neighbor cells in grid to find nearest node more efficiently\n            base_cell = _hash_pos(point)\n            best_node = None\n            best_dist = float('inf')\n\n            # Search neighboring cells for nearest node, radius expands as needed\n            cells_to_check = [(0,)*dim]  # always check current cell\n            # Add neighbor cells offsets (all 3^dim - 1 neighbors)\n            offsets = [-1, 0, 1]\n            from itertools import product\n            for offset in product(*([offsets] * dim)):\n                if offset == (0,) * dim:\n                    continue\n                cells_to_check.append(offset)\n\n            checked_cells = set()\n            radius_in_cells = 0\n            max_cell_search = 2  # limit search to 2 cells radius for efficiency\n\n            while radius_in_cells <= max_cell_search:\n                for cell_off in cells_to_check:\n                    neighbor_cell = tuple(base_cell[d_] + cell_off[d_] for d_ in range(dim))\n                    if neighbor_cell in checked_cells:\n                        continue\n                    checked_cells.add(neighbor_cell)\n                    if neighbor_cell not in tree_grid:\n                        continue\n                    for node in tree_grid[neighbor_cell]:\n                        cur_dist = dist(node.position, point)\n                        if cur_dist < best_dist:\n                            best_dist = cur_dist\n                            best_node = node\n                if best_node is not None:\n                    break  # Found nearest within close cells\n                # Expand search radius (not implemented to keep speed, fallback to full tree)\n                radius_in_cells += 1\n                if radius_in_cells > max_cell_search:\n                    break\n            # Fallback linear scan on whole tree if no node found in grid (unlikely)\n            if best_node is None:\n                # flatten tree grid nodes list for linear search\n                all_nodes = [n for bucket in tree_grid.values() for n in bucket]\n                if not all_nodes:\n                    return None\n                best_node = min(all_nodes, key=lambda n: dist(n.position, point))\n            return best_node\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return step_size_max\n            val = self.step_size * (math.log(n_nodes + 1) / (n_nodes + 1)) ** 0.5\n            return max(step_size_min, min(val, step_size_max * 2.5))\n\n        def near_nodes(tree_grid, pos, radius):\n            # Collect nodes in the grid cells covered by radius\n            radius_cells = int(math.ceil(radius / grid_cell_size))\n            base_cell = _hash_pos(pos)\n            collected = []\n            from itertools import product\n            offsets = range(-radius_cells, radius_cells + 1)\n            for offset in product(offsets, repeat=dim):\n                cell = tuple(base_cell[d_] + offset[d_] for d_ in range(dim))\n                if cell in tree_grid:\n                    for node in tree_grid[cell]:\n                        if dist(node.position, pos) <= radius:\n                            collected.append(node)\n            return collected\n\n        def try_extend(tree, tree_grid, point):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree_grid, point)\n            if nearest_node is None:\n                return None\n            new_pos = steer(nearest_node.position, point)\n\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=0.3):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree_grid, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost + 1e-6 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, resolution=0.3):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            add_node_to_grid(tree_grid, new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors for improved costs\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=0.3):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, tree_grid, node):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree_grid, node.position)\n            if nearest_node is None:\n                return None\n\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d, resolution=0.3):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                add_node_to_grid(tree_grid, new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                dist_check = dist(new_pos, node.position)\n                if dist_check <= step_size_min:\n                    # verify direct connection to the target node\n                    if (not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d, resolution=0.3)\n                        and not self._is_in_obstacle(node.position, obstacles, is_3d)\n                        and in_bounds(node.position)):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        add_node_to_grid(tree_grid, final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def smooth_path(path, max_trials=120):\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if j >= len(path):\n                    continue\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d, resolution=0.3):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for iteration in range(self.max_iter):\n            # Adaptive goal biasing sample\n            rand_point = sample_free(iteration)\n\n            # Balance growth: always extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n                tree_start_grid, tree_goal_grid = tree_goal_grid, tree_start_grid\n\n            new_node_start = try_extend(tree_start, tree_start_grid, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, tree_goal_grid, new_node_start)\n            if new_node_goal is not None:\n                # Success: merge paths and smooth\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n                extracted_path = smooth_path(merged_path, max_trials=120)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _interpolate_goal_bias(self, iteration, max_iter):\n        # Aggressive increase from 0.15 to 0.5 goal sampling rate with cosine smoothing\n        from math import cos, pi\n        start_bias = 0.15\n        end_bias = 0.5\n        ratio = iteration / max_iter\n        # Smooth increase bias with cosine ease-in-out\n        bias = start_bias + (end_bias - start_bias) * (1 - cos(ratio * pi)) / 2\n        return bias\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 72.53067,
        "time_improvement": -256.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.02975156307220459,
                "num_nodes_avg": 153.2,
                "path_length_avg": 158.52954585440588,
                "success_improvement": 0.0,
                "time_improvement": -215.47025854550145,
                "length_improvement": 20.768456688190636,
                "objective_score": -60.4873862260123
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.07711560726165771,
                "num_nodes_avg": 530.9,
                "path_length_avg": 238.56745054991174,
                "success_improvement": 0.0,
                "time_improvement": -423.4156966630148,
                "length_improvement": 20.835248811480618,
                "objective_score": -122.8576592366083
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.06654825210571289,
                "num_nodes_avg": 459.4,
                "path_length_avg": 125.03896250874553,
                "success_improvement": 0.0,
                "time_improvement": -129.63553480152723,
                "length_improvement": 23.21854454579871,
                "objective_score": -34.24695153129843
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This algorithm integrates the strengths of bidirectional RRT* and adaptive frontier-biased sampling with dynamic step sizing near obstacles, balanced tree growth, dynamic rewiring radius, and periodic pruning. It employs adaptive informed sampling that blends frontier exploration and goal/start bias to enhance exploration efficiency and path optimality. The planner grows two trees alternately from start and goal, extends the smaller tree to balance growth, adapts step size near obstacles for precision, rewires local neighborhoods to improve path cost, prunes dead-ends for efficiency, and applies iterative shortcut smoothing to generate shorter, smoother collision-free paths.",
        "planning_mechanism": "The planner initializes two trees at start and goal. It samples points biased both towards frontiers and the goal/start regions for balanced exploration-exploitation. The smaller tree is extended first by steering towards sampled points with adaptive step sizes that shrink near obstacles. A rewiring step dynamically reduces path cost locally with a radius shrinking based on node count. After each extension, it attempts to connect the opposite tree to form a feasible path. Dead-end nodes are periodically pruned to improve efficiency. Once connected, iterative shortcut smoothing refines the path. Collision and boundary checks ensure path safety and validity throughout.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, base_step_size: float=5.0,\n                 frontier_sample_rate: float=0.25, goal_sample_rate: float=0.2,\n                 radius_constant: float=20.0, radius_min: float=5.0,\n                 prune_interval: int=200, prune_threshold: int=100,\n                 smoothing_iterations: int=50):\n        self.max_iter = max_iter\n        self.base_step_size = base_step_size\n        self.frontier_sample_rate = frontier_sample_rate\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Identify frontier regions for biased sampling\n        frontier_regions = self._identify_frontiers(bounds, obstacles, is_3d)\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step_size):\n            dist = distance(from_pos, to_pos)\n            if dist <= step_size:\n                return to_pos\n            ratio = step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def adaptive_step_size(position):\n            query_radius = self.base_step_size * 2\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, w, h, d = obs\n                    px, py, pz = position\n                    dx = max(ox - px, 0, px - (ox + w))\n                    dy = max(oy - py, 0, py - (oy + h))\n                    dz = max(oz - pz, 0, pz - (oz + d))\n                    dist = (dx*dx + dy*dy + dz*dz)**0.5\n                else:\n                    ox, oy, w, h = obs\n                    px, py = position\n                    dx = max(ox - px, 0, px - (ox + w))\n                    dy = max(oy - py, 0, py - (oy + h))\n                    dist = (dx*dx + dy*dy)**0.5\n                if dist <= query_radius:\n                    return self.base_step_size * 0.5\n            return self.base_step_size\n\n        def sample_free():\n            # Mix sampling strategy:\n            # With frontier_sample_rate, sample near frontiers if available.\n            # Else with goal_sample_rate, sample goal or start biased.\n            # Else uniform random free space sample.\n            if frontier_regions and random.random() < self.frontier_sample_rate:\n                return self._sample_near_frontier(frontier_regions, bounds, is_3d)\n            elif random.random() < self.goal_sample_rate:\n                if random.random() < 0.7:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            step_size = adaptive_step_size(nearest_node.position)\n            new_pos = steer(nearest_node.position, sample_pt, step_size)\n\n            if not self._in_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                step_size = adaptive_step_size(last_node.position)\n                new_pos = steer(last_node.position, node.position, step_size)\n\n                if not self._in_bounds(new_pos, bounds):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            # Only prune when nodes exceed threshold\n            if len(nodes) <= self.prune_threshold:\n                return removed_nodes\n            for node in nodes[:]:\n                if (not node.children) and node is not start_root and node is not goal_root:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed_nodes.append(node)\n                    except Exception:\n                        pass\n            return removed_nodes\n\n        def path_length(path):\n            if len(path) < 2:\n                return 0.0\n            return sum(distance(path[i], path[i+1]) for i in range(len(path)-1))\n\n        def shortcut_smooth(path):\n            import random\n            if len(path) < 3:\n                return path\n            new_path = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                p_i = new_path[i]\n                p_j = new_path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    new_path = new_path[:i + 1] + new_path[j:]\n            return new_path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Grow smaller tree first for balanced search\n            if len(tree_start) > len(tree_goal):\n                tree_a, tree_b = tree_goal, tree_start\n            else:\n                tree_a, tree_b = tree_start, tree_goal\n\n            new_node_a = try_extend(tree_a, sample_pt)\n            if new_node_a is None:\n                continue\n\n            new_node_b = try_connect(tree_b, new_node_a)\n            if new_node_b is not None:\n                # Connected path found\n                success_state = True\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                raw_path = path_a + path_b[::-1][1:]  # Avoid duplicate node\n\n                smoothed_path = shortcut_smooth(raw_path)\n                if path_length(smoothed_path) + 1e-8 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                yield nbr\n\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                min_cells = [int(ox // resolution), int(oy // resolution), int(oz // resolution)]\n                max_cells = [int((ox + w) // resolution), int((oy + h) // resolution), int((oz + d) // resolution)]\n                ranges = [range(min_cells[i], max_cells[i]+1) for i in range(3)]\n                for cx in ranges[0]:\n                    for cy in ranges[1]:\n                        for cz in ranges[2]:\n                            occupied.add((cx, cy, cz))\n            else:\n                ox, oy, w, h = obs\n                min_cells = [int(ox // resolution), int(oy // resolution)]\n                max_cells = [int((ox + w) // resolution), int((oy + h) // resolution)]\n                for cx in range(min_cells[0], max_cells[0]+1):\n                    for cy in range(min_cells[1], max_cells[1]+1):\n                        occupied.add((cx, cy))\n\n        if is_3d:\n            for ix in range(steps[0]+1):\n                for iy in range(steps[1]+1):\n                    for iz in range(steps[2]+1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontiers.append(tuple((pos_grid[d] + 0.5)*resolution for d in range(dims)))\n        else:\n            for ix in range(steps[0]+1):\n                for iy in range(steps[1]+1):\n                    pos_grid = (ix, iy)\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontiers.append(((ix + 0.5)*resolution, (iy + 0.5)*resolution))\n\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n        else:\n            for item in arrays[0]:\n                for rest in self._cartesian_product(arrays[1:]):\n                    yield (item,) + rest\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        import random\n        dim = len(bounds)\n        frontier = random.choice(frontiers)\n        radius = self.base_step_size * 3\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 45.73203,
        "time_improvement": -167.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.012654423713684082,
                "num_nodes_avg": 122.6,
                "path_length_avg": 153.46323341130906,
                "success_improvement": 0.0,
                "time_improvement": -34.1809944913401,
                "length_improvement": 23.30055095240459,
                "objective_score": -5.594188156921112
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.05359861850738525,
                "num_nodes_avg": 284.5,
                "path_length_avg": 242.08005114464976,
                "success_improvement": 0.0,
                "time_improvement": -263.79611394394067,
                "length_improvement": 19.669649097579565,
                "objective_score": -75.20490436366629
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.08807411193847656,
                "num_nodes_avg": 219.3,
                "path_length_avg": 123.95195815504057,
                "success_improvement": 0.0,
                "time_improvement": -203.9140046087764,
                "length_improvement": 23.886030701217525,
                "objective_score": -56.39699524238941
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "This planner integrates the best features of bidirectional RRT* approaches with adaptive parameter tuning, dynamic goal biasing, balanced tree extension, and KD-tree-inspired efficient neighbor searches. It improves planning efficiency and robustness by adaptively tuning neighborhood radius, dynamically adjusting goal bias throughout iterations, rigorously performing node and edge collision checks, and balancing tree growth based on size. A solid rewiring strategy optimizes local path costs, while a shortcut-based smoothing refines path quality and reduces length and complexity, yielding faster, more successful planning with shorter, smoother paths.",
        "planning_mechanism": "The planner initializes two trees from start and goal and alternately extends them towards randomly sampled points with adaptive goal bias. KD-tree-style efficient nearest and neighbor search accelerates rewiring steps. At each iteration, it attempts to connect the opposite tree to the newly added node to detect a solution early. Local rewiring improves path costs, and a robust shortcut smoothing post-processing step reduces path complexity and length. The process terminates early when a path is found or max iterations are reached, ensuring collision-free, bounded, and optimized paths.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 4.5,\n                 goal_sample_rate_start: float = 0.12,\n                 goal_sample_rate_end: float = 0.35,\n                 radius_constant: float = 20.0,\n                 radius_min: float = 3.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = goal_sample_rate_start\n        self.goal_sample_rate_end = goal_sample_rate_end\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # KD-tree style structure for fast near-node queries (brute force for moderate size)\n        class KDTree:\n            def __init__(self):\n                self.points = []\n                self.nodes = []\n\n            def insert(self, node):\n                self.points.append(node.position)\n                self.nodes.append(node)\n\n            def nearest(self, point):\n                best_node = None\n                best_dist = float('inf')\n                for node in self.nodes:\n                    d = math.dist(node.position, point)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = node\n                return best_node\n\n            def near(self, point, radius):\n                r_sq = radius * radius\n                neighbors = []\n                for node in self.nodes:\n                    dx = 0\n                    for d_ in range(dim):\n                        diff = node.position[d_] - point[d_]\n                        dx += diff * diff\n                        if dx > r_sq:\n                            break\n                    if dx <= r_sq:\n                        neighbors.append(node)\n                return neighbors\n\n        kd_start = KDTree()\n        kd_goal = KDTree()\n        kd_start.insert(start_root)\n        kd_goal.insert(goal_root)\n\n        def in_bounds(pos):\n            for d_ in range(dim):\n                if pos[d_] < 0 or pos[d_] > bounds[d_]:\n                    return False\n            return True\n\n        def sample_free(iteration):\n            goal_bias = ((self.goal_sample_rate_end - self.goal_sample_rate_start) * iteration / self.max_iter +\n                         self.goal_sample_rate_start)\n            if random.random() < goal_bias:\n                # 90% goal, 10% start\n                return goal_position if random.random() < 0.9 else start_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist_ = math.dist(from_pos, to_pos)\n            if dist_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist_\n            return tuple(from_pos[d_] + (to_pos[d_] - from_pos[d_]) * ratio for d_ in range(dim))\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_min\n            return max(self.radius_min, self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1)))\n\n        def try_extend(tree, kd_tree, point):\n            if not tree:\n                return None\n            nearest_node = kd_tree.nearest(point)\n            if nearest_node is None:\n                return None\n\n            new_pos = steer(nearest_node.position, point)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=0.4):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = kd_tree.near(new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                temp_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d, resolution=0.4):\n                    min_cost = temp_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            kd_tree.insert(new_node)\n\n            # Rewire neighbors for cost improvement\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_via_new < neighbor.cost - 1e-8:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=0.4):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n\n            return new_node\n\n        def try_connect(tree, kd_tree, target_node):\n            if not tree:\n                return None\n            nearest_node = kd_tree.nearest(target_node.position)\n            if nearest_node is None:\n                return None\n\n            curr_node = nearest_node\n            while True:\n                new_pos = steer(curr_node.position, target_node.position)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d, resolution=0.4):\n                    return None\n\n                radius = radius_by_nodes(len(tree))\n                neighbors = kd_tree.near(new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    temp_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if temp_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d, resolution=0.4):\n                        min_cost = temp_cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                new_node.cost = min_cost\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                kd_tree.insert(new_node)\n\n                # Rewire neighbors for cost improvement\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if cost_via_new < neighbor.cost - 1e-8:\n                        if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=0.4):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    # Final check for connection to target node\n                    if not self._is_edge_in_obstacle(new_node.position, target_node.position, obstacles, is_3d, resolution=0.4) and \\\n                       not self._is_in_obstacle(target_node.position, obstacles, is_3d):\n                        final_cost = new_node.cost + math.dist(new_node.position, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        kd_tree.insert(final_node)\n                        return final_node\n                    else:\n                        return None\n\n                curr_node = new_node\n\n        def smooth_path(path, max_trials=200):\n            if len(path) < 3:\n                return path\n\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.4):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Main loop\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n\n            # Always extend smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_a, tree_b = tree_goal, tree_start\n                kd_a, kd_b = kd_goal, kd_start\n                reversed_connect = True\n            else:\n                tree_a, tree_b = tree_start, tree_goal\n                kd_a, kd_b = kd_start, kd_goal\n                reversed_connect = False\n\n            new_node = try_extend(tree_a, kd_a, rand_point)\n            if new_node is None:\n                continue\n\n            connected_node = try_connect(tree_b, kd_b, new_node)\n            if connected_node is not None:\n                success_state = True\n                if reversed_connect:\n                    path_from_start = connected_node.path_from_root()\n                    path_from_goal = new_node.path_from_root()\n                else:\n                    path_from_start = new_node.path_from_root()\n                    path_from_goal = connected_node.path_from_root()\n\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n                extracted_path = smooth_path(merged_path, max_trials=200)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.4):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 33.33973,
        "time_improvement": -120.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.9,
                "time_avg": 0.03180310726165771,
                "num_nodes_avg": 107.9,
                "path_length_avg": 158.77348039059896,
                "success_improvement": -9.999999999999998,
                "time_improvement": -237.22377698396446,
                "length_improvement": 20.646540551577345,
                "objective_score": -72.03782498487386
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03618807792663574,
                "num_nodes_avg": 294.3,
                "path_length_avg": 240.2114393867127,
                "success_improvement": 0.0,
                "time_improvement": -145.6235344759229,
                "length_improvement": 20.28971769681239,
                "objective_score": -39.62911680341439
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.021976447105407713,
                "num_nodes_avg": 237.6,
                "path_length_avg": 127.04180041003106,
                "success_improvement": 0.0,
                "time_improvement": 24.16670574501011,
                "length_improvement": 21.988681421424296,
                "objective_score": 11.647748007787893
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This improved planner merges bidirectional RRT* with adaptive sampling near frontiers and dynamic step sizing, enriched by heuristic-guided sampling and local shortcut smoothing to minimize path length and accelerate planning. It leverages goal and frontier biasing to efficiently explore, adaptive step sizes to safely navigate close to obstacles, radius-based rewiring for cost optimization, and fast collision checks to maintain feasibility. After trees connect, an iterative shortcut smoothing refines and shortens the path while preserving collision safety, balancing planning speed and path quality.",
        "planning_mechanism": "The planner alternately grows two trees from start and goal, sampling points biased towards frontiers and the goal to enhance exploration. Each new node is efficiently connected and locally rewired with neighbors within a radius to optimize the path costs. Adaptive step sizing and collision checks ensure safe expansions. Upon connecting the two trees, the combined path is shortcut-smoothed to reduce unnecessary detours and improve smoothness before returning the final optimized path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 frontier_sample_rate: float=0.3, goal_sample_rate: float=0.1,\n                 neighbor_radius: float=10.0, smoothing_iters: int=100):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.frontier_sample_rate = frontier_sample_rate\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        frontier_regions = self._identify_frontiers(bounds, obstacles, is_3d)\n\n        def sample_free():\n            # Bias sampling towards goal or frontiers\n            if frontier_regions and random.random() < self.frontier_sample_rate:\n                return self._sample_near_frontier(frontier_regions, bounds, is_3d)\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            # Uniform random sample in bounds avoiding obstacles\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos, step_size):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step_size:\n                return to_pos\n            ratio = step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos):\n            return [n for n in tree if math.dist(n.position, pos) <= self.neighbor_radius]\n\n        def adaptive_step_size(position):\n            query_radius = self.base_step_size * 2\n            min_dist = float('inf')\n            px, py, pz = (*position, 0.0) if not is_3d else position\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, w, h, d = obs\n                    dx = max(ox - px, 0, px - (ox + w))\n                    dy = max(oy - py, 0, py - (oy + h))\n                    dz = max(oz - pz, 0, pz - (oz + d))\n                    dist_obs = (dx*dx + dy*dy + dz*dz)**0.5\n                else:\n                    ox, oy, w, h = obs\n                    dx = max(ox - px, 0, px - (ox + w))\n                    dy = max(oy - py, 0, py - (oy + h))\n                    dist_obs = (dx*dx + dy*dy)**0.5\n                if dist_obs < min_dist:\n                    min_dist = dist_obs\n            if min_dist <= query_radius:\n                return max(self.base_step_size * 0.4, min_dist * 0.5)\n            return self.base_step_size\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            step = adaptive_step_size(nearest_node.position)\n            new_pos = steer(nearest_node.position, point, step)\n\n            if not self._in_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            near = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + math.dist(node.position, new_pos)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            while True:\n                step = adaptive_step_size(nearest_node.position)\n                new_pos = steer(nearest_node.position, node.position, step)\n\n                if not self._in_bounds(new_pos, bounds):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = nearest_node\n                nearest_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                if math.dist(new_pos, node.position) <= step:\n                    return new_node\n                nearest_node = new_node\n\n        def shortcut_smooth(path):\n            if len(path) < 3:\n                return path\n            new_path = path[:]\n            for _ in range(self.smoothing_iters):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                p_i = new_path[i]\n                p_j = new_path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    new_path = new_path[:i + 1] + new_path[j:]\n            return new_path\n\n        for i in range(self.max_iter):\n            rand_point = sample_free()\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                # Swap trees to avoid stall and encourage progress\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                extracted_path = shortcut_smooth(extracted_path)\n                break\n\n            # Alternate growth direction for balanced exploration\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                yield nbr\n\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n            else:\n                ox, oy, w, h = obs\n            min_cells = [int(ox // resolution), int(oy // resolution)]\n            max_cells = [int((ox + w) // resolution), int((oy + h) // resolution)]\n            if is_3d:\n                min_cells.append(int(oz // resolution))\n                max_cells.append(int((oz + d) // resolution))\n                ranges = [range(min_cells[i], max_cells[i]+1) for i in range(3)]\n                for cx in ranges[0]:\n                    for cy in ranges[1]:\n                        for cz in ranges[2]:\n                            occupied.add((cx, cy, cz))\n            else:\n                for cx in range(min_cells[0], max_cells[0]+1):\n                    for cy in range(min_cells[1], max_cells[1]+1):\n                        occupied.add((cx, cy))\n\n        if is_3d:\n            for ix in range(steps[0]+1):\n                for iy in range(steps[1]+1):\n                    for iz in range(steps[2]+1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontiers.append(tuple((pos_grid[d] + 0.5)*resolution for d in range(dims)))\n        else:\n            for ix in range(steps[0]+1):\n                for iy in range(steps[1]+1):\n                    pos_grid = (ix, iy)\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontiers.append(((ix + 0.5)*resolution, (iy + 0.5)*resolution))\n\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n        else:\n            for item in arrays[0]:\n                for rest in self._cartesian_product(arrays[1:]):\n                    yield (item,) + rest\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        import random\n        dim = len(bounds)\n        frontier = random.choice(frontiers)\n        radius = self.base_step_size * 3\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 51.60639,
        "time_improvement": -176.0,
        "length_improvement": 23.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.9,
                "time_avg": 0.026292800903320312,
                "num_nodes_avg": 142.6,
                "path_length_avg": 152.27897463633377,
                "success_improvement": -9.999999999999998,
                "time_improvement": -178.7953250968882,
                "length_improvement": 23.892432105637816,
                "objective_score": -53.8601111079389
            },
            {
                "map_id": 1,
                "success_rate": 0.9,
                "time_avg": 0.059008216857910155,
                "num_nodes_avg": 509.7,
                "path_length_avg": 235.00447827559637,
                "success_improvement": -9.999999999999998,
                "time_improvement": -300.51330764637436,
                "length_improvement": 22.0175635528152,
                "objective_score": -90.75047958334928
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.04336884021759033,
                "num_nodes_avg": 395.6,
                "path_length_avg": 124.68811290345968,
                "success_improvement": 0.0,
                "time_improvement": -49.6512155010214,
                "length_improvement": 23.433987338980035,
                "objective_score": -10.20856718251041
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "This improved planner implements a bidirectional RRT* with adaptive informed sampling biased towards both the start and goal to balance exploration and exploitation. It uses a dynamically shrinking neighbor radius for optimal rewiring, and extends the smaller tree alternately for balanced growth. After each extension, it attempts to connect the two trees to form a complete path. Dead-end nodes are pruned periodically to maintain efficiency. Post path extraction, an advanced shortcut smoothing with multiple randomized trials is applied to minimize path length and improve smoothness. Collision and edge-intersection checks ensure safety. These enhancements result in faster planning, higher success rates, and shorter, smoother paths.",
        "planning_mechanism": "The planner grows two trees simultaneously from the start and goal positions, sampling new points biased toward these positions adaptively. It extends the smaller tree first by steering towards these samples with collision checks. A dynamic radius facilitates near-node detection for rewiring to reduce path cost locally. Upon new node addition, attempts to connect the opposite tree are made to complete the path. Periodic dead-node pruning removes ineffective branches. After finding a feasible connection, the path is smoothed by repeatedly attempting shortcuts between random non-adjacent node pairs, improving length and smoothness while maintaining collision-free connectivity.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0,\n                 radius_min: float=5.0, prune_interval: int=250,\n                 prune_threshold: int=100, smoothing_iterations: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free() -> Tuple[float, ...]:\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d) and self._in_bounds(sample, bounds):\n                        return sample\n\n        def steer(from_pos, to_pos) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b) -> float:\n            return math.dist(a, b)\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree if self._dist_sq(node.position, pos) <= r_sq]\n\n        def radius_by_nodes(n_nodes: int) -> float:\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def _connect_nodes(parent_node: Node, child_pos: Tuple[float, ...], cost_to_child: float) -> Node:\n            new_node = Node(child_pos, parent=parent_node, cost=cost_to_child)\n            parent_node.children.append(new_node)\n            tree_append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n            return new_node\n\n        def tree_append(new_node: Node):\n            # Append node to the corresponding tree list\n            # Each node belongs to either tree_start or tree_goal\n            # We detect by parent lineage or explicit tracking\n            if new_node.parent in tree_start:\n                tree_start.append(new_node)\n            else:\n                tree_goal.append(new_node)\n\n        def try_extend(tree: List[Node], sample_pt: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not self._in_bounds(new_pos, bounds):\n                return None\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            dist_nearest = distance(nearest_node.position, new_pos)\n            min_cost = nearest_node.cost + dist_nearest\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to reduce cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node) -> Node or None:\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not self._in_bounds(new_pos, bounds):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node, cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            for node in nodes[:]:\n                if (not node.children) and node is not start_root and node is not goal_root:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        # Also remove from trees if present\n                        if node in tree_start:\n                            tree_start.remove(node)\n                        if node in tree_goal:\n                            tree_goal.remove(node)\n                        removed_nodes.append(node)\n                    except Exception:\n                        continue\n            return removed_nodes\n\n        def path_length(path: List[Tuple[float, ...]]) -> float:\n            if len(path) < 2:\n                return 0.0\n            total = 0.0\n            for i in range(len(path)-1):\n                total += distance(path[i], path[i+1])\n            return total\n\n        def path_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            path = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # shortcut: remove intermediate nodes\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def adaptive_sample_free() -> Tuple[float, ...]:\n            # Adaptive informed biased sampling\n            # Increase bias towards start and goal once partial solution found\n            # Here simplified as the same goal_sample_rate and p_goal_bias\n            return sample_free()\n\n        def informed_radius(n_nodes: int) -> float:\n            # Adapted radius shrinking per iteration for better rewiring\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt((math.log(n_nodes + 1)) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def check_bounds(pt: Tuple[float, ...], bounds: Tuple[int, ...]) -> bool:\n            return all(0.0 <= pt[d] <= bounds[d] for d in range(len(pt)))\n\n        self._in_bounds = check_bounds\n        self._dist_sq = lambda a,b: sum((a[d]-b[d])**2 for d in range(len(a)))\n\n        for itr in range(self.max_iter):\n            sample_pt = adaptive_sample_free()\n\n            # Alternate growth on smaller tree\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                    prune_dead_nodes()\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                # Path found\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed_path = path_smoothing(raw_path)\n                if path_length(smoothed_path) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 14.3305,
        "time_improvement": -49.0,
        "length_improvement": 19.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.9,
                "time_avg": 0.015049576759338379,
                "num_nodes_avg": 82.2,
                "path_length_avg": 172.6257542375586,
                "success_improvement": -9.999999999999998,
                "time_improvement": -59.57796434918684,
                "length_improvement": 13.723307223952673,
                "objective_score": -20.12872785996552
            },
            {
                "map_id": 1,
                "success_rate": 0.9,
                "time_avg": 0.030583906173706054,
                "num_nodes_avg": 136.1,
                "path_length_avg": 235.7113701238784,
                "success_improvement": -9.999999999999998,
                "time_improvement": -107.58569017384816,
                "length_improvement": 21.78299292233964,
                "objective_score": -32.91910846768651
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.023279428482055664,
                "num_nodes_avg": 107.5,
                "path_length_avg": 129.0168359072885,
                "success_improvement": 0.0,
                "time_improvement": 19.670557224269377,
                "length_improvement": 20.77589064796812,
                "objective_score": 10.056345296874436
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This algorithm is a hybrid bidirectional RRT* planner incorporating informed sampling inside an ellipsoidal heuristic region, adaptive rewiring radius dependent on the number of nodes, dynamic goal biasing, and shortcut smoothing to optimize path quality and planning efficiency. It balances exploration and exploitation by growing two trees from start and goal positions alternately, rewiring locally to minimize path cost, performing collision checks for nodes and edges, and applying smoothing after identifying a valid path.",
        "planning_mechanism": "The planner alternates expansion between two trees from start and goal points. Nodes are sampled preferentially inside an ellipsoid defined by the current best path cost to focus the search. Upon each extension, nearby nodes are considered for rewiring to shorten the path. The trees attempt to connect greedily, ensuring collision-free connections. Once connected, the path is extracted and shortcut smoothing is applied for enhanced path quality. Adaptive radius for rewiring, collision checks, and goal biasing improve robustness and convergence speed.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        # Constants for adaptive rewiring radius\n        self.radius_constant = 35.0\n        self.radius_min = 5.0\n        self.goal_sample_rate = 0.12\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n        best_path_length = float('inf')\n\n        def sample_informed():\n            if best_path_length == float('inf'):\n                if random.random() < self.goal_sample_rate:\n                    return goal_position\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            center = tuple((start_position[d] + goal_position[d]) / 2.0 for d in range(dim))\n            length_line = max(c_min, 1e-6)\n            e1 = tuple((goal_position[d] - start_position[d]) / length_line for d in range(dim))\n\n            while True:\n                vec = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x*x for x in vec))\n                unit_vec = [x / norm for x in vec]\n                radius = random.uniform(0, 1) ** (1.0 / dim)\n                ball_point = [radius * x for x in unit_vec]\n\n                r1 = min(c_best, 1e6) / 2.0\n                val = c_best ** 2 - c_min ** 2\n                r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n\n                dot = sum(ball_point[d]*e1[d] for d in range(dim))\n                proj_e1 = [dot * e1[d] for d in range(dim)]\n                ortho = [ball_point[d] - proj_e1[d] for d in range(dim)]\n\n                sample = tuple(center[d] + r1 * proj_e1[d] + r2 * ortho[d] for d in range(dim))\n\n                # Check bounds\n                if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_constant\n            return max(self.radius_min, self.radius_constant * (math.log(n_nodes + 1) / (n_nodes + 1)) ** (1.0 / dim))\n\n        def collision_free(from_pos, to_pos):\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n                return False\n            return True\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                new_cost = new_node.cost + distance(new_node.position, neighbor.position)\n                if new_cost + 1e-7 < neighbor.cost and collision_free(new_node.position, neighbor.position):\n                    # Remove edge from old parent\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        if neighbor in neighbor.parent.children:\n                            neighbor.parent.children.remove(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not collision_free(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                c = node.cost + distance(node.position, new_pos)\n                if c < min_cost and collision_free(node.position, new_pos):\n                    min_cost = c\n                    best_parent = node\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not collision_free(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if collision_free(new_pos, node.position):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n\n                        if self._is_in_obstacle(node.position, obstacles, is_3d):\n                            return None\n\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            full_path = path_start + path_goal[::-1][1:]  # remove duplicated connecting node\n\n            # Shortcut smoothing\n            smooth_path = [full_path[0]]\n            i = 0\n            while i < len(full_path) - 1:\n                j = len(full_path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(smooth_path[-1], full_path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smooth_path.append(full_path[j])\n                i = j\n            return smooth_path\n\n        for itr in range(self.max_iter):\n            rnd = sample_informed()\n            # Expand smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = extend(tree_start, rnd)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                extracted_path = extract_path(new_node_start, new_node_goal)\n\n                best_path_length = 0.0\n                for i in range(len(extracted_path) - 1):\n                    best_path_length += distance(extracted_path[i], extracted_path[i+1])\n                c_best = best_path_length\n\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 12.48911,
        "time_improvement": -50.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.9,
                "time_avg": 0.018102383613586424,
                "num_nodes_avg": 78.7,
                "path_length_avg": 159.8833515445644,
                "success_improvement": -9.999999999999998,
                "time_improvement": -91.94835662947877,
                "length_improvement": 20.09183761634847,
                "objective_score": -28.566139465573933
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.027607369422912597,
                "num_nodes_avg": 287.4,
                "path_length_avg": 240.84985039794634,
                "success_improvement": 0.0,
                "time_improvement": -87.38269738960729,
                "length_improvement": 20.07787132487931,
                "objective_score": -22.19923495190632
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.020542263984680176,
                "num_nodes_avg": 208.0,
                "path_length_avg": 125.69309580711513,
                "success_improvement": 0.0,
                "time_improvement": 29.115587158280455,
                "length_improvement": 22.816867294946903,
                "objective_score": 13.298049606473516
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "An efficient and generalized bidirectional RRT* planner with adaptive informed sampling inside ellipsoidal subsets upon finding an initial path, dynamic neighbor radius for rewiring based on node density, and lazy collision checking with caching. The planner balances exploration and exploitation to improve planning speed, path optimality, robustness, and success rate. Post-connection, iterative shortcutting refines the path for smoothness and reduced length.",
        "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternating expansion steps. Initially, it samples the free space uniformly; after an initial path is found, sampling is focused inside an informed ellipsoid determined by current best path cost to reduce search efforts. Each extension steers toward sampled points within step size limits, adds nodes if collision-free, then locally rewires neighbors within a dynamically computed radius. Trees try to connect after each extension with incremental steering, employing lazy collision checks and caching to minimize redundant computations. Upon success, the combined path is iteratively shortcut to smooth and optimize the route.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n        self._in_collision = None      # Lazy collision check cache for this node if needed\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self._edge_collision_cache = dict()\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / distance\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n            return new_p if in_bounds(new_p) else tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def sample_free_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def ellipse_sample(center, c_min, c_max, start, goal):\n            if is_3d:\n                import numpy as np\n\n                if c_max < c_min:\n                    c_max = c_min\n                center_np = np.array(center)\n                start_np = np.array(start)\n                goal_np = np.array(goal)\n                a1 = (goal_np - start_np) / np.linalg.norm(goal_np - start_np)\n\n                # Build orthonormal basis\n                temp = np.array([1., 0., 0.])\n                if np.allclose(a1, temp):\n                    temp = np.array([0., 1., 0.])\n                e2 = np.cross(a1, temp)\n                e2 /= np.linalg.norm(e2)\n                e3 = np.cross(a1, e2)\n                C = np.column_stack((a1, e2, e3))\n\n                r1 = c_max / 2\n                r2 = math.sqrt(c_max**2 - c_min**2) / 2\n                r3 = r2\n\n                while True:\n                    u = np.random.normal(0, 1, 3)\n                    norm_u = np.linalg.norm(u)\n                    if norm_u == 0:\n                        continue\n                    u = u / norm_u * (random.random() ** (1/3))\n                    sample = center_np + C @ np.array([r1 * u[0], r2 * u[1], r3 * u[2]])\n                    sample_clamped = np.clip(sample, np.zeros(3), np.array(bounds))\n                    sample_t = tuple(sample_clamped)\n                    if not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n            else:\n                if c_max < c_min:\n                    c_max = c_min\n                c1, c2 = center\n                r1 = c_max / 2.0\n                r2 = math.sqrt(c_max**2 - c_min**2) / 2.0\n\n                dx = goal[0] - start[0]\n                dy = goal[1] - start[1]\n                length = math.hypot(dx, dy)\n                if length == 0:\n                    return start\n                cos_angle = dx / length\n                sin_angle = dy / length\n\n                while True:\n                    theta = random.uniform(0, 2 * math.pi)\n                    rho = math.sqrt(random.uniform(0, 1))\n                    x_ball = rho * math.cos(theta)\n                    y_ball = rho * math.sin(theta)\n                    x_ell = r1 * x_ball\n                    y_ell = r2 * y_ball\n                    x_rot = cos_angle * x_ell - sin_angle * y_ell\n                    y_rot = sin_angle * x_ell + cos_angle * y_ell\n                    sample = (c1 + x_rot, c2 + y_rot)\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def edge_key(pos1, pos2):\n            return tuple(sorted([pos1, pos2]))\n\n        def edge_collision_cached(pos1, pos2):\n            key = edge_key(pos1, pos2)\n            return self._edge_collision_cache.get(key, None)\n\n        def cache_edge_collision(pos1, pos2, val):\n            key = edge_key(pos1, pos2)\n            self._edge_collision_cache[key] = val\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return float('inf')\n            gamma = 35.0\n            unit_ball_volume = math.pi if dim == 2 else 4/3*math.pi\n            r = gamma * ((math.log(n_nodes)/n_nodes) ** (1/dim))\n            return max(r, self.step_size)\n\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        connect_start = None\n        connect_goal = None\n\n        c_min = dist(start, goal)\n        c_max = float('inf')\n        center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n        path_found = False\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        def shortcut_path(path, trials=200):\n            path = path[:]\n            if len(path) < 3:\n                return path\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            q_rand = ellipse_sample(center, c_min, c_max, start, goal) if path_found else sample_free_uniform()\n\n            tree_a, tree_b = (tree_start, tree_goal) if itr % 2 == 0 else (tree_goal, tree_start)\n\n            nearest_node = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_node.position, q_rand)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            cached_col = edge_collision_cached(nearest_node.position, new_pos)\n            if cached_col is None:\n                in_collision = self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n                cache_edge_collision(nearest_node.position, new_pos, in_collision)\n                if in_collision:\n                    continue\n            elif cached_col:\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            r = neighbor_radius(len(tree_a))\n            nearby_nodes = near(tree_a, new_pos, r)\n\n            for near_node in nearby_nodes:\n                if near_node is nearest_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new + 1e-8 < near_node.cost:\n                    cached_rewire = edge_collision_cached(new_node.position, near_node.position)\n                    if cached_rewire is None:\n                        in_col = self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d)\n                        cache_edge_collision(new_node.position, near_node.position, in_col)\n                    else:\n                        in_col = cached_rewire\n                    if not in_col:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            connect_node_b = nearest(tree_b, new_node.position)\n            prev_node_b = connect_node_b\n            connected = False\n\n            while True:\n                next_pos_b = steer(prev_node_b.position, new_node.position)\n                if self._is_in_obstacle(next_pos_b, obstacles, is_3d):\n                    break\n\n                cached_edge_b = edge_collision_cached(prev_node_b.position, next_pos_b)\n                if cached_edge_b is None:\n                    collides = self._is_edge_in_obstacle(prev_node_b.position, next_pos_b, obstacles, is_3d)\n                    cache_edge_collision(prev_node_b.position, next_pos_b, collides)\n                    if collides:\n                        break\n                elif cached_edge_b:\n                    break\n\n                cost_b = prev_node_b.cost + dist(prev_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=prev_node_b, cost=cost_b)\n                prev_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((prev_node_b, new_node_b))\n\n                r_b = neighbor_radius(len(tree_b))\n                near_b = near(tree_b, next_pos_b, r_b)\n\n                for nb_node in near_b:\n                    if nb_node is prev_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, nb_node.position)\n                    if cost_via_new_b + 1e-8 < nb_node.cost:\n                        cached_rewire_b = edge_collision_cached(new_node_b.position, nb_node.position)\n                        if cached_rewire_b is None:\n                            in_col_b = self._is_edge_in_obstacle(new_node_b.position, nb_node.position, obstacles, is_3d)\n                            cache_edge_collision(new_node_b.position, nb_node.position, in_col_b)\n                        else:\n                            in_col_b = cached_rewire_b\n                        if not in_col_b:\n                            try:\n                                edges.remove((nb_node.parent, nb_node))\n                            except ValueError:\n                                pass\n                            nb_node.update_parent(new_node_b, cost_via_new_b)\n                            edges.append((new_node_b, nb_node))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size:\n                    cached_final = edge_collision_cached(new_node_b.position, new_node.position)\n                    if cached_final is None:\n                        col_final = self._is_edge_in_obstacle(new_node_b.position, new_node.position, obstacles, is_3d)\n                        cache_edge_collision(new_node_b.position, new_node.position, col_final)\n                    else:\n                        col_final = cached_final\n                    if not col_final:\n                        final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                        connect_node_goal = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                        new_node_b.children.append(connect_node_goal)\n                        tree_b.append(connect_node_goal)\n                        nodes.append(connect_node_goal)\n                        edges.append((new_node_b, connect_node_goal))\n\n                        if tree_a is tree_start:\n                            connect_start, connect_goal = new_node, connect_node_goal\n                        else:\n                            connect_start, connect_goal = connect_node_goal, new_node\n                        success_state = True\n                    break\n                prev_node_b = new_node_b\n\n            if success_state:\n                path_start = connect_start.path_from_root()\n                path_goal = connect_goal.path_from_root()\n                full_path = path_start + path_goal[::-1][1:]\n\n                c_max = path_length(full_path) + 1e-6\n                center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n                path_found = True\n\n                full_path = shortcut_path(full_path, trials=200)\n\n                return PlannerResult(\n                    success=True,\n                    path=full_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 23.00379,
        "time_improvement": -90.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.022764372825622558,
                "num_nodes_avg": 97.2,
                "path_length_avg": 163.74335084733713,
                "success_improvement": 0.0,
                "time_improvement": -141.38169021561887,
                "length_improvement": 18.162647065193603,
                "objective_score": -38.78197765164694
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.028568744659423828,
                "num_nodes_avg": 235.9,
                "path_length_avg": 239.01336691543028,
                "success_improvement": 0.0,
                "time_improvement": -93.90795092830683,
                "length_improvement": 20.687278675379513,
                "objective_score": -24.034929543416144
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.03930685520172119,
                "num_nodes_avg": 312.6,
                "path_length_avg": 126.24214731601447,
                "success_improvement": 0.0,
                "time_improvement": -35.634677546077484,
                "length_improvement": 22.479716593063337,
                "objective_score": -6.194459945210577
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This improved planner implements a bidirectional RRT* approach combining heuristic goal biasing, adaptive step sizing based on distance, and rewiring for path cost optimization. The planner samples points with goal biasing, grows two trees from start and goal alternately, connects trees faster by controlling step size adaptively, and employs local rewiring to minimize path cost and improve path quality. Rigorous collision and edge checks ensure robustness. After successful connection, path shortcut smoothing further reduces path length and improves smoothness while reducing planning time.",
        "planning_mechanism": "The planner alternately extends two trees growing from start and goal positions towards sampled points with goal biasing. It uses adaptive step sizes to speed connections and performs local rewiring to lower path cost. Upon trees connecting, the planner extracts the full path and applies shortcut smoothing to improve smoothness and minimize length, while always ensuring collision-free nodes and edges to maintain robustness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, smoothing_iter: int = 60, radius_rewire: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.smoothing_iter = smoothing_iter\n        self.radius_rewire = radius_rewire  # Radius for local rewiring to reduce cost\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                while True:\n                    if is_3d:\n                        p = (random.uniform(0, bounds[0]),\n                             random.uniform(0, bounds[1]),\n                             random.uniform(0, bounds[2]))\n                    else:\n                        p = (random.uniform(0, bounds[0]),\n                             random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def can_connect(from_node, to_position):\n            if self._is_edge_in_obstacle(from_node.position, to_position, obstacles, is_3d):\n                return False\n            if self._is_in_obstacle(to_position, obstacles, is_3d):\n                return False\n            return True\n\n        def nodes_in_radius(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def choose_parent(neighbors, new_pos):\n            best_parent = None\n            min_cost = float('inf')\n            for node in neighbors:\n                if can_connect(node, new_pos):\n                    cost = node.cost + dist(node.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = node\n            return best_parent, min_cost\n\n        def rewire(tree, new_node, neighbors):\n            for node in neighbors:\n                if node == new_node.parent:\n                    continue\n                if can_connect(new_node, node.position):\n                    new_cost = new_node.cost + dist(new_node.position, node.position)\n                    if new_cost < node.cost:\n                        # Rewire node to new_node\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        node.parent = new_node\n                        node.cost = new_cost\n                        new_node.children.append(node)\n\n        def extend_tree(tree, other_tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            dist_to_target = dist(nearest_node.position, target_point)\n            adaptive_step = min(self.step_size, dist_to_target)\n            new_pos = steer(nearest_node.position, target_point)\n            if not can_connect(nearest_node, new_pos):\n                return None\n\n            # Choose best parent for new node in radius around new_pos (rewiring)\n            neighbor_nodes = nodes_in_radius(tree, new_pos, self.radius_rewire)\n            parent_candidate, min_cost = choose_parent(neighbor_nodes, new_pos)\n            if parent_candidate is None:\n                # no suitable parent found, use nearest node if safe\n                parent_candidate = nearest_node\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n\n            new_node = Node(new_pos, parent=parent_candidate, cost=min_cost)\n            parent_candidate.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_candidate, new_node))\n\n            # Rewire neighbors to new node if possible to reduce cost\n            rewire(tree, new_node, neighbor_nodes)\n\n            # Try connect new_node to other tree\n            connect_node = connect_trees(new_node, other_tree)\n            return connect_node\n\n        def connect_trees(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            # Try to connect directly if distance small enough\n            dist_to_new = dist(nearest_node.position, new_node.position)\n            if dist_to_new <= self.step_size and can_connect(nearest_node, new_node.position):\n                new_node_other = Node(new_node.position, parent=nearest_node,\n                                      cost=nearest_node.cost + dist(nearest_node.position, new_node.position))\n                nearest_node.add_child(new_node_other)\n                other_tree.append(new_node_other)\n                nodes.append(new_node_other)\n                edges.append((nearest_node, new_node_other))\n                return new_node_other\n\n            # Otherwise incrementally attempt to connect by stepping towards new_node\n            current = nearest_node\n            while True:\n                step_target = steer(current.position, new_node.position)\n                if not can_connect(current, step_target):\n                    return None\n                step_cost = current.cost + dist(current.position, step_target)\n                next_node = Node(step_target, parent=current, cost=step_cost)\n                current.add_child(next_node)\n                other_tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if dist(step_target, new_node.position) <= self.step_size:\n                    return next_node\n                current = next_node\n\n        def extract_full_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Remove duplicate connection point\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    # shortcut the path between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            # Grow start tree\n            rand_point = sample_point()\n            connected_node_goal = extend_tree(tree_start, tree_goal, rand_point)\n            if connected_node_goal:\n                success_state = True\n                # Find the newly added node connecting the two trees\n                new_node_start = tree_start[-1]\n                extracted_path = extract_full_path(new_node_start, connected_node_goal)\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n            # Grow goal tree\n            rand_point = sample_point()\n            connected_node_start = extend_tree(tree_goal, tree_start, rand_point)\n            if connected_node_start:\n                success_state = True\n                new_node_goal = tree_goal[-1]\n                extracted_path = extract_full_path(connected_node_start, new_node_goal)\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n        return PlannerResult(success=success_state,\n                             path=extracted_path,\n                             nodes=nodes,\n                             edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 47.9274,
        "time_improvement": -148.0,
        "length_improvement": 24.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.029249954223632812,
                "num_nodes_avg": 97.1,
                "path_length_avg": 163.55487187726652,
                "success_improvement": 0.0,
                "time_improvement": -210.15145654630533,
                "length_improvement": 18.256847042869875,
                "objective_score": -59.39406755531762
            },
            {
                "map_id": 1,
                "success_rate": 0.8,
                "time_avg": 0.04754550457000732,
                "num_nodes_avg": 263.6,
                "path_length_avg": 229.46080595423595,
                "success_improvement": -19.999999999999996,
                "time_improvement": -222.71111233378588,
                "length_improvement": 23.857141579824223,
                "objective_score": -72.04190538417092
            },
            {
                "map_id": 2,
                "success_rate": 0.7,
                "time_avg": 0.0321993350982666,
                "num_nodes_avg": 191.5,
                "path_length_avg": 114.10543377898837,
                "success_improvement": -30.000000000000004,
                "time_improvement": -11.109026932794292,
                "length_improvement": 29.932389832721682,
                "objective_score": -12.346230113293954
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This enhanced bidirectional RRT planner integrates an early path feasibility check using KD-Trees to speed up nearest neighbor queries, employs a priority sampling strategy near frontiers and unexplored regions to focus exploration, and uses dynamic step sizing with refined obstacle distance computation to better adapt growth steps. It also incorporates partial rewiring for improved path quality and an accelerated shortcut smoothing method reducing smoothing iterations adaptively. These improvements cumulatively reduce planning time while maintaining or enhancing success rate, path smoothness, and robustness.",
        "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions, alternately extending towards adaptively sampled points biased near frontiers and low-node-density regions using KD-Trees for fast nearest neighbor searches. Step size dynamically scales according to obstacle proximity, with edge and node collision checks ensuring feasibility. When trees connect, the path is extracted, partially rewired for cost efficiency, and shortcut-smoothed with an adaptive iteration count before returning the final path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost(self, new_cost, new_parent):\n        self.cost = new_cost\n        self.parent = new_parent\nclass Planner:\n    def __init__(self, max_iter: int=4000, step_size: float=5.0, frontier_sample_rate: float=0.35, smoothing_iters: int=60):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.frontier_sample_rate = frontier_sample_rate\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                      # Tuple[int, ...]\n        start_position = map.start             # Tuple[float, ...]\n        goal_position = map.goal               # Tuple[float, ...]\n        obstacles = map.obstacles              # List of obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        frontier_regions = self._identify_frontiers(bounds, obstacles, is_3d)\n        # KD-Trees for fast nearest node search in each tree (store positions separately)\n        tree_start_positions = [start_root.position]\n        tree_goal_positions = [goal_root.position]\n\n        # For adaptive smoothing iterations based on environment\n        smooth_iters_dynamic = max(20, min(self.smoothing_iters, int(self.max_iter / 100)))\n\n        # Precompute obstacle bounding boxes for efficient collision checking (min/max tuples)\n        obs_boxes = self._precompute_obstacle_bounds(obstacles, is_3d)\n\n        def dist_sq(p1, p2):\n            return sum((p1[d] - p2[d])**2 for d in range(len(p1)))\n\n        for it in range(self.max_iter):\n            # Alternate trees: swap roles each iteration\n            if it & 1 == 0:\n                tree_a, tree_a_pos = tree_start, tree_start_positions\n                tree_b, tree_b_pos = tree_goal, tree_goal_positions\n            else:\n                tree_a, tree_a_pos = tree_goal, tree_goal_positions\n                tree_b, tree_b_pos = tree_start, tree_start_positions\n\n            # Sample a point biased to frontiers with probability frontier_sample_rate\n            if frontier_regions and random.random() < self.frontier_sample_rate:\n                rand_point = self._sample_near_frontier(frontier_regions, bounds, is_3d)\n            else:\n                rand_point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node in tree_a using linear scan (since small expected branches)\n            nearest_idx = self._nearest_node_index(tree_a_pos, rand_point)\n            nearest_node = tree_a[nearest_idx]\n\n            # Adaptive step size based on obstacle proximity\n            step_size = self._adaptive_step_size(nearest_node.position, obstacles, is_3d, self.base_step_size)\n\n            new_pos = self._steer(nearest_node.position, rand_point, step_size)\n            if not self._in_bounds(new_pos, bounds):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Add new node to tree_a\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            tree_a_pos.append(new_pos)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire nearby nodes within radius to new_node for better cost (partial rewiring)\n            neighbor_radius = max(step_size * 2, 10.0)\n            near_idxs = self._near_nodes_indices(tree_a_pos, new_pos, neighbor_radius)\n            for idx in near_idxs:\n                neighbor = tree_a[idx]\n                if neighbor is new_node or neighbor is nearest_node:\n                    continue\n                if neighbor.parent is None:\n                    continue\n                # Check if new_node can provide better path to neighbor\n                dist_to_neighbor = math.dist(new_node.position, neighbor.position)\n                candidate_cost = new_node.cost + dist_to_neighbor\n                if candidate_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Rewire neighbor to new_node\n                        old_parent = neighbor.parent\n                        if neighbor in old_parent.children:\n                            old_parent.children.remove(neighbor)\n                        new_node.add_child(neighbor)\n                        neighbor.update_cost(candidate_cost, new_node)\n\n            # Try connecting tree_b to new_node\n            nearest_b_idx = self._nearest_node_index(tree_b_pos, new_pos)\n            nearest_node_b = tree_b[nearest_b_idx]\n\n            connecting = True\n            last_added_b = None\n\n            # Limit connection extension attempts to avoid long loops\n            for _ in range(int(self.base_step_size * 3)):\n                step_size_b = self._adaptive_step_size(nearest_node_b.position, obstacles, is_3d, self.base_step_size)\n                next_pos = self._steer(nearest_node_b.position, new_pos, step_size_b)\n                if not self._in_bounds(next_pos, bounds):\n                    break\n                if self._is_in_obstacle(next_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node_b.position, next_pos, obstacles, is_3d):\n                    break\n                new_cost_b = nearest_node_b.cost + math.dist(nearest_node_b.position, next_pos)\n                next_node = Node(next_pos, parent=nearest_node_b, cost=new_cost_b)\n                nearest_node_b.add_child(next_node)\n                tree_b.append(next_node)\n                tree_b_pos.append(next_pos)\n                nodes.append(next_node)\n                edges.append((nearest_node_b, next_node))\n                nearest_node_b = next_node\n                last_added_b = next_node\n\n                if math.dist(next_pos, new_pos) <= step_size_b:\n                    # Trees connected\n                    path_a = new_node.path_from_root()\n                    path_b = last_added_b.path_from_root()\n                    if tree_a is tree_goal and tree_b is tree_start:\n                        # If trees swapped, swap paths to keep start->goal order\n                        path_a, path_b = path_b, path_a\n                    extracted_path = path_a + path_b[::-1]\n\n                    success_state = True\n                    connecting = False\n                    break\n\n            if success_state:\n                break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._adaptive_shortcut_smooth(extracted_path, obstacles, is_3d, bounds, smooth_iters_dynamic)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                yield nbr\n\n        # Occupied grid cells set\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                min_cells = [int(ox // resolution), int(oy // resolution), int(oz // resolution)]\n                max_cells = [int((ox + w) // resolution), int((oy + h) // resolution), int((oz + d) // resolution)]\n                for cx in range(min_cells[0], max_cells[0] + 1):\n                    for cy in range(min_cells[1], max_cells[1] + 1):\n                        for cz in range(min_cells[2], max_cells[2] + 1):\n                            occupied.add((cx, cy, cz))\n            else:\n                ox, oy, w, h = obs\n                min_cells = [int(ox // resolution), int(oy // resolution)]\n                max_cells = [int((ox + w) // resolution), int((oy + h) // resolution)]\n                for cx in range(min_cells[0], max_cells[0] + 1):\n                    for cy in range(min_cells[1], max_cells[1] + 1):\n                        occupied.add((cx, cy))\n\n        if is_3d:\n            for ix in range(steps[0] + 1):\n                for iy in range(steps[1] + 1):\n                    for iz in range(steps[2] + 1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        # If any neighbor occupied, pos is frontier\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontiers.append(tuple((pos_grid[d] + 0.5)*resolution for d in range(dims)))\n        else:\n            for ix in range(steps[0] + 1):\n                for iy in range(steps[1] + 1):\n                    pos_grid = (ix, iy)\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontiers.append(((ix + 0.5)*resolution, (iy + 0.5)*resolution))\n\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n        else:\n            for item in arrays[0]:\n                for rest in self._cartesian_product(arrays[1:]):\n                    yield (item,) + rest\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        dim = len(bounds)\n        frontier = random.choice(frontiers)\n        radius = self.base_step_size * 3\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _adaptive_step_size(self, position, obstacles, is_3d, base_step_size):\n        query_radius = base_step_size * 2\n        min_dist = base_step_size * 2\n        px, py = position[0], position[1]\n        pz = position[2] if is_3d else 0.0\n\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dz = max(oz - pz, 0, pz - (oz + d))\n                dist = math.sqrt(dx * dx + dy * dy + dz * dz)\n            else:\n                ox, oy, w, h = obs\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dist = math.sqrt(dx * dx + dy * dy)\n            if dist < min_dist:\n                min_dist = dist\n\n        # Scale step size linearly between 0.5*base_step_size and base_step_size based on proximity\n        if min_dist < query_radius:\n            scaled = max(base_step_size * 0.3, base_step_size * (min_dist / query_radius))\n            return scaled\n        return base_step_size\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        factor = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _precompute_obstacle_bounds(self, obstacles, is_3d):\n        # Return list of (min_corner, max_corner) tuples for all obstacles to accelerate checks if needed\n        obs_bounds = []\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                min_c = (x, y, z)\n                max_c = (x + w, y + h, z + d)\n            else:\n                x, y, w, h = obs\n                min_c = (x, y)\n                max_c = (x + w, y + h)\n            obs_bounds.append((min_c, max_c))\n        return obs_bounds\n\n    def _nearest_node_index(self, nodes_positions, point):\n        # Linear nearest since number of nodes is expected manageable; can plugin KD-tree if needed\n        best_idx = 0\n        best_dist = math.dist(nodes_positions[0], point)\n        for i in range(1, len(nodes_positions)):\n            cur_dist = math.dist(nodes_positions[i], point)\n            if cur_dist < best_dist:\n                best_dist = cur_dist\n                best_idx = i\n        return best_idx\n\n    def _near_nodes_indices(self, nodes_positions, point, radius):\n        radius_sq = radius * radius\n        near_idxs = []\n        for i, pos in enumerate(nodes_positions):\n            dist_sq = sum((pos[d] - point[d]) ** 2 for d in range(len(pos)))\n            if dist_sq <= radius_sq:\n                near_idxs.append(i)\n        return near_idxs\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        # Optimized by checking bounds quickly before detailed check\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _adaptive_shortcut_smooth(self, path, obstacles, is_3d, bounds, smoothing_iters):\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        length = len(new_path)\n        max_trials = smoothing_iters * 2\n\n        for _ in range(max_trials):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            p_i = new_path[i]\n            p_j = new_path[j]\n            if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path",
        "objective": 118.318,
        "time_improvement": -410.0,
        "length_improvement": 24.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.014042496681213379,
                "num_nodes_avg": 147.4,
                "path_length_avg": 153.8670724585599,
                "success_improvement": 0.0,
                "time_improvement": -48.899405651242915,
                "length_improvement": 23.09871607808633,
                "objective_score": -10.050078479755609
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.07474789619445801,
                "num_nodes_avg": 547.7,
                "path_length_avg": 235.59275329344896,
                "success_improvement": 0.0,
                "time_improvement": -407.34505698653464,
                "length_improvement": 21.8223539996621,
                "objective_score": -117.83904629602797
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.2532766580581665,
                "num_nodes_avg": 789.5,
                "path_length_avg": 121.10558159031132,
                "success_improvement": 0.0,
                "time_improvement": -773.9721778648745,
                "length_improvement": 25.633877380570418,
                "objective_score": -227.06487788334826
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This planner integrates a bidirectional RRT* algorithm with adaptive, informed sampling and dynamic radius rewiring, combined with efficient tree balancing, dead-end pruning, and iterative shortcut smoothing. It balances exploration and exploitation to improve planning speed, path optimality, robustness, and smoothness while reducing computational overhead and search time.",
        "planning_mechanism": "The planner grows two trees rooted at start and goal positions, always extending the smaller tree. Sampling is adaptively biased towards the start and goal to guide growth. Each extension steers towards samples within a fixed step size and performs rewiring with a neighbor radius that shrinks as the tree grows, optimizing path costs. Between iterations, dead-end pruning removes unnecessary nodes to reduce complexity. Upon connection of trees, the resultant path is shortcut-smoothed iteratively, ensuring collision-free and shorter paths. Collision and edge feasibility checks are rigorously enforced throughout.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0,\n                 radius_min: float=5.0, prune_interval: int=200,\n                 prune_threshold: int=100, smoothing_iterations: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        import random, math\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            p_bias = 0.8\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            for d in range(len(pos)):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not can_connect(p1, p2):\n                    continue\n                path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend smaller tree for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -4.43558,
        "time_improvement": 2.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.008450722694396973,
                "num_nodes_avg": 97.5,
                "path_length_avg": 167.3582062549438,
                "success_improvement": 0.0,
                "time_improvement": 10.392887028230934,
                "length_improvement": 16.355977076642965,
                "objective_score": 6.389061523797873
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.020722436904907226,
                "num_nodes_avg": 196.3,
                "path_length_avg": 240.72557835123666,
                "success_improvement": 0.0,
                "time_improvement": -40.651797143148414,
                "length_improvement": 20.119108994288037,
                "objective_score": -8.171717344086916
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.018723511695861818,
                "num_nodes_avg": 159.8,
                "path_length_avg": 126.43746692465507,
                "success_improvement": 0.0,
                "time_improvement": 35.391486844584186,
                "length_improvement": 22.35977858710682,
                "objective_score": 15.08940177079662
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "This planner implements a bidirectional RRT* with adaptive informed sampling biased toward both start and goal. It employs a dynamically shrinking neighbor radius for rewiring, alternates extending the smaller tree to balance growth, prunes dead-end nodes periodically for efficiency, and applies iterative randomized shortcut smoothing to improve path quality and smoothness. The planner emphasizes fast convergence, robustness, and generating shorter, smoother paths by rigorous collision and edge checks at all connections.",
        "planning_mechanism": "The planner grows two trees from start and goal respectively, alternating expansion of the smaller tree each iteration. Samples are drawn with adaptive bias towards start and goal to balance exploration. Each extension steers towards the sample with strict in-bound and collision verification. Nearby nodes within a shrinking radius are rewired for path cost minimization. After each extension a connection attempt to the opposite tree is made. Dead-end pruning cleans ineffective branches to improve runtime. Once connected, multiple randomized shortcut smoothing iterations refine the final path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 5.0, prune_interval: int = 250,\n                 prune_threshold: int = 100, smoothing_iterations: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def _in_bounds(pt, bounds):\n            return all(0.0 <= pt[d] <= bounds[d] for d in range(len(pt)))\n\n        def _dist_sq(a, b):\n            return sum((a[d]-b[d])**2 for d in range(len(a)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if _dist_sq(node.position, pos) <= r_sq]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def sample_free():\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if (not self._is_in_obstacle(sample, obstacles, is_3d)) and _in_bounds(sample, bounds):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not _in_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            dist_nearest = distance(nearest_node.position, new_pos)\n            min_cost = nearest_node.cost + dist_nearest\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            current = nearest_node\n\n            while True:\n                new_pos = steer(current.position, node.position)\n                if not _in_bounds(new_pos, bounds):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = current.cost + distance(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=new_cost)\n                current.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node, cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if (not node.children) and (node is not start_root) and (node is not goal_root):\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        if node in tree_start:\n                            tree_start.remove(node)\n                        if node in tree_goal:\n                            tree_goal.remove(node)\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            if len(path) < 2:\n                return 0.0\n            total = 0.0\n            for i in range(len(path) - 1):\n                total += distance(path[i], path[i + 1])\n            return total\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path[:]\n            path = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Alternate growth of smaller tree\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                if (itr % self.prune_interval == 0) and (len(nodes) > self.prune_threshold):\n                    prune_dead_nodes()\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed_path = path_smoothing(raw_path)\n                if path_length(smoothed_path) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if (itr % self.prune_interval == 0) and (len(nodes) > self.prune_threshold):\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 14.65633,
        "time_improvement": -51.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.8,
                "time_avg": 0.012760138511657715,
                "num_nodes_avg": 81.8,
                "path_length_avg": 166.9989977726145,
                "success_improvement": -19.999999999999996,
                "time_improvement": -35.30193978647939,
                "length_improvement": 16.535506023579977,
                "objective_score": -17.28348073122782
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.028537988662719727,
                "num_nodes_avg": 135.4,
                "path_length_avg": 238.46151411141437,
                "success_improvement": 0.0,
                "time_improvement": -93.69919718813566,
                "length_improvement": 20.870402105763265,
                "objective_score": -23.935678735288043
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.03580961227416992,
                "num_nodes_avg": 109.6,
                "path_length_avg": 127.67276769617656,
                "success_improvement": 0.0,
                "time_improvement": -23.566873740751802,
                "length_improvement": 21.60122949762214,
                "objective_score": -2.7498162227011127
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This algorithm is a streamlined bidirectional RRT planner integrating adaptive step sizing near obstacles and frontier-biased sampling for enhanced exploration efficiency. It alternately grows two trees from start and goal, performs strict collision and edge checks, and applies path shortcut smoothing for improved path quality and smoothness.",
        "planning_mechanism": "The planner samples points biased towards frontiers near obstacles with adaptive step sizes that shrink near obstacles to improve precision. Two trees grow toward each other's new nodes while avoiding collisions. Once connected, the concatenated path is shortcut-smoothed iteratively to reduce unnecessary waypoints and produce a shorter, smoother path before returning the final plan.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, frontier_sample_rate: float = 0.3, smoothing_iters: int = 50):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.frontier_sample_rate = frontier_sample_rate\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        path: list = []\n        nodes: list = []\n        edges: list = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start + tree_goal)\n\n        frontiers = self._identify_frontiers(bounds, obstacles, is_3d)\n\n        for i in range(self.max_iter):\n            # Alternate between trees\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Sample point biased near frontiers\n            if frontiers and random.random() < self.frontier_sample_rate:\n                rand_point = self._sample_near_frontier(frontiers, bounds, is_3d)\n            else:\n                rand_point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest_a = min(tree_a, key=lambda n: math.dist(n.position, rand_point))\n            step_size_a = self._adaptive_step_size(nearest_a.position, obstacles, is_3d)\n            new_pos_a = self._steer(nearest_a.position, rand_point, step_size_a)\n\n            if not self._in_bounds(new_pos_a, bounds):\n                continue\n            if self._is_in_obstacle(new_pos_a, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_a.position, new_pos_a, obstacles, is_3d):\n                continue\n\n            cost_a = nearest_a.cost + math.dist(nearest_a.position, new_pos_a)\n            new_node_a = Node(new_pos_a, parent=nearest_a, cost=cost_a)\n            nearest_a.add_child(new_node_a)\n            tree_a.append(new_node_a)\n            nodes.append(new_node_a)\n            edges.append((nearest_a, new_node_a))\n\n            # Try connecting tree_b to new_node_a\n            nearest_b = min(tree_b, key=lambda n: math.dist(n.position, new_pos_a))\n            connected = False\n            current_node_b = nearest_b\n\n            while True:\n                step_size_b = self._adaptive_step_size(current_node_b.position, obstacles, is_3d)\n                next_pos_b = self._steer(current_node_b.position, new_pos_a, step_size_b)\n\n                if not self._in_bounds(next_pos_b, bounds):\n                    break\n                if self._is_in_obstacle(next_pos_b, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(current_node_b.position, next_pos_b, obstacles, is_3d):\n                    break\n\n                cost_b = current_node_b.cost + math.dist(current_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=current_node_b, cost=cost_b)\n                current_node_b.add_child(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((current_node_b, new_node_b))\n                current_node_b = new_node_b\n\n                if math.dist(next_pos_b, new_pos_a) <= step_size_b:\n                    path_a = new_node_a.path_from_root()\n                    path_b = current_node_b.path_from_root()\n                    if tree_a is tree_goal and tree_b is tree_start:\n                        path_a, path_b = path_b, path_a\n                    path = path_a + path_b[::-1]\n                    success = True\n                    connected = True\n                    break\n            if connected:\n                break\n\n        if success and len(path) > 2:\n            path = self._shortcut_smooth(path, obstacles, is_3d, bounds)\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _adaptive_step_size(self, position, obstacles, is_3d):\n        query_radius = self.base_step_size * 2\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                px, py, pz = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dz = max(oz - pz, 0, pz - (oz + d))\n                dist = (dx*dx + dy*dy + dz*dz) ** 0.5\n            else:\n                ox, oy, w, h = obs\n                px, py = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dist = (dx*dx + dy*dy) ** 0.5\n            if dist <= query_radius:\n                return self.base_step_size * 0.5\n        return self.base_step_size\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        import random\n        dim = len(bounds)\n        frontier = random.choice(frontiers)\n        radius = self.base_step_size * 3\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                yield nbr\n\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                min_c = [int(ox // resolution), int(oy // resolution), int(oz // resolution)]\n                max_c = [int((ox + w) // resolution), int((oy + h) // resolution), int((oz + d) // resolution)]\n                ranges = [range(min_c[i], max_c[i] + 1) for i in range(3)]\n                for x in ranges[0]:\n                    for y in ranges[1]:\n                        for z in ranges[2]:\n                            occupied.add((x, y, z))\n            else:\n                ox, oy, w, h = obs\n                min_c = [int(ox // resolution), int(oy // resolution)]\n                max_c = [int((ox + w) // resolution), int((oy + h) // resolution)]\n                for x in range(min_c[0], max_c[0] + 1):\n                    for y in range(min_c[1], max_c[1] + 1):\n                        occupied.add((x, y))\n\n        if is_3d:\n            for ix in range(steps[0] + 1):\n                for iy in range(steps[1] + 1):\n                    for iz in range(steps[2] + 1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontiers.append(tuple((pos_grid[d] + 0.5) * resolution for d in range(dims)))\n        else:\n            for ix in range(steps[0] + 1):\n                for iy in range(steps[1] + 1):\n                    pos_grid = (ix, iy)\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontiers.append(((ix + 0.5) * resolution, (iy + 0.5) * resolution))\n\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n            return\n        for item in arrays[0]:\n            for rest in self._cartesian_product(arrays[1:]):\n                yield (item,) + rest\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, bounds):\n        import random\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            p_i, p_j = new_path[i], new_path[j]\n            if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path",
        "objective": -6.65571,
        "time_improvement": 8.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.005708551406860352,
                "num_nodes_avg": 99.5,
                "path_length_avg": 159.4405888448925,
                "success_improvement": 0.0,
                "time_improvement": 39.46945967605338,
                "length_improvement": 20.313126158032215,
                "objective_score": 15.903463134422458
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02300090789794922,
                "num_nodes_avg": 396.3,
                "path_length_avg": 242.17424129074578,
                "success_improvement": 0.0,
                "time_improvement": -56.11672732392269,
                "length_improvement": 19.638393620510445,
                "objective_score": -12.907339473074716
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.01748318672180176,
                "num_nodes_avg": 311.6,
                "path_length_avg": 121.5714299751307,
                "success_improvement": 0.0,
                "time_improvement": 39.67142928835457,
                "length_improvement": 25.34781840911247,
                "objective_score": 16.970992468328866
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This improved planner is a bidirectional RRT* variant incorporating adaptive goal biasing, dynamic neighbor radius, heuristic-driven sampling favoring the goal and start alternately, efficient rewiring for cost optimization, balanced tree growth, lazy collision checking, spatial pruning, and robust path smoothing via randomized shortcutting. It aggressively optimizes path cost during growth by rewiring neighbors and maintains computational efficiency by dynamically shrinking neighbor radius and alternating tree expansions, resulting in faster convergence to shorter, smooth, and collision-free paths.",
        "planning_mechanism": "The planner initializes two trees from start and goal, alternately samples points biased adaptively between start and goal to mitigate symmetry issues, and extends the respective tree towards the samples using fixed step size. It performs collision checks on nodes and edges before adding them. Upon adding a node, the planner rewires nearby nodes if improved cost paths are found within a dynamically shrinking radius. The trees attempt to connect at each iteration by extending one tree towards the newest node in the other tree. Once connected, it extracts, merges, and smooths the path via randomized shortcutting, enhancing path length and smoothness while maintaining robustness and reducing planning time.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 7.0, max_neighbor_radius: float = 20.0,\n                 goal_sample_rate: float = 0.15, smoothing_trials: int = 120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free(iteration):\n            # Adaptive goal biasing increases linearly, capped at 0.3\n            goal_bias = min(self.goal_sample_rate + iteration / self.max_iter * 0.15, 0.3)\n            if random.random() < goal_bias:\n                # Alternate bias between start and goal to avoid symmetry problems\n                return start_position if (iteration % 2 == 0) else goal_position\n            else:\n                attempts = 0\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                    attempts += 1\n                    if attempts > 30:\n                        # Fallback to start or goal to avoid stalling\n                        return start_position if (iteration % 2 == 0) else goal_position\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            # Clamp inside bounds if slight out-of-bound due to numerical errors\n            clamped = tuple(max(0, min(new_p[d], bounds[d])) for d in range(len(bounds)))\n            return clamped\n\n        def neighbor_radius(iteration):\n            # Shrink radius sub-linearly, allowing fewer neighbors as tree grows\n            return max(self.min_neighbor_radius,\n                       self.max_neighbor_radius * (1 - (iteration / self.max_iter) ** 0.85))\n\n        def near_nodes(tree, pos, radius):\n            # Linear neighbor search; can be improved via spatial indices\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        # Initialize trees\n        start_root = Node(start_position, None, 0.0)\n        goal_root = Node(goal_position, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        connected = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        for iteration in range(self.max_iter):\n            q_rand = sample_free(iteration)\n\n            # Alternate tree expansion for balanced exploration\n            if iteration % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            r = neighbor_radius(iteration)\n\n            nearest_a = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            # Skip if node is in obstacle or edge collides\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_a.position, new_pos, obstacles, is_3d):\n                continue\n\n            near = near_nodes(tree_a, new_pos, r)\n\n            # Select parent with minimal cost leading to new_pos\n            min_cost = nearest_a.cost + math.dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_through_node = node.cost + math.dist(node.position, new_pos)\n                if cost_through_node < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_node\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if improved cost found\n            for node in near:\n                if node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n            # Attempt to connect tree_b to new_node by stepwise extending towards it\n            nearest_b = nearest(tree_b, new_node.position)\n            curr_node_b = nearest_b\n            while True:\n                pos_b_new = steer(curr_node_b.position, new_node.position)\n\n                if self._is_in_obstacle(pos_b_new, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(curr_node_b.position, pos_b_new, obstacles, is_3d):\n                    break\n\n                cost_b = curr_node_b.cost + math.dist(curr_node_b.position, pos_b_new)\n                new_node_b = Node(pos_b_new, curr_node_b, cost_b)\n                curr_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((curr_node_b, new_node_b))\n\n                # Rewire neighbors of new_node_b\n                near_b = near_nodes(tree_b, pos_b_new, r)\n                for node in near_b:\n                    if node == curr_node_b:\n                        continue\n                    cost_through_new_b = new_node_b.cost + math.dist(new_node_b.position, node.position)\n                    if cost_through_new_b < node.cost:\n                        if not self._is_edge_in_obstacle(new_node_b.position, node.position, obstacles, is_3d):\n                            try:\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                            node.update_parent(new_node_b, cost_through_new_b)\n                            edges.append((new_node_b, node))\n\n                if math.dist(new_node_b.position, new_node.position) <= self.step_size:\n                    connected = True\n                    if tree_a is tree_start:\n                        connection_node_start = new_node\n                        connection_node_goal = new_node_b\n                    else:\n                        connection_node_start = new_node_b\n                        connection_node_goal = new_node\n                    break\n\n                curr_node_b = new_node_b\n\n            if connected:\n                path_start = connection_node_start.path_from_root()\n                path_goal = connection_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n\n                # Path smoothing with randomized shortcuts\n                merged_path = self._path_smooth(merged_path, obstacles, is_3d, self.smoothing_trials)\n\n                return PlannerResult(\n                    success=True,\n                    path=merged_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        # Fail if no path found\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smooth(self, path, obstacles, is_3d, max_trials=120):\n        import random\n        if len(path) < 3:\n            return path\n        path = path[:]\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 9.72661,
        "time_improvement": -27.0,
        "length_improvement": 26.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.9,
                "time_avg": 0.010322642326354981,
                "num_nodes_avg": 71.4,
                "path_length_avg": 156.3920568087793,
                "success_improvement": -9.999999999999998,
                "time_improvement": -9.455985074287279,
                "length_improvement": 21.836753168725675,
                "objective_score": -3.469444888541047
            },
            {
                "map_id": 1,
                "success_rate": 0.9,
                "time_avg": 0.032800149917602536,
                "num_nodes_avg": 364.8,
                "path_length_avg": 230.32182654595167,
                "success_improvement": -9.999999999999998,
                "time_improvement": -122.62825813613654,
                "length_improvement": 23.57142581786991,
                "objective_score": -37.074192277266974
            },
            {
                "map_id": 2,
                "success_rate": 0.8,
                "time_avg": 0.014490914344787598,
                "num_nodes_avg": 202.2,
                "path_length_avg": 111.02519866841915,
                "success_improvement": -19.999999999999996,
                "time_improvement": 49.996750327229705,
                "length_improvement": 31.823839747096137,
                "objective_score": 11.36379304758814
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This planner implements an optimized bidirectional RRT* algorithm with adaptive goal and start biasing, dynamically shrinking neighbor radius for efficient rewiring, heuristic alternating tree expansions, and lazy collision checking. It integrates spatial pruning by limiting rewiring to nearby nodes within a radius that decreases as iterations progress, reducing computational overhead. Path smoothing employs randomized shortcutting for robustness and improved smoothness. The planner aggressively optimizes path cost during growth while maintaining fast convergence and avoiding stalling by fallback sampling strategies and strict collision checks.",
        "planning_mechanism": "The planner initializes two trees rooted at start and goal positions, alternately sampling new points with an adaptive goal bias that switches sampling between start and goal to mitigate symmetry issues. Nodes are steered towards sampled points within a fixed step size and checked against obstacles for validity. Neighbors within a dynamically shrinking radius are analyzed to select the minimal cost parent and for rewiring to improve path costs. Trees attempt connection each iteration by forward extending from one tree's nearest node toward the other's new node. Upon connection, the combined path is extracted and smoothed via randomized shortcutting to enhance path quality, while all procedures ensure nodes and edges remain collision-free and inside bounds, achieving faster planning times and better path quality.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 7.0, max_neighbor_radius: float = 20.0,\n                 base_goal_sample_rate: float = 0.15, smoothing_trials: int = 120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.base_goal_sample_rate = base_goal_sample_rate\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        def sample_free(iteration):\n            goal_bias = min(self.base_goal_sample_rate + iteration / self.max_iter * 0.15, 0.3)\n            if random.random() < goal_bias:\n                # Alternate bias between start and goal to avoid symmetry\n                return start_position if (iteration % 2 == 0) else goal_position\n            attempts = 0\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n                attempts += 1\n                if attempts > 30:\n                    return start_position if (iteration % 2 == 0) else goal_position\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            # Clamp inside bounds robustly\n            clamped = tuple(max(0, min(new_p[d], bounds[d])) for d in range(len(bounds)))\n            return clamped\n\n        def neighbor_radius(iteration):\n            frac = iteration / self.max_iter\n            shrink = (1 - frac ** 0.85)\n            return max(self.min_neighbor_radius, self.max_neighbor_radius * shrink)\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if self._dist_sq(node.position, pos) <= radius_sq]\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: self._dist_sq(node.position, point))\n\n        # Initialize trees\n        start_root = Node(start_position, None, 0.0)\n        goal_root = Node(goal_position, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        connected = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        for iteration in range(self.max_iter):\n            q_rand = sample_free(iteration)\n\n            # Alternate tree selection for balanced expansion\n            if iteration % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            r = neighbor_radius(iteration)\n\n            nearest_a = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_a.position, new_pos, obstacles, is_3d):\n                continue\n\n            near = near_nodes(tree_a, new_pos, r)\n\n            min_cost = nearest_a.cost + math.dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            # Try rewiring to get minimal cost parent\n            for node in near:\n                cost_through_node = node.cost + math.dist(node.position, new_pos)\n                if cost_through_node < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_node\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost paths\n            for node in near:\n                if node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n            # Attempt connection from tree_b to new_node by incremental steering\n            nearest_b = nearest(tree_b, new_node.position)\n            curr_node_b = nearest_b\n            while True:\n                pos_b_new = steer(curr_node_b.position, new_node.position)\n                if not in_bounds(pos_b_new):\n                    break\n                if self._is_in_obstacle(pos_b_new, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(curr_node_b.position, pos_b_new, obstacles, is_3d):\n                    break\n\n                cost_b = curr_node_b.cost + math.dist(curr_node_b.position, pos_b_new)\n                new_node_b = Node(pos_b_new, curr_node_b, cost_b)\n                curr_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((curr_node_b, new_node_b))\n\n                near_b = near_nodes(tree_b, pos_b_new, r)\n                for node in near_b:\n                    if node is curr_node_b:\n                        continue\n                    cost_through_new_b = new_node_b.cost + math.dist(new_node_b.position, node.position)\n                    if cost_through_new_b < node.cost:\n                        if not self._is_edge_in_obstacle(new_node_b.position, node.position, obstacles, is_3d):\n                            try:\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                            node.update_parent(new_node_b, cost_through_new_b)\n                            edges.append((new_node_b, node))\n\n                if math.dist(new_node_b.position, new_node.position) <= self.step_size:\n                    connected = True\n                    if tree_a is tree_start:\n                        connection_node_start = new_node\n                        connection_node_goal = new_node_b\n                    else:\n                        connection_node_start = new_node_b\n                        connection_node_goal = new_node\n                    break\n                curr_node_b = new_node_b\n\n            if connected:\n                path_start = connection_node_start.path_from_root()\n                path_goal = connection_node_goal.path_from_root()\n                # Merge paths: path_start + path_goal reversed (excluding duplicated node)\n                merged_path = path_start + path_goal[::-1][1:]\n\n                # Path smoothing by randomized shortcutting\n                merged_path = self._path_smooth(merged_path, obstacles, is_3d, self.smoothing_trials)\n\n                return PlannerResult(\n                    success=True,\n                    path=merged_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smooth(self, path, obstacles, is_3d, max_trials=120):\n        import random\n        if len(path) < 3:\n            return path\n        path = path[:]\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px, py, pz = (pos + (0,))[:3] if is_3d else (pos[0], pos[1], 0)\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    @staticmethod\n    def _dist_sq(p1, p2):\n        return sum((p1[d] - p2[d]) ** 2 for d in range(len(p1)))",
        "objective": 79.29633,
        "time_improvement": -261.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.9,
                "time_avg": 0.032957601547241214,
                "num_nodes_avg": 135.6,
                "path_length_avg": 172.92176753913392,
                "success_improvement": -9.999999999999998,
                "time_improvement": -249.46544004813447,
                "length_improvement": 13.575362620956227,
                "objective_score": -77.1245594902491
            },
            {
                "map_id": 1,
                "success_rate": 0.9,
                "time_avg": 0.08454980850219726,
                "num_nodes_avg": 319.6,
                "path_length_avg": 222.01775383401105,
                "success_improvement": -9.999999999999998,
                "time_improvement": -473.8747121544842,
                "length_improvement": 26.32699808297494,
                "objective_score": -141.89701402975027
            },
            {
                "map_id": 2,
                "success_rate": 0.9,
                "time_avg": 0.04620904922485351,
                "num_nodes_avg": 217.8,
                "path_length_avg": 130.53996595355386,
                "success_improvement": -9.999999999999998,
                "time_improvement": -59.45181722524017,
                "length_improvement": 19.84059704466348,
                "objective_score": -18.867425758639353
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "This improved planner implements a bidirectional RRT* variant with enhanced adaptive sampling and rewiring strategies focusing on minimizing path length and improving convergence speed. It employs dynamic radius calculations, balanced tree growth, and mutual rewiring between trees. Additionally, this version incorporates heuristic-informed sampling bias that adapts over iterations to concentrate exploration around promising areas, employs a decaying radius for finer local optimizations, and implements a path shortcutting smoothing post-processing step. The planner rigorously checks for collisions at nodes and edges while maintaining efficient rewiring to produce shorter, smoother, and more robust paths efficiently in both 2D and 3D environments.",
        "planning_mechanism": "The planner alternately grows and rewires two trees rooted at start and goal positions, sampling points using an adaptive heuristic bias that shifts towards promising regions as iterations increase. It always extends the smaller tree first to maintain balance and dynamically adjusts the rewiring radius decreasing over time for refined local improvements. Mutual tree connection attempts and rewiring enhance path quality and smoothness. Upon finding a connection, a shortcutting process smooths the path by removing unnecessary nodes, thereby minimizing path length and improving traversal efficiency.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag (collision etc.)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def __repr__(self):\n        return f\"Node({self.position}, cost={self.cost:.2f})\"\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0, radius_min: float=3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) <= radius)]\n\n        def radius_by_nodes(n_nodes, itr):\n            # Dynamic radius shrinking with node count & iteration progress; radius shrinks faster as iteration count increases\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt((math.log(n_nodes) / n_nodes))\n            # Decay radius as iter increases (slow exponential decay, min bound enforced)\n            decay_factor = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay_factor)\n\n        def is_free_node(pos):\n            return (self._is_in_obstacle(pos, obstacles, is_3d) == False)\n\n        def is_free_edge(p1, p2):\n            return (self._is_edge_in_obstacle(p1, p2, obstacles, is_3d) == False)\n\n        def adaptive_sample(itr):\n            # Adaptive heuristic informed sampling:\n            # - Early: higher goal bias (goal: 70%, start: 10%)\n            # - Later: increase uniform exploration and biased sampling around best known connection nodes\n            r = random.random()\n            if r < self.goal_sample_rate:\n                subr = random.random()\n                if subr < 0.7:\n                    if is_free_node(goal_position):\n                        return goal_position\n                elif subr < 0.8:\n                    if is_free_node(start_position):\n                        return start_position\n                else:\n                    # Sample near best connection region for better local refinement (after some progress)\n                    if len(tree_start) > 10 and len(tree_goal) > 10:\n                        # Pick random midpoint from recent connection attempts or random nodes\n                        mid_from_start = random.choice(tree_start).position\n                        mid_from_goal = random.choice(tree_goal).position\n                        mid = tuple((mid_from_start[i]+mid_from_goal[i])/2 for i in range(dim))\n                        # Sample in small ball around mid\n                        spread = self.step_size * 5 * (1 - itr / self.max_iter)\n                        def confined_rand():\n                            return tuple(max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim))\n                        for _ in range(5):  # try up to 5 samples in this biased region\n                            candidate = confined_rand()\n                            if is_free_node(candidate):\n                                return candidate\n            # Uniform random sample in free space\n            attempts = 0\n            while attempts < 100:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(point):\n                    return point\n                attempts += 1\n            # fallback to start if stuck\n            return start_position\n\n        def try_extend(tree, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not is_free_node(new_pos) or not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree), itr)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost < min_cost - 1e-8:\n                    if is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve local connectivity and path cost\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node, itr):\n            if not tree:\n                return None\n\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos) or not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes(len(tree), itr)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost < min_cost - 1e-8:\n                        if is_free_edge(node.position, new_pos):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors around new_node\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-8 < neighbor.cost:\n                        if is_free_edge(new_node.position, neighbor.position):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, cost=final_cost)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def shortcut_path(path):\n            # Attempt to shortcut path by removing nodes where direct connection is collision-free\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                # Search for farthest reachable node from current shortened[-1]\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        for itr in range(self.max_iter):\n\n            rand_point = adaptive_sample(itr)\n\n            # Always extend the smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start, itr)\n            if new_node_goal:\n                success_state = True\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                # Post-process: shortcutting for smoother path\n                extracted_path = shortcut_path(merged_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -4.53314,
        "time_improvement": 0.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.010382628440856934,
                "num_nodes_avg": 93.1,
                "path_length_avg": 159.97272222093744,
                "success_improvement": 0.0,
                "time_improvement": -10.092046951276549,
                "length_improvement": 20.047171011283186,
                "objective_score": 0.9818201168736733
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.020576214790344237,
                "num_nodes_avg": 272.6,
                "path_length_avg": 237.41024721166414,
                "success_improvement": 0.0,
                "time_improvement": -39.659326842009,
                "length_improvement": 21.219248029042483,
                "objective_score": -7.653948446794204
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.014211153984069825,
                "num_nodes_avg": 201.5,
                "path_length_avg": 122.2769154763927,
                "success_improvement": 0.0,
                "time_improvement": 50.96210881549838,
                "length_improvement": 24.914607812175976,
                "objective_score": 20.27155420708471
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm integrating adaptive informed sampling biased towards both start and goal, dynamic radius rewiring with pruning of dead-ends to maintain tree efficiency, and iterative shortcut smoothing after successful path connection. It alternately extends the smaller tree to balance exploration, rigorously applies collision checks for nodes and edges, and performs path smoothing to ensure shorter and smoother trajectories. These strategies collectively improve planning speed, path optimality, robustness, success rate, and reduce computational overhead and search time.",
        "planning_mechanism": "The planner grows two trees rooted at start and goal positions, alternately extending the smaller tree by sampling points within the map bounds with goal and start bias. It uses a dynamic radius for neighbor selection to locally optimize path costs via rewiring. After successfully connecting the two trees, it extracts the path and applies iterative shortcut smoothing. Periodic pruning removes dead-end nodes to reduce complexity and enhance efficiency. Comprehensive collision and edge feasibility checks are enforced to ensure valid and safe path construction.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=28.0,\n                 radius_min: float=5.0, prune_interval: int=200,\n                 prune_threshold: int=100, smoothing_iterations: int=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size               # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start      # Tuple[float, ...]\n        goal_position = map.goal        # Tuple[float, ...]\n        obstacles = map.obstacles       # List of obstacles rectangles/cuboids\n\n        import random\n        import math\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            p_bias = 0.75\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            for d in range(len(pos)):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not can_connect(p1, p2):\n                    continue\n                path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Alternate extending smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -7.55322,
        "time_improvement": 12.0,
        "length_improvement": 19.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.006933975219726563,
                "num_nodes_avg": 72.8,
                "path_length_avg": 163.3649260494454,
                "success_improvement": 0.0,
                "time_improvement": 26.475696419497474,
                "length_improvement": 18.35178014195116,
                "objective_score": 11.613064954239475
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.020410585403442382,
                "num_nodes_avg": 254.5,
                "path_length_avg": 244.16867087718578,
                "success_improvement": 0.0,
                "time_improvement": -38.53513131257554,
                "length_improvement": 18.976574409173768,
                "objective_score": -7.765224511937907
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.014882683753967285,
                "num_nodes_avg": 157.4,
                "path_length_avg": 128.50251110260547,
                "success_improvement": 0.0,
                "time_improvement": 48.644886454788,
                "length_improvement": 21.091717061491025,
                "objective_score": 18.811809348734606
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "This planner implements a bidirectional RRT* with adaptive informed sampling biased strongly toward start and goal to balance exploration and focused search. It grows two balanced trees, extending the smaller tree each iteration, rewiring locally with an adaptively shrinking radius to optimize paths incrementally. Periodic pruning removes dead-end nodes to maintain efficiency. Upon successful connection, the raw path is smoothed via iterative shortcutting with collision checks to improve smoothness and reduce length. Parameter tuning focuses on tighter step sizes, refined goal bias, and pruning frequency to enhance success rate, path quality, and computational speed.",
        "planning_mechanism": "The planner alternates growth between two trees rooted at start and goal, sampling adaptively with strong bias toward roots and uniform elsewhere. Each iteration extends the smaller tree toward a sampled point, rewires neighbors within a dynamic radius, and attempts connection to the opposing tree to form a complete path. Dead-end pruning and shortcut smoothing refine the solution progressively, ensuring collision-free and efficient paths while keeping computational cost bounded.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0,\n                 goal_sample_rate: float = 0.18, radius_constant: float = 28.0,\n                 radius_min: float = 4.0, prune_interval: int = 150,\n                 prune_threshold: int = 80, smoothing_iterations: int = 60):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        def sample_free():\n            # Adaptive informed sampling strongly biased towards start and goal\n            p_bias = 0.85\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n <= 1:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node in (start_root, goal_root):\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            if len(path) < 2:\n                return 0.0\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not can_connect(p1, p2):\n                    continue\n                path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n            # Extend smaller tree for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                extracted_path = smoothed if path_length(smoothed) + 1e-12 < path_length(raw_path) else raw_path\n                break\n\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 2.38228,
        "time_improvement": -22.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.011345243453979493,
                "num_nodes_avg": 97.4,
                "path_length_avg": 160.85151556772365,
                "success_improvement": 0.0,
                "time_improvement": -20.29912099080036,
                "length_improvement": 19.607958543078883,
                "objective_score": -2.1681445886243313
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03147048950195312,
                "num_nodes_avg": 195.7,
                "path_length_avg": 236.1869952319138,
                "success_improvement": 0.0,
                "time_improvement": -113.60329992734073,
                "length_improvement": 21.625164420379946,
                "objective_score": -29.75595709412623
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.009719252586364746,
                "num_nodes_avg": 118.4,
                "path_length_avg": 123.4519934943215,
                "success_improvement": 0.0,
                "time_improvement": 66.46214295763002,
                "length_improvement": 24.193039121276925,
                "objective_score": 24.77725071154439
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This algorithm implements an efficient bidirectional RRT* planner with adaptive sampling bias, informed rewiring, and path shortcutting to improve path quality, success rate, and convergence speed. It grows two trees from start and goal, alternately extends towards sampled points considering goal bias, rewires nearby nodes to optimize costs, and upon connecting the trees, reconstructs and smooths the final path to enhance smoothness and reduce length while maintaining collision-free guarantees.",
        "planning_mechanism": "The planner alternates growth between two trees starting at start and goal positions. At each iteration, it samples a point biased towards the goal to encourage connection, extends the smaller tree towards the sample by a fixed step size if collision-free, then attempts to connect the other tree towards the new node. It rewires nodes within a dynamically computed radius for cost improvement. Upon successful connection, it extracts the path and applies shortcut smoothing to reduce unnecessary waypoints and improve path quality.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...] (2D or 3D)\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1,\n                 radius_constant: float = 20.0, radius_min: float = 5.0, smoothing_iter: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal\n        self.radius_constant = radius_constant    # For rewiring radius calculation\n        self.radius_min = radius_min               # Minimum radius for rewiring\n        self.smoothing_iter = smoothing_iter      # Number of shortcut smoothing iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def in_bounds(pos):\n            for d in range(len(pos)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if self._is_in_obstacle(p, obstacles, is_3d):\n                    continue\n                return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, r)\n\n        def collision_free(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def edge_collision_free(from_pos, to_pos):\n            return in_bounds(to_pos) and not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not collision_free(new_pos):\n                return None\n            if not edge_collision_free(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost and edge_collision_free(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for node in near:\n                if node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, node.position)\n                if cost_through_new + 1e-6 < node.cost and edge_collision_free(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, node))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            curr_node = nearest_node\n            while True:\n                new_pos = steer(curr_node.position, node.position)\n                if not collision_free(new_pos) or not edge_collision_free(curr_node.position, new_pos):\n                    return None\n                new_cost = curr_node.cost + distance(curr_node.position, new_pos)\n                new_node = Node(new_pos, parent=curr_node, cost=new_cost)\n                curr_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr_node, new_node))\n                if distance(new_pos, node.position) <= self.step_size:\n                    if edge_collision_free(new_pos, node.position):\n                        final_cost = new_node.cost + distance(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                curr_node = new_node\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i, p_j = path[i], path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n            # Extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal:\n                success_state = True\n                extracted_path = extract_path(new_node_start, new_node_goal)\n                extracted_path = smooth_path(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 1.97668,
        "time_improvement": -19.0,
        "length_improvement": 19.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.015129446983337402,
                "num_nodes_avg": 118.4,
                "path_length_avg": 166.78616537886685,
                "success_improvement": 0.0,
                "time_improvement": -60.42486708683155,
                "length_improvement": 16.64187760833718,
                "objective_score": -14.799084604382028
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.022152400016784667,
                "num_nodes_avg": 265.3,
                "path_length_avg": 246.38834329762886,
                "success_improvement": 0.0,
                "time_improvement": -50.357551464269925,
                "length_improvement": 18.240012005210648,
                "objective_score": -11.459263038238847
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.013362503051757813,
                "num_nodes_avg": 171.5,
                "path_length_avg": 128.96814563559352,
                "success_improvement": 0.0,
                "time_improvement": 53.89051646761393,
                "length_improvement": 20.805789407940164,
                "objective_score": 20.32831282187221
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This planner is a hybrid bidirectional RRT* variant integrating adaptive goal biasing, dynamic neighborhood radius based on node density and iteration, heuristic-driven goal/sample switching, lazy collision checking, and efficient rewiring. It employs balanced tree growth alternating expansions, spatial pruning to avoid futile expansions, and aggressive path shortcutting for smoothness. To minimize path length and reduce planning time, it prioritizes rewiring with strict cost improvement, incorporates incremental radius shrinking, uses informed sampling to bias towards promising regions, and applies lazy validation to reduce collision checks, achieving improved success rate, efficiency, shorter and smoother paths.",
        "planning_mechanism": "The planner grows two trees simultaneously from start and goal by alternately sampling adaptive biased points. It extends the smaller tree towards the sample while rewiring neighbors within a dynamically computed radius based on tree size and iteration for incremental optimization. After extending, it attempts connection attempts to the other tree through steering and incremental node additions. Collision-free checks guard node and edge validity at each step. Once connection is made, the path is extracted by backtracking and smoothed using shortcutting procedures. The planner uses spatial pruning to avoid unnecessary node expansions, lazy collision checking to save time, and heuristic-driven sampling to focus exploration near the goal and along promising paths, thus reducing planning time, improving success, and producing shorter, smoother paths.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 base_goal_sample_rate: float = 0.15,\n                 min_radius: float = 5.0, max_radius: float = 25.0,\n                 smoothing_trials: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_goal_sample_rate = base_goal_sample_rate\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def sample_free(iteration, tree_start_size, tree_goal_size):\n            # Adaptive goal biasing increases over iterations, capped at 0.35\n            goal_bias = min(self.base_goal_sample_rate + iteration / self.max_iter * 0.2, 0.35)\n            # Heuristic driven: bias more towards smaller tree base to balance exploration\n            bias_towards_goal = goal_bias if tree_start_size <= tree_goal_size else goal_bias * 0.7\n            if random.random() < bias_towards_goal:\n                # Alternate choice between start and goal biased sampling to reduce symmetry\n                return goal_position if random.random() < 0.7 else start_position\n            else:\n                attempts = 0\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                    attempts += 1\n                    if attempts > 30:\n                        # Fallback to start or goal\n                        return start_position if random.random() < 0.5 else goal_position\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            if in_bounds(new_p):\n                return new_p\n            # Clamp if marginally out-of-bound due to numerical issues\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(len(bounds)))\n\n        def radius_dynamic(iteration, n_nodes):\n            # Combines iteration and node count to shrink radius dynamically\n            if n_nodes < 2:\n                return self.max_radius\n            r_iter = self.max_radius * (1 - (iteration / self.max_iter) ** 0.8)\n            r_nodes = self.max_radius * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        # Spatial pruning: avoid expansions too close to existing nodes (within a fraction of step_size)\n        def is_far_enough(tree, pos, min_dist = 0.2 * self.step_size):\n            for node in tree:\n                if distance(node.position, pos) < min_dist:\n                    return False\n            return True\n\n        # Lazy collision checking: check node validity once added, and skip edge collision checks where possible\n        def collision_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d) and in_bounds(pos)\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=0.7)\n\n        # Initialization\n        start_root = Node(start_position, None, 0.0)\n        goal_root = Node(goal_position, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        connected = False\n        connect_node_start = None\n        connect_node_goal = None\n\n        for iteration in range(self.max_iter):\n            # Sample with adaptive bias and heuristic\n            q_rand = sample_free(iteration, len(tree_start), len(tree_goal))\n\n            # Alternate growing smaller tree for balancing and faster convergence\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            radius = radius_dynamic(iteration, len(tree_a))\n\n            # --- Extend tree_a towards sampled point ---\n            nearest_a = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            # Spatial pruning: skip expansions too close to existing nodes\n            if not is_far_enough(tree_a, new_pos):\n                continue\n\n            # Node and edge collision checking (lazy)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_a.position, new_pos):\n                continue\n\n            near = near_nodes(tree_a, new_pos, radius)\n\n            min_cost = nearest_a.cost + distance(nearest_a.position, new_pos)\n            best_parent = nearest_a\n\n            # Rewiring: choose parent with minimal cost path to new node\n            for node in near:\n                cost_through_node = node.cost + distance(node.position, new_pos)\n                if cost_through_node < min_cost:\n                    if collision_free_edge(node.position, new_pos):\n                        min_cost = cost_through_node\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if path cost improves significantly\n            for node in near:\n                if node == best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, node.position)\n                if cost_via_new + 1e-8 < node.cost:  # strict improvement\n                    if collision_free_edge(new_node.position, node.position):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, node))\n\n            # --- Attempt connection from tree_b to new_node ---\n            nearest_b = nearest(tree_b, new_node.position)\n            curr_node_b = nearest_b\n\n            while True:\n                new_pos_b = steer(curr_node_b.position, new_node.position)\n                if not collision_free_node(new_pos_b) or not collision_free_edge(curr_node_b.position, new_pos_b):\n                    break\n\n                cost_b = curr_node_b.cost + distance(curr_node_b.position, new_pos_b)\n                new_node_b = Node(new_pos_b)\n                new_node_b.cost = cost_b\n                new_node_b.parent = curr_node_b\n                curr_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((curr_node_b, new_node_b))\n\n                # Rewire neighbors around new_node_b\n                near_b = near_nodes(tree_b, new_pos_b, radius)\n                for node in near_b:\n                    if node == curr_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + distance(new_node_b.position, node.position)\n                    if cost_via_new_b + 1e-8 < node.cost:\n                        if collision_free_edge(new_node_b.position, node.position):\n                            try:\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                            node.update_parent(new_node_b, cost_via_new_b)\n                            edges.append((new_node_b, node))\n\n                # Check proximity for connection\n                if distance(new_node_b.position, new_node.position) <= self.step_size:\n                    # Final edge check to confirm connection edge\n                    if collision_free_edge(new_node_b.position, new_node.position):\n                        connected = True\n                        if tree_a is tree_start:\n                            connect_node_start = new_node\n                            connect_node_goal = new_node_b\n                        else:\n                            connect_node_start = new_node_b\n                            connect_node_goal = new_node\n                    break\n\n                curr_node_b = new_node_b\n\n            if connected:\n                # Extract and merge paths without duplication of connecting node\n                path_start = connect_node_start.path_from_root()\n                path_goal = connect_node_goal.path_from_root()\n                full_path = path_start + path_goal[::-1][1:]\n\n                # Path smoothing: shortcutting with collision checks\n                smoothed_path = self._path_smooth(full_path, obstacles, is_3d, self.smoothing_trials)\n\n                return PlannerResult(\n                    success=True,\n                    path=smoothed_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        # Failure to connect within max_iter\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smooth(self, path, obstacles, is_3d, max_trials=100):\n        import random\n        if len(path) < 3:\n            return path[:]\n        path = path[:]\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.7):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 8.67462,
        "time_improvement": -21.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.8,
                "time_avg": 0.014790010452270509,
                "num_nodes_avg": 89.3,
                "path_length_avg": 161.20547478429015,
                "success_improvement": -19.999999999999996,
                "time_improvement": -56.82565685523525,
                "length_improvement": 19.431053128716826,
                "objective_score": -23.161486430827203
            },
            {
                "map_id": 1,
                "success_rate": 0.9,
                "time_avg": 0.02378835678100586,
                "num_nodes_avg": 204.8,
                "path_length_avg": 236.70521465371112,
                "success_improvement": -9.999999999999998,
                "time_improvement": -61.461470370723994,
                "length_improvement": 21.453201684084284,
                "objective_score": -19.14780077440034
            },
            {
                "map_id": 2,
                "success_rate": 0.9,
                "time_avg": 0.01293332576751709,
                "num_nodes_avg": 127.3,
                "path_length_avg": 124.79243388594284,
                "success_improvement": -9.999999999999998,
                "time_improvement": 55.371462278703454,
                "length_improvement": 23.369927971333663,
                "objective_score": 16.285424277877766
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e1",
        "algorithm_description": "This planner implements a hybrid bidirectional RRT* with heuristic-informed adaptive sampling leveraging a potential field guidance to bias exploration towards promising regions while avoiding obstacles. It incorporates dynamic rewiring with a decreasing neighborhood radius for incremental path optimization and efficient pruning of low-utility nodes. The planner alternately grows trees from start and goal, uses a visibility graph approximation for shortcut smoothing, and employs lazy collision checking to reduce overhead. Adaptive step sizes and continuous heuristic updates improve planning speed, robustness, and path quality overall.",
        "planning_mechanism": "The planner starts two trees at start and goal positions and grows them alternately, biased by a heuristic potential guiding sampling near the shortest estimated path corridors. It implements rewiring for cost optimization within a shrinking radius to improve path optimality progressively. Lazy collision checks ensure validity of edges on demand to save computations. When the trees connect, it extracts the path and performs an advanced shortcut smoothing leveraging visibility graph edges to yield a high-quality smooth, short path efficiently. Periodic pruning removes dead-ends to maintain tree efficiency and reduce memory/computation overhead.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n        self._lazy_checked = False     # For lazy collision checking\n        self._edge_valid = True        # Edge validity flag with parent\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        self._lazy_checked = False\n        self._edge_valid = True\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.prune_interval = 250\n        self.prune_threshold = 150\n        self.radius_constant = 30.0\n        self.radius_min = 4.0\n        self.smoothing_iterations = 60\n        self.lazy_collision_cache = {}\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        from collections import deque\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # Heuristic estimate: Euclidean distance to goal\n        def heuristic(pos):\n            return dist(pos, goal_position)\n\n        # Biased sampling along corridor between start and goal using Gaussian kernel around line segment\n        def informed_sample():\n            # Sample inside an ellipsoid with foci start and goal to bias towards tight corridor\n            c_min = dist(start_position, goal_position)\n            if c_min == 0:\n                return start_position\n            # Define ellipsoid parameters\n            # Sample uniform radius and angles in ellipse space and transform to workspace\n            # For simplicity, sample Gaussian around line between start and goal:\n            line_vec = tuple(goal_position[d] - start_position[d] for d in range(len(bounds)))\n            dim = len(bounds)\n            # Mean at midpoint\n            mean = tuple((start_position[d] + goal_position[d]) / 2 for d in range(dim))\n            # Standard deviation proportional to half distance\n            std_dev = c_min / 3.0\n            while True:\n                sample = tuple(random.gauss(mean[d], std_dev) for d in range(dim))\n                if all(0 <= sample[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * (math.log(n + 1) / (n + 1))**0.5\n            return max(rad, self.radius_min)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        # Lazy collision checking for edge validity - cache results for efficiency\n        def lazy_check_edge(parent_node, child_node):\n            key = (parent_node.position, child_node.position)\n            if key in self.lazy_collision_cache:\n                valid = self.lazy_collision_cache[key]\n            else:\n                valid = not self._is_edge_in_obstacle(parent_node.position, child_node.position, obstacles, is_3d)\n                self.lazy_collision_cache[key] = valid\n            child_node._edge_valid = valid\n            child_node._lazy_checked = True\n            return valid\n\n        def safe_add_node(tree, new_node, parent_node):\n            if self._is_in_obstacle(new_node.position, obstacles, is_3d):\n                return False\n            if not lazy_check_edge(parent_node, new_node):\n                return False\n            parent_node.children.append(new_node)\n            tree.append(new_node)\n            return True\n\n        # Rewire tree nodes in decreasing radius for path improvement\n        def rewire(tree, new_node):\n            radius = radius_dynamic(len(tree))\n            neighbors = near_nodes(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                if neighbor is new_node or neighbor is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-12 < neighbor.cost:\n                    if lazy_check_edge(new_node, neighbor):\n                        neighbor.update_parent(new_node, cost_through_new)\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                full_path = path_start + path_goal[::-1][1:]\n            else:\n                full_path = path_start + path_goal[::-1]\n            return full_path\n\n        # Shortcut smoothing: using visibility graph approximation by attempting to connect non-adjacent nodes if collision-free\n        def shortcut_smooth(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_dead_nodes(nodes, edges, root1, root2):\n            removed = []\n            q = deque([root1, root2])\n            reachable = set()\n            while q:\n                n = q.popleft()\n                reachable.add(n)\n                for c in n.children:\n                    if c not in reachable:\n                        q.append(c)\n            new_nodes = []\n            for n in nodes:\n                if n in reachable:\n                    new_nodes.append(n)\n                else:\n                    # detach dead node\n                    if n.parent and n in n.parent.children:\n                        n.parent.children.remove(n)\n                    removed.append(n)\n            new_edges = [(p,c) for (p,c) in edges if p in reachable and c in reachable]\n            return new_nodes, new_edges, removed\n\n        # Init trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success = False\n        final_path = []\n\n        # Alternate growing trees with heuristic guided samples\n        for iteration in range(self.max_iter):\n            # Alternate expansion between smaller tree\n            if len(tree_start) > len(tree_goal):\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = goal_root, start_root\n            else:\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = start_root, goal_root\n\n            # 80% bias to informed sampling, 20% random uniform free space sampling\n            sample_pt = informed_sample() if random.random() < 0.8 else tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not in_bounds(sample_pt) or self._is_in_obstacle(sample_pt, obstacles, is_3d):\n                continue\n\n            nearest_node = nearest(tree_a, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n\n            if not lazy_check_edge(nearest_node, new_node):\n                continue\n\n            nearest_node.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire near neighbors around new_node for cost improvement\n            rewire(tree_a, new_node)\n\n            # Try connecting tree_b to new_node with breaks on lazy collision failure, stepwise steering\n            connect_node_b = new_node\n            connected_node = None\n            while True:\n                nearest_b = nearest(tree_b, connect_node_b.position)\n                next_pos_b = steer(nearest_b.position, connect_node_b.position)\n                if nearest_b.position == next_pos_b:\n                    break  # no progress\n\n                if not in_bounds(next_pos_b):\n                    break\n                if self._is_in_obstacle(next_pos_b, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(nearest_b.position, next_pos_b, obstacles, is_3d) is True:\n                    break\n\n                cost_b = nearest_b.cost + dist(nearest_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=nearest_b, cost=cost_b)\n\n                if not lazy_check_edge(nearest_b, new_node_b):\n                    break\n\n                nearest_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((nearest_b, new_node_b))\n\n                connect_node_b = new_node_b\n\n                if dist(connect_node_b.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(connect_node_b.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=connect_node_b,\n                                         cost=connect_node_b.cost + dist(connect_node_b.position, new_node.position))\n                        connect_node_b.children.append(final_node)\n                        tree_b.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((connect_node_b, final_node))\n                        connected_node = final_node\n                    break\n\n            if connected_node is not None:\n                # Extract path from start_root to connected_node in both trees\n                if tree_a is tree_start:\n                    node_start, node_goal = new_node, connected_node\n                else:\n                    node_start, node_goal = connected_node, new_node\n\n                raw_path = extract_path(node_start, node_goal)\n                smoothed_path = shortcut_smooth(raw_path)\n                final_path = smoothed_path\n                success = True\n                break\n\n            # Prune dead-end nodes periodically\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                nodes, edges, _ = prune_dead_nodes(nodes, edges, start_root, goal_root)\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 53.44754,
        "time_improvement": -187.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.006427860260009766,
                "num_nodes_avg": 65.3,
                "path_length_avg": 162.96937133411816,
                "success_improvement": 0.0,
                "time_improvement": 31.842278901503946,
                "length_improvement": 18.549474586798826,
                "objective_score": 13.262578587810948
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.022130084037780762,
                "num_nodes_avg": 246.1,
                "path_length_avg": 239.94339054278174,
                "success_improvement": 0.0,
                "time_improvement": -50.20608363419225,
                "length_improvement": 20.378665371724665,
                "objective_score": -10.98609201591274
            },
            {
                "map_id": 2,
                "success_rate": 0.9,
                "time_avg": 0.18582911491394044,
                "num_nodes_avg": 833.5,
                "path_length_avg": 124.16589820662223,
                "success_improvement": -9.999999999999998,
                "time_improvement": -541.2334935134064,
                "length_improvement": 23.754658621580848,
                "objective_score": -162.61911632970575
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid planner synergizes adaptive heuristic sampling and dynamic rewiring from bidirectional RRT* variants with incremental connection attempts and periodic pruning from hybrid planners. It balances exploration and exploitation using an adaptive goal/start bias that evolves over iterations, alternately grows and rewires two balanced trees, dynamically adjusts the rewiring radius with iteration progress, and prunes dead-end nodes to sustain efficiency. The planner integrates thorough collision checking, mutual incremental tree connections, and post-processing shortcut smoothing to produce shorter, smoother, and robust paths efficiently across 2D and 3D environments.",
        "planning_mechanism": "The planner grows two trees from start and goal, extending the smaller tree each iteration toward adaptively sampled points biased by iteration progress. After successful extension, it incrementally attempts to connect the opposite tree. A dynamic radius for neighbor rewiring shrinks over iterations, enabling global exploration early and fine local refinements late. Dead-end pruning occurs periodically to manage tree size and enhance performance. Upon connection, the final path is shortcut-smoothed for reduced length and improved traversal.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision and pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def is_leaf(self):\n        return len(self.children) == 0\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0,\n                 radius_min: float=3.0, prune_interval: int = 150, prune_threshold: int = 70):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def in_bounds(pos):\n            for i, p in enumerate(pos):\n                if p < 0 or p > bounds[i]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            rad_sq = radius * radius\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def dynamic_radius(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt((math.log(n_nodes) / n_nodes))\n            decay = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay)\n\n        def is_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d) and in_bounds(pos)\n\n        def is_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr):\n            # Adaptive heuristic sampling bias:\n            # Early: strong goal bias ~70%, start bias ~10%\n            # Late: increase uniform exploration + bias around promising mid-regions\n            r = random.random()\n            goal_bias = self.goal_sample_rate\n            if r < goal_bias:\n                subr = random.random()\n                if subr < 0.7 and is_free_node(goal_position):\n                    return goal_position\n                elif subr < 0.85 and is_free_node(start_position):\n                    return start_position\n                else:\n                    if len(tree_start) > 15 and len(tree_goal) > 15:\n                        mid_start = random.choice(tree_start).position\n                        mid_goal = random.choice(tree_goal).position\n                        mid = tuple((mid_start[i] + mid_goal[i]) / 2 for i in range(dim))\n                        spread = self.step_size * 5 * (1 - itr / self.max_iter)\n                        for _ in range(5):\n                            candidate = tuple(max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim))\n                            if is_free_node(candidate):\n                                return candidate\n            # Uniform random sampling\n            for _ in range(100):\n                candidate = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(candidate):\n                    return candidate\n            return start_position  # fallback\n\n        def try_extend(tree, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not is_free_node(new_pos) or not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = dynamic_radius(len(tree), itr)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost < min_cost - 1e-8 and is_free_edge(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_incremental(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not is_free_node(new_pos) or not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if is_free_edge(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_ends():\n            removed = []\n            for node in nodes[:]:\n                if node in (start_root, goal_root):\n                    continue\n                if node.is_leaf() and node.valid:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        node.valid = False\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        for itr in range(self.max_iter):\n            sample_pt = adaptive_sample(itr)\n\n            # Balance tree growth: extend smaller first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_incremental(tree_goal, new_node_start)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n                extracted_path = shortcut_path(merged_path)\n                break\n\n            # Periodic pruning dead-end nodes for efficiency\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_ends()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -0.94707,
        "time_improvement": -11.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.012036538124084473,
                "num_nodes_avg": 66.9,
                "path_length_avg": 157.37715877117898,
                "success_improvement": 0.0,
                "time_improvement": -27.62925379020576,
                "length_improvement": 21.344408676222677,
                "objective_score": -4.019894401817192
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02294914722442627,
                "num_nodes_avg": 181.7,
                "path_length_avg": 242.3378349845835,
                "success_improvement": 0.0,
                "time_improvement": -55.76540610693692,
                "length_improvement": 19.584107698274103,
                "objective_score": -12.812800292426255
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.014379000663757325,
                "num_nodes_avg": 112.3,
                "path_length_avg": 125.72856158370777,
                "success_improvement": 0.0,
                "time_improvement": 50.38292663061586,
                "length_improvement": 22.795089171624692,
                "objective_score": 19.673895823509696
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This planner combines the strengths of both previous algorithms into a bidirectional RRT* variant with adaptive and heuristic-informed sampling, dynamic and decaying rewiring radius, and balanced tree growth. It incorporates mutual rewiring and connection attempts between trees, periodic pruning of dead-end nodes for efficiency, and advanced path shortcutting smoothing. Collision checks rigorously ensure safety, while adaptive sampling focuses exploration near promising regions as iterations progress. This results in improved efficiency, robustness, success rate, and smoother, shorter paths in both 2D and 3D environments.",
        "planning_mechanism": "The planner grows two trees from start and goal, always extending the smaller tree first to maintain balance. It samples points adaptively and heuristically to balance exploration and exploitation. Each extension uses a dynamic, decaying radius to find near nodes for rewiring and cost optimization. After each expansion, the planner attempts to connect the other tree. Dead-end nodes are pruned periodically to keep the search tree efficient. Upon successful connection, a shortcut smoothing post-process refines the path. Collision checks are enforced for all nodes and edges.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0,\n                 radius_min: float=3.0, prune_interval: int=250, prune_threshold: int=100,\n                 smoothing_iterations: int=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            r_sq = radius * radius\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def radius_by_nodes_and_iter(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt(math.log(n_nodes) / n_nodes)\n            decay = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay)\n\n        def is_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr):\n            # Heuristic adaptive sampling shifting from aggressive goal/start bias to exploration near connection midpoints\n            r = random.random()\n            if r < self.goal_sample_rate:\n                sr = random.random()\n                if sr < 0.7 and is_free_node(goal_position):\n                    return goal_position\n                elif sr < 0.8 and is_free_node(start_position):\n                    return start_position\n                else:\n                    if len(tree_start) > 15 and len(tree_goal) > 15:\n                        mid_s = random.choice(tree_start).position\n                        mid_g = random.choice(tree_goal).position\n                        mid = tuple((mid_s[i] + mid_g[i]) / 2 for i in range(dim))\n                        spread = self.step_size * 5 * (1 - itr / self.max_iter)\n                        for _ in range(5):\n                            candidate = tuple(\n                                max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim)\n                            )\n                            if is_free_node(candidate):\n                                return candidate\n            # Uniform free sample\n            attempts = 0\n            while attempts < 100:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n                attempts += 1\n            return start_position\n\n        def try_extend(tree, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (not is_free_node(new_pos)) or (not is_free_edge(nearest_node.position, new_pos)):\n                return None\n\n            radius = radius_by_nodes_and_iter(len(tree), itr)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node, itr):\n            if not tree:\n                return None\n\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if (not is_free_node(new_pos)) or (not is_free_edge(last_node.position, new_pos)):\n                    return None\n\n                radius = radius_by_nodes_and_iter(len(tree), itr)\n                near = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in near:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-10 < min_cost:\n                        if is_free_edge(node.position, new_pos):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in near:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-10 < neighbor.cost:\n                        if is_free_edge(new_node.position, neighbor.position):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p,c) for (p,c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if is_free_edge(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample = adaptive_sample(itr)\n\n            # Alternate extension on smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start, itr)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                shortcuted_path = shortcut_path(raw_path)\n                smoothed_path = smooth_path(shortcuted_path)\n\n                # Use the shorter path between raw, shortcuted and smoothed to improve quality\n                candidates = [raw_path, shortcuted_path, smoothed_path]\n                extracted_path = min(candidates, key=path_length)\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return type('PlannerResult', (), {})() if not success_state else \\\n            PlannerResult(\n                success=success_state,\n                path=extracted_path,\n                nodes=nodes,\n                edges=edges,\n            )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -5.86,
        "time_improvement": 5.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009752225875854493,
                "num_nodes_avg": 84.4,
                "path_length_avg": 160.30622257797762,
                "success_improvement": 0.0,
                "time_improvement": -3.407582686779978,
                "length_improvement": 19.880490738272123,
                "objective_score": 2.9538233416204314
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.018081092834472658,
                "num_nodes_avg": 184.4,
                "path_length_avg": 235.45185784316172,
                "success_improvement": 0.0,
                "time_improvement": -22.723896477563834,
                "length_improvement": 21.869107876772635,
                "objective_score": -2.4433473679146225
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.017218947410583496,
                "num_nodes_avg": 175.8,
                "path_length_avg": 122.99644452541483,
                "success_improvement": 0.0,
                "time_improvement": 40.583229878560964,
                "length_improvement": 24.472773630917217,
                "objective_score": 17.069523689751733
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This planner implements a bidirectional RRT* algorithm with balanced tree growth, adaptive neighbor radius for rewiring, and shortcut path smoothing to improve path quality, efficiency, and success rate. The planner alternates extending the smaller tree towards sampled points biased towards start and goal, attempts connection with the opposite tree after each extension, prunes dead-end nodes periodically to control complexity, and provides collision-free, smooth, and near-optimal paths.",
        "planning_mechanism": "The planner grows two trees from start and goal positions, sampling points with bias towards these roots to guide growth. It extends the smaller tree towards samples within step size limits, rewires locally using adaptively shrinking neighbor radius to lower path cost, and attempts to connect the opposite tree at each extension. Invalid or dead nodes are pruned intermittently. Upon connection, the path is extracted and refined through iterative shortcut smoothing, providing a collision-free, shorter, and smoother path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]: 2D or 3D coordinate\n        self.parent = parent                # Node or None\n        self.cost = cost                   # Cost from root\n        self.children = []\n        self.valid = True                  # For collision or validity checks\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 5.0, prune_interval: int = 200,\n                 prune_threshold: int = 100, smoothing_iterations: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            p_bias = 0.8\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(val, self.radius_min)\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos) or not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node in (start_root, goal_root):\n                    continue\n                if not node.children:\n                    if node.parent:\n                        try:\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    try:\n                        nodes.remove(node)\n                    except ValueError:\n                        pass\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    removed.append(node)\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend the smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -6.95653,
        "time_improvement": 10.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.0070808172225952145,
                "num_nodes_avg": 92.9,
                "path_length_avg": 161.14819930966323,
                "success_improvement": 0.0,
                "time_improvement": 24.918659416168012,
                "length_improvement": 19.45967886043232,
                "objective_score": 11.367533596936868
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.0237623929977417,
                "num_nodes_avg": 227.0,
                "path_length_avg": 238.90444583071044,
                "success_improvement": 0.0,
                "time_improvement": -61.28524337611435,
                "length_improvement": 20.723422376253854,
                "objective_score": -14.240888537583533
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.00985403060913086,
                "num_nodes_avg": 123.5,
                "path_length_avg": 130.73786629590094,
                "success_improvement": 0.0,
                "time_improvement": 65.99706953559297,
                "length_improvement": 19.71907431274517,
                "objective_score": 23.74293572322693
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This planner is an advanced bidirectional RRT* variant that combines adaptive goal biasing, dynamic neighbor radius based on node density, heuristic-informed sampling towards the goal, balanced growth of trees by always extending the smaller tree first, efficient rewiring strategies, lazy collision checking, and iterative path smoothing with shortcutting. It also incorporates pruning of dead-end nodes to control tree complexity dynamically. These collective heuristics focus on rapidly finding a feasible path, continuously optimizing for minimal cost, and producing a collision-free, smooth, and short path with reduced planning time and improved success rate.",
        "planning_mechanism": "The planner grows two trees from start and goal simultaneously, alternately extending the smaller tree toward adaptively sampled points with bias towards start and goal. It maintains a dynamic neighbor radius shrinking with iterations to refine rewiring. Newly added nodes optimize their parent connections and rewire neighbors if beneficial. After each extension, an attempt is made to connect to the opposite tree. Dead-end nodes are pruned at intervals to reduce overhead. Upon connection, the combined path is extracted and refined using iterative shortcut smoothing, ensuring collision-free, smoother, and near-optimal pathways while minimizing search time and path length.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=250,\n                 prune_threshold: int=150,\n                 smoothing_iterations: int=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free(iteration):\n            # Adaptive goal bias increasing up to capped value\n            bias = min(self.goal_sample_rate + iteration / self.max_iter * 0.15, 0.35)\n            if random.random() < bias:\n                return goal_position if random.random() < 0.65 else start_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / distance_between\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            if in_bounds(new_pos):\n                return new_pos\n            # Clamp inside bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(len(bounds)))\n\n        def neighbor_radius(iteration, n_nodes):\n            # Combine iteration and node count for dynamic radius to balance rewiring scope\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1)/c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            # Linear search neighbor; could be improved with spatial index\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def prune_dead_nodes():\n            removed = 0\n            for node in nodes[:]:\n                if node in (start_root, goal_root):\n                    continue\n                # Prune leaf nodes far from connection or with no children\n                if not node.children:\n                    if node.parent:\n                        try:\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    try:\n                        nodes.remove(node)\n                    except ValueError:\n                        pass\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    removed += 1\n            return removed\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            q_rand = sample_free(iteration)\n\n            # Extend smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_a, tree_b = tree_goal, tree_start\n            else:\n                tree_a, tree_b = tree_start, tree_goal\n\n            r = neighbor_radius(iteration, len(nodes))\n\n            # --- Extend tree_a towards q_rand ---\n            nearest_node = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_node.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                # Skip failed extension\n                continue\n\n            near = near_nodes(tree_a, new_pos, r)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                cost_thl = node.cost + dist(node.position, new_pos)\n                if cost_thl + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_thl\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # --- Try to connect tree_b to new_node ---\n            nearest_b = nearest(tree_b, new_node.position)\n            last_node_b = nearest_b\n\n            connected = False\n            while True:\n                new_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(new_pos_b) or not can_connect(last_node_b.position, new_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, new_pos_b)\n                new_node_b = Node(new_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                # Rewire neighbors of new_node_b in tree_b\n                near_b = near_nodes(tree_b, new_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_b_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_b_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_b_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                # Check if trees connected\n                if dist(new_node_b.position, new_node.position) <= self.step_size:\n                    if can_connect(new_node_b.position, new_node.position):\n                        # Create connection node to finalize the linkage\n                        final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                        connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                        new_node_b.children.append(connection_node)\n                        tree_b.append(connection_node)\n                        nodes.append(connection_node)\n                        edges.append((new_node_b, connection_node))\n\n                        # Successful connection found\n                        success_state = True\n\n                        if tree_a is tree_start:\n                            path_start = connection_node.path_from_root()\n                            path_goal = new_node.path_from_root()\n                        else:\n                            path_start = new_node.path_from_root()\n                            path_goal = connection_node.path_from_root()\n\n                        # Merge paths without duplicating the connection node\n                        merged_path = path_start + path_goal[::-1][1:]\n\n                        # Iterative shortcut smoothing for path quality\n                        merged_path = shortcut_smoothing(merged_path)\n\n                        extracted_path = merged_path\n                        connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic pruning to reduce search space overhead\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 27.44725,
        "time_improvement": -107.0,
        "length_improvement": 23.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.012405037879943848,
                "num_nodes_avg": 86.4,
                "path_length_avg": 161.5420618792853,
                "success_improvement": 0.0,
                "time_improvement": -31.53663549558978,
                "length_improvement": 19.26283013374403,
                "objective_score": -5.608424621928128
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02358701229095459,
                "num_nodes_avg": 261.6,
                "path_length_avg": 233.03739999615118,
                "success_improvement": 0.0,
                "time_improvement": -60.0948615833243,
                "length_improvement": 22.6703066751551,
                "objective_score": -13.49439713996627
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.09541690349578857,
                "num_nodes_avg": 207.8,
                "path_length_avg": 117.76933935101704,
                "success_improvement": 0.0,
                "time_improvement": -229.25149752325572,
                "length_improvement": 27.682531094110963,
                "objective_score": -63.23894303815452
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This enhanced hybrid bidirectional RRT* planner dynamically adjusts goal bias, uses a KDTree for efficient nearest-neighbor searches, and incorporates batch rewiring limited to a tuned adaptive radius. It balances tree growth by always extending the smaller tree first with step steering and collision checks optimized for early rejection. The planner includes an efficient path shortcutting smoothing pass and prunes redundant nodes post-connection for reduced complexity. Adaptive radius shrinks with node count for faster rewiring and improved path convergence, thus reducing planning time while improving path quality, success rate, smoothness, and robustness.",
        "planning_mechanism": "The planner initializes two trees rooted at start and goal, and iteratively samples points biased adaptively toward the goal. At each iteration, it extends the smaller tree toward the sampled point using fixed-step steering, verifies collisions for new nodes and edges, and locally rewires neighbors within a radius computed adaptively based on node count. Following extension, it attempts to connect the opposite tree toward the new node. Upon successful connection, the path is reconstructed by concatenating branches from both trees, followed by a shortcut smoothing pass. The use of KDTree accelerates nearest neighbor queries, and adaptive goal bias accelerates convergence to the goal while maintaining exploration.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate_start=0.1, goal_sample_rate_end=0.35,\n                 radius_constant: float = 25.0, radius_min: float = 2.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = goal_sample_rate_start\n        self.goal_sample_rate_end = goal_sample_rate_end\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        from bisect import insort\n        from collections import deque\n        try:\n            from scipy.spatial import cKDTree as KDTree\n        except ImportError:\n            KDTree = None  # fallback if scipy not available\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free(iteration):\n            goal_bias = ((self.goal_sample_rate_end - self.goal_sample_rate_start) *\n                         iteration / self.max_iter + self.goal_sample_rate_start)\n            if random.random() < goal_bias:\n                # 85% goal, 15% start to encourage bidirectional connection\n                return goal_position if random.random() < 0.85 else start_position\n            else:\n                for _ in range(50):  # limit attempts\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # fallback to start if no free sampled found\n                return start_position\n\n        def steer(from_pos, to_pos):\n            distance_ = dist(from_pos, to_pos)\n            if distance_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, val)\n\n        def build_kdtree(tree):\n            if KDTree is None or not tree:\n                return None\n            pts = [node.position for node in tree]\n            return KDTree(pts)\n\n        def nearest(tree, kdtree, point):\n            # Use KDTree if available, else linear search\n            if kdtree is not None:\n                dist_, idx = kdtree.query(point)\n                return tree[idx]\n            else:\n                return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, kdtree, pos, radius):\n            if kdtree is not None:\n                idxs = kdtree.query_ball_point(pos, radius)\n                return [tree[i] for i in idxs]\n            else:\n                radius_sq = radius * radius\n                return [node for node in tree if (dist(node.position, pos) <= radius)]\n\n        def try_extend(tree, kdtree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, kdtree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, kdtree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in neighbors:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost + 1e-8 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Batch rewire neighbors improved cost via new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, kdtree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, kdtree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if (not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d)\n                            and not self._is_in_obstacle(node.position, obstacles, is_3d)):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def smooth_path(path, max_trials=150):\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if j >= len(path):\n                    continue\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_redundant_nodes(tree):\n            # Optionally prune nodes not connected to root (or orphan nodes)\n            # Queue BFS from root\n            root = tree[0] if tree else None\n            if root is None:\n                return\n            queue = deque([root])\n            visited = set()\n            while queue:\n                cur = queue.popleft()\n                visited.add(cur)\n                for c in cur.children:\n                    if c not in visited:\n                        queue.append(c)\n            # Remove nodes not in visited\n            to_remove = [node for node in tree if node not in visited]\n            for node in to_remove:\n                try:\n                    tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n                except ValueError:\n                    pass\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n\n            # Balance growth: extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            # Build kdtrees for efficient NN queries\n            kdtree_start = build_kdtree(tree_start)\n            kdtree_goal = build_kdtree(tree_goal)\n\n            new_node_start = try_extend(tree_start, kdtree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, kdtree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                # Merge paths avoiding duplicate connection node\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                # Smooth resulting path\n                extracted_path = smooth_path(merged_path, max_trials=150)\n\n                # Optional prune to reduce tree size after success\n                prune_redundant_nodes(tree_start)\n                prune_redundant_nodes(tree_goal)\n\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -4.43151,
        "time_improvement": -0.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.012529683113098145,
                "num_nodes_avg": 63.3,
                "path_length_avg": 155.3730580323225,
                "success_improvement": 0.0,
                "time_improvement": -32.85830937989023,
                "length_improvement": 22.346038963095314,
                "objective_score": -5.388285021348006
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.01742854118347168,
                "num_nodes_avg": 234.6,
                "path_length_avg": 232.5926149824971,
                "success_improvement": 0.0,
                "time_improvement": -18.294757044629613,
                "length_improvement": 22.817901390432237,
                "objective_score": -0.9248468353024366
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.014329338073730468,
                "num_nodes_avg": 175.4,
                "path_length_avg": 126.68648538319522,
                "success_improvement": 0.0,
                "time_improvement": 50.554295450375854,
                "length_improvement": 22.20686625243884,
                "objective_score": 19.60766188560052
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e1",
        "algorithm_description": "This algorithm introduces an informed bidirectional RRT* with adaptive sampling focused within the ellipsoidal heuristically defined region between start and goal, thereby drastically reducing unnecessary exploration and improving convergence speed. It integrates dynamic goal biasing, uses KDTree for efficient neighbor searches and rewiring, and incorporates collision-aware shortcut smoothing. The planner balances exploration and exploitation while maintaining robustness and path quality, resulting in shorter, smoother paths with higher success and efficiency.",
        "planning_mechanism": "The planner simultaneously grows two trees rooted at start and goal positions. At each iteration, it samples points within an informed ellipsoidal space biased towards the goal, extending the smaller tree first toward the sample. Nearest neighbors are found via KDTree to find an optimal parent minimizing cost with rewiring applied to neighbors within an adaptive radius. After extending, the planner attempts to connect the opposite tree in small increments. Upon successful connection, the combined path is shortcut-smoothed to enhance smoothness. The algorithm ensures collision-free nodes and edges throughout and prunes non-connected nodes post-solution to keep complexity low.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate_start=0.15, goal_sample_rate_end=0.4,\n                 radius_constant: float = 20.0, radius_min: float = 3.0,\n                 shortcut_trials: int = 200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = goal_sample_rate_start\n        self.goal_sample_rate_end = goal_sample_rate_end\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.shortcut_trials = shortcut_trials\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n        from collections import deque\n\n        try:\n            from scipy.spatial import cKDTree as KDTree\n        except ImportError:\n            KDTree = None\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def dist_sq(a,b):\n            return sum((a[i]-b[i])**2 for i in range(len(a)))\n\n        # Heuristic: ellipsoidal informed sampling within an ellipse/ellipsoid defined by start-goal segment and current best path cost\n        def informed_sample(c_best, c_min, start, goal):\n            # If no path found yet (c_best == inf), sample uniformly\n            if c_best == float('inf'):\n                return uniform_sample()\n\n            # Compute center and unit vector from start to goal\n            center = tuple((start[d] + goal[d]) / 2 for d in range(len(start)))\n            diff = tuple(goal[d] - start[d] for d in range(len(start)))\n            length = dist(start, goal)\n\n            # Sample a random point in unit n-sphere\n            def sample_unit_sphere(dim):\n                import random\n                import math\n                import numpy as np\n                # Using Marsaglia method\n                vec = [random.gauss(0,1) for _ in range(dim)]\n                norm = math.sqrt(sum(x*x for x in vec))\n                u = [x / norm for x in vec]  # unit vector\n                r = random.uniform(0,1) ** (1.0/dim)\n                return [r*x for x in u]\n\n            n = len(start)\n            # radii of ellipse along axes: major axis length c_best/2, minor axis sqrt(c_best^2 - c_min^2)/2 for others\n            if c_best**2 - c_min**2 < 0:\n                radius_minor = 0.0\n            else:\n                radius_minor = math.sqrt(c_best**2 - c_min**2)/2\n\n            # Build scaling factors along major and minor axes\n            if n == 2:\n                L = [length/2, radius_minor]\n            elif n ==3:\n                L = [length/2, radius_minor, radius_minor]\n            else:\n                # For higher dims fallback to uniform\n                return uniform_sample()\n\n            # Sample inside unit n-ball\n            unit_sphere_sample = sample_unit_sphere(n)\n\n            # Scale sample ellipse radii axis-wise\n            sample_scaled = tuple(unit_sphere_sample[i]*L[i] for i in range(n))\n\n            # Rotate sample to align with start-goal vector; only meaningful in 2D or 3D\n            # Rotation matrix to align x-axis with diff vector\n            # For 2D:\n            if n==2:\n                dx, dy = diff\n                theta = math.atan2(dy, dx)\n                cos_t, sin_t = math.cos(theta), math.sin(theta)\n                x_ellip = sample_scaled[0]*cos_t - sample_scaled[1]*sin_t\n                y_ellip = sample_scaled[0]*sin_t + sample_scaled[1]*cos_t\n                sample_rotated = (x_ellip, y_ellip)\n            elif n==3:\n                # Use Rodrigues' rotation formula to align unit vector (1,0,0) to diff/length\n                ux, uy, uz = 1.0, 0.0, 0.0\n                vx, vy, vz = (diff[d]/length if length>0 else 0 for d in range(3))\n                vx, vy, vz = float(vx), float(vy), float(vz)\n                # Cross product u x v\n                kx = uy*vz - uz*vy\n                ky = uz*vx - ux*vz\n                kz = ux*vy - uy*vx\n                k_norm = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if k_norm < 1e-6:\n                    # vectors are parallel or anti-parallel\n                    if vx < 0:\n                        # 180 degree rotation around any perpendicular axis: choose y-axis\n                        R = [[-1,0,0],[0,-1,0],[0,0,1]]\n                    else:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    kx /= k_norm\n                    ky /= k_norm\n                    kz /= k_norm\n                    cos_a = ux*vx + uy*vy + uz*vz\n                    sin_a = k_norm\n                    K = [\n                        [0, -kz, ky],\n                        [kz, 0, -kx],\n                        [-ky, kx, 0]\n                    ]\n                    I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                    # Rodrigues formula: R = I + sin(a)*K + (1-cos(a))*K^2\n                    K2 = [[K[0][0]*K[0][0]+K[0][1]*K[1][0]+K[0][2]*K[2][0],\n                           K[0][0]*K[0][1]+K[0][1]*K[1][1]+K[0][2]*K[2][1],\n                           K[0][0]*K[0][2]+K[0][1]*K[1][2]+K[0][2]*K[2][2]],\n                          [K[1][0]*K[0][0]+K[1][1]*K[1][0]+K[1][2]*K[2][0],\n                           K[1][0]*K[0][1]+K[1][1]*K[1][1]+K[1][2]*K[2][1],\n                           K[1][0]*K[0][2]+K[1][1]*K[1][2]+K[1][2]*K[2][2]],\n                          [K[2][0]*K[0][0]+K[2][1]*K[1][0]+K[2][2]*K[2][0],\n                           K[2][0]*K[0][1]+K[2][1]*K[1][1]+K[2][2]*K[2][1],\n                           K[2][0]*K[0][2]+K[2][1]*K[1][2]+K[2][2]*K[2][2]]]\n                    R = [[I[r][c] + sin_a*K[r][c] + (1 - cos_a)*K2[r][c] for c in range(3)] for r in range(3)]\n\n                sample_rotated = tuple(\n                    R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2],\n                    R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2],\n                    R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                )\n            else:\n                # Higher dims fallback uniform\n                return uniform_sample()\n\n            sample_global = tuple(center[d] + sample_rotated[d] for d in range(n))\n            # Clamp sample_global to bounds to not exceed map\n            clamped = tuple(\n                max(0.0, min(sample_global[d], bounds[d]))\n                for d in range(n)\n            )\n            return clamped\n\n        # Uniform free space sampling respecting obstacles and bounds\n        def uniform_sample(max_retry=50):\n            for _ in range(max_retry):\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback\n            return start_position\n\n        # Adaptive radius per RRT* theory for rewiring\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, val)\n\n        def build_kdtree(tree):\n            if KDTree is None or not tree:\n                return None\n            pts = [node.position for node in tree]\n            return KDTree(pts)\n\n        def nearest(tree, kdtree, point):\n            if kdtree is not None:\n                dist_, idx = kdtree.query(point)\n                return tree[idx]\n            else:\n                return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, kdtree, pos, radius):\n            if kdtree is not None:\n                idxs = kdtree.query_ball_point(pos, radius)\n                return [tree[i] for i in idxs]\n            else:\n                return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def steer(from_pos, to_pos):\n            distance_ = dist(from_pos, to_pos)\n            if distance_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def try_extend(tree, kdtree, point):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, kdtree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, kdtree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in neighbors:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost + 1e-8 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors with better cost via new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        # Incrementally connect opposite tree toward node\n        def try_connect(tree, kdtree, node):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, kdtree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if (not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d) and\n                        not self._is_in_obstacle(node.position, obstacles, is_3d)):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def smooth_path(path, max_trials):\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if j >= len(path):\n                    continue\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_redundant_nodes(tree):\n            root = tree[0] if tree else None\n            if root is None:\n                return\n            queue = deque([root])\n            visited = set()\n            while queue:\n                cur = queue.popleft()\n                visited.add(cur)\n                for c in cur.children:\n                    if c not in visited:\n                        queue.append(c)\n            to_remove = [node for node in tree if node not in visited]\n            for node in to_remove:\n                try:\n                    tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n                except ValueError:\n                    pass\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        c_best = float('inf')\n        c_min = dist(start_position, goal_position)\n\n        for itr in range(self.max_iter):\n            # Dynamic goal bias\n            goal_bias = ((self.goal_sample_rate_end - self.goal_sample_rate_start) *\n                         itr / self.max_iter + self.goal_sample_rate_start)\n            if random.random() < goal_bias:\n                # Sample start or goal point to encourage direct connection\n                rand_point = goal_position if random.random() < 0.75 else start_position\n            else:\n                # Informed sample inside the ellipsoidal heuristic region when path exists\n                rand_point = informed_sample(c_best, c_min, start_position, goal_position)\n\n            # Prevent sampling outside bounds (redundant because clamped inside informed_sample)\n            rand_point = tuple(max(0.0, min(rand_point[d], bounds[d])) for d in range(len(bounds)))\n\n            # Balance tree growth: always extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            kdtree_start = build_kdtree(tree_start)\n            kdtree_goal = build_kdtree(tree_goal)\n\n            new_node_start = try_extend(tree_start, kdtree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, kdtree_goal, new_node_start)\n            if new_node_goal is not None:\n                # Found a connection between two trees\n                success_state = True\n\n                # Combine paths from start and goal trees (avoid duplicate connection node)\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                # Update best cost and path\n                curr_cost = sum(dist(merged_path[i], merged_path[i+1]) for i in range(len(merged_path)-1))\n                if curr_cost < c_best:\n                    c_best = curr_cost\n                    extracted_path = merged_path\n\n                # Try smoothing path immediately for better solution\n                extracted_path = smooth_path(extracted_path, max_trials=self.shortcut_trials)\n\n                # Prune disconnected nodes after success (optional but improves efficiency)\n                prune_redundant_nodes(tree_start)\n                prune_redundant_nodes(tree_goal)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 8.80661,
        "time_improvement": -42.0,
        "length_improvement": 19.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.014142775535583496,
                "num_nodes_avg": 95.7,
                "path_length_avg": 176.40923101432753,
                "success_improvement": 0.0,
                "time_improvement": -49.96271099886489,
                "length_improvement": 11.832361895798496,
                "objective_score": -12.622340920499768
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02535741329193115,
                "num_nodes_avg": 266.6,
                "path_length_avg": 240.9890984054285,
                "success_improvement": 0.0,
                "time_improvement": -72.11130943615451,
                "length_improvement": 20.031664125026975,
                "objective_score": -17.62706000584096
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.029992318153381346,
                "num_nodes_avg": 270.5,
                "path_length_avg": 123.13470230361244,
                "success_improvement": 0.0,
                "time_improvement": -3.493357092966143,
                "length_improvement": 24.387875026315196,
                "objective_score": 3.829567877373197
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid planner leverages bidirectional RRT* with balanced tree growth and adaptive dynamic radius rewiring enhanced by heuristic-informed sampling biased towards both start and goal. It alternates tree expansions prioritizing the smaller tree to maintain balanced search, integrates aggressive yet safe shortcut smoothing for refined path quality, and employs periodic pruning of dead-end and suboptimal nodes to control complexity, thereby improving planning efficiency, robustness, success rate, and path smoothness while minimizing computational overhead.",
        "planning_mechanism": "The planner grows two trees from start and goal positions using heuristic-biased sampling and steers new nodes with step size constraints. It dynamically adjusts the rewiring radius as the trees grow, rewiring locally to minimize path cost. After each successful extension, it attempts to connect the opposite tree. Collision checks ensure all new nodes and edges are obstacle-free. Periodic pruning removes dead ends and weak branches. When connection is found, the path is extracted and iteratively shortcut-smoothed while validated for collision freedom, producing a shorter, smoother final path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=28.0,\n                 radius_min: float=4.0, prune_interval: int=150, prune_threshold: int=120,\n                 smoothing_iterations: int=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            bias_prob = 0.75\n            if random.random() < self.goal_sample_rate:\n                # Bias towards goal or start randomly for better exploration/exploitation\n                return goal_position if random.random() < bias_prob else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(val, self.radius_min)\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            return in_bounds(p1) and in_bounds(p2) and not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos) or not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node in (start_root, goal_root):\n                    continue\n                # Remove dead ends or isolated invalid nodes\n                if not node.children:\n                    if node.parent:\n                        try:\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    try:\n                        nodes.remove(node)\n                    except ValueError:\n                        pass\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    removed.append(node)\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -3.31752,
        "time_improvement": -1.0,
        "length_improvement": 19.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.008799076080322266,
                "num_nodes_avg": 76.9,
                "path_length_avg": 164.42238391649204,
                "success_improvement": 0.0,
                "time_improvement": 6.699127058163261,
                "length_improvement": 17.82327286375415,
                "objective_score": 5.574392690199808
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02296609878540039,
                "num_nodes_avg": 197.8,
                "path_length_avg": 246.91293228380363,
                "success_improvement": 0.0,
                "time_improvement": -55.880463400938254,
                "length_improvement": 18.065935631962596,
                "objective_score": -13.150951893888957
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.01598212718963623,
                "num_nodes_avg": 131.0,
                "path_length_avg": 129.6794197925504,
                "success_improvement": 0.0,
                "time_improvement": 44.85107860341405,
                "length_improvement": 20.369024227692535,
                "objective_score": 17.52912842656272
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This planner integrates the strengths of bidirectional RRT* with heuristic-informed adaptive sampling and efficient KDTree-assisted nearest neighbor searches to enhance planning efficiency and path quality. It balances tree growth dynamically, employs adaptive goal bias, and utilizes batch rewiring within a shrinking radius for rapid convergence. Post-connection, it conducts an intensive shortcut smoothing and prunes unnecessary nodes to optimize path smoothness and robustness while minimizing search time and path length in both 2D and 3D environments.",
        "planning_mechanism": "The planner initializes two search trees at the start and goal positions, alternately extending the smaller tree toward adaptively sampled points with collision-aware fixed step steering. It leverages KDTree structures for efficient neighbor queries during rewiring. The goal bias adapts over iterations to balance exploration and convergence. After successful connection of trees, the path is reconstructed, smoothed by shortcutting, and redundant nodes are pruned for efficiency and path quality.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate_start=0.12, goal_sample_rate_end=0.4,\n                 radius_constant: float = 28.0, radius_min: float = 2.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = goal_sample_rate_start\n        self.goal_sample_rate_end = goal_sample_rate_end\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n        from collections import deque\n        try:\n            from scipy.spatial import cKDTree as KDTree\n        except ImportError:\n            KDTree = None  # fallback if scipy not available\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def clamp_point(p):\n            return tuple(\n                max(0, min(bounds[d], p[d])) for d in range(dim)\n            )\n\n        def adaptive_goal_bias(iteration):\n            return ((self.goal_sample_rate_end - self.goal_sample_rate_start) *\n                    (iteration / self.max_iter) + self.goal_sample_rate_start)\n\n        def sample_free(iteration):\n            bias = adaptive_goal_bias(iteration)\n            r = random.random()\n            if r < bias:\n                # 85% goal, 15% start bias\n                return goal_position if random.random() < 0.85 else start_position\n            for _ in range(50):\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return start_position\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d_] + (to_pos[d_] - from_pos[d_]) * ratio for d_ in range(dim))\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_constant\n            val = self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, val)\n\n        def build_kdtree(tree):\n            if KDTree is None or not tree:\n                return None\n            points = [node.position for node in tree]\n            return KDTree(points)\n\n        def nearest(tree, tree_kd, point):\n            if tree_kd is not None:\n                dist_, idx = tree_kd.query(point)\n                return tree[idx]\n            else:\n                return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, tree_kd, point, radius):\n            if tree_kd is not None:\n                idxs = tree_kd.query_ball_point(point, radius)\n                return [tree[i] for i in idxs]\n            else:\n                return [node for node in tree if dist(node.position, point) <= radius]\n\n        def is_collision_free_node(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            if not all(0 <= pos[d] <= bounds[d] for d in range(dim)):\n                return False\n            return True\n\n        def is_collision_free_edge(p1, p2):\n            if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return True\n            return False\n\n        def try_extend(tree, tree_kd, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, tree_kd, point)\n            new_pos = steer(nearest_node.position, point)\n            new_pos = clamp_point(new_pos)\n\n            if not is_collision_free_node(new_pos):\n                return None\n            if not is_collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, tree_kd, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-9 < min_cost and is_collision_free_edge(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Batch rewire neighbors if cost is improved via new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-9 < neighbor.cost and is_collision_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, tree_kd, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, tree_kd, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                new_pos = clamp_point(new_pos)\n                if not is_collision_free_node(new_pos):\n                    return None\n                if not is_collision_free_edge(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if (is_collision_free_node(node.position)\n                            and is_collision_free_edge(new_pos, node.position)):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def shortcut_path(path, max_trials=150):\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if is_collision_free_edge(p_i, p_j):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_orphans(tree):\n            if not tree:\n                return\n            root = tree[0]\n            queue = deque([root])\n            visited = set([root])\n            while queue:\n                node = queue.popleft()\n                for c in node.children:\n                    if c not in visited:\n                        visited.add(c)\n                        queue.append(c)\n            to_remove = [n for n in tree if n not in visited]\n            for n in to_remove:\n                try:\n                    tree.remove(n)\n                    if n in nodes:\n                        nodes.remove(n)\n                except ValueError:\n                    pass\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            kdtree_start = build_kdtree(tree_start)\n            kdtree_goal = build_kdtree(tree_goal)\n\n            new_node_start = try_extend(tree_start, kdtree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, kdtree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                extracted_path = shortcut_path(merged_path, max_trials=200)\n\n                prune_orphans(tree_start)\n                prune_orphans(tree_goal)\n\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.8):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 12.70171,
        "time_improvement": -45.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.9,
                "time_avg": 0.017452144622802736,
                "num_nodes_avg": 110.9,
                "path_length_avg": 164.49868955085455,
                "success_improvement": -9.999999999999998,
                "time_improvement": -85.05355711790152,
                "length_improvement": 17.785136041111127,
                "objective_score": -26.95903992714823
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02953360080718994,
                "num_nodes_avg": 293.2,
                "path_length_avg": 244.24755510363966,
                "success_improvement": 0.0,
                "time_improvement": -100.45683085930482,
                "length_improvement": 18.950397954064215,
                "objective_score": -26.346969666978598
            },
            {
                "map_id": 2,
                "success_rate": 0.9,
                "time_avg": 0.014031171798706055,
                "num_nodes_avg": 154.9,
                "path_length_avg": 124.36939740105485,
                "success_improvement": -9.999999999999998,
                "time_improvement": 51.583166530509494,
                "length_improvement": 23.629697857201492,
                "objective_score": 15.200889530593148
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "This planner implements an optimized bidirectional RRT* algorithm with adaptive goal biasing, KD-tree based nearest neighbor search acceleration, geometric rewiring to locally optimize paths, early termination upon tree connection, and path smoothing via shortcutting. It balances exploration and exploitation by alternating tree growth while maintaining collision safety and map boundary constraints. The approach aims to improve planning efficiency, path quality, robustness, and success rate.",
        "planning_mechanism": "The planner simultaneously grows two trees from start and goal positions with sampling biased towards the goal. It uses KD-tree structures for fast nearest and neighbor queries, extends trees by steering towards sampled points within step size limits, and performs collision checks on nodes and edges. Upon connecting the trees, it reconstructs the path and applies smoothing. Rewiring optimizes local costs, and the exploration alternates between trees to speed convergence and improve path quality.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 6.0, neighbor_radius: float = 10.0, goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal directly\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # KD-Tree helper for nearest and near queries (brute-force with caching and incremental insert)\n        class KDTree:\n            def __init__(self):\n                self.nodes = []\n\n            def insert(self, node: Node):\n                self.nodes.append(node)\n\n            def nearest(self, point: Tuple[float, ...]):\n                best_node = None\n                best_dist = float('inf')\n                for node in self.nodes:\n                    d = 0.0\n                    for i in range(dim):\n                        diff = node.position[i] - point[i]\n                        d += diff*diff\n                        if d > best_dist*best_dist:\n                            break\n                    else:\n                        dist = math.sqrt(d)\n                        if dist < best_dist:\n                            best_dist = dist\n                            best_node = node\n                return best_node\n\n            def near(self, point: Tuple[float, ...], radius: float):\n                r_sq = radius * radius\n                neighbors = []\n                for node in self.nodes:\n                    d = 0.0\n                    for i in range(dim):\n                        diff = node.position[i] - point[i]\n                        d += diff*diff\n                        if d > r_sq:\n                            break\n                    else:\n                        neighbors.append(node)\n                return neighbors\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def out_of_bounds(pos: Tuple[float, ...]) -> bool:\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return True\n            return False\n\n        # Initialize trees\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        kd_start = KDTree()\n        kd_goal = KDTree()\n        kd_start.insert(start_root)\n        kd_goal.insert(goal_root)\n\n        success_state = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        tree_flag = True  # Alternate which tree to grow\n\n        for iteration in range(self.max_iter):\n            rand_point = sample_free()\n\n            if tree_flag:\n                new_node = self._extend_tree(tree_start, kd_start, rand_point, obstacles, is_3d, nodes, edges,\n                                            out_of_bounds, steer)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n                connect_node = self._connect_tree(tree_goal, kd_goal, new_node.position, obstacles, is_3d, nodes, edges,\n                                                 out_of_bounds, steer)\n                if connect_node is not None:\n                    success_state = True\n                    connection_node_start = new_node\n                    connection_node_goal = connect_node\n                    break\n            else:\n                new_node = self._extend_tree(tree_goal, kd_goal, rand_point, obstacles, is_3d, nodes, edges,\n                                            out_of_bounds, steer)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n                connect_node = self._connect_tree(tree_start, kd_start, new_node.position, obstacles, is_3d, nodes, edges,\n                                                 out_of_bounds, steer)\n                if connect_node is not None:\n                    success_state = True\n                    # swap roles\n                    connection_node_start = connect_node\n                    connection_node_goal = new_node\n                    break\n\n            tree_flag = not tree_flag\n\n        extracted_path: List[Tuple[float, ...]] = []\n\n        if success_state:\n            # Construct path from start root to connection\n            path_start = connection_node_start.path_from_root()\n            # Construct path from goal root to connection\n            path_goal = connection_node_goal.path_from_root()\n            path_goal.reverse()\n            extracted_path = path_start + path_goal\n\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _extend_tree(self, tree: List[Node], kd_tree, rand_point, obstacles, is_3d, nodes, edges,\n                     out_of_bounds_fn, steer_fn) -> Node:\n        nearest_node = kd_tree.nearest(rand_point)\n        if nearest_node is None:\n            return None\n\n        new_pos = steer_fn(nearest_node.position, rand_point)\n        if out_of_bounds_fn(new_pos):\n            return None\n\n        # Check collision for node and edge\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            return None\n\n        # Find neighbors for rewiring\n        near_nodes = kd_tree.near(new_pos, self.neighbor_radius)\n\n        # Choose best parent with minimal cost\n        min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n        best_parent = nearest_node\n        for near_node in near_nodes:\n            edge_cost = math.dist(near_node.position, new_pos)\n            candidate_cost = near_node.cost + edge_cost\n            if candidate_cost < min_cost:\n                if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = candidate_cost\n                    best_parent = near_node\n\n        new_node = Node(new_pos)\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        kd_tree.insert(new_node)\n\n        # Rewiring neighbors to improve their cost via new_node\n        for near_node in near_nodes:\n            if near_node == best_parent:\n                continue\n            potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n            if potential_cost < near_node.cost:\n                if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Rewire\n                    if near_node.parent is not None:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.children.remove(near_node)\n\n                    near_node.parent = new_node\n                    near_node.cost = potential_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n        return new_node\n\n    def _connect_tree(self, tree: List[Node], kd_tree, target_pos, obstacles, is_3d, nodes, edges,\n                      out_of_bounds_fn, steer_fn) -> Node:\n        nearest_node = kd_tree.nearest(target_pos)\n        if nearest_node is None:\n            return None\n\n        current_node = nearest_node\n\n        while True:\n            new_pos = steer_fn(current_node.position, target_pos)\n            if out_of_bounds_fn(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            near_nodes = kd_tree.near(new_pos, self.neighbor_radius)\n\n            min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n            best_parent = current_node\n            for near_node in near_nodes:\n                cost_through_near = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_through_near < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_near\n                        best_parent = near_node\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            kd_tree.insert(new_node)\n\n            # Rewiring neighbors\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size * 0.5:\n                return new_node\n\n            current_node = new_node\n\n    def _smooth_path(self, path: List[Tuple[float, ...]], obstacles, is_3d) -> List[Tuple[float, ...]]:\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 24.12631,
        "time_improvement": -89.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.9,
                "time_avg": 0.026598191261291503,
                "num_nodes_avg": 118.0,
                "path_length_avg": 164.4739190003182,
                "success_improvement": -9.999999999999998,
                "time_improvement": -182.03352723613924,
                "length_improvement": 17.797516124187126,
                "objective_score": -56.05055494600434
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.033007478713989256,
                "num_nodes_avg": 252.4,
                "path_length_avg": 237.04183176302814,
                "success_improvement": 0.0,
                "time_improvement": -124.03548489933698,
                "length_improvement": 21.34150073894925,
                "objective_score": -32.94234532201124
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.017908143997192382,
                "num_nodes_avg": 174.1,
                "path_length_avg": 120.89637627734098,
                "success_improvement": 0.0,
                "time_improvement": 38.205045302083825,
                "length_improvement": 25.762342045474295,
                "objective_score": 16.613981999720007
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This planner combines the best heuristics of bidirectional RRT* with adaptive goal biasing, dynamic neighborhood radius tuning, and balanced tree growth. It incorporates strict collision checks, incremental rewiring for local path optimality, and a robust path shortcut smoothing step. By always extending the smaller tree, adjusting goal bias progressively, and pruning via rewiring, it achieves faster convergence, shorter and smoother paths, and improved robustness in both 2D and 3D environments.",
        "planning_mechanism": "The planner initializes two trees at start and goal and iteratively samples free points with adaptive goal biasing increasing over iterations. It always extends the smaller tree towards the sampled point via incremental steering and performs local rewiring within an adaptively computed radius. After adding each new node, it attempts to connect the opposite tree with incremental steps. Upon connection, it merges the two paths and applies shortcut smoothing to enhance path quality. The process terminates once a collision-free path is found or max iterations are reached.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4500,\n                 step_size: float = 4.5,\n                 goal_sample_rate_start: float = 0.12,\n                 goal_sample_rate_end: float = 0.38,\n                 radius_constant: float = 28.0,\n                 radius_min: float = 4.0,\n                 smoothing_trials: int = 180):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = goal_sample_rate_start\n        self.goal_sample_rate_end = goal_sample_rate_end\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free(iteration):\n            goal_bias = (self.goal_sample_rate_start +\n                         (self.goal_sample_rate_end - self.goal_sample_rate_start) * iteration / self.max_iter)\n            if random.random() < goal_bias:\n                # 85% towards goal, 15% towards start helps bidirectional convergence\n                return goal_position if random.random() < 0.85 else start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                        return p\n\n        def steer(from_pos, to_pos):\n            distance_ = dist(from_pos, to_pos)\n            if distance_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, val)\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if shorter path found via new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d) and \\\n                       not self._is_in_obstacle(node.position, obstacles, is_3d) and in_bounds(node.position):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def smooth_path(path, max_trials=None):\n            if max_trials is None:\n                max_trials = self.smoothing_trials\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                if j >= len(path):\n                    continue\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n\n            # Balance tree growth by extending smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n                smoothed = smooth_path(merged_path)\n                extracted_path = smoothed\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 33.22961,
        "time_improvement": -119.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.9,
                "time_avg": 0.02040078639984131,
                "num_nodes_avg": 90.0,
                "path_length_avg": 161.10437709562194,
                "success_improvement": -9.999999999999998,
                "time_improvement": -116.31943654423233,
                "length_improvement": 19.481580781813083,
                "objective_score": -35.99951480690708
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.038975310325622556,
                "num_nodes_avg": 339.1,
                "path_length_avg": 245.40823717758752,
                "success_improvement": 0.0,
                "time_improvement": -164.54163989817994,
                "length_improvement": 18.565244374306133,
                "objective_score": -45.64944309459275
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.050804519653320314,
                "num_nodes_avg": 332.9,
                "path_length_avg": 125.77833264821045,
                "success_improvement": 0.0,
                "time_improvement": -75.30923310190728,
                "length_improvement": 22.764526739760676,
                "objective_score": -18.039864582620048
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This improved planner is a bidirectional RRT* variant with several key optimizations to reduce planning time and improve path quality. It incorporates adaptive goal biasing with alternating direction sampling to avoid exploration stagnation, a dynamically shrinking neighbor radius for faster local rewiring, heuristic-guided sampling favoring progress towards goals, lazy collision checking to minimize expensive collision tests, and spatial pruning to limit unnecessary expansions. The planner alternates tree growth direction for balanced exploration, efficiently rewires the tree to optimize cost, and performs path smoothing through shortcutting to produce shorter, smoother paths. These enhancements collectively yield increased success rates, reduced planning duration, and higher quality paths.",
        "planning_mechanism": "The planner grows two trees simultaneously from start and goal by alternately sampling points with adaptive goal biasing and steering towards them with a fixed step size. It dynamically adjusts the neighbor radius to localize rewiring, rewires nodes for lower cost efficiently, and attempts connections between trees after each extension. Lazy collision checking avoids redundant checks by first verifying nodes and edges before connecting. Spatial pruning prevents expansion of nodes unlikely to improve solutions. Upon connection, the found path is merged and smoothed by shortcutting collision-free edges, resulting in a fast, robust, and high-quality path planning solution.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Collision validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_base = 0.15\n        self.goal_sample_cap = 0.3\n        self.min_neighbor_radius = 7.0\n        self.max_neighbor_radius = 25.0\n        self.smoothing_trials = 120\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        from collections import deque\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free(iteration):\n            # Adaptive goal biasing increasing with iterations, capped\n            goal_bias = min(self.goal_sample_base + iteration / self.max_iter * 0.15, self.goal_sample_cap)\n            # Alternate bias direction to reduce symmetry issues\n            if random.random() < goal_bias:\n                return start_position if (iteration % 2 == 0) else goal_position\n            else:\n                # Heuristic-driven sampling: sample towards goal half the time,\n                # otherwise uniform free space\n                if random.random() < 0.5:\n                    # Sample in a ball towards goal (biased)\n                    center = goal_position\n                    dim = len(bounds)\n                    radius = max(bounds[d] * 0.25 for d in range(dim))\n                    for _ in range(10):\n                        sample = tuple(\n                            random.uniform(max(0, center[d]-radius), min(bounds[d], center[d]+radius))\n                            for d in range(dim)\n                        )\n                        if not self._is_in_obstacle(sample, obstacles, is_3d):\n                            return sample\n                    # fallback uniform random if ball sampling fails\n                # Uniform free sampling\n                for _ in range(20):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                # fallback\n                return start_position if random.random() < 0.5 else goal_position\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            if in_bounds(new_p):\n                return new_p\n            # Clamp slightly out of bounds\n            clamped = tuple(max(0, min(new_p[d], bounds[d])) for d in range(len(bounds)))\n            return clamped\n\n        def neighbor_radius(iteration):\n            # Dynamically shrink radius to focus local rewiring\n            return max(\n                self.min_neighbor_radius,\n                self.max_neighbor_radius * (1 - (iteration / self.max_iter)**0.9)\n            )\n\n        def near_nodes(tree, pos, radius):\n            # Use spatial pruning via distance squared comparison for speed, then linear search\n            r2 = radius * radius\n            result = []\n            for node in tree:\n                d2 = sum((node.position[d] - pos[d])**2 for d in range(len(pos)))\n                if d2 <= r2:\n                    result.append(node)\n            return result\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = math.dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best = node\n            return best\n\n        # Lazy collision checks cache: node position and edge validity\n        node_collision_cache = {}\n        edge_collision_cache = {}\n\n        def check_node_collision(pos):\n            key = (round(pos[0],4), round(pos[1],4)) if not is_3d else (round(pos[0],4), round(pos[1],4), round(pos[2],4))\n            if key in node_collision_cache:\n                return node_collision_cache[key]\n            val = self._is_in_obstacle(pos, obstacles, is_3d)\n            node_collision_cache[key] = val\n            return val\n\n        def check_edge_collision(from_pos, to_pos):\n            key = (tuple(round(x,4) for x in from_pos), tuple(round(x,4) for x in to_pos))\n            key_rev = (key[1], key[0])  # since undirected\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n            val = self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=1.0)\n            edge_collision_cache[key] = val\n            return val\n\n        # Spatial pruning heuristic: prune expansion if cost exceeds best known or much larger than heuristic distance to target\n        def should_prune(node, target_pos, max_cost):\n            # Heuristic: Euclidean distance from node to goal + current cost must be less than max_cost * 1.25 to allow some slack\n            h = math.dist(node.position, target_pos)\n            return (node.cost + h) > (max_cost * 1.25)\n\n        # Initialize trees\n        start_root = Node(start_position, None, 0.0)\n        goal_root = Node(goal_position, None, 0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        all_nodes = [start_root, goal_root]\n        edges = []\n\n        connected = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        best_cost = float('inf')\n\n        for it in range(self.max_iter):\n            q_rand = sample_free(it)\n\n            # Alternate tree growth direction for balanced exploration\n            if it % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = start_root, goal_root\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = goal_root, start_root\n\n            r = neighbor_radius(it)\n\n            nearest_a = nearest(tree_a, q_rand)\n            if should_prune(nearest_a, goal_position if tree_a is tree_start else start_position, best_cost):\n                continue\n\n            new_pos = steer(nearest_a.position, q_rand)\n\n            # Lazy collision check for node and edge\n            if check_node_collision(new_pos):\n                continue\n            if check_edge_collision(nearest_a.position, new_pos):\n                continue\n\n            near = near_nodes(tree_a, new_pos, r)\n\n            min_cost = nearest_a.cost + math.dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_through_node = node.cost + math.dist(node.position, new_pos)\n                if cost_through_node < min_cost:\n                    if not check_edge_collision(node.position, new_pos):\n                        min_cost = cost_through_node\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node\n            for node in near:\n                if node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new + 1e-9 < node.cost:  # add epsilon to avoid floating issues\n                    if not check_edge_collision(new_node.position, node.position):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n            # Attempt connecting tree_b to new_node\n            nearest_b = nearest(tree_b, new_node.position)\n            curr_node_b = nearest_b\n\n            extend_success = False\n            extend_iter_limit = max(3, int(self.step_size))\n            for _ in range(extend_iter_limit):\n                pos_b_new = steer(curr_node_b.position, new_node.position)\n                if check_node_collision(pos_b_new) or check_edge_collision(curr_node_b.position, pos_b_new):\n                    break\n\n                cost_b = curr_node_b.cost + math.dist(curr_node_b.position, pos_b_new)\n                new_node_b = Node(pos_b_new)\n                new_node_b.cost = cost_b\n                new_node_b.parent = curr_node_b\n                curr_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                all_nodes.append(new_node_b)\n                edges.append((curr_node_b, new_node_b))\n\n                # Rewire neighbors around new_node_b in tree_b\n                near_b = near_nodes(tree_b, pos_b_new, r)\n                for node_b in near_b:\n                    if node_b == curr_node_b:\n                        continue\n                    cost_through_new_b = new_node_b.cost + math.dist(new_node_b.position, node_b.position)\n                    if cost_through_new_b + 1e-9 < node_b.cost:\n                        if not check_edge_collision(new_node_b.position, node_b.position):\n                            try:\n                                edges.remove((node_b.parent, node_b))\n                            except ValueError:\n                                pass\n                            node_b.update_parent(new_node_b, cost_through_new_b)\n                            edges.append((new_node_b, node_b))\n\n                # Check if connection established within step_size\n                dist_connect = math.dist(new_node_b.position, new_node.position)\n                if dist_connect <= self.step_size and not check_edge_collision(new_node_b.position, new_node.position):\n                    connected = True\n                    extend_success = True\n                    if tree_a is tree_start:\n                        connection_node_start = new_node\n                        connection_node_goal = new_node_b\n                    else:\n                        connection_node_start = new_node_b\n                        connection_node_goal = new_node\n                    break\n\n                curr_node_b = new_node_b\n\n            if connected:\n                # Extract path from roots and merge without duplicating connection node\n                path_start = connection_node_start.path_from_root()\n                path_goal = connection_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n\n                # Update best_cost for potential further pruning\n                total_cost = connection_node_start.cost + connection_node_goal.cost + math.dist(connection_node_start.position, connection_node_goal.position)\n                best_cost = min(best_cost, total_cost)\n\n                # Path smoothing by iterative shortcutting\n                merged_path = self._path_smooth(merged_path, obstacles, is_3d, self.smoothing_trials)\n\n                return PlannerResult(\n                    success=True,\n                    path=merged_path,\n                    nodes=all_nodes,\n                    edges=edges\n                )\n\n        # Fail if no path found within max_iter\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _path_smooth(self, path, obstacles, is_3d, max_trials=100):\n        import random\n        import math\n\n        if len(path) < 3:\n            return path[:]\n\n        path = path[:]\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Shortcut path by removing intermediate nodes\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 144.84568,
        "time_improvement": -483.0,
        "length_improvement": 26.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.9,
                "time_avg": 0.049432682991027835,
                "num_nodes_avg": 189.5,
                "path_length_avg": 153.45427942338446,
                "success_improvement": -9.999999999999998,
                "time_improvement": -424.158722213374,
                "length_improvement": 23.305026069508077,
                "objective_score": -127.58661145011057
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.15793004035949706,
                "num_nodes_avg": 671.6,
                "path_length_avg": 225.66624058956205,
                "success_improvement": 0.0,
                "time_improvement": -971.9368625121973,
                "length_improvement": 25.116306743682713,
                "objective_score": -286.55779740492267
            },
            {
                "map_id": 2,
                "success_rate": 0.8,
                "time_avg": 0.044450783729553224,
                "num_nodes_avg": 317.2,
                "path_length_avg": 117.0670286324166,
                "success_improvement": -19.999999999999996,
                "time_improvement": -53.38463702800561,
                "length_improvement": 28.11379218324113,
                "objective_score": -20.392632671753454
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid planner combines bidirectional RRT* with adaptive informed sampling, dynamic neighbor radius rewiring, balanced tree growth, dead-end pruning, and iterative shortcut smoothing to efficiently search in complex environments. It integrates fast connection attempts like RRT-Connect, while maintaining asymptotic optimality and robustness through rewiring and pruning.",
        "planning_mechanism": "The planner grows two trees from start and goal, always extending the smaller tree to balance expansion. Samples are adaptively biased towards start and goal for directed exploration. Each extension uses a dynamic radius depending on tree size to perform rewiring optimizing path cost. Dead-end pruning is periodically applied to remove unnecessary nodes and reduce computational burden. Upon connecting the two trees without collision, the resultant path is shortcut-smoothed iteratively to improve path quality and smoothness. Collision and edge validity checks are enforced rigorously, ensuring robustness and feasibility.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 5.0, prune_interval: int = 200,\n                 prune_threshold: int = 100, smoothing_iterations: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D or 3D\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            p_bias = 0.8\n            if random.random() < self.goal_sample_rate:\n                # Choose between goal and start with bias p_bias\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            for d in range(len(pos)):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes if beneficial\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not can_connect(p1, p2):\n                    continue\n                path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Extend smaller tree for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -6.83895,
        "time_improvement": 9.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009789466857910156,
                "num_nodes_avg": 98.0,
                "path_length_avg": 163.5535741174694,
                "success_improvement": 0.0,
                "time_improvement": -3.8024668886310224,
                "length_improvement": 18.257495650743063,
                "objective_score": 2.5107590635593064
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.01988651752471924,
                "num_nodes_avg": 202.9,
                "path_length_avg": 241.16005059975564,
                "success_improvement": 0.0,
                "time_improvement": -34.97806467482155,
                "length_improvement": 19.974936403379097,
                "objective_score": -6.498432121770645
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.009808039665222168,
                "num_nodes_avg": 127.6,
                "path_length_avg": 124.92422072194663,
                "success_improvement": 0.0,
                "time_improvement": 66.15576874505864,
                "length_improvement": 23.28900291505477,
                "objective_score": 24.504531206528544
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "This planner is a tuned and optimized bidirectional RRT* variant featuring balanced tree growth with dynamic, decaying rewiring radius and heuristic adaptive sampling. It integrates mutual rewiring and connection attempts between the two growing trees, combined with periodic pruning of dead-end nodes and aggressive shortcut smoothing for path quality. Collision checks ensure all nodes and edges are obstacle-free, while adaptive sampling shifts focus from start/goal bias towards promising middle regions as iterations progress, enhancing efficiency, robustness, success rate, and resulting in smoother, shorter paths in both 2D and 3D environments.",
        "planning_mechanism": "The planner grows two trees from start and goal positions alternately extending the smaller tree to keep balanced growth. Sampling is adaptively biased, progressively favoring exploration near the midpoint between trees. Nodes are added if collision-free with rewiring performed locally using a radius that decays with iterations and node count. After each extension, it attempts to connect and mutually rewire the opposite tree. Dead-ends are pruned periodically to maintain efficiency. Upon finding a connection, the raw path is shortcut and smoothed aggressively with collision validation, outputting the shortest highest-quality path found within the iteration budget.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 radius_constant: float = 30.0,\n                 radius_min: float = 3.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 100,\n                 smoothing_iterations: int = 40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def radius_by_nodes_and_iter(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt(math.log(n_nodes) / n_nodes)\n            decay_factor = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay_factor)\n\n        def is_free_node(pos):\n            if not in_bounds(pos):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr):\n            r = random.random()\n            if r < self.goal_sample_rate:\n                sr = random.random()\n                if sr < 0.7 and is_free_node(goal_position):\n                    return goal_position\n                elif sr < 0.85 and is_free_node(start_position):\n                    return start_position\n                else:\n                    if len(tree_start) > 20 and len(tree_goal) > 20:\n                        mid_s = random.choice(tree_start).position\n                        mid_g = random.choice(tree_goal).position\n                        mid = tuple((mid_s[i] + mid_g[i]) / 2 for i in range(dim))\n                        spread = self.step_size * 4 * (1 - itr / self.max_iter)\n                        for _ in range(7):\n                            candidate = tuple(\n                                max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim)\n                            )\n                            if is_free_node(candidate):\n                                return candidate\n            attempts = 0\n            while attempts < 100:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n                attempts += 1\n            # Fallbacks\n            if is_free_node(start_position):\n                return start_position\n            if is_free_node(goal_position):\n                return goal_position\n            return tuple(bounds[d]/2 for d in range(dim))\n\n        def try_extend(tree, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not is_free_node(new_pos) or not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes_and_iter(len(tree), itr)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node, itr):\n            if not tree:\n                return None\n\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos) or not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes_and_iter(len(tree), itr)\n                near = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in near:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-10 < min_cost:\n                        if is_free_edge(node.position, new_pos):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in near:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-10 < neighbor.cost:\n                        if is_free_edge(new_node.position, neighbor.position):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if is_free_edge(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample = adaptive_sample(itr)\n\n            # Alternate extension on smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start, itr)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                shortcuted_path = shortcut_path(raw_path)\n                smoothed_path = smooth_path(shortcuted_path)\n\n                candidates = [raw_path, shortcuted_path, smoothed_path]\n                extracted_path = min(candidates, key=path_length)\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 2.00464,
        "time_improvement": -21.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.011858797073364258,
                "num_nodes_avg": 75.7,
                "path_length_avg": 160.299997433265,
                "success_improvement": 0.0,
                "time_improvement": -25.7445791904621,
                "length_improvement": 19.883602005766534,
                "objective_score": -3.746653355985323
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.021180176734924318,
                "num_nodes_avg": 184.2,
                "path_length_avg": 235.78565562855914,
                "success_improvement": 0.0,
                "time_improvement": -43.75866773039373,
                "length_improvement": 21.758342478696097,
                "objective_score": -8.775931823378901
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.027430248260498048,
                "num_nodes_avg": 172.0,
                "path_length_avg": 122.9161912557353,
                "success_improvement": 0.0,
                "time_improvement": 5.347480516360658,
                "length_improvement": 24.522053973038755,
                "objective_score": 6.5086549495159485
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This planner implements a simplified bidirectional RRT* algorithm with adaptive informed sampling biased toward start and goal. It extends the smaller of two trees each iteration, dynamically adjusts the rewiring radius to optimize path cost, and prunes dead-ends periodically to maintain efficiency. Upon connecting the trees, a shortcut path smoothing is applied to improve path quality while rigorously checking collisions and edge feasibility. The approach balances exploration and exploitation, enhancing planning speed, path smoothness, and success rate without excessive complexity.",
        "planning_mechanism": "The planner grows two trees from start and goal, sampling points biased towards these points. Each iteration extends the smaller tree toward a sample with steering and rewiring via nearby nodes in a dynamic radius. It attempts to connect the trees after extensions. Dead-end pruning reduces complexity, and iterative shortcut smoothing refines the final path. All nodes and edges undergo collision and obstacle intersection checks to ensure safety and validity.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 radius_constant: float=25.0,\n                 radius_min: float=5.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=100,\n                 smoothing_iterations: int=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            bias_prob = 0.8\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < bias_prob else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            return max(self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1)), self.radius_min)\n\n        def can_add_node(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            for d in range(len(pos)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed_nodes.append(node)\n                    except Exception:\n                        continue\n            return removed_nodes\n\n        def path_length(path: List[Tuple[float, ...]]):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path: List[Tuple[float, ...]]):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n                smoothed_path = shortcut_smoothing(raw_path)\n                if path_length(smoothed_path) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 0.92955,
        "time_improvement": -16.0,
        "length_improvement": 19.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.00610663890838623,
                "num_nodes_avg": 71.6,
                "path_length_avg": 164.5770735955512,
                "success_improvement": 0.0,
                "time_improvement": 35.24834474755979,
                "length_improvement": 17.74596044895973,
                "objective_score": 14.123695514059882
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.020606112480163575,
                "num_nodes_avg": 232.9,
                "path_length_avg": 247.8890045532666,
                "success_improvement": 0.0,
                "time_improvement": -39.862254896407975,
                "length_improvement": 17.74204183096025,
                "objective_score": -8.410268102730342
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.04159536361694336,
                "num_nodes_avg": 163.0,
                "path_length_avg": 125.74184748902557,
                "success_improvement": 0.0,
                "time_improvement": -43.53154691828184,
                "length_improvement": 22.78693082540316,
                "objective_score": -8.50207791040392
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This planner integrates the adaptive bidirectional RRT* framework with dynamic neighbor radius rewiring, heuristic sampling biasing towards both start and goal, incremental rewiring optimization, lazy collision checks, and enhanced path shortcut smoothing. It alternates tree growth from start and goal with adaptive sampling bias balancing exploration and focused search, dynamically controls neighbor radius to balance global exploration and local path refinement, and incrementally rewires nodes to minimize path cost while ensuring collision-free connections. The planner employs efficient incremental connection attempts between trees and performs iterative shortcut-based smoothing after path extraction to minimize path length and improve smoothness, resulting in improved planning efficiency, higher success rates, shorter and smoother paths, and reduced computational overhead.",
        "planning_mechanism": "The planner grows two trees alternately from start and goal positions by sampling points with adaptive goal bias, steering nodes towards these samples within step size limits, and adding collision-free nodes. It dynamically adjusts the neighbor radius for rewiring to locally optimize connections and path costs. Each newly added node rewires its neighborhood if cheaper paths exist without collisions. The trees attempt incremental connection via steering; upon successful connection, the algorithm extracts and merges the paths from both trees and applies iterative shortcut smoothing to the combined path. This process results in efficient and robust path planning with minimized planning time and improved path quality.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2,\n                 min_neighbor_radius: float=8.0,\n                 max_neighbor_radius: float=25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def adaptive_goal_bias(iteration, toggle_start):\n            bias = min(self.goal_sample_rate + 0.25 * (iteration / self.max_iter), 0.4)\n            if random.random() < bias:\n                return start_position if toggle_start else goal_position\n            attempts = 100\n            for _ in range(attempts):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return start_position if toggle_start else goal_position\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            if in_bounds(new_p):\n                return new_p\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(len(bounds)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def neighbor_radius(iteration):\n            factor = (1.0 - (iteration / self.max_iter) ** 0.95)\n            radius = max(self.min_neighbor_radius, self.max_neighbor_radius * factor)\n            return radius\n\n        def near_nodes(tree, pos, radius):\n            # Linear search - could be optimized with spatial structures if needed\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        # Initialize trees\n        start_root = Node(start_position, None, 0.0)\n        goal_root = Node(goal_position, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        final_path = []\n        toggle_start_tree = True  # alternate which tree grows sampling bias\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_goal_bias(it, toggle_start_tree)\n\n            tree_a = tree_start if toggle_start_tree else tree_goal\n            tree_b = tree_goal if toggle_start_tree else tree_start\n\n            radius = neighbor_radius(it)\n\n            nearest_node = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_node.position, q_rand)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                toggle_start_tree = not toggle_start_tree\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                toggle_start_tree = not toggle_start_tree\n                continue\n\n            near = near_nodes(tree_a, new_pos, radius)\n\n            # Find best parent minimizing cost with collision check\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                cost_candidate = node.cost + math.dist(node.position, new_pos)\n                if cost_candidate < min_cost and \\\n                   not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper paths via new_node found\n            for node in near:\n                if node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost and \\\n                   not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, node))\n\n            # Attempt incremental connection from tree_b to new_node\n            curr_node_b = nearest(tree_b, new_node.position)\n            connected_node_b = None\n            while True:\n                new_pos_b = steer(curr_node_b.position, new_node.position)\n\n                if self._is_in_obstacle(new_pos_b, obstacles, is_3d) or \\\n                   self._is_edge_in_obstacle(curr_node_b.position, new_pos_b, obstacles, is_3d):\n                    break\n\n                cost_b = curr_node_b.cost + math.dist(curr_node_b.position, new_pos_b)\n                new_node_b = Node(new_pos_b)\n                new_node_b.cost = cost_b\n                new_node_b.parent = curr_node_b\n                curr_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((curr_node_b, new_node_b))\n\n                # Rewire around new_node_b\n                near_b = near_nodes(tree_b, new_pos_b, radius)\n                for node in near_b:\n                    if node == curr_node_b:\n                        continue\n                    cost_through_new_b = new_node_b.cost + math.dist(new_node_b.position, node.position)\n                    if cost_through_new_b < node.cost and \\\n                       not self._is_edge_in_obstacle(new_node_b.position, node.position, obstacles, is_3d):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node_b, cost_through_new_b)\n                        edges.append((new_node_b, node))\n\n                if math.dist(new_node_b.position, new_node.position) <= self.step_size * 0.5:\n                    connected_node_b = new_node_b\n                    break\n\n                curr_node_b = new_node_b\n\n            if connected_node_b:\n                success_state = True\n                connection_start = new_node if toggle_start_tree else connected_node_b\n                connection_goal = connected_node_b if toggle_start_tree else new_node\n\n                path_start = connection_start.path_from_root()\n                path_goal = connection_goal.path_from_root()\n\n                merged_path = path_start + path_goal[::-1][1:]  # avoid duplicate connection node\n\n                # Improved smoothing: iterative shortcutting with early stopping on improvements\n                merged_path = self._path_smooth(merged_path, obstacles, is_3d, max_trials=200)\n\n                final_path = merged_path\n                break\n\n            toggle_start_tree = not toggle_start_tree\n\n        return PlannerResult(\n            success=success_state,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smooth(self, path, obstacles, is_3d, max_trials=200):\n        import random\n        if len(path) < 3:\n            return path[:]\n        path = path[:]\n        improved = True\n        trials = 0\n        while trials < max_trials and improved and len(path) >= 3:\n            improved = False\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                path = path[:i+1] + path[j:]\n                improved = True\n            trials += 1\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 35.52619,
        "time_improvement": -127.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.016216087341308593,
                "num_nodes_avg": 92.8,
                "path_length_avg": 167.21171696397616,
                "success_improvement": 0.0,
                "time_improvement": -71.94704203418452,
                "length_improvement": 16.42919101628725,
                "objective_score": -18.298274406997905
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.045920491218566895,
                "num_nodes_avg": 405.4,
                "path_length_avg": 234.2820767789768,
                "success_improvement": 0.0,
                "time_improvement": -211.68147092092764,
                "length_improvement": 22.25728080932391,
                "objective_score": -59.0529851144135
            },
            {
                "map_id": 2,
                "success_rate": 0.9,
                "time_avg": 0.05715479850769043,
                "num_nodes_avg": 388.4,
                "path_length_avg": 122.63231395473022,
                "success_improvement": -9.999999999999998,
                "time_improvement": -97.22189999728509,
                "length_improvement": 24.696371736912198,
                "objective_score": -29.227295651803086
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This improved planner implements a bidirectional informed RRT* with enhancements focusing on efficiency and robustness: it integrates adaptive dynamic neighbor radius pruning based on node density, incremental lazy collision checking with caching to minimize redundant checks, and heuristic-informed ellipsoidal sampling after the initial path discovery. It performs balanced alternate growth of start and goal trees, applies local rewiring to improve path costs, and incrementally attempts to connect trees. Once connected, the planner performs accelerated path smoothing with optimized iterative shortcutting and cost-aware pruning to improve path quality and smoothness while reducing search time. Additional optimizations include early collision skipping, bounding-box based quick pruning for edge checks, and clustering to speed nearest neighbor queries. Overall, it strives to improve success rate, planning time, path length, and smoothness.",
        "planning_mechanism": "The planner alternates growing two RRT* trees from start and goal points. It begins with uniform random sampling across the configuration space. After finding an initial feasible path, sampling is restricted within an informed ellipsoid defined by the current best path cost to focus search efficiently. Each sampled point guides the tree extension after steering within step limits. Collision checks for new nodes and edges are performed lazily with caching. A dynamically computed neighborhood radius governs local rewiring of nodes to reduce path cost. The planner incrementally attempts to connect the two trees after every extension using incremental steering with edge collision checks. Upon successful connection, it reconstructs the optimized path and further refines it using iterative shortcutting while ensuring collision-free shortcuts, resulting in smoother and shorter paths in less time.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position          # Tuple[float, ...] (2D or 3D)\n        self.parent = parent              # Parent Node or None\n        self.cost = cost                  # Cost from root node to this node\n        self.children = []\n        self.valid = True                 # For potential future use (lazy validation)\n\n        # Lazy collision check cache for node inside obstacle (True=collision, False=free, None=unchecked)\n        self._in_collision = None\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def __repr__(self):\n        return f\"Node(pos={self.position}, cost={self.cost:.3f})\"\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n        # Cache for edge collision checks {(pos1,pos2): bool}\n        self._edge_collision_cache = {}\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def distance(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n            # Clamp inside bounds to avoid floating errors\n            clamped = tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n            return clamped\n\n        def sample_free_uniform() -> Tuple[float, ...]:\n            for _ in range(1000):  # Limit retries for robustness\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback if retries exhausted: return start or goal minimally disturbed\n            return start_position if random.random() < 0.5 else goal_position\n\n        def ellipse_sample(center, c_min, c_max, start, goal) -> Tuple[float, ...]:\n            # Inspired by Informed RRT* - sample inside ellipsoidal informed subset\n            if c_max < c_min:\n                c_max = c_min\n\n            if is_3d:\n                import numpy as np\n                c1 = np.array(start)\n                c2 = np.array(goal)\n                center_np = np.array(center)\n\n                a1 = (c2 - c1) / np.linalg.norm(c2 - c1)  # major axis unit vector\n\n                # Construct orthonormal basis around a1\n                def orthonormal_basis(a):\n                    # Generate vector not parallel to a\n                    if abs(a[0]) < 0.9:\n                        v = np.array([1, 0, 0])\n                    else:\n                        v = np.array([0, 1, 0])\n                    e2 = np.cross(a, v)\n                    e2 /= np.linalg.norm(e2)\n                    e3 = np.cross(a, e2)\n                    return np.column_stack((a, e2, e3))\n\n                C = orthonormal_basis(a1)\n\n                r1 = c_max / 2.0\n                r2 = math.sqrt(c_max*c_max - c_min*c_min) / 2.0\n                r3 = r2\n\n                for _ in range(100):\n                    u = np.random.normal(0, 1, 3)\n                    norm_u = np.linalg.norm(u)\n                    if norm_u == 0:\n                        continue\n                    unit_u = u / norm_u\n                    radius_scale = random.random() ** (1/3)\n                    sample_ball = unit_u * radius_scale\n                    sample_ellipsoid = C @ np.array([r1*sample_ball[0], r2*sample_ball[1], r3*sample_ball[2]])\n                    sample = center_np + sample_ellipsoid\n                    clipped = np.clip(sample, np.zeros_like(sample), np.array(bounds))\n                    sample_t = tuple(clipped)\n                    if not self._is_in_obstacle(sample_t, obstacles, is_3d) and in_bounds(sample_t):\n                        return sample_t\n                # Fallback uniform sample\n                return sample_free_uniform()\n\n            else:\n                # 2D ellipse sampling\n                c1x, c1y = center\n                r1 = c_max / 2.0\n                if c_max*c_max - c_min*c_min < 0.0:\n                    r2 = 0.0\n                else:\n                    r2 = math.sqrt(c_max*c_max - c_min*c_min) / 2.0\n\n                dx = goal[0] - start[0]\n                dy = goal[1] - start[1]\n                length = math.hypot(dx, dy)\n                if length == 0:\n                    return start\n\n                cos_angle = dx / length\n                sin_angle = dy / length\n\n                for _ in range(100):\n                    theta = random.uniform(0, 2 * math.pi)\n                    rho = math.sqrt(random.uniform(0, 1))  # uniform sampling in ellipse\n                    x_ball = rho * math.cos(theta)\n                    y_ball = rho * math.sin(theta)\n                    x_ell = r1 * x_ball\n                    y_ell = r2 * y_ball\n\n                    x_rot = cos_angle * x_ell - sin_angle * y_ell\n                    y_rot = sin_angle * x_ell + cos_angle * y_ell\n                    sample = (c1x + x_rot, c1y + y_rot)\n\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                # Fallback uniform sample\n                return sample_free_uniform()\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            # Linear nearest neighbor search; replaceable by spatial index if desired\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = distance(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            # Linear near neighbor search; can be optimized with spatial indexing\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def neighbor_radius(n_nodes: int) -> float:\n            # Typical RRT* neighbor radius with adaptive decay\n            if n_nodes < 2:\n                return float('inf')\n            gamma = 35.0  # Tuned for problem size and dimension\n            unit_ball_volume = math.pi if dim == 2 else 4 / 3 * math.pi\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1 / dim))\n            return max(r, self.step_size)\n\n        def edge_cache_key(pos1: Tuple[float, ...], pos2: Tuple[float, ...]) -> Tuple[Tuple[float, ...], Tuple[float, ...]]:\n            # Order-independent tuple key for caching edges\n            return tuple(sorted([pos1, pos2]))\n\n        def is_edge_collision_cached(pos1, pos2):\n            key = edge_cache_key(pos1, pos2)\n            return self._edge_collision_cache.get(key, None)\n\n        def cache_edge_collision(pos1, pos2, value: bool):\n            key = edge_cache_key(pos1, pos2)\n            self._edge_collision_cache[key] = value\n\n        # Initialize trees\n        start_root = Node(start_position, None, 0.0)\n        goal_root = Node(goal_position, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        c_min = distance(start_position, goal_position)\n        c_max = float('inf')\n        center = tuple((start_position[d] + goal_position[d]) / 2.0 for d in range(dim))\n\n        path_found = False\n        success_state = False\n        connection_start = None\n        connection_goal = None\n\n        for it in range(self.max_iter):\n            # Sampling\n            if path_found:\n                q_rand = ellipse_sample(center, c_min, c_max, start_position, goal_position)\n            else:\n                q_rand = sample_free_uniform()\n\n            # Alternate tree growth\n            tree_a, tree_b = (tree_start, tree_goal) if it % 2 == 0 else (tree_goal, tree_start)\n\n            # Find nearest node in tree_a and steer\n            nearest_node = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_node.position, q_rand)\n\n            # Avoid checking if new_pos coincides with nearest node (to prevent degenerate branches)\n            if distance(nearest_node.position, new_pos) < 1e-7:\n                continue\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Edge collision lazy check with caching\n            cached = is_edge_collision_cached(nearest_node.position, new_pos)\n            if cached is None:\n                in_collision = self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n                cache_edge_collision(nearest_node.position, new_pos, in_collision)\n                if in_collision:\n                    continue\n            else:\n                if cached:\n                    continue\n\n            # Add new node and edge\n            new_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Local rewiring within neighbor radius in tree_a\n            radius = neighbor_radius(len(tree_a))\n            near = near_nodes(tree_a, new_pos, radius)\n\n            for other in near:\n                if other is nearest_node or other is new_node:\n                    continue\n                potential_cost = new_node.cost + distance(new_node.position, other.position)\n                if potential_cost + 1e-8 < other.cost:\n                    cached_rewire = is_edge_collision_cached(new_node.position, other.position)\n                    if cached_rewire is None:\n                        in_collision_rewire = self._is_edge_in_obstacle(new_node.position, other.position, obstacles, is_3d)\n                        cache_edge_collision(new_node.position, other.position, in_collision_rewire)\n                    else:\n                        in_collision_rewire = cached_rewire\n                    if not in_collision_rewire:\n                        # Remove old edge safely\n                        if other.parent:\n                            try:\n                                edges.remove((other.parent, other))\n                            except ValueError:\n                                pass\n                        other.update_parent(new_node, potential_cost)\n                        edges.append((new_node, other))\n\n            # Attempt to connect tree_b to new_node via incremental steering\n            connect_node_b = nearest(tree_b, new_node.position)\n            prev_node_b = connect_node_b\n            connected = False\n\n            # Limit max steps to avoid excessive expansions at connection attempt\n            max_connect_steps = max(10, int(distance(connect_node_b.position, new_node.position) / self.step_size) + 2)\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(prev_node_b.position, new_node.position)\n\n                # Early stop if no movement possible\n                if distance(prev_node_b.position, next_pos_b) < 1e-7:\n                    break\n\n                # Node collision check for next_pos_b\n                if self._is_in_obstacle(next_pos_b, obstacles, is_3d):\n                    break\n\n                # Edge collision check lazy with cache\n                cached_conn = is_edge_collision_cached(prev_node_b.position, next_pos_b)\n                if cached_conn is None:\n                    collides = self._is_edge_in_obstacle(prev_node_b.position, next_pos_b, obstacles, is_3d)\n                    cache_edge_collision(prev_node_b.position, next_pos_b, collides)\n                    if collides:\n                        break\n                else:\n                    if cached_conn:\n                        break\n\n                cost_b = prev_node_b.cost + distance(prev_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=prev_node_b, cost=cost_b)\n                prev_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((prev_node_b, new_node_b))\n\n                # Local rewiring in tree_b near new_node_b\n                radius_b = neighbor_radius(len(tree_b))\n                near_b = near_nodes(tree_b, next_pos_b, radius_b)\n                for nb_node in near_b:\n                    if nb_node is prev_node_b or nb_node is new_node_b:\n                        continue\n                    cost_via_new = new_node_b.cost + distance(new_node_b.position, nb_node.position)\n                    if cost_via_new + 1e-8 < nb_node.cost:\n                        cached_rewire_b = is_edge_collision_cached(new_node_b.position, nb_node.position)\n                        if cached_rewire_b is None:\n                            in_col_b = self._is_edge_in_obstacle(new_node_b.position, nb_node.position, obstacles, is_3d)\n                            cache_edge_collision(new_node_b.position, nb_node.position, in_col_b)\n                        else:\n                            in_col_b = cached_rewire_b\n                        if not in_col_b:\n                            # Remove old edge safely\n                            if nb_node.parent:\n                                try:\n                                    edges.remove((nb_node.parent, nb_node))\n                                except ValueError:\n                                    pass\n                            nb_node.update_parent(new_node_b, cost_via_new)\n                            edges.append((new_node_b, nb_node))\n\n                # Check if close enough to connect directly to new_node\n                if distance(new_node_b.position, new_node.position) <= self.step_size:\n                    cached_final = is_edge_collision_cached(new_node_b.position, new_node.position)\n                    if cached_final is None:\n                        col_final = self._is_edge_in_obstacle(new_node_b.position, new_node.position, obstacles, is_3d)\n                        cache_edge_collision(new_node_b.position, new_node.position, col_final)\n                    else:\n                        col_final = cached_final\n                    if not col_final:\n                        final_cost = new_node_b.cost + distance(new_node_b.position, new_node.position)\n                        connect_node_goal = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                        new_node_b.children.append(connect_node_goal)\n                        tree_b.append(connect_node_goal)\n                        nodes.append(connect_node_goal)\n                        edges.append((new_node_b, connect_node_goal))\n\n                        if tree_a is tree_start:\n                            connection_start = new_node\n                            connection_goal = connect_node_goal\n                        else:\n                            connection_start = connect_node_goal\n                            connection_goal = new_node\n\n                        success_state = True\n                        connected = True\n                    break\n\n                prev_node_b = new_node_b\n            if success_state and connected:\n                # Merge path from start and goal (avoid duplicate connection node)\n                path_start = connection_start.path_from_root()\n                path_goal = connection_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n\n                # Update informed sampling parameters\n                best_path_length = 0.0\n                for i in range(len(merged_path) - 1):\n                    best_path_length += distance(merged_path[i], merged_path[i + 1])\n                c_max = best_path_length + 1e-6\n                center = tuple((start_position[d] + goal_position[d]) / 2.0 for d in range(dim))\n                path_found = True\n\n                # Accelerated iterative path smoothing with cost pruning\n                def path_smooth(path: List[Tuple[float, ...]], max_trials: int = 250) -> List[Tuple[float, ...]]:\n                    path = path[:]\n                    length = len(path)\n                    if length < 3:\n                        return path\n\n                    for _ in range(max_trials):\n                        if len(path) < 3:\n                            break\n                        i = random.randint(0, len(path) - 3)\n                        j = random.randint(i + 2, len(path) - 1)\n\n                        # Quick cost pruning: shortcut should reduce path length\n                        old_segment_length = 0.0\n                        for idx in range(i, j):\n                            old_segment_length += distance(path[idx], path[idx + 1])\n                        shortcut_length = distance(path[i], path[j])\n                        if shortcut_length + 1e-6 >= old_segment_length:\n                            continue\n\n                        if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                            # Remove intermediate nodes\n                            path[i + 1:j] = []\n                    return path\n\n                merged_path = path_smooth(merged_path)\n                return PlannerResult(\n                    success=True,\n                    path=merged_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        # Failed to find path within max_iter\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 23.57999,
        "time_improvement": -92.0,
        "length_improvement": 19.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.024658703804016115,
                "num_nodes_avg": 97.2,
                "path_length_avg": 164.23396332317765,
                "success_improvement": 0.0,
                "time_improvement": -161.46820069825236,
                "length_improvement": 17.917443665288754,
                "objective_score": -44.85697147641796
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.0352531909942627,
                "num_nodes_avg": 256.6,
                "path_length_avg": 244.92522235971245,
                "success_improvement": 0.0,
                "time_improvement": -139.27806807313826,
                "length_improvement": 18.725525031995637,
                "objective_score": -38.03831541554235
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.021411323547363283,
                "num_nodes_avg": 243.6,
                "path_length_avg": 127.67242521371278,
                "success_improvement": 0.0,
                "time_improvement": 26.116756217775787,
                "length_improvement": 21.601439802486393,
                "objective_score": 12.155314825830015
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "This improved bidirectional RRT* planner leverages goal-biased sampling with adaptive probabilities, enhanced nearest neighbor searching using a k-d tree structure for quick retrieval, and dynamic rewiring to minimize path length and increase convergence speed. It incorporates smoothing via shortcut attempts and biasing towards the connecting path to reduce total planning time and improve path quality. The planner carefully avoids map boundary exceedance, optimizes local rewiring by radius, and validates every node and edge for collisions to maintain robustness and safety.",
        "planning_mechanism": "The planner alternately grows two trees from start and goal by sampling points with adaptive goal bias, steering new nodes towards samples with limited step size, and locally rewiring neighbors to reduce costs. Using fast nearest neighbor search and incremental rewiring within a radius improves path optimality. Once the two trees connect via collision-free edges, the planner backtracks the lowest cost path and applies path shortcuts for smoothness and length reduction. This combination accelerates convergence, increases success rate, and outputs a shorter, smoother path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def dist(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        from collections import deque\n        from bisect import bisect_left\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Maintain k-d tree like structure for fast nearest search\n        # We'll store positions separately for quick access\n        def build_kd_tree(node_list):\n            # Simple spatial sorted list per dimension for quick pruning\n            # Here for simplicity we only sort by first dimension \n            return sorted(node_list, key=lambda n: n.position[0])\n\n        def kd_nearest(tree, point):\n            # Binary search approach on first dimension for initial pruning\n            sorted_nodes = build_kd_tree(tree)\n            xs = [n.position[0] for n in sorted_nodes]\n            i = bisect_left(xs, point[0])\n            candidates = []\n            # pick neighbors around i (+/- 10 nodes or less depending on tree size)\n            start_idx = max(0, i - 10)\n            end_idx = min(len(sorted_nodes), i + 10)\n            for cand in sorted_nodes[start_idx:end_idx]:\n                candidates.append(cand)\n            return min(candidates, key=lambda n: math.dist(n.position, point)) if candidates else None\n\n        def sample_free():\n            nonlocal start_position, goal_position\n            # Adaptive goal bias:\n            # Increase goal bias as iterations grow to speed convergence\n            prob_goal = min(0.5, self.goal_sample_rate + (iteration / self.max_iter) * 0.35)\n            if random.random() < prob_goal:\n                # Pick start or goal with 50% chance to reduce symmetry bias\n                return start_position if random.random() < 0.5 else goal_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos):\n            # Local radius-based neighbor search (approximate)\n            # To speed-up, filter first by bounding box around pos and radius\n            radius = self.neighbor_radius\n            r2 = radius * radius\n            candidates = []\n            threshold_min = [pos[d] - radius for d in range(dim)]\n            threshold_max = [pos[d] + radius for d in range(dim)]\n            for n in tree:\n                p = n.position\n                # Quick bounding box filter:\n                in_box = True\n                for d in range(dim):\n                    if p[d] < threshold_min[d] or p[d] > threshold_max[d]:\n                        in_box = False\n                        break\n                if not in_box:\n                    continue\n                # Precise squared distance check:\n                dist_sq = sum((p[d] - pos[d])**2 for d in range(dim))\n                if dist_sq <= r2:\n                    candidates.append(n)\n            return candidates\n\n        def try_extend(tree, point):\n            nearest_node = kd_nearest(tree, point)\n            if nearest_node is None:\n                return None\n            new_pos = steer(nearest_node.position, point)\n\n            if not self._within_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            near = near_nodes(tree, new_pos)\n            # Find best parent minimizing cost + edge length\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                edge_len = math.dist(node.position, new_pos)\n                temp_cost = node.cost + edge_len\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper paths through new_node\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = kd_nearest(tree, node.position)\n            if nearest_node is None:\n                return None\n\n            current = nearest_node\n            last_node = None\n            while True:\n                new_pos = steer(current.position, node.position)\n\n                if not self._within_bounds(new_pos, bounds):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = current.cost + math.dist(current.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = current\n                current.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n\n                last_node = new_node\n\n                if math.dist(new_pos, node.position) <= self.step_size:\n                    return new_node\n                current = new_node\n\n        def shorten_path(path, max_trials=30):\n            # Attempts shortcutting path segments to smooth and shorten path\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # Shortcut path segment\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Alternate growth between start and goal tree\n        for iteration in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Extend tree_start towards sample\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                # Swap and continue search\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            # Attempt to connect tree_goal towards new_node_start\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                # Verify connection edge safe\n                if not self._is_edge_in_obstacle(new_node_start.position, new_node_goal.position, obstacles, is_3d):\n                    success_state = True\n\n                    # Compute cost + path from roots\n                    path_start = new_node_start.path_from_root()\n                    path_goal = new_node_goal.path_from_root()\n\n                    # Merge paths avoiding duplicate connection point\n                    full_path = path_start + path_goal[::-1][1:]\n                    # Shortcut path to improve smoothness and length\n                    extracted_path = shorten_path(full_path, max_trials=50)\n                    break\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        for d in range(len(bounds)):\n            if pos[d] < 0 or pos[d] > bounds[d]:\n                return False\n        return True",
        "objective": 154.97603,
        "time_improvement": -526.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.015265512466430663,
                "num_nodes_avg": 86.3,
                "path_length_avg": 163.78498192434841,
                "success_improvement": 0.0,
                "time_improvement": -61.867635422275804,
                "length_improvement": 18.141840253040325,
                "objective_score": -14.931922576074674
            },
            {
                "map_id": 1,
                "success_rate": 0.9,
                "time_avg": 0.2385347843170166,
                "num_nodes_avg": 700.0,
                "path_length_avg": 231.2405784910686,
                "success_improvement": -9.999999999999998,
                "time_improvement": -1519.034780962306,
                "length_improvement": 23.26655283971846,
                "objective_score": -456.0571237207481
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.02815964221954346,
                "num_nodes_avg": 202.6,
                "path_length_avg": 120.41337962188034,
                "success_improvement": 0.0,
                "time_improvement": 2.830588388219888,
                "length_improvement": 26.058931088135186,
                "objective_score": 6.060962734093003
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This improved planner implements a hybrid bidirectional RRT* algorithm that combines adaptive heuristic-informed sampling with rewiring and dynamic radius adjustments to enhance path quality, planning efficiency, and robustness. It grows two balanced trees from start and goal, uses decaying radius for local optimization, and applies shortcut smoothing. The planner enforces rigorous collision checks on nodes and edges and includes mutual rewiring between the trees.",
        "planning_mechanism": "The planner alternately samples points biased towards the goal and promising connection regions, extends the smaller of two trees first, and attempts to connect and rewire the opposite tree to the new node. It dynamically shrinks the rewiring radius over iterations to fine-tune the path. When connection succeeds, the final path is shortcut to improve smoothness and reduce path length.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = parent                # Node or None\n        self.cost = cost                   # Total cost from root\n        self.children: List[Node] = []\n        self.valid = True                  # For collision and validity checks\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0, radius_min: float=3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # (W,H) or (W,H,D)\n        start_position = map.start         # (x,y) or (x,y,z)\n        goal_position = map.goal           # (x,y) or (x,y,z)\n        obstacles = map.obstacles          # obstacle list\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes: int, itr: int) -> float:\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt((math.log(n_nodes) / n_nodes))\n            decay_factor = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay_factor)\n\n        def is_free_node(pos: Tuple[float, ...]) -> bool:\n            return not self._is_in_obstacle(pos, obstacles, is_3d) and self._in_bounds(pos, bounds)\n\n        def is_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr: int) -> Tuple[float, ...]:\n            r = random.random()\n            # Increase goal bias early on, then bias around connection regions\n            if r < self.goal_sample_rate:\n                subr = random.random()\n                if subr < 0.7 and is_free_node(goal_position):\n                    return goal_position\n                elif subr < 0.8 and is_free_node(start_position):\n                    return start_position\n                else:\n                    if len(tree_start) > 10 and len(tree_goal) > 10:\n                        mid_start = random.choice(tree_start).position\n                        mid_goal = random.choice(tree_goal).position\n                        mid = tuple((mid_start[i] + mid_goal[i]) / 2 for i in range(dim))\n                        spread = self.step_size * 5 * (1 - itr / self.max_iter)\n                        for _ in range(5):\n                            candidate = tuple(max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim))\n                            if is_free_node(candidate):\n                                return candidate\n            # Uniform random sampling in free space\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n            # fallback\n            return start_position\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...], itr: int) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not is_free_node(new_pos) or not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree), itr)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect_and_rewire(tree: List[Node], target_node: Node, itr: int) -> Node or None:\n            if not tree:\n                return None\n\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos) or not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes(len(tree), itr)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-10 < min_cost:\n                        if is_free_edge(node.position, new_pos):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-10 < neighbor.cost:\n                        if is_free_edge(new_node.position, neighbor.position):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, cost=final_cost)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        for itr in range(self.max_iter):\n            rand_point = adaptive_sample(itr)\n\n            # Grow and extend smaller tree first for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start, itr)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n                extracted_path = shortcut_path(merged_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles, is_3d: bool, resolution: float=1.0) -> bool:\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _in_bounds(self, pos: Tuple[float, ...], bounds: Tuple[int, ...]) -> bool:\n        for i, val in enumerate(pos):\n            if not (0 <= val <= bounds[i]):\n                return False\n        return True",
        "objective": -2.01459,
        "time_improvement": -8.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.01171426773071289,
                "num_nodes_avg": 88.1,
                "path_length_avg": 156.993274506226,
                "success_improvement": 0.0,
                "time_improvement": -24.212064445506222,
                "length_improvement": 21.536270342143798,
                "objective_score": -2.9563652652231065
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02367534637451172,
                "num_nodes_avg": 304.5,
                "path_length_avg": 240.06958683889093,
                "success_improvement": 0.0,
                "time_improvement": -60.6944217440485,
                "length_improvement": 20.33678917126493,
                "objective_score": -14.140968688961562
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.010984659194946289,
                "num_nodes_avg": 171.9,
                "path_length_avg": 126.10799280654412,
                "success_improvement": 0.0,
                "time_improvement": 62.095652266914136,
                "length_improvement": 22.56209554348175,
                "objective_score": 23.14111478877059
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This planner is a streamlined bidirectional RRT* variant optimized for general use. It balances efficient exploration and exploitation by alternating growth between two trees starting at the start and goal positions. Using fixed step steering, it samples free points with a goal biasing strategy, validates nodes and edges rigorously against obstacles, and incrementally rewires near neighbors to improve path cost locally. Upon successfully connecting the two trees, it reconstructs and smooths the path for better quality, maintaining robustness, efficiency, and improved path lengths without complex adaptive heuristics.",
        "planning_mechanism": "The planner alternates extending the smaller of two growing trees toward sampled points biased toward the goal. Each extension node is checked against collisions, and rewiring within a radius improves local optimality. Attempted connections between trees validate collision-free edges to establish the final path. Post connection, path smoothing removes unnecessary waypoints, enhancing smoothness and reducing path length.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 5.0, smoothing_iterations: int = 20):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes = []\n        edges = []\n        success = False\n        final_path = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            r_sq = radius * radius\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, base)\n\n        def sample_free():\n            r = random.random()\n            if r < self.goal_sample_rate:\n                # Bias mostly to goal, sometimes start for balanced growth\n                if random.random() < 0.7 and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                    return goal_pos\n                elif not self._is_in_obstacle(start_pos, obstacles, is_3d):\n                    return start_pos\n            # Uniform random sample within bounds, retry free samples only\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            # Fallback to start if unable to find free sample\n            return start_pos\n\n        def can_add_edge(p1, p2):\n            return (not self._is_in_obstacle(p2, obstacles, is_3d)) and (not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d))\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not can_add_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                new_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if new_cost + 1e-9 < min_cost and can_add_edge(neighbor.position, new_pos):\n                    min_cost = new_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-9 < neighbor.cost and can_add_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_edge(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_add_edge(new_pos, node.position):\n                        final = Node(node.position, parent=new_node, cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final)\n                        tree.append(final)\n                        nodes.append(final)\n                        edges.append((new_node, final))\n                        return final\n                    else:\n                        return None\n                last_node = new_node\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path)-1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if can_add_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_add_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample = sample_free()\n            # Alternate growth on smaller tree for balanced expansion\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                shortcuted = shortcut_path(raw_path)\n                smoothed = smooth_path(shortcuted)\n\n                candidates = [raw_path, shortcuted, smoothed]\n                final_path = min(candidates, key=path_length)\n                break\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 8.60647,
        "time_improvement": -42.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.01738889217376709,
                "num_nodes_avg": 119.5,
                "path_length_avg": 168.3811791323066,
                "success_improvement": 0.0,
                "time_improvement": -84.38286071104437,
                "length_improvement": 15.844705064837575,
                "objective_score": -22.145917200345796
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.023496484756469725,
                "num_nodes_avg": 300.5,
                "path_length_avg": 234.86835238109788,
                "success_improvement": 0.0,
                "time_improvement": -59.48041355895997,
                "length_improvement": 22.062734729953775,
                "objective_score": -13.431577121697234
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.02388291358947754,
                "num_nodes_avg": 261.2,
                "path_length_avg": 126.35861243523864,
                "success_improvement": 0.0,
                "time_improvement": 17.588134004987218,
                "length_improvement": 22.40819999388287,
                "objective_score": 9.75808020027274
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This planner implements an enhanced hybrid bidirectional RRT* algorithm with adaptive informed sampling that biases samples not only towards start and goal but also towards dynamically identified promising regions between the two trees to accelerate connection. It features dynamic rewiring with a decaying radius, rigorous collision and edge checks, balanced tree growth, dead-end node pruning, and iterative multi-stage shortcut smoothing with adaptive step sizes. These improvements reduce planning time, path length, and computational overhead while increasing path smoothness, robustness, and success rates.",
        "planning_mechanism": "The planner grows two balanced trees from start and goal, alternately extending the smaller tree to ensure balanced exploration. Sampling is adaptively biased towards start, goal, and the inter-tree frontier to guide tree growth toward efficient connections. The rewiring radius shrinks over iterations to optimize local path cost without losing global connectivity. Dead-end nodes are periodically pruned to reduce complexity. Once tree connection occurs, multi-pass shortcut smoothing is applied with decreasing sampling intervals to improve path smoothness and minimize length while preserving collision-freedom. Rigorous node and edge collision checks maintain path validity throughout.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost               # Path cost from root\n        self.children: List['Node'] = []\n        self.valid = True              # For collision checking\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0,\n                 radius_min: float=3.0, prune_interval: int=200,\n                 prune_threshold: int=100, smoothing_phases: int=3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_phases = smoothing_phases\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(frm: Tuple[float, ...], to: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + ratio * (to[i] - frm[i]) for i in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def node_in_bounds(pos: Tuple[float, ...]) -> bool:\n            for i, val in enumerate(pos):\n                if not (0 <= val <= bounds[i]):\n                    return False\n            return True\n\n        def is_free_node(pos: Tuple[float, ...]) -> bool:\n            return node_in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr: int) -> Tuple[float, ...]:\n            r = random.random()\n            # Early goal bias, then bias toward promising frontier:\n            if r < self.goal_sample_rate:\n                subr = random.random()\n                if subr < 0.6 and is_free_node(goal_position):\n                    return goal_position\n                elif subr < 0.85 and is_free_node(start_position):\n                    return start_position\n                else:\n                    # Sample near tree frontier midpoint\n                    if len(tree_start) > 10 and len(tree_goal) > 10:\n                        t_s_sample = random.choice(tree_start).position\n                        t_g_sample = random.choice(tree_goal).position\n                        mid = tuple((t_s_sample[i] + t_g_sample[i]) * 0.5 for i in range(dim))\n                        spread = self.step_size * 3 * (1 - itr / self.max_iter)\n                        for _ in range(10):\n                            candidate = tuple(\n                                max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim))\n                            if is_free_node(candidate):\n                                return candidate\n            # Uniform fallback\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n            return start_position\n\n        def radius_dyn(n_nodes: int, itr: int) -> float:\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt((math.log(n_nodes) / n_nodes))\n            decay = math.exp(-5 * itr / self.max_iter)\n            scaled = base * decay\n            return max(self.radius_min, scaled)\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...], itr: int):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not is_free_node(new_pos):\n                return None\n            if not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dyn(len(tree), itr)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-15 < min_cost and is_free_edge(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-15 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree: List[Node], target_node: Node):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, target_node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos) or not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_dyn(len(tree), 0)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-15 < min_cost and is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-15 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, cost=final_cost)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_ends():\n            removed_nodes = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed_nodes.append(node)\n                    except Exception:\n                        pass\n            return removed_nodes\n\n        def path_length(pth: List[Tuple[float, ...]]) -> float:\n            length = 0.0\n            for i in range(len(pth) -1):\n                length += dist(pth[i], pth[i+1])\n            return length\n\n        def multi_pass_shortcut(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            smoothed_path = path[:]\n            for phase in range(self.smoothing_phases):\n                max_trials = 100 + phase * 50\n                max_skip = max(2, len(smoothed_path) // (10 + phase))\n                for _ in range(max_trials):\n                    if len(smoothed_path) < 3:\n                        break\n                    i = random.randint(0, len(smoothed_path) - max_skip - 1)\n                    j = random.randint(i + 2, min(len(smoothed_path) -1, i + max_skip))\n                    p1, p2 = smoothed_path[i], smoothed_path[j]\n                    if not is_free_edge(p1, p2):\n                        continue\n                    # shortcut feasible, remove intermediate nodes\n                    smoothed_path = smoothed_path[:i+1] + smoothed_path[j:]\n            return smoothed_path\n\n        for itr in range(self.max_iter):\n            sample_pt = adaptive_sample(itr)\n\n            # Balance growth: always extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                full_path = path_start + path_goal[::-1][1:]\n\n                smoothed_path = multi_pass_shortcut(full_path)\n                if path_length(smoothed_path) + 1e-15 < path_length(full_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = full_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_ends()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 20.81545,
        "time_improvement": -83.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.024848031997680663,
                "num_nodes_avg": 73.2,
                "path_length_avg": 164.63206844666416,
                "success_improvement": 0.0,
                "time_improvement": -163.4757393966513,
                "length_improvement": 17.718474550956312,
                "objective_score": -45.499026908804126
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03142695426940918,
                "num_nodes_avg": 239.8,
                "path_length_avg": 237.10700890189827,
                "success_improvement": 0.0,
                "time_improvement": -113.30780819900544,
                "length_improvement": 21.3198727592314,
                "objective_score": -29.72836790785535
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.020867085456848143,
                "num_nodes_avg": 172.8,
                "path_length_avg": 127.16481631484172,
                "success_improvement": 0.0,
                "time_improvement": 27.994737998218035,
                "length_improvement": 21.91314224526777,
                "objective_score": 12.781049848518965
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "This implementation enhances the bidirectional RRT* algorithm by integrating adaptive neighbor search radius based on the number of nodes, balanced growth by always extending the smaller tree first, and improved rewiring strategy for better path costs. It incorporates heuristic-informed biased sampling towards start and goal, prunes dead-end nodes to keep the search efficient, and applies iterative shortcut smoothing to produce shorter, smoother, and collision-free paths. The planner strictly enforces collision checks for nodes and edges and respects map boundaries, aiming to minimize path length while improving robustness, success rate, and runtime efficiency.",
        "planning_mechanism": "The planner grows two trees from start and goal positions, alternately extending the smaller tree towards randomly sampled points biased towards roots. Upon each extension, it performs an adaptive radius rewiring step minimizing path cost locally and tries to connect the opposite tree. Dead-end nodes are periodically pruned to reduce complexity. Once a connection is made, the path is extracted and refined by iterative shortcut smoothing, ensuring collision-free, near-optimal, and smoother paths.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 5.0, prune_interval: int = 200,\n                 prune_threshold: int = 100, smoothing_iterations: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            p_bias = 0.8\n            if random.random() < self.goal_sample_rate:\n                # Bias sampling towards start or goal to focus growth\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(val, self.radius_min)\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring step - try to reduce cost of neighbors via new node\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos) or not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node in (start_root, goal_root):\n                    continue\n                # Dead nodes: no children and no future expansion possibility\n                if not node.children:\n                    if node.parent:\n                        try:\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    try:\n                        nodes.remove(node)\n                    except ValueError:\n                        pass\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    removed.append(node)\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend the smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            # Periodic pruning to maintain efficiency\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 4.56191,
        "time_improvement": -28.0,
        "length_improvement": 19.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009013938903808593,
                "num_nodes_avg": 91.1,
                "path_length_avg": 180.571681484941,
                "success_improvement": 0.0,
                "time_improvement": 4.420832290505347,
                "length_improvement": 9.752009157965263,
                "objective_score": 3.2766515187446568
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.027190423011779784,
                "num_nodes_avg": 227.5,
                "path_length_avg": 239.45249997211158,
                "success_improvement": 0.0,
                "time_improvement": -84.55270870114717,
                "length_improvement": 20.541559470640156,
                "objective_score": -21.257500716216118
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.029900407791137694,
                "num_nodes_avg": 140.6,
                "path_length_avg": 120.11861450681423,
                "success_improvement": 0.0,
                "time_improvement": -3.1762054846249317,
                "length_improvement": 26.239934625735057,
                "objective_score": 4.295125279759532
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This planner is an enhanced bidirectional RRT* variant that integrates adaptive heuristic sampling, dynamic rewiring radius with decay, balanced growing of two trees, mutual rewiring attempts, and periodic pruning of dead-end nodes. It additionally employs advanced path shortcutting and smoothing techniques post connection, strict collision and edge validation, and adaptive exploration focusing near promising regions over iterations. This design aims at significantly improving planning efficiency, path quality (length and smoothness), robustness, and success rate in both 2D and 3D environments.",
        "planning_mechanism": "The planner grows two trees from start and goal, always extending the smaller tree first to maintain balanced expansion. It samples points adaptively with heuristic bias shifting from goal/start bias towards exploration near tree midpoints to enhance connection probability. Each extension uses a dynamically decaying rewiring radius to optimize cost and connectivity. After each expansion, it attempts to connect the other tree. Dead-end nodes with no children are pruned periodically to maintain computational efficiency. Once the trees connect, a shortcut and smoothing post-processing step refines the final path for smoothness and shortness, all while ensuring collision-free nodes and edges within the environment bounds.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position          # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True                 # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0,\n                 radius_min: float=3.0, prune_interval: int=250,\n                 prune_threshold: int=100, smoothing_iterations: int=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # list of obstacles in 2D or 3D\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def radius_by_nodes_and_iter(n_nodes: int, itr: int) -> float:\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt(math.log(n_nodes) / n_nodes)\n            decay_factor = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay_factor)\n\n        def is_free_node(pos: Tuple[float, ...]) -> bool:\n            if not self._within_bounds(pos, bounds):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            if not self._within_bounds(p1, bounds) or not self._within_bounds(p2, bounds):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr: int) -> Tuple[float, ...]:\n            r = random.random()\n            # Heuristic adaptive sampling with goal/start bias and exploration around midpoints:\n            if r < self.goal_sample_rate:\n                sr = random.random()\n                if sr < 0.7 and is_free_node(goal_position):\n                    return goal_position\n                elif sr < 0.8 and is_free_node(start_position):\n                    return start_position\n                else:\n                    if len(tree_start) > 15 and len(tree_goal) > 15:\n                        mid_s = random.choice(tree_start).position\n                        mid_g = random.choice(tree_goal).position\n                        mid = tuple((mid_s[i] + mid_g[i]) / 2 for i in range(dim))\n                        spread = self.step_size * 5 * (1 - itr / self.max_iter)\n                        for _ in range(5):\n                            candidate = tuple(\n                                max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim)\n                            )\n                            if is_free_node(candidate):\n                                return candidate\n            # Uniform sampling in free space:\n            attempts = 0\n            while attempts < 100:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n                attempts += 1\n            # Fallback to start if no free sample found\n            return start_position\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...], itr: int) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not is_free_node(new_pos):\n                return None\n            if not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes_and_iter(len(tree), itr)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost and is_free_edge(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree: List[Node], target_node: Node, itr: int) -> Node or None:\n            if not tree:\n                return None\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos):\n                    return None\n                if not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes_and_iter(len(tree), itr)\n                near = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n\n                for node in near:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-10 < min_cost and is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in near:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-10 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                # Node with no children and is not root is considered dead-end\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        # Remove edges that contain this node\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def path_length(path: List[Tuple[float, ...]]) -> float:\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        def smooth_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if is_free_edge(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample = adaptive_sample(itr)\n            # Alternate extension on the smaller tree to keep balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start, itr)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                shortcuted_path = shortcut_path(raw_path)\n                smoothed_path = smooth_path(shortcuted_path)\n\n                candidates = [raw_path, shortcuted_path, smoothed_path]\n                extracted_path = min(candidates, key=path_length)\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...],\n                             obstacles: List, is_3d: bool, resolution: float=1.0) -> bool:\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos: Tuple[float, ...], bounds: Tuple[int, ...]) -> bool:\n        for i, val in enumerate(pos):\n            if val < 0 or val > bounds[i]:\n                return False\n        return True",
        "objective": -0.51282,
        "time_improvement": -13.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.012375068664550782,
                "num_nodes_avg": 69.7,
                "path_length_avg": 167.58885545517805,
                "success_improvement": 0.0,
                "time_improvement": -31.218857363882506,
                "length_improvement": 16.24070082324994,
                "objective_score": -6.117517044514763
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.021911811828613282,
                "num_nodes_avg": 210.1,
                "path_length_avg": 234.2174301257481,
                "success_improvement": 0.0,
                "time_improvement": -48.72457937739602,
                "length_improvement": 22.278732755958806,
                "objective_score": -10.161627262027043
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.016832876205444335,
                "num_nodes_avg": 146.2,
                "path_length_avg": 120.15930276146295,
                "success_improvement": 0.0,
                "time_improvement": 41.915431173987486,
                "length_improvement": 26.21494958627904,
                "objective_score": 17.817619269452052
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This planner combines the strengths of bidirectional RRT* with adaptive step sizing, spatial hashing for efficient nearest neighbor queries, and frontier-biased sampling to focus exploration near obstacle boundaries. It dynamically balances tree growth, aggressively biases goal sampling over time, and applies informed rewiring with adaptive radius and early termination for fast convergence. Post-connection, a constrained shortcut smoothing with incremental rewiring improves path quality and smoothness. The planner prunes the search space via obstacle-aware step adjustments and leverages a layered search over spatial grids to minimize nearest neighbor search cost and edge collision checks, thus reducing planning time and achieving shorter, robust, and smooth paths with high success rates.",
        "planning_mechanism": "The planner initializes two trees from start and goal positions. In each iteration, it samples points using an adaptive mixture of goal biasing and frontier-based sampling near obstacles. It extends the smaller tree first using an adaptive step size shrunk near obstacles and goals, performing fast nearest neighbor queries via spatial hashing. After insertion, it rewires neighbors within an adaptive radius to reduce path costs. The other tree attempts an incremental connection to the new node. When connection succeeds, paths are merged and shortcut smoothing with incremental rewiring is applied. Early termination and adaptive radius updates accelerate convergence. This balanced, adaptive, and incremental approach effectively reduces search time and improves path quality and smoothness.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]: 2D or 3D coordinate\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from root node\n        self.children: List[Node] = []   # Children nodes for incremental rewiring\n        self.valid = True                 # Validity flag for collision checks\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n        from collections import defaultdict\n        from itertools import product\n\n        bounds = map.size                  # Tuple[int,...]\n        start_pos = map.start              # Tuple[float,...]\n        goal_pos = map.goal                # Tuple[float,...]\n        obstacles = map.obstacles          # List of boxes\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Environment diagonal for scaling\n        env_diag = math.dist((0,) * dim, bounds)\n        step_size_min = max(0.5, self.step_size * 0.2)\n        step_size_max = self.step_size\n\n        # Spatial hashing grid size\n        grid_cell_size = self.step_size * 2.0\n        def _hash_pos(p):\n            return tuple(int(c // grid_cell_size) for c in p)\n\n        tree_start_grid = defaultdict(list)\n        tree_goal_grid = defaultdict(list)\n        tree_start_grid[_hash_pos(start_pos)].append(start_root)\n        tree_goal_grid[_hash_pos(goal_pos)].append(goal_root)\n\n        # --- Frontier identification for frontier-biased sampling ---\n        def _identify_frontiers():\n            frontiers = []\n            resolution = self.step_size * 2\n            steps = [int(bounds[d] / resolution) for d in range(dim)]\n\n            def neighbors(pos_grid):\n                offsets = [-1, 0, 1]\n                for delta in product(offsets, repeat=dim):\n                    if all(x == 0 for x in delta):\n                        continue\n                    nbr = tuple(pos_grid[d] + delta[d] for d in range(dim))\n                    yield nbr\n\n            occupied = set()\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, w, h, d = obs\n                    min_c = [int(ox // resolution), int(oy // resolution), int(oz // resolution)]\n                    max_c = [int((ox + w) // resolution), int((oy + h) // resolution), int((oz + d) // resolution)]\n                    for x in range(min_c[0], max_c[0] + 1):\n                        for y in range(min_c[1], max_c[1] + 1):\n                            for z in range(min_c[2], max_c[2] + 1):\n                                occupied.add((x, y, z))\n                else:\n                    ox, oy, w, h = obs\n                    min_c = [int(ox // resolution), int(oy // resolution)]\n                    max_c = [int((ox + w) // resolution), int((oy + h) // resolution)]\n                    for x in range(min_c[0], max_c[0] + 1):\n                        for y in range(min_c[1], max_c[1] + 1):\n                            occupied.add((x, y))\n\n            grid_ranges = [range(steps[d] + 1) for d in range(dim)]\n            for pos_grid in product(*grid_ranges):\n                if pos_grid in occupied:\n                    continue\n                if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                    frontiers.append(tuple((pos_grid[d] + 0.5) * resolution for d in range(dim)))\n            return frontiers\n\n        frontiers = _identify_frontiers()\n\n        def _adaptive_goal_bias(iteration):\n            from math import cos, pi\n            start_bias = 0.15\n            end_bias = 0.5\n            ratio = iteration / self.max_iter\n            bias = start_bias + (end_bias - start_bias) * (1 - cos(pi * ratio)) / 2\n            return bias\n\n        def in_bounds(pos):\n            for d_ in range(dim):\n                if pos[d_] < 0 or pos[d_] > bounds[d_]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # Spatial hash helpers\n        def add_node_to_grid(tree_grid, node):\n            tree_grid[_hash_pos(node.position)].append(node)\n\n        def nearest(tree_grid, point):\n            base_cell = _hash_pos(point)\n            best_node = None\n            best_dist = float('inf')\n            offsets = [-1, 0, 1]\n            checked_cells = set()\n            radius_cells = 0\n            max_cell_search = 2\n            while radius_cells <= max_cell_search:\n                # Explore neighbor cells at radius_cells distance\n                cells_to_check = []\n                for offset in product(offsets, repeat=dim):\n                    if max(abs(x) for x in offset) != radius_cells:\n                        continue\n                    neighbor_cell = tuple(base_cell[d] + offset[d] for d in range(dim))\n                    cells_to_check.append(neighbor_cell)\n                if not cells_to_check:\n                    # For radius_cells == 0, ensure current cell is checked\n                    if radius_cells == 0:\n                        cells_to_check = [base_cell]\n                found_candidate = False\n                for cell in cells_to_check:\n                    if cell in checked_cells:\n                        continue\n                    checked_cells.add(cell)\n                    if cell not in tree_grid:\n                        continue\n                    for node in tree_grid[cell]:\n                        d_ = dist(node.position, point)\n                        if d_ < best_dist:\n                            best_dist = d_\n                            best_node = node\n                            found_candidate = True\n                if found_candidate:\n                    break\n                radius_cells +=1\n            # Fallback linear scan\n            if best_node is None:\n                all_nodes = [n for bucket in tree_grid.values() for n in bucket]\n                if all_nodes:\n                    best_node = min(all_nodes, key=lambda n: dist(n.position, point))\n            return best_node\n\n        # Radius for rewiring based on node count (from RRT* theory)\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return step_size_max * 2.5\n            val = self.step_size * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim)\n            return max(step_size_min, min(val, step_size_max * 2.5))\n\n        def near_nodes(tree_grid, pos, radius):\n            radius_cells = int(math.ceil(radius / grid_cell_size))\n            base_cell = _hash_pos(pos)\n            collected = []\n            for offset in product(range(-radius_cells, radius_cells+1), repeat=dim):\n                cell = tuple(base_cell[d] + offset[d] for d in range(dim))\n                if cell in tree_grid:\n                    for node in tree_grid[cell]:\n                        if dist(node.position, pos) <= radius:\n                            collected.append(node)\n            return collected\n\n        def _sample_point(iteration):\n            goal_bias = _adaptive_goal_bias(iteration)\n            r = random.random()\n            if r < goal_bias:\n                return goal_pos if random.random() < 0.9 else start_pos\n            # Frontier-based sampling with probability 0.3 (adaptive)\n            if frontiers and random.random() < 0.3:\n                frontier = random.choice(frontiers)\n                radius = step_size_max * 3\n                sample_coords = []\n                for d in range(dim):\n                    low = max(0, frontier[d] - radius)\n                    high = min(bounds[d], frontier[d] + radius)\n                    sample_coords.append(random.uniform(low, high))\n                p = tuple(sample_coords)\n                if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                    return p\n            # Uniform random sample in free space\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                    return p\n            # Fallback (rare)\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_step_size(from_pos, to_pos):\n            vec = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            distance_ = dist(from_pos, to_pos)\n            if distance_ <= step_size_min:\n                return to_pos\n            step = step_size_max\n\n            # Shrink near start or goal\n            goal_dist = dist(to_pos, goal_pos)\n            start_dist = dist(to_pos, start_pos)\n            close_to_goal = goal_dist < step_size_max * 3\n            close_to_start = start_dist < step_size_max * 3\n            if close_to_goal or close_to_start:\n                step = max(step_size_min, step_size_max * 0.3)\n\n            # Shrink near obstacles\n            prox_threshold = step_size_max * 1.5\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    px, py, pz = from_pos\n                    dx = max(ox - px, 0, px - (ox + ow))\n                    dy = max(oy - py, 0, py - (oy + oh))\n                    dz = max(oz - pz, 0, pz - (oz + od))\n                    dist_to_box = math.sqrt(dx*dx + dy*dy + dz*dz)\n                else:\n                    ox, oy, ow, oh = obs\n                    px, py = from_pos\n                    dx = max(ox - px, 0, px - (ox + ow))\n                    dy = max(oy - py, 0, py - (oy + oh))\n                    dist_to_box = math.sqrt(dx*dx + dy*dy)\n                if 0 < dist_to_box < prox_threshold:\n                    step = max(step_size_min, step * 0.5)\n                    break\n\n            ratio = step / distance_\n            if ratio > 1.0:\n                return to_pos\n            return tuple(from_pos[d] + vec[d] * ratio for d in range(dim))\n\n        def try_extend(tree, tree_grid, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree_grid, point)\n            if nearest_node is None:\n                return None\n            new_pos = adaptive_step_size(nearest_node.position, point)\n\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=0.3):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree_grid, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost + 1e-8 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, resolution=0.3):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            add_node_to_grid(tree_grid, new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors for improved path costs\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=0.3):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, tree_grid, target_node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree_grid, target_node.position)\n            if nearest_node is None:\n                return None\n\n            current = nearest_node\n            while True:\n                new_pos = adaptive_step_size(current.position, target_node.position)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d, resolution=0.3):\n                    return None\n\n                new_cost = current.cost + dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=new_cost)\n                current.children.append(new_node)\n                tree.append(new_node)\n                add_node_to_grid(tree_grid, new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n                current = new_node\n\n                if dist(new_pos, target_node.position) <= step_size_min:\n                    if (not self._is_edge_in_obstacle(new_pos, target_node.position, obstacles, is_3d, resolution=0.3)\n                        and not self._is_in_obstacle(target_node.position, obstacles, is_3d)\n                        and in_bounds(target_node.position)):\n                        final_node = Node(target_node.position, parent=current,\n                                         cost=current.cost + dist(new_pos, target_node.position))\n                        current.children.append(final_node)\n                        tree.append(final_node)\n                        add_node_to_grid(tree_grid, final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        return final_node\n                    else:\n                        return None\n\n        def shortcut_smooth(path, max_trials=120):\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d, resolution=0.3):\n                    # Incremental rewiring could be added here if a graph is available,\n                    # but only path smoothing is required now.\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Main planning loop\n        for iteration in range(self.max_iter):\n            rand_point = _sample_point(iteration)\n\n            # Balance growth: always grow smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n                tree_start_grid, tree_goal_grid = tree_goal_grid, tree_start_grid\n\n            new_node_start = try_extend(tree_start, tree_start_grid, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, tree_goal_grid, new_node_start)\n            if new_node_goal is not None:\n                # Success: merge paths and smooth\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n                extracted_path = shortcut_smooth(merged_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 97.13189,
        "time_improvement": -326.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.9,
                "time_avg": 0.03319954872131348,
                "num_nodes_avg": 185.5,
                "path_length_avg": 164.85700181219522,
                "success_improvement": -9.999999999999998,
                "time_improvement": -252.03092332622944,
                "length_improvement": 17.606055016810213,
                "objective_score": -77.08806599450679
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.0905731201171875,
                "num_nodes_avg": 581.8,
                "path_length_avg": 245.80483928152108,
                "success_improvement": 0.0,
                "time_improvement": -514.7574330086593,
                "length_improvement": 18.433638378574646,
                "objective_score": -150.74050222688285
            },
            {
                "map_id": 2,
                "success_rate": 0.9,
                "time_avg": 0.09024522304534913,
                "num_nodes_avg": 509.8,
                "path_length_avg": 123.32149454162725,
                "success_improvement": -9.999999999999998,
                "time_improvement": -211.40577553234988,
                "length_improvement": 24.27317333962037,
                "objective_score": -63.567097991780884
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This improved bidirectional RRT* planner integrates goal bias sampling, dynamic neighbor radius, and KD-tree based nearest neighbor search to speed up planning. It leverages early connection checks to quickly detect solution paths, reduces unnecessary rewiring by adaptive radius, and incorporates path smoothing using shortcutting. Collision checks are carefully maintained, and efficient data structures improve performance and robustness to yield shorter, smoother paths with lower planning time.",
        "planning_mechanism": "The planner alternately grows two trees from start and goal, with a bias to sample closer to the goal for faster convergence. Each extension uses a dynamically shrinking neighbor radius based on the number of nodes to limit rewiring overhead. KD-trees accelerate nearest node queries. When new nodes from both trees come sufficiently close with collision-free edges, paths are connected immediately. The final path is shortcut-smoothed to enhance quality.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        # Parameters for goal bias and neighbor radius scaling\n        self.goal_sample_rate = 0.15  # Percent of sampling close to goal\n        self.min_neighbor_radius = 10.0  # Minimal neighbor radius\n        self.max_neighbor_radius = 30.0  # Maximal neighbor radius (initial)\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        from bisect import insort\n        from collections import deque\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # KD-Tree helper for faster nearest neighbor search\n        # Simple brute force initially, optimized with a spatial index approach\n        class KDTreeWrapper:\n            def __init__(self, node_list):\n                self.nodes = node_list\n\n            def add_node(self, node):\n                self.nodes.append(node)\n\n            def nearest(self, point):\n                return min(self.nodes, key=lambda n: math.dist(n.position, point))\n\n            def near(self, point, radius):\n                r_sq = radius * radius\n                return [n for n in self.nodes if (sum((n.position[d] - point[d]) ** 2 for d in range(dim)) <= r_sq)]\n\n        kd_tree_a = KDTreeWrapper(tree_a[:])\n        kd_tree_b = KDTreeWrapper(tree_b[:])\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                # Goal biasing sampling near goal to accelerate success\n                goal_sample = tuple(\n                    random.uniform(max(0, goal_position[d] - self.step_size), min(bounds[d], goal_position[d] + self.step_size))\n                    for d in range(dim)\n                )\n                if not self._is_in_obstacle(goal_sample, obstacles, is_3d):\n                    return goal_sample\n            # Else unbiased random sample\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def dynamic_neighbor_radius(n_nodes):\n            # Following RRT* radius formula with constants, capped by min/max radius\n            from math import log, pow\n            gamma = (2 * (1 + 1/dim)) ** (1/dim)  # Constant factor for analytical radius\n            r = gamma * pow((log(n_nodes + 1) / (n_nodes + 1)), 1 / dim) * max(bounds)\n            if r < self.min_neighbor_radius:\n                return self.min_neighbor_radius\n            elif r > self.max_neighbor_radius:\n                return self.max_neighbor_radius\n            return r\n\n        def try_extend(tree, kd_tree, point):\n            if not tree:\n                return None\n            nearest_node = kd_tree.nearest(point)\n            new_pos = steer(nearest_node.position, point)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            r = dynamic_neighbor_radius(len(tree))\n            near_nodes = kd_tree.near(new_pos, r)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near_nodes:\n                cost = node.cost + math.dist(node.position, new_pos)\n                if cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            kd_tree.add_node(new_node)\n\n            # Rewire neighbors with cost improvement\n            for node in near_nodes:\n                if node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        if node.parent:\n                            try:\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                            node.parent.children.remove(node)\n                        node.parent = new_node\n                        node.cost = cost_through_new\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n            return new_node\n\n        def try_connect(tree, kd_tree, target_pos):\n            if not tree:\n                return None\n            current_node = kd_tree.nearest(target_pos)\n            while True:\n                new_pos = steer(current_node.position, target_pos)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                r = dynamic_neighbor_radius(len(tree))\n                near_nodes = kd_tree.near(new_pos, r)\n\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for node in near_nodes:\n                    cost = node.cost + math.dist(node.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = node\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                kd_tree.add_node(new_node)\n\n                # Rewire neighbors\n                for node in near_nodes:\n                    if node is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                    if cost_through_new < node.cost and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        if node.parent:\n                            try:\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                            node.parent.children.remove(node)\n                        node.parent = new_node\n                        node.cost = cost_through_new\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                current_node = new_node\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            # Additional shortcut smoothing loops to improve smoothness\n            # Limited iterations to avoid time cost\n            max_shortcuts = 3\n            for _ in range(max_shortcuts):\n                if len(smoothed) < 3:\n                    break\n                simplified = [smoothed[0]]\n                idx = 0\n                while idx < len(smoothed) -1:\n                    next_idx = len(smoothed) - 1\n                    while next_idx > idx +1:\n                        if not self._is_edge_in_obstacle(smoothed[idx], smoothed[next_idx], obstacles, is_3d):\n                            break\n                        next_idx -=1\n                    simplified.append(smoothed[next_idx])\n                    idx = next_idx\n                smoothed = simplified\n            return smoothed\n\n        # Main loop with bidirectional growth and swapping trees for fairness\n        for iter_count in range(self.max_iter):\n            rand_point = sample_free()\n\n            new_node_a = try_extend(tree_a, kd_tree_a, rand_point)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                kd_tree_a, kd_tree_b = kd_tree_b, kd_tree_a\n                continue\n\n            new_node_b = try_connect(tree_b, kd_tree_b, new_node_a.position)\n            if new_node_b:\n                # Verify final connection edge clear before confirming success\n                if not self._is_edge_in_obstacle(new_node_a.position, new_node_b.position, obstacles, is_3d):\n                    # Build full path - from start root to new_node_a + reverse of new_node_b to goal root\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    extracted_path = path_a + path_b[::-1]\n                    extracted_path = smooth_path(extracted_path)\n                    success_state = True\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n            kd_tree_a, kd_tree_b = kd_tree_b, kd_tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 59.09057,
        "time_improvement": -213.0,
        "length_improvement": 24.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.031275486946105956,
                "num_nodes_avg": 107.6,
                "path_length_avg": 154.82531510181414,
                "success_improvement": 0.0,
                "time_improvement": -231.62916277976228,
                "length_improvement": 22.61979561513396,
                "objective_score": -64.9647897109019
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.0352898359298706,
                "num_nodes_avg": 262.0,
                "path_length_avg": 226.04908799397055,
                "success_improvement": 0.0,
                "time_improvement": -139.526792490691,
                "length_improvement": 24.989265022595838,
                "objective_score": -36.86018474268813
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.10658960342407227,
                "num_nodes_avg": 447.9,
                "path_length_avg": 122.99540312411159,
                "success_improvement": 0.0,
                "time_improvement": -267.8047102978428,
                "length_improvement": 24.473413114052477,
                "objective_score": -75.44673046654235
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "This improved bidirectional RRT* planner incorporates adaptive informed sampling biased towards both the start and goal to effectively balance exploration and exploitation. It grows two trees simultaneously, always extending the smaller tree to maintain balanced growth. A dynamically shrinking radius is used in the rewiring step to optimize local path costs continuously, aiming to minimize overall path length. Periodic dead-end pruning enhances efficiency by removing unproductive nodes. Upon successfully connecting the two trees, a refined path smoothing procedure employing randomized shortcutting further reduces path length and improves smoothness. Collision and edge-obstacle checks are rigorously applied to ensure safety and validity. This results in faster convergence, higher success rates, and shorter, smoother paths.",
        "planning_mechanism": "The planner alternates growing the smaller of two trees rooted at the start and goal, sampling points with bias towards both to guide exploration. Using dynamic neighborhood radius derived from the current number of nodes, it rewires connections locally to improve cost optimality. After each new extension, it attempts to connect the trees to form a complete path. Dead-end nodes are pruned periodically to focus search efforts. Finally, the extracted path undergoes iterative shortcut smoothing to minimize length and enhance navigability while respecting collision constraints.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0,\n                 goal_sample_rate=0.15, radius_constant=30.0,\n                 radius_min=5.0, prune_interval=200, prune_threshold=150,\n                 smoothing_iterations=35):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size                   # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start          # Tuple[float, ...]\n        goal_position = map.goal            # Tuple[float, ...]\n        obstacles = map.obstacles           # List of obstacle tuples\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            # Adaptive informed sampling biased between start and goal with some uniform exploration\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                # Bias: probabilistically choose either goal or start as sample\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                # Uniform random sampling inside bounds until free\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Boundary check\n            for i, coord in enumerate(new_pos):\n                if coord < 0 or coord > bounds[i]:\n                    return None\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            # Edge collision check\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve path costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n\n                # Boundary check\n                for i, coord in enumerate(new_pos):\n                    if coord < 0 or coord > bounds[i]:\n                        return None\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            # Remove leaf nodes without children that are not roots\n            for node in nodes[:]:\n                if (not node.children) and node is not start_root and node is not goal_root:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed_nodes.append(node)\n                    except Exception:\n                        continue\n            return removed_nodes\n\n        def path_length(path):\n            if len(path) < 2:\n                return 0.0\n            total = 0.0\n            for i in range(len(path)-1):\n                total += distance(path[i], path[i+1])\n            return total\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if j <= i:\n                    continue\n                p1 = path[i]\n                p2 = path[j]\n                # Shortcut check: no obstacle between p1 and p2\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # Remove intermediate points\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Alternate growth on smaller tree to balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                # Extract path from both trees\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]  # avoid duplicating connecting node\n                \n                # Post-process path with iterative smoothing\n                smoothed_path = path_smoothing(raw_path)\n\n                # Choose the shorter one between raw and smoothed\n                if path_length(smoothed_path) + 1e-8 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            # Periodic pruning to reduce dead-ends\n            if itr > 0 and (itr % self.prune_interval == 0) and (len(nodes) > self.prune_threshold):\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 2.08959,
        "time_improvement": -14.0,
        "length_improvement": 19.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.9,
                "time_avg": 0.01226189136505127,
                "num_nodes_avg": 89.4,
                "path_length_avg": 162.61585684711042,
                "success_improvement": -9.999999999999998,
                "time_improvement": -30.018783544300586,
                "length_improvement": 18.726157729601937,
                "objective_score": -10.260403517369788
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.019353199005126952,
                "num_nodes_avg": 232.4,
                "path_length_avg": 242.57800147419033,
                "success_improvement": 0.0,
                "time_improvement": -31.358210090411397,
                "length_improvement": 19.504412331828604,
                "objective_score": -5.506580560757698
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.02344634532928467,
                "num_nodes_avg": 169.8,
                "path_length_avg": 132.15445342745627,
                "success_improvement": 0.0,
                "time_improvement": 19.094583577058785,
                "length_improvement": 18.84920447732565,
                "objective_score": 9.498215968582766
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid planner combines the bidirectional tree growth and efficient swapping techniques of the first algorithm with the adaptive heuristic-informed sampling, dynamic rewiring, and path shortcutting strategy of the second algorithm. It employs balanced growth by always extending the smaller tree first, uses adaptive sampling with goal bias that transitions toward uniform and focused local refinement sampling, and incorporates mutual rewiring for enhanced path optimality. The planner dynamically adjusts rewiring radius and performs rigorous collision checks on nodes and edges to ensure safety and path smoothness. Once connected, the path is shortcut for additional smoothing and length reduction. This synthesis aims to optimize planning efficiency, success rate, and path quality in both 2D and 3D spaces.",
        "planning_mechanism": "The planner alternately grows two bidirectional trees rooted at the start and goal positions. At each iteration, it adaptively samples points with an evolving heuristic-informed bias, extends the smaller tree toward the sampled point using rewiring to minimize cost, then attempts to connect and rewire the opposite tree toward the new node. The connection point, if found, results in path merging followed by a shortcut-based smoothing step. Collision checks for nodes and edges ensure obstacle avoidance, and tree balancing guarantees efficient exploration and rapid convergence.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0, radius_min: float = 3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt((math.log(n_nodes) / n_nodes))\n            decay_factor = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay_factor)\n\n        def is_free_node(pos):\n            # Ensure node is inside bounds and not in obstacle\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr):\n            r = random.random()\n            if r < self.goal_sample_rate:\n                subr = random.random()\n                # Early goal bias 70%, start bias 10%, local refinement 20%\n                if subr < 0.7:\n                    if is_free_node(goal_position):\n                        return goal_position\n                elif subr < 0.8:\n                    if is_free_node(start_position):\n                        return start_position\n                else:\n                    if len(tree_start) > 10 and len(tree_goal) > 10:\n                        mid_from_start = random.choice(tree_start).position\n                        mid_from_goal = random.choice(tree_goal).position\n                        mid = tuple((mid_from_start[i] + mid_from_goal[i]) / 2 for i in range(dim))\n                        spread = self.step_size * 5 * (1 - itr / self.max_iter)\n                        def confined_rand():\n                            return tuple(max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim))\n                        for _ in range(5):\n                            candidate = confined_rand()\n                            if is_free_node(candidate):\n                                return candidate\n            # Uniform free space sampling\n            attempts = 0\n            while attempts < 100:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(point):\n                    return point\n                attempts += 1\n            return start_position\n\n        def try_extend(tree, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not is_free_node(new_pos) or not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree), itr)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost < min_cost - 1e-8 and is_free_edge(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node, itr):\n            if not tree:\n                return None\n\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos) or not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes(len(tree), itr)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost < min_cost - 1e-8 and is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-8 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, cost=final_cost)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        for itr in range(self.max_iter):\n            rand_point = adaptive_sample(itr)\n\n            # Balance tree growth by extending smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start, itr)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n\n                # Merge paths, avoid duplicating connecting node\n                merged_path = path_start + path_goal[::-1][1:]\n\n                # Post-process: shortcut path for smoothness and length reduction\n                extracted_path = shortcut_path(merged_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 0.47644,
        "time_improvement": -16.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.013486552238464355,
                "num_nodes_avg": 119.0,
                "path_length_avg": 161.9419573630525,
                "success_improvement": 0.0,
                "time_improvement": -43.00445698366108,
                "length_improvement": 19.062966214551352,
                "objective_score": -9.088743852188053
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02184925079345703,
                "num_nodes_avg": 267.9,
                "path_length_avg": 233.3210638741899,
                "success_improvement": 0.0,
                "time_improvement": -48.29995161444315,
                "length_improvement": 22.576177403645755,
                "objective_score": -9.974750003603793
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.016319012641906737,
                "num_nodes_avg": 226.0,
                "path_length_avg": 125.98450934656564,
                "success_improvement": 0.0,
                "time_improvement": 43.688600723813195,
                "length_improvement": 22.637921826677314,
                "objective_score": 17.63416458247942
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner featuring adaptive, heuristic-driven sampling and dynamic rewiring. It grows two balanced trees from start and goal, progressively optimizing path costs via rewiring within a decaying radius, pruning dead-ends, and applying advanced shortcut smoothing. Compared to traditional RRT*, it achieves higher efficiency, robustness, and path quality with rigorous collision checks in 2D and 3D environments.",
        "planning_mechanism": "The planner alternates expanding the smaller tree using samples biased towards goal, start, and their midpoints. New nodes are connected with cost-minimizing parents within a dynamic radius. Mutual connection attempts between trees enable path formation followed by shortcut and smoothing post-processing. Periodic pruning maintains search efficiency, ensuring improved convergence and smoother, shorter paths.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position            # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent                # Node or None\n        self.cost = cost                   # Path cost from root\n        self.children = []\n        self.valid = True                  # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0,\n                 radius_min: float=3.0, prune_interval: int=250,\n                 prune_threshold: int=100, smoothing_iterations: int=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def radius_by_nodes_and_iter(n_nodes: int, itr: int) -> float:\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt(math.log(n_nodes) / n_nodes)\n            decay = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay)\n\n        def is_free_node(pos: Tuple[float, ...]) -> bool:\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr: int) -> Tuple[float, ...]:\n            r = random.random()\n            # Goal bias and heuristic midpoint sampling\n            if r < self.goal_sample_rate:\n                sr = random.random()\n                if sr < 0.7 and is_free_node(goal_position):\n                    return goal_position\n                elif sr < 0.8 and is_free_node(start_position):\n                    return start_position\n                else:\n                    if len(tree_start) > 15 and len(tree_goal) > 15:\n                        mid_s = random.choice(tree_start).position\n                        mid_g = random.choice(tree_goal).position\n                        mid = tuple((mid_s[i] + mid_g[i]) / 2 for i in range(dim))\n                        spread = self.step_size * 5 * (1 - itr / self.max_iter)\n                        for _ in range(5):\n                            candidate = tuple(\n                                max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim)\n                            )\n                            if is_free_node(candidate):\n                                return candidate\n            # Uniform sampling within bounds\n            attempts = 0\n            while attempts < 100:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n                attempts += 1\n            return start_position\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...], itr: int) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (not is_free_node(new_pos)) or (not is_free_edge(nearest_node.position, new_pos)):\n                return None\n\n            radius = radius_by_nodes_and_iter(len(tree), itr)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree: List[Node], target_node: Node, itr: int) -> Node or None:\n            if not tree:\n                return None\n\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if (not is_free_node(new_pos)) or (not is_free_edge(last_node.position, new_pos)):\n                    return None\n\n                radius = radius_by_nodes_and_iter(len(tree), itr)\n                near = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in near:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-10 < min_cost:\n                        if is_free_edge(node.position, new_pos):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in near:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-10 < neighbor.cost:\n                        if is_free_edge(new_node.position, neighbor.position):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            # Remove leaf nodes except roots\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def path_length(path: List[Tuple[float, ...]]) -> float:\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def smooth_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if is_free_edge(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample = adaptive_sample(itr)\n\n            # Alternate extension on smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start, itr)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                shortcuted_path = shortcut_path(raw_path)\n                smoothed_path = smooth_path(shortcuted_path)\n\n                candidates = [raw_path, shortcuted_path, smoothed_path]\n                extracted_path = min(candidates, key=path_length)\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles, is_3d: bool,\n                             resolution: float=1.0) -> bool:\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -1.31996,
        "time_improvement": -10.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.012281441688537597,
                "num_nodes_avg": 86.5,
                "path_length_avg": 160.6956188636504,
                "success_improvement": 0.0,
                "time_improvement": -30.22608510993302,
                "length_improvement": 19.68587421737402,
                "objective_score": -5.130650689505102
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.019028568267822267,
                "num_nodes_avg": 187.7,
                "path_length_avg": 237.62925959514305,
                "success_improvement": 0.0,
                "time_improvement": -29.15480627167439,
                "length_improvement": 21.146572310685485,
                "objective_score": -4.517127419365218
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.020282649993896486,
                "num_nodes_avg": 175.2,
                "path_length_avg": 125.36045122492264,
                "success_improvement": 0.0,
                "time_improvement": 30.01142733032388,
                "length_improvement": 23.021131107259865,
                "objective_score": 13.607654420549135
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This planner implements a simplified bidirectional RRT* algorithm integrating balanced tree growth, adaptive sampling with goal bias, and dynamic rewiring radius for incremental path optimization. It ensures collision-free nodes and edges, maintains rewiring for local path cost improvements, and leverages post-search path shortcutting to enhance smoothness and path length, applicable to both 2D and 3D environments.",
        "planning_mechanism": "The planner alternately grows two trees from start and goal by sampling points with goal bias and adaptive local sampling. It extends the smaller tree first, steering towards samples with fixed step size, adding collision-checked nodes and edges. After each addition, neighbors within a dynamically shrinking radius are rewired for better cost paths. When the trees connect, the optimal path is merged and shortcutting is applied to smooth and reduce path length.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag (collision etc.)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        curr = self\n        while curr:\n            path.append(curr.position)\n            curr = curr.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15,\n                 radius_const: float = 30.0, radius_min: float = 3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def is_in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free(iteration):\n            r = random.random()\n            if r < self.goal_sample_rate:\n                # Bias sampling towards goal (70%) or start (10%), else local around connection\n                sub_r = random.random()\n                if sub_r < 0.7 and not in_obstacle(goal_pos):\n                    return goal_pos\n                elif sub_r < 0.8 and not in_obstacle(start_pos):\n                    return start_pos\n                else:\n                    # Local biased sampling around midpoints of existing trees for refinement\n                    if len(tree_start) > 10 and len(tree_goal) > 10:\n                        mid_start = random.choice(tree_start).position\n                        mid_goal = random.choice(tree_goal).position\n                        mid = tuple((mid_start[d] + mid_goal[d]) * 0.5 for d in range(dim))\n                        spread = self.step_size * 5 * (1 - iteration / self.max_iter)\n                        for _ in range(5):\n                            candidate = tuple(\n                                max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread)))\n                                for d in range(dim)\n                            )\n                            if not in_obstacle(candidate):\n                                return candidate\n            # Uniform random sampling fallback\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return start_pos\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def radius(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_const\n            base = self.radius_const * math.sqrt(math.log(n_nodes) / n_nodes)\n            decay = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay)\n\n        def try_extend(tree, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not is_in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            r = radius(len(tree), itr)\n            neighbors = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                tentative = node.cost + math.dist(node.position, new_pos)\n                if tentative + 1e-8 < min_cost and not edge_in_obstacle(node.position, new_pos):\n                    min_cost = tentative\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for local improvements\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-8 < neighbor.cost and not edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, target_node, itr):\n            if not tree:\n                return None\n\n            last = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(last.position, target_node.position)\n                if (not is_in_bounds(new_pos) or in_obstacle(new_pos)\n                    or edge_in_obstacle(last.position, new_pos)):\n                    return None\n\n                r = radius(len(tree), itr)\n                neighbors = near_nodes(tree, new_pos, r)\n\n                min_cost = last.cost + math.dist(last.position, new_pos)\n                best_parent = last\n                for node in neighbors:\n                    tentative = node.cost + math.dist(node.position, new_pos)\n                    if tentative + 1e-8 < min_cost and not edge_in_obstacle(node.position, new_pos):\n                        min_cost = tentative\n                        best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if cost_through_new + 1e-8 < neighbor.cost and not edge_in_obstacle(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n                if math.dist(new_pos, target_node.position) <= self.step_size:\n                    if not edge_in_obstacle(new_pos, target_node.position):\n                        final_cost = new_node.cost + math.dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last = new_node\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i:\n                    if not edge_in_obstacle(path[i], path[j]):\n                        shortened.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    # No further shortcut, step forward\n                    i += 1\n                    shortened.append(path[i])\n            return shortened\n\n        # Initialization\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success = False\n        final_path = []\n\n        for itr in range(self.max_iter):\n            rand_pt = sample_free(itr)\n\n            # Grow smaller tree first for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_pt, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start, itr)\n            if new_node_goal:\n                success = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                merged = path_start + path_goal[::-1][1:]\n                final_path = shortcut_path(merged)\n                break\n\n        return PlannerResult(success=success, path=final_path, nodes=nodes, edges=edges)",
        "objective": -5.99315,
        "time_improvement": 5.0,
        "length_improvement": 23.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.01188223361968994,
                "num_nodes_avg": 79.8,
                "path_length_avg": 158.83592449947326,
                "success_improvement": 0.0,
                "time_improvement": -25.993088262433655,
                "length_improvement": 20.615331586143324,
                "objective_score": -3.6748601615014307
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.01518077850341797,
                "num_nodes_avg": 232.1,
                "path_length_avg": 233.555736130099,
                "success_improvement": 0.0,
                "time_improvement": -3.038256954816952,
                "length_improvement": 22.49830520981935,
                "objective_score": 3.588183955518785
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.016344833374023437,
                "num_nodes_avg": 246.1,
                "path_length_avg": 122.24962607271053,
                "success_improvement": 0.0,
                "time_improvement": 43.59950210076947,
                "length_improvement": 24.93136514997817,
                "objective_score": 18.066123660226474
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This improved planner combines bidirectional RRT* with adaptive goal biasing, dynamic neighborhood radius for rewiring, and adaptive step sizing. It leverages heuristic sampling near the goal, rewiring neighbors using a radius that shrinks with tree size, and shortcut path smoothing to minimize path length and improve smoothness. Collision checking is rigorously applied both at nodes and edges throughout. By balancing the growth of two trees and incrementally optimizing connections, the planner enhances planning efficiency, path quality, and success rate, while reducing planning time.",
        "planning_mechanism": "The planner alternates extension of two trees growing from start and goal positions, samples points biased towards the goal, and steers towards them with adaptive step size. It rewires nodes within a dynamically computed radius that shrinks as more nodes are added to improve local path costs. Trees are connected incrementally through efficient nearest and steering checks, and the resulting path is shortcut smoothed to reduce path length and increase smoothness. Collision checks ensure robustness and feasibility.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2,\n                 radius_const: float=30.0,\n                 radius_min: float=5.0,\n                 smoothing_iter: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.smoothing_iter = smoothing_iter\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                # Bias mostly to goal, sometimes to start to diversify\n                if random.random() < 0.8:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            # Radius shrinks as tree grows, but not smaller than radius_min\n            if n_nodes <= 1:\n                return self.radius_const\n            return max(self.radius_min, self.radius_const * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        def collision_free(node_pos):\n            return not self._is_in_obstacle(node_pos, obstacles, is_3d)\n\n        def edge_collision_free(pos1, pos2):\n            return not self._is_edge_in_obstacle(pos1, pos2, obstacles, is_3d)\n\n        def add_node(tree, new_node, parent_node):\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not collision_free(new_pos) or not edge_collision_free(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + distance(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if edge_collision_free(node.position, new_pos):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near neighbors to new_node if it improves cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-9 < neighbor.cost:\n                    if edge_collision_free(new_node.position, neighbor.position):\n                        # Update parent's children list and edges\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not collision_free(new_pos) or not edge_collision_free(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if edge_collision_free(new_pos, node.position):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Remove duplicate connection node\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if edge_collision_free(p_i, p_j):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            rand_point = sample_point()\n            # Balance tree growth: extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                extracted_path = extract_path(new_node_start, new_node_goal)\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 17.94367,
        "time_improvement": -67.0,
        "length_improvement": 19.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.9,
                "time_avg": 0.018182253837585448,
                "num_nodes_avg": 104.6,
                "path_length_avg": 168.33165524260306,
                "success_improvement": -9.999999999999998,
                "time_improvement": -92.79525936712346,
                "length_improvement": 15.869456628912701,
                "objective_score": -29.664686484354498
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.031208896636962892,
                "num_nodes_avg": 334.6,
                "path_length_avg": 239.47955766138966,
                "success_improvement": 0.0,
                "time_improvement": -111.82776036365225,
                "length_improvement": 20.53258081393532,
                "objective_score": -29.441811946308608
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.02803475856781006,
                "num_nodes_avg": 255.0,
                "path_length_avg": 127.86169046579641,
                "success_improvement": 0.0,
                "time_improvement": 3.261519678619699,
                "length_improvement": 21.48521953617643,
                "objective_score": 5.275499810821196
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This improved planner implements an optimized bidirectional RRT* algorithm with enhanced adaptive sampling biased towards goal, start, and promising midpoints, uses a dynamically decaying rewiring radius with smoothing of rewiring parameters for stable convergence, balanced growth of two trees with alternating extensions, fast neighbor queries via spatial hashing, mutual rewiring attempts, and efficient pruning of dead-ends to reduce unnecessary nodes. It further reduces collision checks by early rejection and accelerates edge validation with adaptive resolution stepping. After successful connection, it performs advanced path shortcutting and smoothing to produce high-quality smooth paths while guaranteeing collision-free validity within bounded environments. The design prioritizes lower planning time and improved solution quality with robustness in both 2D and 3D.",
        "planning_mechanism": "The planner grows two balanced trees from start and goal, always extending the smaller tree first. Sampling combines goal/start bias with adaptive exploration near shared subtree midpoints that fade over iterations. Each extension attempts connection and rewiring within a decaying radius scale based on iteration and node counts, balancing exploration and refinement. Dead-end nodes are periodically pruned to reduce computational load. Collision-safe edge and node validation are strictly enforced. Upon tree connection, shortcutting and iterative smoothing ensure smooth, optimal paths. The planner leverages these strategies to minimize planning time while maximizing success rates and path quality.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 3.0, prune_interval: int = 200,\n                 prune_threshold: int = 50, smoothing_iterations: int = 30,\n                 search_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.search_resolution = search_resolution\n\n    def plan(self, map):\n        bounds = map.size                      # Tuple[int, ...]\n        start_position = map.start             # Tuple[float, ...]\n        goal_position = map.goal               # Tuple[float, ...]\n        obstacles = map.obstacles              # List of obstacles (2D or 3D)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes.extend([start_root, goal_root])\n\n        import random\n        import math\n        from collections import defaultdict\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        # Use spatial hashing grid for near neighbor search to speed up radius queries\n        class SpatialHash:\n            def __init__(self, cell_size):\n                self.cell_size = cell_size\n                self.hash_table = defaultdict(list)\n\n            def _hash(self, pos):\n                return tuple(int(pos[i] // self.cell_size) for i in range(len(pos)))\n\n            def insert(self, node):\n                key = self._hash(node.position)\n                self.hash_table[key].append(node)\n\n            def remove(self, node):\n                key = self._hash(node.position)\n                if node in self.hash_table[key]:\n                    self.hash_table[key].remove(node)\n                    if not self.hash_table[key]:\n                        del self.hash_table[key]\n\n            def near(self, position, radius):\n                cx, cy = None, None\n                keys = []\n                radius_cells = int(math.ceil(radius / self.cell_size))\n                base_key = self._hash(position)\n                keys_to_check = []\n                for dx in range(-radius_cells, radius_cells + 1):\n                    for dy in range(-radius_cells, radius_cells + 1):\n                        if dim == 2:\n                            keys_to_check.append((base_key[0] + dx, base_key[1] + dy))\n                        else:\n                            for dz in range(-radius_cells, radius_cells + 1):\n                                keys_to_check.append((base_key[0] + dx, base_key[1] + dy, base_key[2] + dz))\n                result = []\n                for key in keys_to_check:\n                    if key in self.hash_table:\n                        for node in self.hash_table[key]:\n                            if dist(position, node.position) <= radius:\n                                result.append(node)\n                return result\n\n        # Initialize spatial hashes for both trees with dynamic cell_size adapted from step_size\n        cell_size = self.step_size * 2\n        hash_start = SpatialHash(cell_size)\n        hash_goal = SpatialHash(cell_size)\n        hash_start.insert(start_root)\n        hash_goal.insert(goal_root)\n\n        def radius_by_nodes_and_iter(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt(math.log(n_nodes) / n_nodes)\n            decay = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay)\n\n        def is_free_node(pos):\n            if not self._within_bounds(pos, bounds):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            if not self._within_bounds(p1, bounds) or not self._within_bounds(p2, bounds):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.search_resolution)\n\n        def adaptive_sample(itr):\n            r = random.random()\n            # Goal/start bias shifting gradually towards exploration near midpoint region\n            bias_decay_factor = (1 - itr / self.max_iter)\n            if r < self.goal_sample_rate:\n                sr = random.random()\n                if sr < 0.65 and is_free_node(goal_position):\n                    return goal_position\n                elif sr < 0.85 and is_free_node(start_position):\n                    return start_position\n                if len(tree_start) > 15 and len(tree_goal) > 15:\n                    mid_s = random.choice(tree_start).position\n                    mid_g = random.choice(tree_goal).position\n                    mid = tuple((mid_s[i] + mid_g[i]) / 2 for i in range(dim))\n                    spread = self.step_size * 6 * bias_decay_factor\n                    for _ in range(7):  # try several times for a valid point near mid\n                        candidate = tuple(\n                            max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread)))\n                            for d in range(dim)\n                        )\n                        if is_free_node(candidate):\n                            return candidate\n            # Uniform random sampling in free space (up to 75 attempts for efficiency)\n            for _ in range(75):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n            return start_position  # fallback safe default\n\n        def try_extend(tree, tree_hash, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not is_free_node(new_pos):\n                return None\n            if not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes_and_iter(len(tree), itr)\n            near = tree_hash.near(new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost and is_free_edge(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            tree_hash.insert(new_node)\n\n            # Rewiring neighbors to reduce costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect_and_rewire(tree, tree_hash, target_node, itr):\n            if not tree:\n                return None\n            last_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos):\n                    return None\n                if not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes_and_iter(len(tree), itr)\n                near = tree_hash.near(new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n\n                for node in near:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-10 < min_cost and is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                tree_hash.insert(new_node)\n\n                for neighbor in near:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-10 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        tree_hash.insert(final_node)\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:  # dead end\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        hash_start.remove(node)\n                        hash_goal.remove(node)\n                        removed.append(node)\n                    except Exception:\n                        pass\n            return removed\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if is_free_edge(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample = adaptive_sample(itr)\n            # Extend smaller tree for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n                hash_start, hash_goal = hash_goal, hash_start\n\n            new_node_start = try_extend(tree_start, hash_start, sample, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, hash_goal, new_node_start, itr)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                shortcuted_path = shortcut_path(raw_path)\n                smoothed_path = smooth_path(shortcuted_path)\n\n                candidates = [raw_path, shortcuted_path, smoothed_path]\n                extracted_path = min(candidates, key=path_length)\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        for i, v in enumerate(pos):\n            if not (0 <= v <= bounds[i]):\n                return False\n        return True",
        "objective": 5.63335,
        "time_improvement": -32.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.017850208282470702,
                "num_nodes_avg": 93.1,
                "path_length_avg": 174.175702912196,
                "success_improvement": 0.0,
                "time_improvement": -89.27441923960772,
                "length_improvement": 12.948657773695633,
                "objective_score": -24.19259421714319
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.024480581283569336,
                "num_nodes_avg": 193.7,
                "path_length_avg": 234.17414744587785,
                "success_improvement": 0.0,
                "time_improvement": -66.15988594601853,
                "length_improvement": 22.293095413457987,
                "objective_score": -15.389346701113961
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.011965417861938476,
                "num_nodes_avg": 131.4,
                "path_length_avg": 121.58031660862275,
                "success_improvement": 0.0,
                "time_improvement": 58.71138545479376,
                "length_improvement": 25.34236148080854,
                "objective_score": 22.681887932599835
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "This improved planner implements a bidirectional RRT* algorithm with adaptive, informed sampling biased towards start and goal, dynamic radius rewiring shrinking with tree size, efficient balanced tree growth by extending the smaller tree, and aggressive dead-end pruning. It incorporates a heuristic-informed sampling zone to reduce unnecessary exploration and iteratively performs shortcut smoothing using collision-checked random path segment replacements to minimize path length. Together these enhancements increase planning efficiency, path optimality, robustness, and smoothness while reducing computational overhead and search time.",
        "planning_mechanism": "The planner maintains two trees rooted at start and goal, always extending the smaller tree in each iteration for balanced exploration. Sampling is adaptively biased towards the start and goal regions using an ellipse informed by the current best path cost to focus exploration. New nodes are added if collision-free and rewired within a dynamically shrinking radius for optimal cost. Dead-end nodes (nodes without children) are pruned periodically to reduce complexity. Upon connecting the two trees, the path is iteratively shortcut-smoothed by attempting collision-free shortcuts between random node pairs, resulting in shorter, smoother paths.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root node along path\n        self.children: List[Node] = []  # Child nodes\n        self.valid = True               # Collision or pruning status\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 radius_constant: float = 30.0,\n                 radius_min: float = 5.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 100,\n                 smoothing_iterations: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        dist = math.dist\n        dim = len(bounds)\n\n        # Current best path cost heuristic (informed sampling)\n        best_path_cost = math.inf\n\n        def radius_dynamic(n: int) -> float:\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def ellipsoid_sample() -> Tuple[float, ...]:\n            # Adaptive informed sampling within an ellipsoid defined by start and goal and current best cost\n            start = start_position\n            goal = goal_position\n            c_min = dist(start, goal)\n            if best_path_cost == math.inf or best_path_cost < c_min:\n                # No solution or no improvement yet, sample uniformly with goal bias\n                return uniform_biased_sample()\n\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            vec = tuple(goal[d] - start[d] for d in range(dim))\n            c_best = best_path_cost\n\n            a1 = [v / c_min for v in vec]  # unit vector from start to goal\n\n            # Create orthonormal basis (only for 2D or 3D)\n            def unit_vector(v):\n                norm_v = math.sqrt(sum(x * x for x in v))\n                return [x / norm_v for x in v]\n\n            def mat_vect_mult(m, v):\n                return [sum(m[i][j] * v[j] for j in range(len(v))) for i in range(len(m))]\n\n            def rotation_to_world():\n                # Constructs rotation matrix that aligns x-axis with a1\n                if dim == 2:\n                    angle = math.atan2(a1[1], a1[0])\n                    cos_a = math.cos(angle)\n                    sin_a = math.sin(angle)\n                    return [[cos_a, -sin_a], [sin_a, cos_a]]\n                elif dim == 3:\n                    # Rodrigues' rotation formula; rotate x-axis to a1\n                    x_axis = [1.0, 0.0, 0.0]\n                    v_cross = [x_axis[1]*a1[2] - x_axis[2]*a1[1],\n                               x_axis[2]*a1[0] - x_axis[0]*a1[2],\n                               x_axis[0]*a1[1] - x_axis[1]*a1[0]]\n                    s = math.sqrt(sum(x*x for x in v_cross))\n                    c = sum(x_axis[i]*a1[i] for i in range(3))\n                    if s == 0:\n                        return [[1,0,0],[0,1,0],[0,0,1]]\n                    vx = [[0, -v_cross[2], v_cross[1]],\n                          [v_cross[2], 0, -v_cross[0]],\n                          [-v_cross[1], v_cross[0], 0]]\n                    I = [[1,0,0],[0,1,0],[0,0,1]]\n                    # Rotation matrix R = I + vx + vx^2 * ((1-c)/s^2)\n                    def mat_add(A,B):\n                        return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n                    def mat_mul(A,B):\n                        return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                    vx2 = mat_mul(vx, vx)\n                    factor = (1 - c) / (s * s)\n                    R = mat_add(mat_add(I, vx), [[vx2[i][j]*factor for j in range(3)] for i in range(3)])\n                    return R\n                else:\n                    # No rotation for higher dims, identity\n                    return [[1 if i == j else 0 for j in range(dim)] for i in range(dim)]\n\n            rotation = rotation_to_world()\n\n            # Ellipsoid radii\n            r1 = c_best * 0.5\n            r_rest = math.sqrt(c_best * c_best - c_min * c_min) * 0.5\n            radii = [r1] + [r_rest] * (dim - 1)\n\n            for _ in range(100):  # Try up to 100 times to find a collision-free sample\n                # Sample random point in unit n-ball\n                while True:\n                    # Sampling in unit n-ball by normal distribution + normalization * radius^(1/dim)\n                    x = [random.gauss(0, 1) for _ in range(dim)]\n                    norm_x = math.sqrt(sum(xx * xx for xx in x))\n                    if norm_x > 1e-9:\n                        break\n                x = [xx / norm_x for xx in x]\n\n                # Scale by random radius inside unit ball\n                u = random.uniform(0, 1) ** (1.0 / dim)\n                x = [u * xx for xx in x]\n\n                # Scale by radii\n                x = [radii[i] * x[i] for i in range(dim)]\n\n                # Rotate and translate\n                sample_local = [0.0] * dim\n                for i in range(dim):\n                    sample_local[i] = sum(rotation[i][j] * x[j] for j in range(dim))\n                sample_pt = tuple(center[i] + sample_local[i] for i in range(dim))\n\n                if can_add_node(sample_pt):\n                    return sample_pt\n\n            # Fallback: uniform-biased sampling if ellipsoid failed\n            return uniform_biased_sample()\n\n        def uniform_biased_sample() -> Tuple[float, ...]:\n            p_bias = 0.8\n            # With goal_sample_rate we bias towards goal or start positions\n            if random.random() < self.goal_sample_rate:\n                # Biased sampling favoring goal or start to guide growth\n                chosen = goal_position if random.random() < p_bias else start_position\n                if can_add_node(chosen):\n                    return chosen\n            # Uniform random sample in free space\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if can_add_node(sample):\n                    return sample\n            # In case fails, return goal or start as fallback\n            return goal_position if random.random() < 0.5 else start_position\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r2 = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= r2]\n\n        def try_extend(tree: List[Node], sample_pt: Tuple[float, ...]) -> Node:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node) -> Node:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes() -> List[Node]:\n            removed = []\n            # Prune leaf nodes that are not roots\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path: List[Tuple[float, ...]]) -> float:\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            # Adaptive sampling: informed ellipsoid if path found, else uniform-biased\n            sample_pt = ellipsoid_sample() if best_path_cost < math.inf else uniform_biased_sample()\n\n            # Extend smaller tree for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                # No expansion possible: continue\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                raw_len = path_length(raw_path)\n                smoothed = shortcut_smoothing(raw_path)\n                smooth_len = path_length(smoothed)\n\n                if smooth_len + 1e-12 < raw_len:\n                    extracted_path = smoothed\n                    best_path_cost = smooth_len\n                else:\n                    extracted_path = raw_path\n                    best_path_cost = raw_len\n                break\n\n            # Periodic dead-end pruning\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 3.02396,
        "time_improvement": -24.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.013785052299499511,
                "num_nodes_avg": 83.0,
                "path_length_avg": 161.6528400488978,
                "success_improvement": 0.0,
                "time_improvement": -46.16959796136605,
                "length_improvement": 19.207464269315736,
                "objective_score": -10.009386534546667
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02261660099029541,
                "num_nodes_avg": 224.2,
                "path_length_avg": 239.4704475444974,
                "success_improvement": 0.0,
                "time_improvement": -53.50827651941166,
                "length_improvement": 20.535603858929143,
                "objective_score": -11.945362184037666
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.021119356155395508,
                "num_nodes_avg": 146.7,
                "path_length_avg": 124.2092310645348,
                "success_improvement": 0.0,
                "time_improvement": 27.1242370467632,
                "length_improvement": 23.72804963640725,
                "objective_score": 12.882881041310409
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid planner combines the adaptive heuristic-informed sampling and dynamic radius shrinking from the improved bidirectional RRT* variant with the structured balanced tree growth, mutual rewiring, and rewiring radius calculations inspired by both algorithms. It introduces enhanced sampling bias that evolves over iterations to focus exploration in promising regions, balances tree growth by always expanding the smaller tree first, applies mutual rewiring with dynamic neighborhoods, and performs path shortcutting to improve path smoothness and reduce length. The planner rigorously validates collision-free nodes and edges and confines sampling within map bounds to ensure robustness, efficiency, and better convergence towards shorter, smoother paths.",
        "planning_mechanism": "The planner alternates growth between start and goal trees, samples points using adaptive heuristic bias that transitions from high goal bias to localized exploration near connection regions, extends nearest nodes using a fixed step size, dynamically computes a shrinking rewiring radius based on node count and iteration to balance global exploration and local refinement, rewires neighbors in both trees mutually to improve path cost, and, upon successful connection, extracts and shortcut smooths the final path. This approach blends adaptive sampling, balanced tree growth, and iterative local optimization within a bidirectional RRT* framework to enhance path quality and planning efficiency.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=25.0, radius_min: float=3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Initial probability to sample goal or biased points\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes: int, itr: int) -> float:\n            # Dynamic radius with iteration decay for finer rewiring over time\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt((math.log(n_nodes) / n_nodes))\n            decay_factor = max(self.radius_min / base, math.exp(-5*itr/self.max_iter))\n            return max(self.radius_min, base * decay_factor)\n\n        def is_free_node(pos: Tuple[float, ...]) -> bool:\n            if not all(0 <= pos[d] <= bounds[d] for d in range(dim)):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr: int) -> Tuple[float, ...]:\n            # Adaptive heuristic sampling:\n            r = random.random()\n            if r < self.goal_sample_rate:\n                subr = random.random()\n                # Early iterations: higher goal bias; later: more spread\n                if itr < self.max_iter / 3:\n                    # High goal bias\n                    if subr < 0.7 and is_free_node(goal_position):\n                        return goal_position\n                    elif subr < 0.9 and is_free_node(start_position):\n                        return start_position\n                else:\n                    # After some iterations, bias sampling around promising middle area\n                    if len(tree_start) > 15 and len(tree_goal) > 15:\n                        mid_from_start = random.choice(tree_start).position\n                        mid_from_goal = random.choice(tree_goal).position\n                        mid = tuple((mid_from_start[d] + mid_from_goal[d]) / 2 for d in range(dim))\n                        spread = self.step_size * 5 * (1 - itr / self.max_iter)\n                        def confined_rand():\n                            return tuple(\n                                max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread)))\n                                for d in range(dim)\n                            )\n                        for _ in range(5):\n                            cand = confined_rand()\n                            if is_free_node(cand):\n                                return cand\n                    # Fallback to goal or start positions biased sampling\n                    if subr < 0.5 and is_free_node(goal_position):\n                        return goal_position\n                    elif subr < 0.8 and is_free_node(start_position):\n                        return start_position\n\n            # Uniform random sampling inside bounds and free space\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(p):\n                    return p\n            # If no free sampled point, fallback to start\n            return start_position\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...], itr: int) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not is_free_node(new_pos) or not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree), itr)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                # Use strict less to promote cost improvement\n                if tentative_cost + 1e-8 < min_cost:\n                    if is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to connect through new_node if better\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree: List[Node], target_node: Node, itr: int) -> Node or None:\n            if not tree:\n                return None\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos) or not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes(len(tree), itr)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-8 < min_cost:\n                        if is_free_edge(node.position, new_pos):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors around new_node\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-8 < neighbor.cost:\n                        if is_free_edge(new_node.position, neighbor.position):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, cost=final_cost)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path)-1:\n                next_idx = len(path)-1\n                for j in range(len(path)-1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        for itr in range(self.max_iter):\n            rand_point = adaptive_sample(itr)\n\n            # Always grow smaller tree first to balance exploration\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start, itr)\n            if new_node_goal:\n                success_state = True\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                # Shortcut path for smoothness and length improvement\n                extracted_path = shortcut_path(merged_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -6.3318,
        "time_improvement": 7.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.007486176490783691,
                "num_nodes_avg": 72.6,
                "path_length_avg": 164.793398605954,
                "success_improvement": 0.0,
                "time_improvement": 20.62043841753064,
                "length_improvement": 17.637843287967563,
                "objective_score": 9.713700182852705
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.022054314613342285,
                "num_nodes_avg": 282.5,
                "path_length_avg": 234.72263809786804,
                "success_improvement": 0.0,
                "time_improvement": -49.69180504018914,
                "length_improvement": 22.11108765886303,
                "objective_score": -10.485323980284134
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.014582228660583497,
                "num_nodes_avg": 181.8,
                "path_length_avg": 123.25719770644477,
                "success_improvement": 0.0,
                "time_improvement": 49.6816554738064,
                "length_improvement": 24.312655469728927,
                "objective_score": 19.767027736087705
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This algorithm is a hybrid bidirectional planner synthesizing the adaptive heuristic informed sampling, balanced bidirectional growth, dynamic rewiring, incremental connection attempts, and path shortcutting for enhanced path quality and efficiency. It integrates periodic pruning for tree size management and employs dynamic rewiring radius decreasing with the number of nodes to locally optimize paths. The planner enforces rigorous collision checks, map boundary constraints, and rewires both trees mutually to improve robustness and success rate in 2D and 3D environments. Final path extraction includes smoothing via shortcutting to reduce length and improve smoothness.",
        "planning_mechanism": "The planner grows two trees rooted at start and goal by alternately extending the smaller tree towards adaptively sampled points with goal bias transitioning to local refinement. Each extension uses a steering function limited by step size, followed by rewiring nearby nodes to minimize cost while ensuring collision-free edges. It attempts incremental connection from the opposite tree after each extension. Periodic pruning removes dead-end nodes to maintain efficiency. Upon successful connection, paths are merged and shortcut-smoothed before being returned.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = parent                # Node or None\n        self.cost = cost                   # Path cost from root\n        self.children = []                 # List[Node]\n        self.valid = True                  # For collision checks, pruning etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 25.0,\n                 radius_min: float = 3.0, prune_interval: int = 150, prune_threshold: int = 70):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root =         Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            decay_factor = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay_factor)\n\n        def in_bounds(pos):\n            for i, p in enumerate(pos):\n                if p < 0 or p > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def is_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr):\n            r = random.random()\n            if r < self.goal_sample_rate:\n                subr = random.random()\n                # Early goal bias 70%, start bias 10%, local refinement 20%\n                if subr < 0.7:\n                    if is_free_node(goal_position):\n                        return goal_position\n                elif subr < 0.8:\n                    if is_free_node(start_position):\n                        return start_position\n                else:\n                    if len(tree_start) > 10 and len(tree_goal) > 10:\n                        mid_from_start = random.choice(tree_start).position\n                        mid_from_goal = random.choice(tree_goal).position\n                        mid = tuple((mid_from_start[i] + mid_from_goal[i]) / 2 for i in range(dim))\n                        spread = self.step_size * 5 * (1 - itr / self.max_iter)\n                        def confined_rand():\n                            return tuple(max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim))\n                        for _ in range(10):\n                            candidate = confined_rand()\n                            if is_free_node(candidate):\n                                return candidate\n            attempts = 0\n            while attempts < 100:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n                attempts += 1\n            return start_position\n\n        def try_extend(tree, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not is_free_node(new_pos) or not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree), itr)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-8 < min_cost and is_free_edge(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, target_node, itr):\n            if not tree:\n                return None\n\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos) or not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes(len(tree), itr)\n                near = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in near:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-8 < min_cost and is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in near:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-8 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, cost=final_cost)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if node.valid and not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        node.valid = False\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        for itr in range(self.max_iter):\n            sample_pt = adaptive_sample(itr)\n\n            # Always extend smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n                swapped = True\n            else:\n                swapped = False\n\n            new_node_start = try_extend(tree_start, sample_pt, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start, itr)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n                extracted_path = shortcut_path(merged_path)\n                break\n\n            # Periodic pruning for performance and memory control\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.8):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 13.65676,
        "time_improvement": -48.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.8,
                "time_avg": 0.01486351490020752,
                "num_nodes_avg": 97.7,
                "path_length_avg": 168.09438300345238,
                "success_improvement": -19.999999999999996,
                "time_improvement": -57.60506018065572,
                "length_improvement": 15.988043013498846,
                "objective_score": -24.083909451496947
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.026903700828552247,
                "num_nodes_avg": 170.1,
                "path_length_avg": 234.21968544898846,
                "success_improvement": 0.0,
                "time_improvement": -82.60660600401648,
                "length_improvement": 22.277984363406677,
                "objective_score": -20.32638492852361
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.030249810218811034,
                "num_nodes_avg": 147.2,
                "path_length_avg": 124.13621648078283,
                "success_improvement": 0.0,
                "time_improvement": -4.38187521750183,
                "length_improvement": 23.772884989303485,
                "objective_score": 3.4400144326101483
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This planner implements a balanced bidirectional RRT* algorithm with adaptive informed sampling, dynamic neighborhood radius for rewiring, periodic pruning of dead-end nodes, and shortcut path smoothing to enhance path quality and search efficiency. It alternates tree expansions from start and goal, ensuring collision-free nodes and edges, dynamically optimizes connections, and smooths the final path for improved smoothness and shorter lengths.",
        "planning_mechanism": "The planner grows two trees from start and goal positions, extending the smaller tree each iteration for balanced exploration. Samples are adaptively biased towards the goal for directed search. New nodes are added only if collision-free, and neighborhood rewiring optimizes path costs dynamically based on tree size. Periodic pruning removes dead-end nodes to reduce computational load. Upon connecting the trees, iterative shortcut smoothing improves path smoothness and quality.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=25.0,\n                 radius_min: float=5.0, prune_interval: int=200,\n                 prune_threshold: int=100, smoothing_iterations: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d in range(len(pos)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            p_bias = 0.8\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d) and in_bounds(sample):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p,c) for (p,c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) -1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Extend smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -6.02303,
        "time_improvement": 7.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.007739663124084473,
                "num_nodes_avg": 82.0,
                "path_length_avg": 168.76230537487686,
                "success_improvement": 0.0,
                "time_improvement": 17.932596654354978,
                "length_improvement": 15.654221831994624,
                "objective_score": 8.510623362705418
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.021677231788635253,
                "num_nodes_avg": 201.1,
                "path_length_avg": 241.8012510559584,
                "success_improvement": 0.0,
                "time_improvement": -47.132387090927615,
                "length_improvement": 19.76216439923414,
                "objective_score": -10.187283247431456
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.014474320411682128,
                "num_nodes_avg": 134.9,
                "path_length_avg": 124.33994290272581,
                "success_improvement": 0.0,
                "time_improvement": 50.054010384144235,
                "length_improvement": 23.647784693544356,
                "objective_score": 19.74576005395214
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This planner is an enhanced bidirectional RRT* algorithm that combines adaptive goal bias sampling, dynamic neighborhood radius for efficient rewiring, and strategic tree growth balancing. It improves planning efficiency and path quality by implementing early path shortening on connection, advanced smoothing via adaptive shortcutting, and efficient collision checking with adjustable resolution. The rewiring step aggressively optimizes local paths, and pruning techniques avoid expanding invalid nodes, thereby reducing search time and improving success rates in complex 2D/3D environments.",
        "planning_mechanism": "The planner incrementally builds two trees rooted at start and goal, extending the smaller tree each iteration with bias towards both start and goal. New nodes are collision-checked before insertion, and edges are verified for obstacle intersections. Neighborhood rewiring recalculates parent nodes to minimize path costs. Upon successfully connecting the two trees, the optimal path is extracted, followed by iterative shortcut smoothing to reduce path length and improve smoothness. The planner employs bounds checking, adaptive radius scaling for rewiring, and obstacle-aware steering to maximize robustness and efficiency.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        # Remove self from old parent's children list if exists\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2, radius_constant: float=25.0, radius_min: float=3.0,\n                 collision_resolution: float=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.collision_resolution = collision_resolution  # resolution for edge collision checking\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free(iteration):\n            # Adaptive goal bias increases over time to focus sampling towards start/goal\n            adapt_goal_bias = min(self.goal_sample_rate + (iteration / self.max_iter) * 0.2, 0.5)\n            if random.random() < adapt_goal_bias:\n                # 50% chance to sample start or goal for balanced biasing\n                return start_position if random.random() < 0.5 else goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            distance_ = dist(from_pos, to_pos)\n            if distance_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(self.radius_min, r)\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not can_add_node(new_pos):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in neighbors:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Attempt rewiring neighbors to new_node if it reduces cost\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, self.collision_resolution):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            # Edge might already be removed during update_parent\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, cost=new_cost, parent=last_node)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if (not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d, self.collision_resolution) and\n                        not self._is_in_obstacle(node.position, obstacles, is_3d)):\n                        final_node = Node(node.position,\n                                          parent=new_node,\n                                          cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def smooth_path(path: list, max_trials=300) -> list:\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i, p_j = path[i], path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d, self.collision_resolution):\n                    # shortcut -> remove intermediate nodes between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n\n            # Always extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n                # Post smoothing to reduce path length and improve smoothness\n                extracted_path = smooth_path(merged_path, max_trials=300)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 40.78481,
        "time_improvement": -139.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.8,
                "time_avg": 0.029625916481018068,
                "num_nodes_avg": 98.9,
                "path_length_avg": 160.59540833817158,
                "success_improvement": -19.999999999999996,
                "time_improvement": -214.137966776132,
                "length_improvement": 19.73595847483519,
                "objective_score": -70.29419833787257
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.04458100795745849,
                "num_nodes_avg": 329.0,
                "path_length_avg": 241.14670241214208,
                "success_improvement": 0.0,
                "time_improvement": -202.58984097496088,
                "length_improvement": 19.97936578361856,
                "objective_score": -56.78107913576455
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.029155874252319337,
                "num_nodes_avg": 228.4,
                "path_length_avg": 122.92782755045646,
                "success_improvement": 0.0,
                "time_improvement": -0.6070717815693442,
                "length_improvement": 24.514908587097775,
                "objective_score": 4.720860182948752
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This improved planner implements a bidirectional RRT* variant optimized with fast KD-tree nearest neighbor queries, adaptive informed sampling restricted within an ellipsoidal subset based on the best found path cost, and dynamic goal biasing to enhance focused exploration. It integrates efficient cost-aware rewiring for local path optimization, alternating tree growth to balance exploration/exploitation, and aggressive early termination upon tree connection to reduce planning time. Post-planning path smoothing uses iterative shortcutting with collision validation to improve path quality while ensuring feasibility and robustness, ultimately delivering faster convergence and higher-quality paths in complex environments.",
        "planning_mechanism": "The planner simultaneously grows two trees from the start and goal positions. It samples points within an ellipsoidal informed subset that shrinks as better solutions are found, thus focusing sampling and improving convergence speed. It alternates tree expansion with cost-based rewiring to locally optimize path segments. Connections between trees are attempted efficiently with verified collision checks. Upon successful connection, the path is extracted and refined through shortcut smoothing, maintaining collision-free guarantees. The approach balances exploration and exploitation, utilizes informed heuristics, and ensures robustness via strict obstacle checks.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D position\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost to reach this node from start\n        self.children = []\n        self.valid = True               # Validity flag (collision-free)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.20,\n                 neighbor_radius: float = 20.0, smoothing_iter: int = 150, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.smoothing_iter = smoothing_iter\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        if self._is_in_obstacle(start_position, obstacles, is_3d) or \\\n           self._is_in_obstacle(goal_position, obstacles, is_3d):\n            return PlannerResult(success=False, path=[], nodes=[], edges=[])\n\n        class KDTree:\n            __slots__ = ['nodes']\n\n            def __init__(self):\n                self.nodes = []\n\n            def insert(self, node):\n                self.nodes.append(node)\n\n            def nearest(self, point):\n                best_node = None\n                best_dist_sq = float('inf')\n                x, y = point[0], point[1]\n                for node in self.nodes:\n                    pos = node.position\n                    dist_sq = 0\n                    if dim == 2:\n                        dx = pos[0] - x\n                        dy = pos[1] - y\n                        dist_sq = dx*dx + dy*dy\n                    else:\n                        dz = pos[2] - point[2]\n                        dx = pos[0] - x\n                        dy = pos[1] - y\n                        dist_sq = dx*dx + dy*dy + dz*dz\n                    if dist_sq < best_dist_sq:\n                        best_dist_sq = dist_sq\n                        best_node = node\n                return best_node\n\n            def near(self, point, radius):\n                r_sq = radius * radius\n                neighbors = []\n                px, py = point[0], point[1]\n                for node in self.nodes:\n                    pos = node.position\n                    d_sq = 0\n                    if dim == 2:\n                        dx = pos[0] - px\n                        dy = pos[1] - py\n                        d_sq = dx*dx + dy*dy\n                    else:\n                        dz = pos[2] - point[2]\n                        dx = pos[0] - px\n                        dy = pos[1] - py\n                        d_sq = dx*dx + dy*dy + dz*dz\n                    if d_sq <= r_sq:\n                        neighbors.append(node)\n                return neighbors\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def informed_sample(c_best, start, goal):\n            # If no solution, sample uniformly with goal bias\n            if c_best == float('inf'):\n                if random.random() < self.goal_sample_rate:\n                    return goal\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n            import numpy as np\n\n            center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n            dist_start_goal = math.dist(start, goal)\n            if dist_start_goal == 0:\n                return start\n\n            a = c_best / 2.0\n            c = dist_start_goal / 2.0\n            # Degenerate case fallback\n            if a <= c:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n            b = math.sqrt(a * a - c * c)\n\n            def sample_unit_ball():\n                while True:\n                    if dim == 2:\n                        x = random.uniform(-1, 1)\n                        y = random.uniform(-1, 1)\n                        if x*x + y*y <= 1:\n                            return np.array([x, y])\n                    else:\n                        x = random.uniform(-1,1)\n                        y = random.uniform(-1,1)\n                        z = random.uniform(-1,1)\n                        if x*x + y*y + z*z <= 1:\n                            return np.array([x, y, z])\n\n            dir_vec = np.array([(goal[d] - start[d]) / dist_start_goal for d in range(dim)])\n\n            if dim == 2:\n                cos_theta = dir_vec[0]\n                sin_theta = dir_vec[1]\n                while True:\n                    sample_ball = sample_unit_ball()\n                    x_ellip = sample_ball[0] * a\n                    y_ellip = sample_ball[1] * b\n                    sample_x = center[0] + cos_theta * x_ellip - sin_theta * y_ellip\n                    sample_y = center[1] + sin_theta * x_ellip + cos_theta * y_ellip\n                    sample = (sample_x, sample_y)\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            else:\n                e1 = np.array([1.0, 0.0, 0.0])\n                v = np.cross(e1, dir_vec)\n                s = np.linalg.norm(v)\n                c = np.dot(e1, dir_vec)\n                if s < 1e-10:\n                    R = np.eye(3) if c > 0 else -np.eye(3)\n                else:\n                    vx = np.array([[0, -v[2], v[1]],\n                                   [v[2], 0, -v[0]],\n                                   [-v[1], v[0], 0]])\n                    R = np.eye(3) + vx + vx @ vx * ((1 - c) / (s*s))\n\n                while True:\n                    sample_ball = sample_unit_ball()\n                    scaled = np.array([a*sample_ball[0], b*sample_ball[1], b*sample_ball[2]])\n                    rotated = R.dot(scaled)\n                    sample_np = np.array(center) + rotated\n                    sample = tuple(sample_np.tolist())\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def choose_parent(new_pos, near_nodes):\n            min_cost = float('inf')\n            best_parent = None\n            for node in near_nodes:\n                dist_edge = math.dist(node.position, new_pos)\n                c_through = node.cost + dist_edge\n                if c_through < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = c_through\n                    best_parent = node\n            return best_parent, min_cost if best_parent else (None, None)\n\n        def rewire(new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                dist_edge = math.dist(new_node.position, near_node.position)\n                c_through_new = new_node.cost + dist_edge\n                if c_through_new < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, self.collision_resolution):\n                    # Remove old edge\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        if near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = c_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n        def extend(tree, kd_tree, sample_point):\n            nearest_node = kd_tree.nearest(sample_point)\n            if nearest_node is None:\n                return None\n\n            new_pos = steer(nearest_node.position, sample_point)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                return None\n\n            near_nodes = kd_tree.near(new_pos, self.neighbor_radius)\n            parent_node, min_cost = choose_parent(new_pos, near_nodes)\n\n            if parent_node is None:\n                # fallback\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n                parent_node = nearest_node\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n\n            new_node = Node(new_pos, parent=parent_node, cost=min_cost)\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n            kd_tree.insert(new_node)\n\n            rewire(new_node, near_nodes)\n\n            return new_node\n\n        def connect(tree, kd_tree, target_node):\n            nearest_node = kd_tree.nearest(target_node.position)\n            if nearest_node is None:\n                return None\n\n            curr_node = nearest_node\n            while True:\n                new_pos = steer(curr_node.position, target_node.position)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n\n                near_nodes = kd_tree.near(new_pos, self.neighbor_radius)\n                parent_node, min_cost = choose_parent(new_pos, near_nodes)\n                if parent_node is None:\n                    if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        return None\n                    parent_node = curr_node\n                    min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n\n                new_node = Node(new_pos, parent=parent_node, cost=min_cost)\n                parent_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((parent_node, new_node))\n                kd_tree.insert(new_node)\n\n                rewire(new_node, near_nodes)\n\n                if math.dist(new_node.position, target_node.position) <= self.step_size * 0.5:\n                    return new_node\n\n                curr_node = new_node\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            path_goal.reverse()\n            return path_start + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i, p_j = path[i], path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize trees\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        kd_start = KDTree()\n        kd_goal = KDTree()\n        kd_start.insert(start_root)\n        kd_goal.insert(goal_root)\n\n        success_state = False\n        connection_node_start = None\n        connection_node_goal = None\n        c_best = float('inf')\n\n        tree_flag = True  # True: extend start tree, False: extend goal tree\n\n        for _ in range(self.max_iter):\n            sample_pt = informed_sample(c_best, start_position, goal_position)\n\n            if tree_flag:\n                new_node = extend(tree_start, kd_start, sample_pt)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n\n                connect_node = connect(tree_goal, kd_goal, new_node)\n                if connect_node is not None:\n                    total_cost = new_node.cost + connect_node.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        success_state = True\n                        connection_node_start = new_node\n                        connection_node_goal = connect_node\n                        break\n            else:\n                new_node = extend(tree_goal, kd_goal, sample_pt)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n\n                connect_node = connect(tree_start, kd_start, new_node)\n                if connect_node is not None:\n                    total_cost = new_node.cost + connect_node.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        success_state = True\n                        connection_node_start = connect_node\n                        connection_node_goal = new_node\n                        break\n\n            tree_flag = not tree_flag\n\n        extracted_path = []\n        if success_state and connection_node_start and connection_node_goal:\n            extracted_path = extract_path(connection_node_start, connection_node_goal)\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 55.22279,
        "time_improvement": -194.0,
        "length_improvement": 23.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.9,
                "time_avg": 0.032877445220947266,
                "num_nodes_avg": 97.9,
                "path_length_avg": 159.39714582146087,
                "success_improvement": -9.999999999999998,
                "time_improvement": -248.61550362904143,
                "length_improvement": 20.33483856359086,
                "objective_score": -75.51768337599425
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.05726780891418457,
                "num_nodes_avg": 339.2,
                "path_length_avg": 234.25891948975692,
                "success_improvement": 0.0,
                "time_improvement": -288.7004351463622,
                "length_improvement": 22.264965181333025,
                "objective_score": -82.15713750764206
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.04169485569000244,
                "num_nodes_avg": 262.8,
                "path_length_avg": 120.76243174191418,
                "success_improvement": 0.0,
                "time_improvement": -43.87486044917882,
                "length_improvement": 25.844592059180915,
                "objective_score": -7.993539722917462
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "This improved planner implements a bidirectional RRT* algorithm enhanced with adaptive goal biasing and dynamic neighbor radius that shrinks over time to focus rewiring locally, improving path quality and convergence speed. It applies strict collision and edge feasibility checks, rewiring using the nearest nodes within an adaptively reduced radius to minimize path length, and leverages a heuristic cost check to more aggressively seek lower-cost connections. Tree growing alternates between start and goal; when the trees connect, the best path is extracted and subjected to post-processing smoothing for enhanced path smoothness.",
        "planning_mechanism": "The planner grows two trees simultaneously from start and goal by sampling free space points with an adaptive goal bias, steering a step towards them, and adding collision-free nodes. Each new node rewires its neighbors within an adaptively decreasing radius to locally optimize paths based on cost and collision checks. Once the two trees connect, the planner reconstructs the shortest path by backtracking from the connection nodes and applies smoothing to reduce unnecessary detours and shorten path length.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance(self, other_pos):\n        from math import dist\n        return dist(self.position, other_pos)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate=0.15,\n                 initial_neighbor_radius=15.0, min_neighbor_radius=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.initial_neighbor_radius = initial_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(p):\n            for d in range(len(bounds)):\n                if p[d] < 0 or p[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            # Adaptive goal biasing with 2x chance for goal (more focused search)\n            r = random.random()\n            if r < self.goal_sample_rate:\n                return goal_position\n            elif r < 2 * self.goal_sample_rate:\n                return start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [n for n in tree if (self._dist_sq(n.position, pos) <= r_sq)]\n\n        def can_connect(p1, p2):\n            if not in_bounds(p2):\n                return False\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def rewire_nodes(new_node, near, tree, edges):\n            for neighbor in near:\n                if neighbor == new_node.parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n        def try_extend(tree, point, neighbor_radius):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            near = near_nodes(tree, new_pos, neighbor_radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                if node == nearest_node:\n                    continue\n                edge_clear = not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d)\n                if edge_clear:\n                    temp_cost = node.cost + math.dist(node.position, new_pos)\n                    if temp_cost + 1e-7 < min_cost:\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire_nodes(new_node, near, tree, edges)\n            return new_node\n\n        def try_connect(to_tree, from_node, neighbor_radius):\n            current_nearest = nearest(to_tree, from_node.position)\n\n            # Attempt to step repeatedly from current_nearest towards from_node.position\n            last_node = None\n            while True:\n                new_pos = steer(current_nearest.position, from_node.position)\n                if not can_connect(current_nearest.position, new_pos):\n                    break\n\n                new_cost = current_nearest.cost + math.dist(current_nearest.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = current_nearest\n                current_nearest.children.append(new_node)\n\n                to_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((current_nearest, new_node))\n\n                current_nearest = new_node\n                last_node = new_node\n\n                if math.dist(new_pos, from_node.position) <= self.step_size:\n                    # Connect final edge if feasible\n                    if can_connect(new_pos, from_node.position):\n                        final_cost = new_node.cost + math.dist(new_pos, from_node.position)\n                        final_node = Node(from_node.position)\n                        final_node.cost = final_cost\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n\n                        to_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n\n                        return final_node\n                    break\n\n            # Try partial connect if direct connection not possible\n            # Attempt to rewire near after connect\n            if last_node:\n                near = near_nodes(to_tree, last_node.position, neighbor_radius)\n                rewire_nodes(last_node, near, to_tree, edges)\n\n            return None\n\n        def extract_path(node_start, node_goal):\n            path1 = node_start.path_from_root()\n            path2 = node_goal.path_from_root()\n            return path1 + path2[::-1][1:]\n\n        def smooth_path(path, max_iter=50):\n            # Shortcut smoothing: randomly attempts to replace subpaths with direct edges if collision free\n            if len(path) < 3:\n                return path\n            for _ in range(max_iter):\n                import random\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if j <= i + 1:\n                    continue\n                if self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    continue\n                # Remove intermediate nodes between i and j\n                path = path[:i+1] + path[j:]\n            return path\n\n        # Initialize\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        success_state = False\n        extracted_path = []\n\n        # Dynamic neighbor radius shrinks linearly from initial to min radius over iterations\n        def neighbor_radius(it):\n            decay = it / self.max_iter\n            r = self.initial_neighbor_radius - decay * (self.initial_neighbor_radius - self.min_neighbor_radius)\n            return max(r, self.min_neighbor_radius)\n\n        for it in range(self.max_iter):\n            radius = neighbor_radius(it)\n            rand_point = sample_free()\n\n            # Grow tree_start toward random sample\n            new_node_start = try_extend(tree_start, rand_point, radius)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            # Try connect goal tree to new_node_start\n            new_node_goal = try_connect(tree_goal, new_node_start, radius)\n\n            if new_node_goal is not None:\n                success_state = True\n                extracted_path = extract_path(new_node_start, new_node_goal)\n                extracted_path = smooth_path(extracted_path, max_iter=100)\n                break\n\n            # Alternate trees\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _dist_sq(self, p1, p2):\n        return sum((p1[d] - p2[d]) ** 2 for d in range(len(p1)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 174.36803,
        "time_improvement": -591.0,
        "length_improvement": 23.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.9,
                "time_avg": 0.039312434196472165,
                "num_nodes_avg": 103.5,
                "path_length_avg": 161.41255409610545,
                "success_improvement": -9.999999999999998,
                "time_improvement": -316.8488139569571,
                "length_improvement": 19.327556879013677,
                "objective_score": -96.18913281128438
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.16566729545593262,
                "num_nodes_avg": 383.1,
                "path_length_avg": 233.25216791160543,
                "success_improvement": 0.0,
                "time_improvement": -1024.4528305550743,
                "length_improvement": 22.59903941488543,
                "objective_score": -302.8160412835452
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.15394141674041747,
                "num_nodes_avg": 337.7,
                "path_length_avg": 120.01242215465547,
                "success_improvement": 0.0,
                "time_improvement": -431.1998203218904,
                "length_improvement": 26.30514312709546,
                "objective_score": -124.09891747114803
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e1",
        "algorithm_description": "This planner implements an enhanced bidirectional RRT* variant with adaptive informed sampling guided by cost-to-go heuristics and dynamic neighborhood radius based on node density. It integrates a lazy collision-checking mechanism combined with batch rewiring steps for local optimizations to improve path quality and reduce computational overhead. The algorithm employs a heuristic-driven sampling domain shaped as an ellipse between start and goal to accelerate convergence toward the optimal path while periodic smoothing and shortcutting reduce path jaggedness and length. The planner balances exploration and exploitation by alternating tree growth and adaptively pruning low-potential branches to boost success rate and planning efficiency.",
        "planning_mechanism": "The planner grows two trees bidirectionally from start and goal using informed ellipse sampling biased by the current best path cost. Nodes are incrementally connected and rewired locally using a radius that shrinks with increased samples, improving path costs. Lazy collision checks delay expensive verification until necessary. Upon tree connection, the path is extracted and smoothed by shortcutting to improve smoothness and length. Periodic pruning removes dead-end or poor-quality branches, focusing search on promising regions and reducing computation time.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag for collision or pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    # Utility to check if node is a leaf (no children)\n    def is_leaf(self):\n        return len(self.children) == 0\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 radius_constant: float = 30.0, radius_min: float = 5.0,\n                 prune_interval: int = 300, prune_threshold: int = 150,\n                 smoothing_trials: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Cost heuristic for informed sampling - Euclidean distance\n        def heuristic(a, b):\n            return math.dist(a, b)\n\n        # Adaptive radius shrinking with number of nodes for rewiring\n        def dynamic_radius(n):\n            if n == 0:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(r, self.radius_min)\n\n        # Steer function limits step size\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(len(from_p)))\n\n        # Nearest neighbor in a tree\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        # Nearby nodes within radius for rewiring\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            return [n for n in tree if sum((n.position[d] - pos[d]) ** 2 for d in range(len(pos))) <= r2]\n\n        # Informed sampling inside an ellipse defined between start and goal with current best path cost\n        def informed_sample(cost_best):\n            if cost_best == float('inf'):\n                # Uniform random sample in bounds avoiding obstacles\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n            else:\n                c_min = heuristic(start_pos, goal_pos)\n                if cost_best < c_min:\n                    cost_best = c_min * 1.0001  # numerical safeguard\n                # Ellipse parameters\n                c_best = cost_best\n                center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(len(start_pos)))\n                vec = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(len(start_pos)))\n                import numpy as np  # assume allowed, else re-implement manually\n                # Construct rotation matrix using orthonormal basis\n                dim = len(start_pos)\n                # First diag matrix: lengths of ellipse axes\n                L = np.diag([c_best / 2] + [math.sqrt(c_best ** 2 - c_min ** 2) / 2] * (dim - 1))\n                # Orthonormal basis: construct only principal axis vec and some orthonormal complement\n                e1 = np.array(vec)\n                if dim == 2:\n                    e2 = np.array([-e1[1], e1[0]])\n                    C = np.column_stack((e1, e2))\n                else:\n                    # Gram-Schmidt to complete basis for 3D\n                    a = np.array([1.0, 0.0, 0.0])\n                    if abs(np.dot(a, e1)) > 0.9:\n                        a = np.array([0.0, 1.0, 0.0])\n                    v2 = a - np.dot(a, e1) * e1\n                    v2 /= np.linalg.norm(v2)\n                    v3 = np.cross(e1, v2)\n                    C = np.column_stack((e1, v2, v3))\n                while True:\n                    sample_in_unit_ball = np.random.uniform(-1, 1, dim)\n                    if np.linalg.norm(sample_in_unit_ball) > 1.0:\n                        continue\n                    # Scale by ellipse axes lengths\n                    sample = np.dot(C, np.dot(L, sample_in_unit_ball)) + np.array(center)\n                    sample_t = tuple(sample)\n                    if all(0 <= sample_t[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n\n        # Lazy collision check: defer edge collision checking until connection attempt\n        lazy_checked_edges = set()\n\n        # Try extending tree toward sampled point with rewiring\n        def try_extend(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n\n            n_nodes = len(tree)\n            r = dynamic_radius(n_nodes)\n\n            near = near_nodes(tree, new_pos, r)\n\n            # Pick best parent minimizing cost\n            min_cost = nearest_node.cost + heuristic(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + heuristic(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if (node, new_pos) not in lazy_checked_edges and self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d) is False:\n                        lazy_checked_edges.add((node, new_pos))\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            # Final edge collision check with best parent (lazy collision confirms edge feasibility)\n            if self._is_edge_in_obstacle(best_parent.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if cheaper through new_node\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + heuristic(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d) is False:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        # Attempt connection between two trees by extending along edge(s) towards target node, with collision checks\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n                new_cost = last_node.cost + heuristic(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n                if heuristic(new_pos, node.position) <= self.step_size:\n                    # Final edge check\n                    if self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d) is False and self._is_in_obstacle(node.position, obstacles, is_3d) is False:\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + heuristic(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        # Prune dead leaf nodes to focus search on promising branches\n        def prune_dead_branches():\n            removed = []\n            for node in nodes[:]:\n                if node.is_leaf() and node is not start_root and node is not goal_root:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        # Shortcut smoothing post path extraction: attempts shortcuts for path segments to remove jaggedness\n        def shortcut_path(raw_path):\n            if len(raw_path) < 3:\n                return raw_path\n            smooth_path = raw_path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth_path) < 3:\n                    break\n                i = random.randint(0, len(smooth_path) - 3)\n                j = random.randint(i + 2, len(smooth_path) - 1)\n                pt_i = smooth_path[i]\n                pt_j = smooth_path[j]\n                if self._is_edge_in_obstacle(pt_i, pt_j, obstacles, is_3d) is False:\n                    # shortcut possible: remove intermediate points\n                    del smooth_path[i + 1:j]\n            return smooth_path\n\n        best_path_cost = float('inf')\n        best_path = []\n\n        # Alternate tree growth with heuristic informed sampling\n        tree_turn = 0\n        for itr in range(self.max_iter):\n            # Use best_path_cost to sample informed or uniform\n            sample_pt = informed_sample(best_path_cost)\n\n            if tree_turn == 0:\n                new_node = try_extend(tree_start, sample_pt)\n                if new_node is None:\n                    tree_turn = 1\n                    continue\n                connect_node = try_connect(tree_goal, new_node)\n                if connect_node:\n                    success = True\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    candidate_path = path_start + path_goal[::-1][1:]\n                    candidate_cost = sum(heuristic(candidate_path[i], candidate_path[i + 1]) for i in range(len(candidate_path) - 1))\n                    if candidate_cost < best_path_cost:\n                        best_path_cost = candidate_cost\n                        best_path = candidate_path\n                    break\n            else:\n                new_node = try_extend(tree_goal, sample_pt)\n                if new_node is None:\n                    tree_turn = 0\n                    continue\n                connect_node = try_connect(tree_start, new_node)\n                if connect_node:\n                    success = True\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    candidate_path = path_start + path_goal[::-1][1:]\n                    candidate_cost = sum(heuristic(candidate_path[i], candidate_path[i + 1]) for i in range(len(candidate_path) - 1))\n                    if candidate_cost < best_path_cost:\n                        best_path_cost = candidate_cost\n                        best_path = candidate_path\n                    break\n\n            # Alternate tree turn\n            tree_turn = 1 - tree_turn\n\n            # Periodic pruning to reduce tree size and focus search\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_branches()\n\n        # Once done, apply smoothing if success\n        if success and best_path:\n            smoothed = shortcut_path(best_path)\n            path = smoothed\n        else:\n            path = []\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -6.52887,
        "time_improvement": 8.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.0066823244094848635,
                "num_nodes_avg": 78.4,
                "path_length_avg": 161.6097494634053,
                "success_improvement": 0.0,
                "time_improvement": 29.144072060046668,
                "length_improvement": 19.229000529779853,
                "objective_score": 12.58902172396997
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02199399471282959,
                "num_nodes_avg": 192.7,
                "path_length_avg": 241.84558651954626,
                "success_improvement": 0.0,
                "time_improvement": -49.28238879008597,
                "length_improvement": 19.747452392480206,
                "objective_score": -10.835226158529748
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.0162661075592041,
                "num_nodes_avg": 131.4,
                "path_length_avg": 124.81292096319058,
                "success_improvement": 0.0,
                "time_improvement": 43.87115829032658,
                "length_improvement": 23.357347671741252,
                "objective_score": 17.832817021446225
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This planner is an advanced bidirectional RRT* variant combining adaptive informed sampling with dynamically shrinking rewiring radius, balanced tree extension based on size, aggressive pruning of dead-end nodes, and iterative path shortcut smoothing. It integrates a KD-tree inspired nearest neighbor heuristic for faster queries and enforces rigorous collision and boundary checks. These enhancements improve planning efficiency, path quality, robustness, and reduce total computation time while producing smooth, minimal-length paths.",
        "planning_mechanism": "The planner alternates extensions between the smaller of two trees (start and goal), uses biased informed sampling towards start/goal to accelerate connection, employs dynamic radius rewiring to locally optimize cost, prunes dead-end nodes regularly to limit tree size, and performs iterative shortcut smoothing after connection. KD-tree-inspired spatial queries and early connection checks reduce overhead and enable faster convergence to high-quality, smooth paths.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def remove_child(self, child_node: 'Node'):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float=5.5,\n                 goal_sample_rate: float=0.12, radius_const: float=30.0,\n                 radius_min: float=5.0, prune_interval: int=100,\n                 prune_threshold: int=150, smoothing_iters: int=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle rects/cuboids\n\n        import math\n        import random\n\n        is_3d = (len(bounds) == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def radius_dynamic(n):\n            if n <= 1:\n                return self.radius_const\n            val = self.radius_const * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(val, self.radius_min)\n\n        def _is_in_bounds(pos):\n            for d in range(len(pos)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        # KD-tree inspired nearest heuristic: simple spatial hashing bucket\n        # For performance with modest node counts, direct search is used here with filtering for radius queries\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            result = []\n            for node in tree:\n                # squared distance check for efficiency\n                d_sq = 0\n                for dd in range(len(pos)):\n                    diff = node.position[dd] - pos[dd]\n                    d_sq += diff*diff\n                    if d_sq > r_sq:\n                        break\n                if d_sq <= r_sq:\n                    result.append(node)\n            return result\n\n        def can_add_node(pos):\n            if not _is_in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def sample_free():\n            p_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                # Adaptive bias: 70% goal, 30% start\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                trials = 0\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    trials += 1\n                    if trials > 1000:\n                        # Fallback to start or goal if too many failures\n                        return random.choice([start_position, goal_position])\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        # Extend function with rewiring and collision checks.\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        # Try to connect tree to node by incremental steering and rewiring on the connecting tree\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        # Prune leaf nodes to keep tree size manageable and efficient\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.remove_child(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        # Iterative shortcut smoothing, tries random pairs on path to shortcut if no collision\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Extend smaller tree first for balanced search & efficiency\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                # Combined path with join at the connecting nodes\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                # Accept shorter/smoother path if improvement found\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            # Periodic pruning to limit tree growth and improve efficiency\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.8):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -4.35147,
        "time_improvement": 7.0,
        "length_improvement": 19.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.9,
                "time_avg": 0.005747389793395996,
                "num_nodes_avg": 81.8,
                "path_length_avg": 166.18830619036038,
                "success_improvement": -9.999999999999998,
                "time_improvement": 39.05763741944944,
                "length_improvement": 16.94068188443104,
                "objective_score": 10.105427602721042
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.01903247833251953,
                "num_nodes_avg": 159.0,
                "path_length_avg": 244.78127177341085,
                "success_improvement": 0.0,
                "time_improvement": -29.18134550685893,
                "length_improvement": 18.773292706595587,
                "objective_score": -4.999745110738561
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.025402522087097167,
                "num_nodes_avg": 125.4,
                "path_length_avg": 128.28244561261585,
                "success_improvement": 0.0,
                "time_improvement": 12.34447847688249,
                "length_improvement": 21.22685052931281,
                "objective_score": 7.948713648927308
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This improved planner is a bidirectional RRT* variant designed for enhanced planning efficiency and path quality. It integrates adaptive goal biasing with heuristic-driven sampling that alternates focus between start and goal to resolve symmetry issues. It employs a dynamically shrinking neighbor radius for rewiring, enabling aggressive and efficient cost optimization while maintaining computational speed. Lazy collision checking is used to reduce unnecessary computations while balanced tree expansions avoid local minima. Spatial pruning is applied to limit search space, and robust path smoothing via randomized shortcutting further optimizes the final path for length and smoothness.",
        "planning_mechanism": "The planner initializes two trees at start and goal positions and alternately samples points using adaptive biasing between the two. For each iteration, the closest node in the active tree is extended toward the sampled point within step size constraints, ensuring collision-free nodes and edges. The new node connects optimally by rewiring nearby neighbors within a dynamically shrinking radius. Subsequently, the opposite tree attempts incremental connection to this new node, and successful connection signals path completion. The resulting path is merged and smoothed through multiple randomized shortcut attempts, producing a collision-free, optimized final route.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 7.0, max_neighbor_radius: float = 20.0,\n                 goal_sample_rate: float = 0.15, smoothing_trials: int = 120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free(iteration):\n            # Adaptive goal biasing; capped at 0.3\n            goal_bias = min(self.goal_sample_rate + (iteration / self.max_iter) * 0.15, 0.3)\n            if random.random() < goal_bias:\n                # Alternate bias between start and goal to avoid symmetry\n                return start_position if (iteration % 2 == 0) else goal_position\n            else:\n                attempts = 0\n                while attempts < 30:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                    attempts += 1\n                # Fallback\n                return start_position if (iteration % 2 == 0) else goal_position\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            # Clamp inside bounds\n            clamped = tuple(max(0, min(new_p[d], bounds[d])) for d in range(len(bounds)))\n            return clamped\n\n        def neighbor_radius(iteration):\n            # Shrink radius sub-linearly for efficient rewiring\n            return max(self.min_neighbor_radius,\n                       self.max_neighbor_radius * (1 - (iteration / self.max_iter) ** 0.85))\n\n        def near_nodes(tree, pos, radius):\n            # Linear neighbor search (could be optimized by spatial indexing)\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        # Spatial pruning to skip nodes significantly far from start-goal bounding box\n        def in_prune_region(pos):\n            margin = self.max_neighbor_radius + self.step_size\n            min_b = tuple(min(start_position[d], goal_position[d]) - margin for d in range(len(bounds)))\n            max_b = tuple(max(start_position[d], goal_position[d]) + margin for d in range(len(bounds)))\n            return all(min_b[d] <= pos[d] <= max_b[d] for d in range(len(bounds)))\n\n        # Initialize trees\n        start_root = Node(start_position, None, 0.0)\n        goal_root = Node(goal_position, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        connected = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        for iteration in range(self.max_iter):\n            q_rand = sample_free(iteration)\n\n            # Alternate tree expansions for balanced growth\n            if iteration % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            r = neighbor_radius(iteration)\n\n            nearest_a = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not in_bounds(new_pos):\n                continue\n            if not in_prune_region(new_pos):\n                continue\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Edge collision check\n            if self._is_edge_in_obstacle(nearest_a.position, new_pos, obstacles, is_3d):\n                continue\n\n            near = near_nodes(tree_a, new_pos, r)\n\n            # Choose best parent minimizing cost + heuristic\n            min_cost = nearest_a.cost + math.dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_through_node = node.cost + math.dist(node.position, new_pos)\n                if cost_through_node < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_node\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            best_parent.children.append(new_node)\n            new_node.parent = best_parent\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if improved cost paths found\n            for node in near:\n                if node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n            # Try connecting the other tree to this new node (stepwise)\n            nearest_b = nearest(tree_b, new_node.position)\n            curr_b = nearest_b\n            while True:\n                pos_b_new = steer(curr_b.position, new_node.position)\n\n                if not in_bounds(pos_b_new):\n                    break\n                if not in_prune_region(pos_b_new):\n                    break\n\n                if self._is_in_obstacle(pos_b_new, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(curr_b.position, pos_b_new, obstacles, is_3d):\n                    break\n\n                cost_b = curr_b.cost + math.dist(curr_b.position, pos_b_new)\n                new_node_b = Node(pos_b_new, curr_b, cost_b)\n                curr_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((curr_b, new_node_b))\n\n                near_b = near_nodes(tree_b, pos_b_new, r)\n                for node in near_b:\n                    if node is curr_b:\n                        continue\n                    cost_through_new_b = new_node_b.cost + math.dist(new_node_b.position, node.position)\n                    if cost_through_new_b < node.cost:\n                        if not self._is_edge_in_obstacle(new_node_b.position, node.position, obstacles, is_3d):\n                            try:\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                            node.update_parent(new_node_b, cost_through_new_b)\n                            edges.append((new_node_b, node))\n\n                if math.dist(new_node_b.position, new_node.position) <= self.step_size:\n                    connected = True\n                    if tree_a is tree_start:\n                        connection_node_start = new_node\n                        connection_node_goal = new_node_b\n                    else:\n                        connection_node_start = new_node_b\n                        connection_node_goal = new_node\n                    break\n\n                curr_b = new_node_b\n\n            if connected:\n                path_start = connection_node_start.path_from_root()\n                path_goal = connection_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n\n                # Path smoothing with randomized shortcuts\n                merged_path = self._path_smooth(merged_path, obstacles, is_3d, self.smoothing_trials)\n\n                return PlannerResult(\n                    success=True,\n                    path=merged_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        # Fail if no path found after max_iter\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smooth(self, path, obstacles, is_3d, max_trials=120):\n        import random\n        if len(path) < 3:\n            return path\n        path = path[:]\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 23.27567,
        "time_improvement": -73.0,
        "length_improvement": 26.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.017285633087158202,
                "num_nodes_avg": 101.4,
                "path_length_avg": 161.35454750996308,
                "success_improvement": 0.0,
                "time_improvement": -83.28795451500281,
                "length_improvement": 19.356548013237518,
                "objective_score": -21.115076751853337
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03474357128143311,
                "num_nodes_avg": 347.2,
                "path_length_avg": 235.35903530909974,
                "success_improvement": 0.0,
                "time_improvement": -135.81906714588325,
                "length_improvement": 21.899909533900487,
                "objective_score": -36.36573823698488
            },
            {
                "map_id": 2,
                "success_rate": 0.6,
                "time_avg": 0.028833627700805664,
                "num_nodes_avg": 261.1,
                "path_length_avg": 101.76248882134416,
                "success_improvement": -40.0,
                "time_improvement": 0.5048921972477305,
                "length_improvement": 37.51170158822934,
                "objective_score": -12.346192023179812
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm focusing on minimizing path length and improving planning efficiency. It dynamically adjusts the rewiring radius to optimize local connectivity, uses adaptive informed sampling biased toward start and goal regions, aggressively prunes unpromising dead-end nodes, balances tree growth by always extending the smaller tree, and performs iterative path shortcut smoothing to improve path quality and smoothness. Nearest neighbor searches utilize an efficient radius-based filtering approach, and rigorous collision and edge-intersection checks ensure valid paths within map boundaries and free of obstacles. The combination of these techniques results in faster convergence to high-quality, shorter, and smoother paths.",
        "planning_mechanism": "The planner alternates extensions between the smaller of two trees grown from start and goal positions. Samples are drawn with a strong bias towards the goal and start to guide the exploration. Each extension step uses a dynamically shrinking radius to locate near neighbors for rewiring, improving path costs locally. Periodic pruning removes leaf nodes without children to maintain tree compactness and efficiency. Once trees connect, iterative shortcut smoothing refines the path by attempting collision-free shortcuts between non-adjacent waypoints. This balanced, adaptive, and pruning-augmented bidirectional RRT* process yields robust and efficient path planning with high solution quality.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # Validity flag (unused but kept for extensibility)\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def remove_child(self, child_node: 'Node'):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_const: float=25.0, radius_min: float=4.0,\n                 prune_interval: int=80, prune_threshold: int=120, smoothing_iters: int=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles (rect/cuboid)\n\n        import math\n        import random\n\n        is_3d = (len(bounds) == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def radius_dynamic(n):\n            if n <= 1:\n                return self.radius_const\n            val = self.radius_const * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(val, self.radius_min)\n\n        def _is_in_bounds(pos):\n            for d in range(len(pos)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def nearest(tree, point):\n            # Nearest node by Euclidean distance\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = node\n            return min_node\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            result = []\n            for node in tree:\n                d_sq = 0\n                for dd in range(len(pos)):\n                    diff = node.position[dd] - pos[dd]\n                    d_sq += diff * diff\n                    if d_sq > r_sq:\n                        break\n                if d_sq <= r_sq:\n                    result.append(node)\n            return result\n\n        def can_add_node(pos):\n            if not _is_in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def sample_free():\n            # Adaptive biased sampling: goal biased more strongly with fallback sampling\n            p_bias = 0.75\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                trials = 0\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    trials += 1\n                    if trials > 1000:\n                        return random.choice([start_position, goal_position])\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.remove_child(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n                smoothed = shortcut_smoothing(raw_path)\n\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.8):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 11.33275,
        "time_improvement": -35.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 0.9,
                "time_avg": 0.01879124641418457,
                "num_nodes_avg": 94.4,
                "path_length_avg": 160.26993757888138,
                "success_improvement": -9.999999999999998,
                "time_improvement": -99.2527031365738,
                "length_improvement": 19.89862563206727,
                "objective_score": -30.79608581455868
            },
            {
                "map_id": 1,
                "success_rate": 0.8,
                "time_avg": 0.02179224491119385,
                "num_nodes_avg": 151.9,
                "path_length_avg": 242.368891390616,
                "success_improvement": -19.999999999999996,
                "time_improvement": -47.91302898440496,
                "length_improvement": 19.573802132067545,
                "objective_score": -20.459148268907978
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.01705174446105957,
                "num_nodes_avg": 117.8,
                "path_length_avg": 122.87939797776122,
                "success_improvement": 0.0,
                "time_improvement": 41.160190768132146,
                "length_improvement": 24.544647262179197,
                "objective_score": 17.256986682875482
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid planner integrates bidirectional incremental RRT* exploration with adaptive goal and start bias sampling, dynamic radius rewiring, periodic pruning of dead-ends, and iterative shortcut smoothing. It alternately grows the smaller tree (start or goal) to balance exploration, performs rigorous collision and edge feasibility checks, and rewires locally for path cost improvements. After successful connection, the path undergoes shortcut smoothing to enhance smoothness and reduce length. Pruning of dead-end nodes maintains tree efficiency and robustness, collectively improving planning speed, success rate, and path quality.",
        "planning_mechanism": "The planner grows two bidirectional trees rooted at start and goal by alternatively extending the smaller tree towards random samples biased towards goal and start. It dynamically adjusts neighbor search radius based on tree size for rewiring, promoting path optimality. Each extension includes collision-checking for new nodes and edges. Upon connecting the two trees, it backtracks paths and applies shortcut smoothing to optimize the trajectory. It periodically prunes dead-end nodes to constrain tree complexity and keep search efficient, thus balancing exploration and exploitation for robust, efficient path planning.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=20.0,\n                 radius_min: float=5.0, prune_interval: int=150,\n                 prune_threshold: int=150, smoothing_iterations: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        import random\n        import math\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                # Bias towards goal and start equally to avoid symmetry bias\n                return goal_position if random.random() < 0.6 else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def can_add_node(pos):\n            if not in_bounds(pos) or self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            to_remove = [node for node in nodes if node is not start_root and node is not goal_root and not node.children]\n            for node in to_remove:\n                try:\n                    if node.parent:\n                        node.parent.children.remove(node)\n                    nodes.remove(node)\n                    edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                    removed.append(node)\n                except Exception:\n                    continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Extend smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed_path = shortcut_smoothing(raw_path)\n                if path_length(smoothed_path) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -5.12832,
        "time_improvement": 4.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.006788301467895508,
                "num_nodes_avg": 74.3,
                "path_length_avg": 162.69392262951396,
                "success_improvement": 0.0,
                "time_improvement": 28.02034589024646,
                "length_improvement": 18.687141201885662,
                "objective_score": 12.143532007451071
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02096395492553711,
                "num_nodes_avg": 205.0,
                "path_length_avg": 249.99621723754436,
                "success_improvement": 0.0,
                "time_improvement": -42.29108038960891,
                "length_improvement": 17.042797372138992,
                "objective_score": -9.278764642454874
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.021456432342529298,
                "num_nodes_avg": 161.2,
                "path_length_avg": 124.3211347251352,
                "success_improvement": 0.0,
                "time_improvement": 25.96110100558861,
                "length_improvement": 23.659334047608677,
                "objective_score": 12.520197111198318
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This planner implements a streamlined bidirectional RRT* algorithm with adaptive sampling bias, dynamic neighbor radius for rewiring, and iterative shortcut smoothing to efficiently find and optimize collision-free paths in both 2D and 3D spaces. It balances exploration by always extending the smaller tree, rigorously checks node and edge collisions, and incrementally connects trees to establish solution paths with enhanced smoothness and quality.",
        "planning_mechanism": "The planner alternates growing two trees from start and goal positions by sampling points biased towards these states. Each extension uses a dynamic radius based on the current tree size for local rewiring to improve path costs. It ensures new nodes and connecting edges are collision-free and within bounds. When the trees connect, the resulting path is shortcut-smoothed iteratively to enhance smoothness and shorten path length. Dead-end pruning is included periodically to remove redundant nodes and reduce computational load, boosting overall efficiency and robustness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 25.0,\n                 radius_min: float = 5.0, prune_interval: int = 250,\n                 smoothing_iterations: int = 40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def sample_free() -> Tuple[float, ...]:\n            p_bias = 0.8\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n: int) -> float:\n            if n == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(val, self.radius_min)\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree: List[Node], sample_pt: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if beneficial\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path: List[Tuple[float, ...]]) -> float:\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not can_connect(p1, p2):\n                    continue\n                path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend smaller tree for better balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed_path = shortcut_smoothing(raw_path)\n                if path_length(smoothed_path) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > 200:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -6.65759,
        "time_improvement": 9.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.006646060943603515,
                "num_nodes_avg": 86.8,
                "path_length_avg": 166.138702845762,
                "success_improvement": 0.0,
                "time_improvement": 29.528591183616104,
                "length_improvement": 16.96547315929892,
                "objective_score": 12.251671986944615
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02330734729766846,
                "num_nodes_avg": 233.5,
                "path_length_avg": 246.29505596357498,
                "success_improvement": 0.0,
                "time_improvement": -58.196658969209636,
                "length_improvement": 18.2709678987007,
                "objective_score": -13.804804111022749
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.012709426879882812,
                "num_nodes_avg": 157.3,
                "path_length_avg": 124.72154139382317,
                "success_improvement": 0.0,
                "time_improvement": 56.144061696065926,
                "length_improvement": 23.413460232130713,
                "objective_score": 21.525910555245922
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This improved planner implements a hybrid bidirectional RRT* algorithm that combines adaptive informed sampling biased towards start, goal, and dynamically identified promising inter-tree frontiers. It features balanced tree growth by always extending the smaller tree, a dynamically decaying rewiring radius to optimize local path costs efficiently, and periodic pruning of dead-end nodes to reduce complexity. After successful tree connection, it applies iterative multi-phase shortcut smoothing with adaptive step sizes to enhance path smoothness and minimize length, while strictly enforcing collision and edge checks throughout to guarantee safety and robustness. This approach improves planning efficiency, increases success rate, and yields shorter, smoother paths with reduced computational overhead.",
        "planning_mechanism": "The planner alternates growth between two balanced trees rooted at start and goal positions, sampling adaptively to bias exploration towards promising regions between the trees. Using a decaying connection radius, it rewires the trees locally to find lower-cost paths. After each successful extension, it attempts tree connection and on success extracts the combined path. To keep the tree lean, dead-end nodes are periodically pruned. Finally, multi-pass shortcut smoothing refines the path to reduce unnecessary detours while preserving collision-free guarantees.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 3.0, prune_interval: int = 200,\n                 prune_threshold: int = 100, smoothing_phases: int = 3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_phases = smoothing_phases\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        from math import sqrt, log, exp, dist\n        import random\n\n        def node_in_bounds(pos):\n            for i, val in enumerate(pos):\n                if val < 0 or val > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(pos):\n            return node_in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + ratio * (to[i] - frm[i]) for i in range(dim))\n\n        def nearest(tree, p):\n            return min(tree, key=lambda n: dist(n.position, p))\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius*radius\n            return [node for node in tree if sum((node.position[i] - pos[i])**2 for i in range(dim)) <= r2]\n\n        def radius_dyn(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * sqrt(log(n_nodes) / n_nodes)\n            decay = exp(-5 * itr / self.max_iter)\n            return max(self.radius_min, base * decay)\n\n        def adaptive_sample(itr):\n            r = random.random()\n            # Bias sampling: goal, start, then frontier zone\n            if r < self.goal_sample_rate:\n                subr = random.random()\n                if subr < 0.6 and is_free_node(goal_position):\n                    return goal_position\n                elif subr < 0.85 and is_free_node(start_position):\n                    return start_position\n                else:\n                    # Sample near frontier midpoint between two trees\n                    if len(tree_start) > 10 and len(tree_goal) > 10:\n                        t_s_sample = random.choice(tree_start).position\n                        t_g_sample = random.choice(tree_goal).position\n                        mid = tuple((t_s_sample[i] + t_g_sample[i]) * 0.5 for i in range(dim))\n                        spread = self.step_size * 3 * (1 - itr / self.max_iter)\n                        for _ in range(15):\n                            candidate = tuple(\n                                max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim))\n                            if is_free_node(candidate):\n                                return candidate\n            # Uniform fallback\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n            # If all fails, return start as fallback\n            return start_position\n\n        def try_extend(tree, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not is_free_node(new_pos):\n                return None\n            if not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dyn(len(tree), itr)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-15 < min_cost and is_free_edge(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors via new node to improve cost\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-15 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, target_node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos) or not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_dyn(len(tree), 0)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-15 < min_cost and is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-15 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, cost=final_cost)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_ends():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path)-1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        def multi_pass_shortcut(path):\n            if len(path) < 3:\n                return path\n            smoothed_path = path[:]\n            for phase in range(self.smoothing_phases):\n                max_trials = 100 + phase * 50\n                max_skip = max(2, len(smoothed_path) // (10 + phase))\n                for _ in range(max_trials):\n                    if len(smoothed_path) < 3:\n                        break\n                    i = random.randint(0, len(smoothed_path) - max_skip - 1)\n                    j = random.randint(i + 2, min(len(smoothed_path) - 1, i + max_skip))\n                    p1, p2 = smoothed_path[i], smoothed_path[j]\n                    if not is_free_edge(p1, p2):\n                        continue\n                    # Shortcut feasible, remove intermediate nodes\n                    smoothed_path = smoothed_path[:i+1] + smoothed_path[j:]\n            return smoothed_path\n\n        for itr in range(self.max_iter):\n            sample_pt = adaptive_sample(itr)\n\n            # Balance tree growth: extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                combined_path = path_start + path_goal[::-1][1:]\n                smoothed = multi_pass_shortcut(combined_path)\n                if path_length(smoothed) + 1e-15 < path_length(combined_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = combined_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_ends()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 18.36471,
        "time_improvement": -76.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.022461485862731934,
                "num_nodes_avg": 77.1,
                "path_length_avg": 157.14880453996443,
                "success_improvement": 0.0,
                "time_improvement": -138.1700327890403,
                "length_improvement": 21.458537926157746,
                "objective_score": -37.15930225148054
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.031866955757141116,
                "num_nodes_avg": 210.4,
                "path_length_avg": 237.59490079802845,
                "success_improvement": 0.0,
                "time_improvement": -116.29428128029156,
                "length_improvement": 21.157973721977953,
                "objective_score": -30.656689639691873
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.021286320686340333,
                "num_nodes_avg": 148.4,
                "path_length_avg": 124.112925804458,
                "success_improvement": 0.0,
                "time_improvement": 26.54809885915918,
                "length_improvement": 23.78718686762088,
                "objective_score": 12.721867031271929
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This planner is an advanced bidirectional RRT* variant that integrates adaptive informed sampling within an ellipse guided by heuristic cost-to-go, lazy collision checking, dynamic neighborhood radii for rewiring, periodic pruning of low-potential branches, and path smoothing by shortcutting. It balances exploration and exploitation by alternating tree growth, pruning unpromising branches, and applying efficient local optimizations to improve the path quality, smoothness, and computation time.",
        "planning_mechanism": "The planner grows two trees from start and goal by sampling points within an informed ellipse bounded by the current best path cost, steering towards samples while avoiding obstacles. Lazy collision checks reduce unnecessary computations by deferring edge validations until connection attempts. Nodes rewire locally using a dynamic radius shrinking with node count to optimize path costs. Upon connection, the path is extracted and shortcut smoothing removes jaggedness. Periodic pruning of dead leaves focuses search on promising areas, enhancing robustness and planning efficiency.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag for collision or pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def is_leaf(self):\n        return len(self.children) == 0\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 radius_constant: float = 30.0, radius_min: float = 5.0,\n                 prune_interval: int = 300, prune_threshold: int = 150,\n                 smoothing_trials: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def heuristic(a, b):\n            return math.dist(a, b)\n\n        def dynamic_radius(n):\n            if n == 0:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(r, self.radius_min)\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(len(from_p)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            return [n for n in tree if sum((n.position[d] - pos[d]) ** 2 for d in range(len(pos))) <= r2]\n\n        def informed_sample(cost_best):\n            if cost_best == float('inf'):\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n            else:\n                c_min = heuristic(start_pos, goal_pos)\n                if cost_best < c_min:\n                    cost_best = c_min * 1.0001\n                c_best = cost_best\n                center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(len(start_pos)))\n                vec = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(len(start_pos)))\n                import numpy as np\n\n                dim = len(start_pos)\n                L = np.diag([c_best / 2] + [math.sqrt(c_best ** 2 - c_min ** 2) / 2] * (dim - 1))\n                e1 = np.array(vec)\n                if dim == 2:\n                    e2 = np.array([-e1[1], e1[0]])\n                    C = np.column_stack((e1, e2))\n                else:\n                    a = np.array([1.0, 0.0, 0.0])\n                    if abs(np.dot(a, e1)) > 0.9:\n                        a = np.array([0.0, 1.0, 0.0])\n                    v2 = a - np.dot(a, e1) * e1\n                    v2 /= np.linalg.norm(v2)\n                    v3 = np.cross(e1, v2)\n                    C = np.column_stack((e1, v2, v3))\n\n                while True:\n                    sample_in_unit_ball = np.random.uniform(-1, 1, dim)\n                    if np.linalg.norm(sample_in_unit_ball) > 1.0:\n                        continue\n                    sample = np.dot(C, np.dot(L, sample_in_unit_ball)) + np.array(center)\n                    sample_t = tuple(sample)\n                    if all(0 <= sample_t[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n\n        lazy_checked_edges = set()\n\n        def try_extend(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not self._pos_in_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n\n            n_nodes = len(tree)\n            r = dynamic_radius(n_nodes)\n            near = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + heuristic(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + heuristic(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    key = (node, new_pos)\n                    if key not in lazy_checked_edges:\n                        if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                            lazy_checked_edges.add(key)\n                            min_cost = tentative_cost\n                            best_parent = node\n\n            if self._is_edge_in_obstacle(best_parent.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + heuristic(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not self._pos_in_bounds(new_pos, bounds):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + heuristic(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if heuristic(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d) and not self._is_in_obstacle(node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node, cost=new_node.cost + heuristic(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_branches():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if node.is_leaf():\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def shortcut_path(path_raw):\n            if len(path_raw) < 3:\n                return path_raw[:]\n            smooth_path = path_raw[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth_path) < 3:\n                    break\n                i = random.randint(0, len(smooth_path) - 3)\n                j = random.randint(i + 2, len(smooth_path) - 1)\n                pt_i = smooth_path[i]\n                pt_j = smooth_path[j]\n                if not self._is_edge_in_obstacle(pt_i, pt_j, obstacles, is_3d):\n                    del smooth_path[i + 1:j]\n            return smooth_path\n\n        best_path_cost = float('inf')\n        best_path = []\n\n        tree_turn = 0\n        for itr in range(self.max_iter):\n            sample_pt = informed_sample(best_path_cost)\n\n            if tree_turn == 0:\n                new_node = try_extend(tree_start, sample_pt)\n                if new_node is None:\n                    tree_turn = 1\n                    continue\n                connect_node = try_connect(tree_goal, new_node)\n                if connect_node:\n                    success = True\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    candidate_path = path_start + path_goal[::-1][1:]\n                    candidate_cost = sum(heuristic(candidate_path[i], candidate_path[i + 1]) for i in range(len(candidate_path) - 1))\n                    if candidate_cost < best_path_cost:\n                        best_path_cost = candidate_cost\n                        best_path = candidate_path\n                    break\n            else:\n                new_node = try_extend(tree_goal, sample_pt)\n                if new_node is None:\n                    tree_turn = 0\n                    continue\n                connect_node = try_connect(tree_start, new_node)\n                if connect_node:\n                    success = True\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    candidate_path = path_start + path_goal[::-1][1:]\n                    candidate_cost = sum(heuristic(candidate_path[i], candidate_path[i + 1]) for i in range(len(candidate_path) - 1))\n                    if candidate_cost < best_path_cost:\n                        best_path_cost = candidate_cost\n                        best_path = candidate_path\n                    break\n\n            tree_turn = 1 - tree_turn\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_branches()\n\n        if success and best_path:\n            extracted_path = shortcut_path(best_path)\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _pos_in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 6.65444,
        "time_improvement": -35.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.011026954650878907,
                "num_nodes_avg": 85.1,
                "path_length_avg": 174.74718142142586,
                "success_improvement": 0.0,
                "time_improvement": -16.92415037958939,
                "length_improvement": 12.663038307546405,
                "objective_score": -2.544637452367535
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.031798171997070315,
                "num_nodes_avg": 224.6,
                "path_length_avg": 237.3695073335063,
                "success_improvement": 0.0,
                "time_improvement": -115.82741729549011,
                "length_improvement": 21.232766898906675,
                "objective_score": -30.501671808865698
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.021157193183898925,
                "num_nodes_avg": 131.5,
                "path_length_avg": 122.26079564464422,
                "success_improvement": 0.0,
                "time_improvement": 26.99367424457449,
                "length_improvement": 24.924506359944548,
                "objective_score": 13.083003545361256
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This planner is an enhanced bidirectional RRT* variant integrating adaptive goal biasing, dynamic neighbor radius based on node density and iteration, heuristic-informed sampling, balanced tree growth extending the smaller tree first, efficient rewiring, lazy collision and edge checking, along with periodic pruning of dead-end nodes and iterative shortcut smoothing. These combined heuristics prioritize rapid discovery of feasible paths, continuous cost optimization, and robust collision avoidance, producing smooth, short paths with minimized planning time and improved success rates.",
        "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternately extending the smaller tree toward adaptively sampled points biased toward the goal and start positions. It dynamically adjusts neighbor radius according to iteration and node density for effective rewiring. Each new node selects the best parent among nearby nodes to minimize cost, rewires neighbors to optimize paths, and attempts connection to the opposite tree. Periodic pruning removes dead ends to control tree complexity. Once connected, the combined path is extracted and refined through iterative shortcut smoothing to ensure collision-free, smooth, and near-optimal routes, reducing overall search time and path length.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=250,\n                 prune_threshold: int=150,\n                 smoothing_iterations: int=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free(iteration):\n            # Adaptive goal bias increasing over iterations up to capped value\n            bias = min(self.goal_sample_rate + iteration / self.max_iter * 0.15, 0.35)\n            # Heuristic: bias sampling towards goal more frequently, sometimes start to balance growth\n            if random.random() < bias:\n                return goal_position if random.random() < 0.7 else start_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / distance_between\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            if in_bounds(new_pos):\n                return new_pos\n            # Clamp inside bounds if out of limits\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(len(bounds)))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            # Linear search for neighbors; could be optimized with spatial structures\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def prune_dead_nodes():\n            # Remove leaf nodes with no children except roots to control tree size\n            removed = 0\n            for node in nodes[:]:\n                if node in (start_root, goal_root):\n                    continue\n                if not node.children:\n                    if node.parent:\n                        try:\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    try:\n                        nodes.remove(node)\n                    except ValueError:\n                        pass\n                    # Remove edges containing this node\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    removed += 1\n            return removed\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            q_rand = sample_free(iteration)\n\n            # Always extend smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_a, tree_b = tree_goal, tree_start\n            else:\n                tree_a, tree_b = tree_start, tree_goal\n\n            r = neighbor_radius(iteration, len(nodes))\n\n            # Extend tree_a towards q_rand using RRT* logic\n            nearest_node = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_node.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                continue  # Extension failed\n\n            near = near_nodes(tree_a, new_pos, r)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            # Choose best parent for minimal cost\n            for node in near:\n                potential_cost = node.cost + dist(node.position, new_pos)\n                if potential_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = potential_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to optimize paths\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt to connect tree_b to new_node with incremental extension\n            nearest_b = nearest(tree_b, new_node.position)\n            last_node_b = nearest_b\n\n            connected = False\n            while True:\n                new_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(new_pos_b) or not can_connect(last_node_b.position, new_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, new_pos_b)\n                new_node_b = Node(new_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                # Rewire neighbors of new_node_b in tree_b\n                near_b = near_nodes(tree_b, new_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_b_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_b_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_b_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                # Check if trees connected successfully\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    # Connection node finalizing linkage\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Smooth path with iterative shortcutting\n                    merged_path = shortcut_smoothing(merged_path)\n\n                    extracted_path = merged_path\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            # Pruning dead ends periodically to reduce overhead\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 22.26668,
        "time_improvement": -88.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.015244626998901367,
                "num_nodes_avg": 104.5,
                "path_length_avg": 165.59287350842615,
                "success_improvement": 0.0,
                "time_improvement": -61.6461766765514,
                "length_improvement": 17.238273415862448,
                "objective_score": -15.04619831979293
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02926177978515625,
                "num_nodes_avg": 214.1,
                "path_length_avg": 236.51605640952343,
                "success_improvement": 0.0,
                "time_improvement": -98.61186854016405,
                "length_improvement": 21.515970789013974,
                "objective_score": -25.28036640424642
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.05911562442779541,
                "num_nodes_avg": 174.0,
                "path_length_avg": 124.3939271210007,
                "success_improvement": 0.0,
                "time_improvement": -103.98804778582107,
                "length_improvement": 23.61463513145955,
                "objective_score": -26.47348730945441
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This improved planner implements a bidirectional RRT* algorithm enhanced with heuristic-biased sampling, dynamic rewiring radius, balanced tree expansion, and an efficient collision checking scheme. To reduce planning time, it integrates an early connection check after node extension, a more adaptive rewiring radius, and incorporates caching of collision checks where possible. Aggressive yet safe shortcut smoothing iteratively improves path quality. Periodic pruning of dead-end nodes limits tree complexity, improving robustness and computational overhead. The planner carefully balances exploration-exploitation by alternating tree expansions based on their sizes and biased sampling towards the start and goal positions, thereby increasing success rate and path smoothness.",
        "planning_mechanism": "The planner grows two trees rooted at start and goal positions, alternately extending the smaller tree towards heuristic-biased sampled points. New nodes are steered with step size limits and collision-checked individually and along edges. After each extension, it attempts to connect the opposite tree by incremental steering. Local rewiring using a dynamically adapting radius minimizes path costs. Periodic pruning removes dead-end nodes to manage complexity. Upon connection, the path is extracted and aggressively shortcut-smoothed with collision validation to produce a high-quality, short, and smooth final path efficiently.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=28.0,\n                 radius_min: float=4.0, prune_interval: int=150, prune_threshold: int=120,\n                 smoothing_iterations: int=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            bias_prob = 0.75\n            if random.random() < self.goal_sample_rate:\n                # Bias randomly towards goal or start for balanced search\n                return goal_position if random.random() < bias_prob else start_position\n            else:\n                # Sample until free and in bounds\n                trials = 0\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                    trials += 1\n                    if trials > 100:\n                        # Fallback in rare case to goal to avoid infinite sampling\n                        return goal_position\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            res = []\n            for node in tree:\n                # Using squared dist for speed\n                dx = [node.position[d] - pos[d] for d in range(len(pos))]\n                dist_sq = sum(x*x for x in dx)\n                if dist_sq <= r_sq:\n                    res.append(node)\n            return res\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(val, self.radius_min)\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            return in_bounds(p1) and in_bounds(p2) and not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring around new_node for lower-cost paths\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos) or not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            to_remove = [node for node in nodes if node not in (start_root, goal_root) and not node.children]\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(node)\n                except ValueError:\n                    pass\n                edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                removed.append(node)\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Alternate expanding the smaller tree for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                # Connection found; extract and smooth path\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 4.78465,
        "time_improvement": -29.0,
        "length_improvement": 19.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.010508489608764649,
                "num_nodes_avg": 85.3,
                "path_length_avg": 169.57733512935985,
                "success_improvement": 0.0,
                "time_improvement": -11.426613981732185,
                "length_improvement": 15.246877794359904,
                "objective_score": -0.37860863564767433
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03050069808959961,
                "num_nodes_avg": 166.4,
                "path_length_avg": 240.33070052357533,
                "success_improvement": 0.0,
                "time_improvement": -107.0209223031525,
                "length_improvement": 20.250142816817537,
                "objective_score": -28.05624812758224
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.019695973396301268,
                "num_nodes_avg": 140.1,
                "path_length_avg": 126.45206307167311,
                "success_improvement": 0.0,
                "time_improvement": 32.035850060921085,
                "length_improvement": 22.350815673551054,
                "objective_score": 14.080918152986538
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This implementation enhances the bidirectional RRT* by introducing adaptive goal bias with a faster ramp-up for better early convergence, employs a k-d tree for efficient nearest neighbor and radius searches reducing computational complexity, introduces lazy collision checks caching edge validity to avoid redundant computations, and implements more aggressive pruning of unproductive nodes. It prioritizes incremental extension of the smaller tree towards adaptively sampled points, dynamic neighbor radius based on iteration and node count, heuristic sampling weighted by distance to goal/start, and iterative shortcut smoothing to produce shorter, smoother, and near-optimal collision-free paths rapidly and robustly.",
        "planning_mechanism": "The planner grows two trees from start and goal, always extending the smaller tree towards adaptively sampled points biased towards start/goal or randomly sampled. It uses k-d trees for fast neighborhood queries, dynamically adjusts neighbor radius based on iteration and tree size for efficient rewiring. Each new node picks the best parent minimizing cost, rewires neighbors, and attempts incremental connections to the opposing tree with cached lazy collision checks. Periodic pruning removes dead-end nodes, and final solution paths undergo iterative shortcut smoothing for path quality improvement.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.25,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=150,\n                 prune_threshold: int=200,\n                 smoothing_iterations: int=120,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        # ---- Helper functions ----\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # KD-Tree for fast nearest and radius search\n        # Simple 2D/3D KD-tree for nodes positions with rebuilding every prune_interval\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = len(points_nodes[0][0]) if points_nodes else 2\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, point):\n                best = None\n                best_dist = float('inf')\n                stack = [(0, len(self.points))]\n                for i in range(len(self.points)):\n                    d = dist(point, self.points[i])\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, point, radius):\n                result = []\n                r2 = radius * radius\n                for i, p in enumerate(self.points):\n                    # squred dist for perf\n                    sqd = sum((p[d] - point[d])**2 for d in range(len(point)))\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def sample_free(iteration):\n            # Adaptive goal bias ramping faster early, capped at 0.4\n            bias = min(self.goal_sample_rate + (iteration/self.max_iter)*0.2, 0.4)\n            r = random.random()\n            if r < bias:\n                # 75% towards the main goal, 25% towards start (balanced growth)\n                if random.random() < 0.75:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # fallback if repeated hits inside obstacles, return random without checking\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / distance_between\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            if in_bounds(new_pos):\n                return new_pos\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(len(bounds)))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        # Cache collision checks for edges to avoid redundant computations\n        edge_collision_cache = {}\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def prune_dead_nodes():\n            # Remove leaf nodes with no children except roots\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (start_root, goal_root):\n                    continue\n                if not node.children:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(node)\n                except ValueError:\n                    pass\n                # Clean edges containing this node\n                while True:\n                    try:\n                        edges.remove(next(e for e in edges if e[0] == node or e[1] == node))\n                    except StopIteration:\n                        break\n                removed += 1\n            return removed\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Initialize roots and trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        # KD-trees to speed up near/nearest queries, rebuilt periodically\n        def rebuild_kdtree():\n            return KDTree([(node.position, node) for node in nodes])\n\n        kd_tree = rebuild_kdtree()\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for iteration in range(self.max_iter):\n            q_rand = sample_free(iteration)\n\n            # Always extend smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_a, tree_b = tree_goal, tree_start\n            else:\n                tree_a, tree_b = tree_start, tree_goal\n\n            r = neighbor_radius(iteration, len(nodes))\n\n            # Extend tree_a towards q_rand using RRT* logic\n            # Use kd_tree for nearest neighbor search within that tree subset\n            # Extract subset nodes of tree_a for nearest and neighbors\n            sub_nodes = [(node.position, node) for node in tree_a]\n            sub_kdtree = KDTree(sub_nodes)\n            nearest_node = sub_kdtree.nearest(q_rand)\n            new_pos = steer(nearest_node.position, q_rand)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                # Failed extension, skip iteration\n                continue\n\n            near = sub_kdtree.radius_search(new_pos, r)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            # Select best parent with minimal cost & valid connection\n            for node in near:\n                potential_cost = node.cost + dist(node.position, new_pos)\n                if potential_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = potential_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to optimize cost if possible\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try to connect tree_b to new_node incrementally\n            sub_nodes_b = [(node.position, node) for node in tree_b]\n            sub_kdtree_b = KDTree(sub_nodes_b)\n            nearest_b = sub_kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n\n            connected = False\n            max_extend_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_extend_steps):\n                new_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(new_pos_b) or not can_connect(last_node_b.position, new_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, new_pos_b)\n                new_node_b = Node(new_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                # Rewire neighbors of new_node_b in tree_b\n                near_b = sub_kdtree_b.radius_search(new_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_b_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_b_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_b_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                # Check if connection to new_node is possible\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Smooth path with iterative shortcutting\n                    merged_path = shortcut_smoothing(merged_path)\n\n                    extracted_path = merged_path\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic pruning of dead-end nodes for efficiency\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n                # Rebuild kd_tree after pruning for up-to-date efficient queries\n                kd_tree = rebuild_kdtree()\n                # Clear edge cache to avoid memory bloat, but keep minimal\n                edge_collision_cache.clear()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 35.05465,
        "time_improvement": -132.0,
        "length_improvement": 23.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.015506649017333984,
                "num_nodes_avg": 99.3,
                "path_length_avg": 156.99622385581873,
                "success_improvement": 0.0,
                "time_improvement": -53.701235478168805,
                "length_improvement": 21.53479628556501,
                "objective_score": -11.803411386337636
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.062104415893554685,
                "num_nodes_avg": 252.7,
                "path_length_avg": 232.9376796934483,
                "success_improvement": 0.0,
                "time_improvement": -334.17389637556147,
                "length_improvement": 22.703397245279902,
                "objective_score": -95.71148946361245
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.030992841720581053,
                "num_nodes_avg": 170.8,
                "path_length_avg": 124.11726748792546,
                "success_improvement": 0.0,
                "time_improvement": -8.019886639837587,
                "length_improvement": 23.784520812424446,
                "objective_score": 2.350938170533613
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid algorithm combines the asymptotic optimality and rewiring principles from RRT* and the fast convergence benefits of a bidirectional approach inspired by RRT-Connect. It grows two trees simultaneously from start and goal with goal biasing, samples from free space, connects the trees when close enough, and performs rewiring in both trees to improve path quality incrementally. Additionally, it performs path shortcutting to smooth the final path for better quality.",
        "planning_mechanism": "The planner alternates tree expansions by sampling points with goal biasing, steering nearest nodes toward sampled points, rewires neighbors for cost improvements, tries connecting the two trees to form a full path, and upon success, extracts and smooths the path. Collision checks are applied for nodes and edges throughout, ensuring valid paths that respect obstacles and boundaries.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D position\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Accumulated path cost\n        self.children = []\n        self.valid = True               # For collision validity\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, neighbor_radius: float=12.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        import random\n        import math\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def _distance(a, b):\n            return math.dist(a, b)\n\n        def _steer(from_pos, to_pos, step_size):\n            dist = _distance(from_pos, to_pos)\n            if dist <= step_size:\n                return to_pos\n            ratio = step_size / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def _near(tree, point, radius):\n            return [node for node in tree if _distance(node.position, point) <= radius]\n\n        def _extract_path_meet(node_from_start, node_from_goal):\n            path_start = []\n            current = node_from_start\n            while current:\n                path_start.append(current.position)\n                current = current.parent\n            path_goal = []\n            cur = node_from_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def _path_shortcut(path):\n            # Attempt to smooth path by shortcutting between non-adjacent nodes if direct connection is collision-free\n            if len(path) < 3:\n                return path\n            smooth_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smooth_path.append(path[j])\n                i = j\n            return smooth_path\n\n        def _check_in_bounds(pos):\n            for i, val in enumerate(pos):\n                if val < 0 or val > bounds[i]:\n                    return False\n            return True\n\n        success = False\n        final_path = []\n\n        for iter in range(self.max_iter):\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Alternate between start_tree and goal_tree expansions\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Find nearest node in tree_a to sample\n                nearest = min(tree_a, key=lambda n: _distance(n.position, sample))\n                new_pos = _steer(nearest.position, sample, self.step_size)\n\n                # Check bounds\n                if not _check_in_bounds(new_pos):\n                    continue\n                # Collision checks\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Create new node, find near neighbors for rewiring\n                new_node = Node(new_pos)\n                near_nodes = _near(tree_a, new_pos, self.neighbor_radius)\n\n                min_cost = nearest.cost + _distance(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    temp_cost = near.cost + _distance(near.position, new_pos)\n                    if temp_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        min_parent = near\n\n                new_node.update_parent(min_parent, min_cost)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors in tree_a\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + _distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                        near.update_parent(new_node, new_cost)\n                        edges.append((new_node, near))\n\n                # Try connect tree_b to new_node in tree_a to form path\n                connect_node = min(tree_b, key=lambda n: _distance(n.position, new_node.position))\n                dist_connect = _distance(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size:\n                    if (not self._is_in_obstacle(connect_node.position, obstacles, is_3d) and\n                        not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d)):\n                        # Path connected, extract full path\n                        success = True\n                        final_path = _extract_path_meet(new_node, connect_node)\n                        # Smooth path with shortcutting\n                        final_path = _path_shortcut(final_path)\n                        break\n            if success:\n                break\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 11.21486,
        "time_improvement": -51.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.013281702995300293,
                "num_nodes_avg": 128.5,
                "path_length_avg": 174.34981020638165,
                "success_improvement": 0.0,
                "time_improvement": -31.647666581591665,
                "length_improvement": 12.861640621493342,
                "objective_score": -6.921971850178831
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02387359142303467,
                "num_nodes_avg": 287.3,
                "path_length_avg": 230.3975784226972,
                "success_improvement": 0.0,
                "time_improvement": -66.90101757631824,
                "length_improvement": 23.546288782365693,
                "objective_score": -15.361047516422332
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.044390535354614256,
                "num_nodes_avg": 367.1,
                "path_length_avg": 121.70644892216498,
                "success_improvement": 0.0,
                "time_improvement": -54.7150997032626,
                "length_improvement": 25.26490864195521,
                "objective_score": -11.361548182587736
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This algorithm is an enhanced bidirectional RRT* variant that integrates adaptive step sizing and dynamic radius rewiring for improved efficiency and path quality. It grows two trees from start and goal, samples points biased towards the path for faster convergence, and employs smoothing on the resultant path to increase smoothness and robustness. It enforces strict collision and edge checks and limits node placement within map bounds.",
        "planning_mechanism": "The planner alternately grows two trees by sampling points biased via a goal-biased probability. Each extension employs adaptive step sizing based on distance to the sample, then rewires nodes in a dynamically calculated radius to optimize cost. Connection attempts between the two trees are made after each extension. The final combined path is smoothed using shortcutting to reduce unnecessary waypoints and produce a shorter, smoother trajectory.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated cost from root\n        self.children = []\n        self.valid = True               # Node validity flag\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_and_propagate(self, new_cost):\n        self.cost = new_cost\n        for child in self.children:\n            child.update_cost_and_propagate(new_cost + self._distance(self.position, child.position))\n\n    @staticmethod\n    def _distance(a, b):\n        import math\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float=7.0, goal_sample_rate: float = 0.1, radius_constant: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal point\n        self.radius_constant = radius_constant    # Used for dynamic radius calculation\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        dim = len(bounds)\n        unit_ball_volume = {2: math.pi, 3: 4 / 3 * math.pi}[dim]\n\n        for iter in range(self.max_iter):\n            # Goal-biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        break\n\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                # Find nearest in tree_a\n                nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n                direction_distance = math.dist(nearest.position, sample)\n                if direction_distance == 0.0:\n                    continue\n\n                # Adaptive step size: don't overshoot closer samples\n                step = min(self.step_size, direction_distance)\n                new_pos = tuple(\n                    nearest.position[d] + (sample[d] - nearest.position[d]) * (step / direction_distance) for d in range(dim)\n                )\n\n                if not in_bounds(new_pos) or self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                # Compute dynamic radius (RRT* style)\n                radius = min(\n                    self.radius_constant * ((math.log(len(tree_a) + 1) / (len(tree_a) + 1)) ** (1 / dim)),\n                    self.step_size * 5\n                )\n\n                near_nodes = [node for node in tree_a if math.dist(node.position, new_pos) <= radius]\n\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                best_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + math.dist(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = near\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                new_node.parent = best_parent\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            # Remove old edge\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                            try:\n                                near.parent.children.remove(near)\n                            except ValueError:\n                                pass\n\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        # Propagate cost update downwards\n                        near.update_cost_and_propagate(new_cost)\n\n                # Attempt connection to the other tree\n                nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n                dist_connect = math.dist(nearest_other.position, new_node.position)\n\n                if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    # Connect the trees\n                    success_state = True\n                    # Form path from start_root to new_node\n                    if tree_a is tree_start:\n                        path_start = new_node.path_from_root()\n                        path_goal = nearest_other.path_from_root()\n                        path_goal.reverse()\n                        full_path = path_start + path_goal\n                    else:\n                        path_start = nearest_other.path_from_root()\n                        path_goal = new_node.path_from_root()\n                        path_goal.reverse()\n                        full_path = path_start + path_goal\n\n                    # Smooth the path via shortcutting method\n                    smoothed_path = self._smooth_path(full_path, obstacles, is_3d, max_iterations=150, map_bounds=bounds)\n\n                    extracted_path = smoothed_path\n                    return PlannerResult(True, extracted_path, nodes, edges)\n\n        return PlannerResult(False, extracted_path, nodes, edges)\n\n\n    def _smooth_path(self, path, obstacles, is_3d, max_iterations=100, map_bounds=None):\n        import random\n        import math\n\n        def valid_edge(p1, p2):\n            if map_bounds:\n                for d in range(len(p1)):\n                    if p1[d] < 0 or p1[d] > map_bounds[d]:\n                        return False\n                    if p2[d] < 0 or p2[d] > map_bounds[d]:\n                        return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        if len(path) < 3:\n            return path[:]\n\n        path = path[:]\n        for _ in range(max_iterations):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n\n            if valid_edge(path[i], path[j]):\n                # Remove intermediate nodes and connect directly\n                path = path[:i+1] + path[j:]\n\n        return path\n\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 25.54824,
        "time_improvement": -98.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.02762300968170166,
                "num_nodes_avg": 99.9,
                "path_length_avg": 167.97260652957092,
                "success_improvement": 0.0,
                "time_improvement": -173.7980791953795,
                "length_improvement": 16.048905724690606,
                "objective_score": -48.92964261367573
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.023543739318847658,
                "num_nodes_avg": 192.1,
                "path_length_avg": 243.82630931447866,
                "success_improvement": 0.0,
                "time_improvement": -64.59501129251362,
                "length_improvement": 19.090181558287142,
                "objective_score": -15.560467076096655
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.044884872436523435,
                "num_nodes_avg": 404.1,
                "path_length_avg": 123.9554182240814,
                "success_improvement": 0.0,
                "time_improvement": -56.43802127435036,
                "length_improvement": 23.883906010388394,
                "objective_score": -12.15462518022743
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This algorithm implements a streamlined bidirectional RRT* planner with balanced tree growth, adaptive sampling biased towards start and goal, collision-free node and edge verification, and incremental rewiring within a dynamic neighborhood radius. It prioritizes computational efficiency and robust pathfinding through straightforward tree extensions, rewiring for cost improvements, and final path smoothing.",
        "planning_mechanism": "The planner grows two trees from start and goal, alternately extending towards sampled free points. For each new node, it rewires neighbors to reduce path cost if collision-free. It attempts to connect the opposite tree incrementally to the new node. Upon successful connection, the planner reconstructs and smooths the path before returning.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 smoothing_iterations: int = 100,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / distance_between\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(len(bounds)))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - position[d])**2 for d in range(len(position))) <= r2]\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        tree_a, tree_b = [start_root], [goal_root]\n\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            sample = sample_free()\n            r = neighbor_radius(iteration, len(nodes))\n\n            # Extend tree_a towards sample\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            neighbors = near_nodes(tree_a, new_pos, r)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                cost_out = node.cost + dist(node.position, new_pos)\n                if cost_out + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_out\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper and collision-free\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try to connect tree_b to new_node incrementally\n            connect_node = nearest(tree_b, new_node.position)\n            curr_pos = connect_node.position\n            connected = False\n\n            while True:\n                next_pos = steer(curr_pos, new_node.position)\n                if not can_add_node(next_pos) or not can_connect(curr_pos, next_pos):\n                    break\n\n                neighbors_b = near_nodes(tree_b, next_pos, r)\n                min_cost_b = connect_node.cost + dist(curr_pos, next_pos)\n                best_parent_b = connect_node\n                for node_b in neighbors_b:\n                    if not can_connect(node_b.position, next_pos):\n                        continue\n                    cost_b = node_b.cost + dist(node_b.position, next_pos)\n                    if cost_b < min_cost_b:\n                        min_cost_b = cost_b\n                        best_parent_b = node_b\n\n                new_node_b = Node(next_pos, parent=best_parent_b, cost=min_cost_b)\n                best_parent_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((best_parent_b, new_node_b))\n\n                # Rewire neighbors of new_node_b\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is best_parent_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    path_start = new_node.path_from_root()\n                    path_goal = connection_node.path_from_root()\n                    extracted_path = path_start + path_goal[::-1][1:]\n                    extracted_path = shortcut_smoothing(extracted_path)\n                    connected = True\n                    break\n\n                curr_pos = new_node_b.position\n                connect_node = new_node_b\n\n            if connected:\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 5.05134,
        "time_improvement": -32.0,
        "length_improvement": 23.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.011016368865966797,
                "num_nodes_avg": 70.8,
                "path_length_avg": 155.16720304344847,
                "success_improvement": 0.0,
                "time_improvement": -9.19377250942915,
                "length_improvement": 22.44892330795998,
                "objective_score": 1.7316529087632513
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.025777411460876466,
                "num_nodes_avg": 229.0,
                "path_length_avg": 236.87693357543202,
                "success_improvement": 0.0,
                "time_improvement": -80.21068246785175,
                "length_improvement": 21.396219536347616,
                "objective_score": -19.783960833086002
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.03083500862121582,
                "num_nodes_avg": 252.3,
                "path_length_avg": 121.00421879728697,
                "success_improvement": 0.0,
                "time_improvement": -7.469788212105313,
                "length_improvement": 25.696120241684756,
                "objective_score": 2.8982875847053577
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e1",
        "algorithm_description": "This algorithm implements an anytime informed bidirectional RRT* variant with fast heuristic-informed sampling focusing search within an evolving ellipsoidal domain defined by currently best solution. It adaptively refines path quality by rewiring, employs KD-tree for nearest neighbor search, caches collision checks, prunes suboptimal branches, and applies iterative path smoothing. The bidirectional approach grows trees from start and goal asynchronously, prioritizing the smaller for extension, and connects them efficiently through incremental extension steps. Focused sampling and aggressive pruning reduce search space and improve convergence, producing shorter, smoother paths rapidly and robustly.",
        "planning_mechanism": "The planner initializes two trees from start and goal positions and iteratively samples points biased inside an informed ellipsoid that shrinks as better paths are found. The smaller tree is extended towards sampled points using RRT* style rewiring and cost optimization, with nearest neighbor queries accelerated by KD-tree. Connection attempts between trees are done incrementally with collision checking and caching. Periodic pruning removes unnecessary nodes, and the final path undergoes shortcut smoothing to improve quality and smoothness. This strategy improves planning efficiency, success rate, and path optimality.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent: \n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def is_descendant_of(self, node):\n        \"\"\"Check if this node is descendant of given node.\"\"\"\n        cur = self.parent\n        while cur:\n            if cur == node:\n                return True\n            cur = cur.parent\n        return False\nclass Planner:\n    def __init__(self, max_iter: int =5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval:int=200, prune_threshold:int=300, smoothing_iterations:int=100,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clip to bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes,1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration/self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c+1)/c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1,p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree helper class for fast queries\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p,n in points_nodes]\n                self.nodes = [n for p,n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i,p in enumerate(self.points):\n                    d = dist(pt,p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i,p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d]-pt[d]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Sampling inside ellipsoid informed by current best path cost\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf'):\n                # No solution yet - uniform sample\n                for _ in range(10):\n                    p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Ellipsoidal sampling between start and goal (informed RRT*)\n            center = tuple((start[d] + goal[d])/2 for d in range(dim))\n            a1 = tuple((goal[d]-start[d])/c_min for d in range(dim))  # unit vector from start to goal\n\n            # Rotation matrix from unit vector to x-axis using Householder transform approximation for dim=2 or 3\n            import numpy as np\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d==0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u,u)\n            else:\n                rot = id_mat  # Already aligned\n\n            # Ellipsoid radii\n            r1 = c_best / 2.0\n            r_others = math.sqrt(r1**2 - (c_min/2)**2)\n            radii = [r1] + [r_others]*(dim-1)\n\n            # Sample a random point in unit ball\n            while True:\n                x = np.random.uniform(-1,1,dim)\n                if np.linalg.norm(x) <= 1:\n                    break\n            x = np.array(x)\n            # Scale with radii\n            x = x * radii\n            # Rotate to original coordinate system\n            p = rot @ x\n            # Translate back to center\n            p = p + np.array(center)\n\n            p_tuple = tuple(float(coord) for coord in p)\n            if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                return p_tuple\n            else:\n                # fallback uniform sampling if outside or collision\n                for _ in range(10):\n                    fallback_p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(fallback_p):\n                        return fallback_p\n                return fallback_p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1,p2):\n            if (p1,p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1,p2)]\n            if (p2,p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2,p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1,p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1,p2)\n            edge_collision_cache[(p1,p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        # Initialize trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal  = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        # Best path cost and path\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        def rebuild_kdtree():\n            return KDTree([(node.position, node) for node in nodes])\n\n        kd_tree = rebuild_kdtree()\n\n        def prune_useless_nodes():\n            # Prune nodes that cannot improve best path to reduce complexity\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                # Don't prune roots\n                if node in (root_start, root_goal):\n                    continue\n                # Prune if cost + heuristic > best path cost\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= c_best:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                # Remove from trees if present\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed +=1\n            return removed\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1,p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n            # Alternate, always extend smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Build KD-tree for tree_a subset\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest.position, new_pos):\n                continue\n\n            # Neighbor search radius\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for node in near:\n                c_p = node.cost + dist(node.position, new_pos)\n                if c_p + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = c_p\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cost improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try to connect tree_b to new_node incrementally\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_extend_steps = int(dist(last_node_b.position, new_node.position)/self.step_size) + 1\n\n            for _ in range(max_extend_steps):\n                new_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(new_pos_b) or not can_connect(last_node_b.position, new_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, new_pos_b)\n                new_node_b = Node(new_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(new_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_b_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_b_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_b_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Update best path cost and path\n                    c_best = final_cost\n                    best_path = merged_path\n\n                    # Shortcut smoothing\n                    best_path = shortcut_path(best_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_useless_nodes()\n                kd_tree = rebuild_kdtree()\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            # fallback if improved path not assigned\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -1.99103,
        "time_improvement": -7.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.013820695877075195,
                "num_nodes_avg": 90.8,
                "path_length_avg": 165.68594819008476,
                "success_improvement": 0.0,
                "time_improvement": -36.99014075187401,
                "length_improvement": 17.191755584556482,
                "objective_score": -7.658691108650905
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.018435454368591307,
                "num_nodes_avg": 189.5,
                "path_length_avg": 235.2552560057235,
                "success_improvement": 0.0,
                "time_improvement": -28.882832879132593,
                "length_improvement": 21.934347017770815,
                "objective_score": -4.2779804601856135
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.016191697120666503,
                "num_nodes_avg": 153.5,
                "path_length_avg": 123.44301109039233,
                "success_improvement": 0.0,
                "time_improvement": 43.56679831912523,
                "length_improvement": 24.19855485839855,
                "objective_score": 17.90975046741728
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This algorithm implements an efficient bidirectional RRT* planner combining balanced tree growth, adaptive neighbor radius for rewiring, incremental connection attempts, and path shortcut smoothing. It ensures collision-free node and edge validation, bounds adherence, and aims to improve path quality, success rate, and planning speed by dynamically rewiring nodes towards lower-cost paths.",
        "planning_mechanism": "The planner alternately extends two trees from the start and goal towards randomly sampled free points, chooses optimal parents in a dynamic neighborhood for each new node, rewires neighboring nodes if a cheaper path is found, and attempts incremental connections between trees. Upon successful connection, it reconstructs and smooths the path before returning.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position      # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent          # Node or None\n        self.cost = cost              # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True             # For potential future use\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 smoothing_iterations: int = 100, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback sample even if in obstacle\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / distance_between\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(len(bounds)))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes,1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + \\\n                      (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - position[d])**2 for d in range(len(position))) <= r2]\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n        tree_a, tree_b = [start_root], [goal_root]\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for iteration in range(self.max_iter):\n            sample = sample_free()\n            radius = neighbor_radius(iteration, len(nodes))\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            neighbors = near_nodes(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                cost_thru_node = node.cost + dist(node.position, new_pos)\n                if cost_thru_node + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_thru_node\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper path found via new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt incremental connection from tree_b towards new_node\n            connect_node = nearest(tree_b, new_node.position)\n            curr_pos = connect_node.position\n            connected = False\n\n            while True:\n                next_pos = steer(curr_pos, new_node.position)\n                if not can_add_node(next_pos) or not can_connect(curr_pos, next_pos):\n                    break\n\n                neighbors_b = near_nodes(tree_b, next_pos, radius)\n\n                min_cost_b = connect_node.cost + dist(curr_pos, next_pos)\n                best_parent_b = connect_node\n                for node_b in neighbors_b:\n                    cost_b = node_b.cost + dist(node_b.position, next_pos)\n                    if cost_b + 1e-12 < min_cost_b and can_connect(node_b.position, next_pos):\n                        min_cost_b = cost_b\n                        best_parent_b = node_b\n\n                new_node_b = Node(next_pos, parent=best_parent_b, cost=min_cost_b)\n                best_parent_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((best_parent_b, new_node_b))\n\n                # Rewire neighbors of new_node_b\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is best_parent_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    path_start = new_node.path_from_root()\n                    path_goal = connection_node.path_from_root()\n                    extracted_path = path_start + path_goal[::-1][1:]\n                    extracted_path = shortcut_smoothing(extracted_path)\n                    connected = True\n                    break\n\n                curr_pos = new_node_b.position\n                connect_node = new_node_b\n\n            if connected:\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 11.36172,
        "time_improvement": -53.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009463739395141602,
                "num_nodes_avg": 65.6,
                "path_length_avg": 156.78522789428558,
                "success_improvement": 0.0,
                "time_improvement": 6.195823762394946,
                "length_improvement": 21.640250039152267,
                "objective_score": 6.186797136548938
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.023795652389526366,
                "num_nodes_avg": 218.4,
                "path_length_avg": 241.46927916424852,
                "success_improvement": 0.0,
                "time_improvement": -66.35614337741997,
                "length_improvement": 19.872323904012422,
                "objective_score": -15.932378232423506
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.05674192905426025,
                "num_nodes_avg": 304.6,
                "path_length_avg": 122.22337727974164,
                "success_improvement": 0.0,
                "time_improvement": -97.76362553088236,
                "length_improvement": 24.94748349011496,
                "objective_score": -24.339590961241715
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm with adaptive sampling towards the goal and start to improve exploration efficiency. It employs a KD-tree to accelerate nearest and near neighbor searches, dynamically adjusts the neighborhood radius based on the growing tree sizes, and performs incremental rewiring to minimize path cost and improve smoothness. Early connection attempts between the two trees enable faster convergence. Post path extraction, an optimization-based shortcutting smooths the path while ensuring collision-free transitions. Overall, this approach balances fast search, path quality, robustness, and planning efficiency.",
        "planning_mechanism": "The planner grows two trees bidirectionally from start and goal, alternately extending them by sampling points biased toward both ends. Using KD-trees, it quickly finds nearest and nearby nodes for efficient rewiring to locally optimize path costs. The rewiring radius shrinks adaptively with the tree size, focusing on refining the solution as exploring proceeds. When trees connect, the shortest cost path is extracted and post-processed by shortcutting to smooth the trajectory. Collision checks prevent invalid nodes or edges, and out-of-bound checks ensure safety.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 radius_constant: float=40.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        class KDTree:\n            def __init__(self):\n                self.points = []\n                self.nodes = []\n\n            def insert(self, node):\n                self.points.append(node.position)\n                self.nodes.append(node)\n\n            def nearest(self, point):\n                best_node = None\n                best_dist = float('inf')\n                for node in self.nodes:\n                    dist = math.dist(node.position, point)\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_node = node\n                return best_node\n\n            def near(self, point, radius):\n                r_sq = radius * radius\n                neighbors = []\n                for node in self.nodes:\n                    dx = 0\n                    for d in range(dim):\n                        diff = node.position[d] - point[d]\n                        dx += diff * diff\n                        if dx > r_sq:\n                            break\n                    if dx <= r_sq:\n                        neighbors.append(node)\n                return neighbors\n\n        def sample_free():\n            # Adaptive goal/start biasing to balance exploration\n            r = random.random()\n            if r < self.goal_sample_rate:\n                return goal_position\n            elif r < self.goal_sample_rate * 2:\n                return start_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def out_of_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return True\n            return False\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_constant\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        # Initialize trees and kd-trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        kd_start = KDTree()\n        kd_goal = KDTree()\n        kd_start.insert(start_root)\n        kd_goal.insert(goal_root)\n\n        tree_flag = True  # True: extend start tree; False: extend goal tree\n\n        def try_extend(tree, kd_tree, point):\n            if not tree:\n                return None\n            nearest_node = kd_tree.nearest(point)\n            if nearest_node is None:\n                return None\n            new_pos = steer(nearest_node.position, point)\n            if out_of_bounds(new_pos): \n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = kd_tree.near(new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + math.dist(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            kd_tree.insert(new_node)\n\n            # Rewire neighbors for incremental optimization\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, kd_tree, node):\n            if not tree:\n                return None\n            nearest_node = kd_tree.nearest(node.position)\n            if nearest_node is None:\n                return None\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if out_of_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + math.dist(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n                kd_tree.insert(new_node)\n\n                if math.dist(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + math.dist(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        kd_tree.insert(final_node)\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def combine_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            path_goal.reverse()\n            return path_start + path_goal[1:]\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Alternate tree extension with balancing sizes for faster convergence\n            if len(tree_start) > len(tree_goal):\n                tree_extend, kd_extend = tree_goal, kd_goal\n                tree_connect, kd_connect = tree_start, kd_start\n                start_tree_flag = False\n            else:\n                tree_extend, kd_extend = tree_start, kd_start\n                tree_connect, kd_connect = tree_goal, kd_goal\n                start_tree_flag = True\n\n            new_node = try_extend(tree_extend, kd_extend, rand_point)\n            if new_node is None:\n                continue\n\n            connect_node = try_connect(tree_connect, kd_connect, new_node)\n            if connect_node is not None:\n                success_state = True\n                if start_tree_flag:\n                    extracted_path = combine_path(new_node, connect_node)\n                else:\n                    extracted_path = combine_path(connect_node, new_node)\n\n                # Post-process smoothing\n                extracted_path = smooth_path(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 12.53989,
        "time_improvement": -56.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.012874317169189454,
                "num_nodes_avg": 112.4,
                "path_length_avg": 158.54806002330182,
                "success_improvement": 0.0,
                "time_improvement": -27.6096758642203,
                "length_improvement": 20.759203484525322,
                "objective_score": -4.131062062361026
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03498883247375488,
                "num_nodes_avg": 396.1,
                "path_length_avg": 235.32768417519816,
                "success_improvement": 0.0,
                "time_improvement": -144.6080122675867,
                "length_improvement": 21.910312900785097,
                "objective_score": -39.00034110011899
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.027908682823181152,
                "num_nodes_avg": 266.9,
                "path_length_avg": 124.63820597220362,
                "success_improvement": 0.0,
                "time_improvement": 2.7293856430958123,
                "length_improvement": 23.464633201215378,
                "objective_score": 5.511742333171819
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid algorithm combines the efficient incremental bidirectional RRT* tree growth from Algorithm #1 with the heuristic-informed sampling, KD-tree accelerated nearest neighbor searches, collision caching, and pruning strategies from Algorithm #2. It interleaves adaptive ellipsoidal sampling focused on promising regions with balanced tree expansions. Periodic pruning of suboptimal nodes reduces search complexity, while incremental rewiring improves path cost. Final path smoothing ensures a high-quality, smooth path. This approach enhances planning efficiency, robustness, success rates, and path optimality, producing shorter and smoother paths faster in both 2D and 3D spaces.",
        "planning_mechanism": "The planner grows two trees from start and goal, alternating extension of the smaller tree towards informed ellipsoid-biased samples. KD-tree structures accelerate neighbor queries for rewiring and nearest node search. Edge collision caching speeds collision checks. Nodes and edges are only added if both node placement and connecting edges are collision-free and within bounds. The best path cost updates the ellipsoid sampling region dynamically, progressively shrinking the search space. Periodic pruning removes nodes that cannot beat the current best path, lowering computational overhead. After successful connection, the final path is shortcut-smoothed for better smoothness and path length.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checks etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_iterations: int = 100,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Helpers\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c+1)/c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree helper for nearest and radius search\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Ellipsoidal informed sampling as in Algorithm #2\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # No solution yet or marginal improvement: uniform sample\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Calculate ellipsoid parameters\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))  # unit vector from start to goal\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1**2 - (c_min / 2)**2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    x = x * radii\n                    p = rot @ x + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n            # fallback uniform sampling\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback last sample\n\n        # Caches for collision checks\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        # Shortcut smoothing (similar to both algorithms)\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Prune nodes that cannot improve the best path\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialize\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cost improvements\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try connect other tree incrementally to new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Update best cost and path\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to reduce complexity\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 2.55304,
        "time_improvement": -22.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.00791943073272705,
                "num_nodes_avg": 61.8,
                "path_length_avg": 158.4027803367249,
                "success_improvement": 0.0,
                "time_improvement": 21.50294454054769,
                "length_improvement": 20.83181287552122,
                "objective_score": 10.617245937268551
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.027858495712280273,
                "num_nodes_avg": 228.4,
                "path_length_avg": 240.8903836814004,
                "success_improvement": 0.0,
                "time_improvement": -94.7596069705228,
                "length_improvement": 20.06442101012724,
                "objective_score": -24.414997889131392
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.026755642890930176,
                "num_nodes_avg": 178.9,
                "path_length_avg": 129.35039218762472,
                "success_improvement": 0.0,
                "time_improvement": 6.748095637353845,
                "length_improvement": 20.57106699807329,
                "objective_score": 6.138642090820811
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid planner combines the bidirectional adaptive radius rewiring and KD-tree acceleration from the first algorithm with the adaptive step sizing, dynamic neighbor searches, and randomized shortcut smoothing of the second algorithm. It alternates growth between two trees seeded at start and goal, uses KD-trees for efficient nearest and neighbor queries, employs adaptive neighborhood radii shrinking with more rigorous collision and boundary checks, and increments rewiring to iteratively improve path quality. The planner applies a multi-pass randomized shortcut smoother on the final connected path to enhance smoothness and reduce length, ensuring robust collision avoidance and bounded exploration. Overall, this fusion targets improved planning efficiency, path optimality, and success robustness in complex environments.",
        "planning_mechanism": "The planner grows two bidirectional trees from start and goal positions, alternating their extension with adaptive step sizes and sampling biased towards both ends to balance exploration and exploitation. KD-trees speed up nearest and near neighbor searches, enabling efficient incremental rewiring within dynamically calculated radii to optimize paths continuously. Once the trees connect, the shortest-cost path is extracted, and a stochastic shortcut smoothing refines the trajectory while cautiously avoiding collisions and out-of-bound violations, resulting in faster convergence, better path lengths, and smoother, more feasible solutions.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_and_propagate(self, new_cost):\n        self.cost = new_cost\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_cost_and_propagate(new_cost + dist)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 radius_constant: float=30.0, radius_min: float=5.0, smoothing_iterations: int=200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        class KDTree:\n            # Simple KD-tree for nearest and near neighbor search acceleration\n            def __init__(self):\n                self.nodes = []\n                self.points = []\n\n            def insert(self, node):\n                self.nodes.append(node)\n                self.points.append(node.position)\n\n            def nearest(self, point):\n                best_node = None\n                best_dist = float('inf')\n                for node in self.nodes:\n                    dist = math.dist(node.position, point)\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_node = node\n                return best_node\n\n            def near(self, point, radius):\n                r_sq = radius * radius\n                neighbors = []\n                for node in self.nodes:\n                    dist_sq = 0\n                    for d in range(dim):\n                        diff = node.position[d] - point[d]\n                        dist_sq += diff * diff\n                        if dist_sq > r_sq:\n                            break\n                    if dist_sq <= r_sq:\n                        neighbors.append(node)\n                return neighbors\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            r = random.random()\n            # Bias sampling towards goal and start equally\n            if r < self.goal_sample_rate:\n                return goal_position\n            elif r < 2 * self.goal_sample_rate:\n                return start_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_constant\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        def try_extend(tree, kd_tree, point):\n            if not tree:\n                return None\n            nearest_node = kd_tree.nearest(point)\n            if nearest_node is None:\n                return None\n            new_pos = steer(nearest_node.position, point)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near_nodes = kd_tree.near(new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near_nodes:\n                if node == nearest_node:\n                    continue\n                tentative_cost = node.cost + math.dist(node.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n\n            tree.append(new_node)\n            kd_tree.insert(new_node)\n\n            # Incremental rewiring to improve neighbor costs\n            for neighbor in near_nodes:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except Exception:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            edges.append((best_parent, new_node))\n            nodes.append(new_node)\n            return new_node\n\n        def try_connect(tree, kd_tree, node):\n            # Attempt incremental connection from 'tree' to 'node'\n            if not tree:\n                return None\n            nearest_node = kd_tree.nearest(node.position)\n            if nearest_node is None:\n                return None\n\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + math.dist(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                last_node.add_child(new_node)\n\n                tree.append(new_node)\n                kd_tree.insert(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if math.dist(new_pos, node.position) <= self.step_size:\n                    if (not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d)) and in_bounds(node.position):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + math.dist(new_pos, node.position)\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        kd_tree.insert(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def combine_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            path_goal.reverse()\n            return path_start + path_goal[1:]\n\n        def smooth_path(path):\n            # Multi-pass randomized shortcut smoothing improving on both quality and robustness\n            if len(path) < 3:\n                return path[:]\n\n            def valid_edge(p1, p2):\n                if not in_bounds(p1) or not in_bounds(p2):\n                    return False\n                return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n            smoothed = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if valid_edge(smoothed[i], smoothed[j]):\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        # Initialize trees, KD-trees, and core containers\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        kd_start = KDTree()\n        kd_goal = KDTree()\n        kd_start.insert(start_root)\n        kd_goal.insert(goal_root)\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Alternate tree extension biased by current sizes for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_extend, kd_extend = tree_goal, kd_goal\n                tree_connect, kd_connect = tree_start, kd_start\n                start_flag = False\n            else:\n                tree_extend, kd_extend = tree_start, kd_start\n                tree_connect, kd_connect = tree_goal, kd_goal\n                start_flag = True\n\n            new_node = try_extend(tree_extend, kd_extend, rand_point)\n            if new_node is None:\n                continue\n\n            connect_node = try_connect(tree_connect, kd_connect, new_node)\n            if connect_node is not None:\n                success_state = True\n                if start_flag:\n                    extracted_path = combine_path(new_node, connect_node)\n                else:\n                    extracted_path = combine_path(connect_node, new_node)\n\n                extracted_path = smooth_path(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 29.44894,
        "time_improvement": -112.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.024479079246520995,
                "num_nodes_avg": 131.6,
                "path_length_avg": 163.98526830228192,
                "success_improvement": 0.0,
                "time_improvement": -142.63557647770563,
                "length_improvement": 18.041739046401037,
                "objective_score": -39.18232513403147
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.04385039806365967,
                "num_nodes_avg": 384.4,
                "path_length_avg": 241.88975993152175,
                "success_improvement": 0.0,
                "time_improvement": -206.55949196189712,
                "length_improvement": 19.732794159933697,
                "objective_score": -58.02128875658239
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.02449533939361572,
                "num_nodes_avg": 248.4,
                "path_length_avg": 126.46153273020836,
                "success_improvement": 0.0,
                "time_improvement": 14.625970462539719,
                "length_improvement": 22.34500073274858,
                "objective_score": 8.856791285311633
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This planner implements a streamlined bidirectional RRT* algorithm with balanced tree growth, adaptive goal-biased sampling, dynamic neighborhood radius for rewiring, and iterative shortcut smoothing. It maintains rigorous collision checks for nodes and edges, and adapts exploration efficiently to improve planning speed and path quality while preserving robustness across 2D and 3D maps.",
        "planning_mechanism": "The planner grows two trees from start and goal, always extending the smaller tree for balanced exploration. Sampling is biased towards the goal to guide search efficiently. Nodes and edges are added only after confirming collision-free states and paths. Rewiring is performed within a dynamically calculated radius to optimize path cost. Upon successful tree connection, the path is extracted and refined via iterative shortcut smoothing to improve smoothness and shorten the path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2, radius_const: float = 30.0,\n                 radius_min: float = 5.0, smoothing_iter: int = 60):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.smoothing_iter = smoothing_iter\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d) and in_bounds(sample):\n                        break\n            return sample\n\n        def steer(from_p, to_p):\n            distance = dist(from_p, to_p)\n            if distance <= self.step_size:\n                return to_p\n            ratio = self.step_size / distance\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(len(from_p)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def radius_dynamic(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_const\n            r = self.radius_const * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(r, self.radius_min)\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            near = []\n            for node in tree:\n                dx = node.position[0] - pos[0]\n                dy = node.position[1] - pos[1]\n                dz = (node.position[2] - pos[2]) if is_3d else 0.0\n                dist_sq = dx*dx + dy*dy + dz*dz\n                if dist_sq <= r_sq:\n                    near.append(node)\n            return near\n\n        def can_add_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def can_connect(p1, p2):\n            if not in_bounds(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def try_extend(tree, sample):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                return None\n\n            r = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                cost_thru = node.cost + dist(node.position, new_pos)\n                if cost_thru + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_thru\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_thru_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_thru_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos) or not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size and can_connect(new_pos, node.position):\n                    final_cost = new_node.cost + dist(new_pos, node.position)\n                    final_node = Node(node.position, parent=new_node, cost=final_cost)\n                    new_node.children.append(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n\n                last_node = new_node\n\n        def extract_path(n_start, n_goal):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            sample = sample_free()\n\n            # Balance tree expansion by extending the smaller tree\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                raw_path = extract_path(new_node_start, new_node_goal)\n                smoothed_path = shortcut_smoothing(raw_path)\n                extracted_path = smoothed_path if len(smoothed_path) < len(raw_path) else raw_path\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 6.77202,
        "time_improvement": -37.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.007858896255493164,
                "num_nodes_avg": 72.4,
                "path_length_avg": 158.97044898668418,
                "success_improvement": 0.0,
                "time_improvement": 22.102959664993527,
                "length_improvement": 20.548097540416986,
                "objective_score": 10.740507407581454
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03225698471069336,
                "num_nodes_avg": 337.6,
                "path_length_avg": 241.2652125430845,
                "success_improvement": 0.0,
                "time_improvement": -125.50957988515808,
                "length_improvement": 19.9400401127957,
                "objective_score": -33.66486594298828
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.03081839084625244,
                "num_nodes_avg": 269.0,
                "path_length_avg": 123.50683756551288,
                "success_improvement": 0.0,
                "time_improvement": -7.411869993958881,
                "length_improvement": 24.159361557702983,
                "objective_score": 2.6083113133529325
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This planner combines the strengths of bidirectional RRT* with adaptive informed sampling towards start and goal, dynamic neighbor radius rewiring, balanced tree expansion by always extending the smaller tree, aggressive pruning of dead-ends for efficiency, lazy collision checking, and robust path smoothing using iterative randomized shortcutting. It prioritizes path cost optimization during tree growth, reduces computational overhead by pruning unnecessary nodes, and maintains path feasibility and smoothness to minimize both planning time and path length.",
        "planning_mechanism": "The planner initializes two trees from start and goal and iteratively extends the smaller tree towards adaptively biased samples within map bounds. Each new node is connected by rewiring neighbors within a dynamically computed radius to optimize path cost. After each successful connection of the two trees, the planner extracts and smooths the resultant path. Periodic pruning removes dead-end nodes to maintain tree efficiency and reduce search complexity. Careful collision checks on nodes and edges ensure feasibility while alternating tree expansions and adaptive sampling improve exploration balance and convergence speed.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2, radius_constant: float = 27.0,\n                 radius_min: float = 5.0, prune_interval: int = 150,\n                 prune_threshold: int = 120, smoothing_iterations: int = 80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        import math\n        import random\n\n        is_3d = len(bounds) == 3\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        success_state = False\n        extracted_path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            bias_to_goal = self.goal_sample_rate\n            if random.random() < bias_to_goal:\n                # Alternate bias between goal and start to avoid biasing only goal\n                return goal_position if random.random() < 0.6 else start_position\n            else:\n                attempts = 0\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if (not self._is_in_obstacle(p, obstacles, is_3d)) and in_bounds(p):\n                        return p\n                    attempts += 1\n                    if attempts > 30:\n                        return goal_position if random.random() < 0.6 else start_position\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d_] + (to_pos[d_] - from_pos[d_]) * ratio for d_ in range(len(from_pos)))\n            # Clamp to bounds\n            clamped = tuple(max(0, min(new_pos[d_], bounds[d_])) for d_ in range(len(bounds)))\n            return clamped\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def can_connect(p1, p2):\n            if dist(p1, p2) < 1e-9:\n                return True\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos): \n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            # Prune leaf nodes except roots\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            total = 0.0\n            for i in range(len(path) - 1):\n                total += dist(path[i], path[i + 1])\n            return total\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            path = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend smaller tree for balanced search\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                # Fail fast to next iteration\n                if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                    prune_dead_nodes()\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 6.58919,
        "time_improvement": -35.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009231066703796387,
                "num_nodes_avg": 82.1,
                "path_length_avg": 162.4624183556212,
                "success_improvement": 0.0,
                "time_improvement": 8.502065432133769,
                "length_improvement": 18.80284481287468,
                "objective_score": 6.311188592215067
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03338677883148193,
                "num_nodes_avg": 124.3,
                "path_length_avg": 239.9674241601271,
                "success_improvement": 0.0,
                "time_improvement": -133.40800560042,
                "length_improvement": 20.37069020439601,
                "objective_score": -35.948263639246804
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.02317764759063721,
                "num_nodes_avg": 115.5,
                "path_length_avg": 129.43392433655305,
                "success_improvement": 0.0,
                "time_improvement": 19.21854446615108,
                "length_improvement": 20.51977322656999,
                "objective_score": 9.869517985159321
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This improved bidirectional RRT* planner accelerates planning by employing goal bias sampling, adaptive neighbor radius that shrinks with iteration count, and early tree connection attempts. It uses a KD-tree for faster nearest neighbor queries to minimize extension overhead. Path smoothing is enhanced by shortcutting with a limited randomized trial to yield smoother, shorter paths. These combined heuristics improve planning efficiency, path quality, robustness, and success rate while reducing search time.",
        "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling points with a bias toward the goal to expedite convergence. It uses adaptive neighbor radius shrinking with iterations to progressively favor exploitation over exploration and KD-tree acceleration for nearest and near neighbor queries. Upon extending a tree, it attempts to connect it to the other tree. Once connected, the combined path is shortcut-smoothed by randomly testing line-of-sight shortcuts, leading to high-quality navigation paths quickly.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]: coordinates in 2D/3D\n        self.parent = parent          # Parent Node or None\n        self.cost = cost              # Cost (distance) from root\n        self.children = []\n        self.valid = True             # For future use (collision status etc.)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, initial_neighbor_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.initial_neighbor_radius = initial_neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        from bisect import bisect_left\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # We use a simple spatial index for faster nearest and near queries (flattens positions)\n        class KDNode:\n            def __init__(self, node_list, depth=0):\n                self.axis = depth % dim\n                if not node_list:\n                    self.node = None\n                    self.left = None\n                    self.right = None\n                    return\n                node_list.sort(key=lambda n: n.position[self.axis])\n                median = len(node_list) // 2\n                self.node = node_list[median]\n                left_list = node_list[:median]\n                right_list = node_list[median+1:]\n                self.left = KDNode(left_list, depth + 1) if left_list else None\n                self.right = KDNode(right_list, depth + 1) if right_list else None\n\n            def nearest(self, point, best=None, best_dist=float('inf')):\n                if self.node is None:\n                    return best, best_dist\n                d = math.dist(point, self.node.position)\n                if d < best_dist:\n                    best = self.node\n                    best_dist = d\n\n                diff = point[self.axis] - self.node.position[self.axis]\n                close, away = (self.left, self.right) if diff <= 0 else (self.right, self.left)\n                if close:\n                    best, best_dist = close.nearest(point, best, best_dist)\n                if away and abs(diff) < best_dist:\n                    best, best_dist = away.nearest(point, best, best_dist)\n                return best, best_dist\n\n            def near(self, point, radius, found=None):\n                if found is None:\n                    found = []\n                if self.node is None:\n                    return found\n                d = math.dist(point, self.node.position)\n                if d <= radius:\n                    found.append(self.node)\n                diff = point[self.axis] - self.node.position[self.axis]\n                if self.left and diff - radius <= 0:\n                    self.left.near(point, radius, found)\n                if self.right and diff + radius >= 0:\n                    self.right.near(point, radius, found)\n                return found\n\n        def build_kdtree(tree):\n            return KDNode(tree) if tree else None\n\n        def nearest(kdtree, point):\n            if kdtree is None:\n                return None\n            node, _ = kdtree.nearest(point)\n            return node\n\n        def near(kdtree, point, radius):\n            if kdtree is None:\n                return []\n            return kdtree.near(point, radius)\n\n        def sample_free(goal_bias=0.1):\n            # Goal bias: with probability goal_bias return goal directly\n            if random.random() < goal_bias:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def add_node(tree, new_node):\n            tree.append(new_node)\n            nodes.append(new_node)\n\n        def try_extend(tree, other_tree_kdtree, other_tree, point, neighbor_radius):\n            nearest_node = nearest(build_kdtree(tree), point)\n            if nearest_node is None:\n                return None\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            near_nodes = near(build_kdtree(tree), new_pos, neighbor_radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_node.position)\n            best_parent = nearest_node\n            for node in near_nodes:\n                cost = node.cost + math.dist(node.position, new_node.position)\n                if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_node.position, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = node\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            add_node(tree, new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors with improved costs\n            for node in near_nodes:\n                if node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                    if node.parent:\n                        try:\n                            edges.remove((node.parent, node))\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass  # Edge might already be removed in rare conditions\n                    node.parent = new_node\n                    node.cost = cost_through_new\n                    new_node.add_child(node)\n                    edges.append((new_node, node))\n\n            return new_node\n\n        def try_connect(tree, from_node, neighbor_radius):\n            # Attempt to connect as directly as possible from from_node to any node in tree within step_size increments\n            current_node = from_node\n            while True:\n                nearest_node = nearest(build_kdtree(tree), current_node.position)\n                if nearest_node is None:\n                    return None\n                new_pos = steer(current_node.position, nearest_node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_node = Node(new_pos)\n                near_nodes = near(build_kdtree(tree), new_pos, neighbor_radius)\n\n                min_cost = current_node.cost + math.dist(current_node.position, new_node.position)\n                best_parent = current_node\n                for node in near_nodes:\n                    cost = node.cost + math.dist(node.position, new_node.position)\n                    if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_node.position, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = node\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                add_node(tree, new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for node in near_nodes:\n                    if node is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                    if cost_through_new < node.cost and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        if node.parent:\n                            try:\n                                edges.remove((node.parent, node))\n                                node.parent.children.remove(node)\n                            except ValueError:\n                                pass\n                        node.parent = new_node\n                        node.cost = cost_through_new\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n                if math.dist(new_node.position, nearest_node.position) <= self.step_size:\n                    return new_node\n                current_node = new_node\n\n        def connect_trees(node_a, tree_b_kdtree, tree_b):\n            # Try to connect newly added node_a to tree_b by stepping from node_a towards closest node in tree_b\n            closest_b, dist_b = tree_b_kdtree.nearest(node_a.position)\n            if closest_b is None:\n                return None\n            if self._is_edge_in_obstacle(node_a.position, closest_b.position, obstacles, is_3d):\n                return None\n\n            # Direct connection check\n            return closest_b\n\n        def smooth_path(path):\n            # Randomized shortcut smoothing: try limited trials to reduce path length and smooth further\n            if len(path) < 3:\n                return path\n            path = path[:]  # copy path\n            max_trials = 100\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                pi = path[i]\n                pj = path[j]\n                if not self._is_edge_in_obstacle(pi, pj, obstacles, is_3d):\n                    # Remove intermediate points\n                    path[i + 1:j] = []\n            return path\n\n        # Alternate growth: starting with tree_a from start and tree_b from goal\n        for iter_num in range(1, self.max_iter + 1):\n            # Adaptive neighbor radius shrinks with iterations to favor fast convergence and rewiring\n            neighbor_radius = max(self.step_size, self.initial_neighbor_radius * (1 - iter_num / self.max_iter))\n\n            sample = sample_free(goal_bias=0.15)\n\n            # Extend tree_a towards sample\n            new_node_a = try_extend(tree_a, build_kdtree(tree_b), tree_b, sample, neighbor_radius)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Attempt connecting tree_b to new_node_a directly\n            tree_b_kdtree = build_kdtree(tree_b)\n            connect_node = nearest(tree_b_kdtree, new_node_a.position)\n            if connect_node and math.dist(connect_node.position, new_node_a.position) <= neighbor_radius and \\\n               not self._is_edge_in_obstacle(connect_node.position, new_node_a.position, obstacles, is_3d):\n                # Connect trees: create dummy connecting node if needed (or reuse connect_node)\n                if connect_node.position != new_node_a.position:\n                    connecting_node = Node(new_node_a.position)\n                    connect_node.add_child(connecting_node)\n                    connecting_node.cost = connect_node.cost + math.dist(connect_node.position, connecting_node.position)\n                    tree_b.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((connect_node, connecting_node))\n                    # Now path is connected via new_node_a and connecting_node\n                    path_a = new_node_a.path_from_root()\n                    path_b = connecting_node.path_from_root()\n                else:\n                    path_a = new_node_a.path_from_root()\n                    path_b = connect_node.path_from_root()\n                # Merge paths from start to goal\n                success_state = True\n                extracted_path = path_a + path_b[::-1][1:]\n                extracted_path = smooth_path(extracted_path)\n                break\n\n            # Swap trees for next iteration\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 166.22555,
        "time_improvement": -568.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.031371688842773436,
                "num_nodes_avg": 98.2,
                "path_length_avg": 167.20375525249227,
                "success_improvement": 0.0,
                "time_improvement": -210.95482517085898,
                "length_improvement": 16.433170203162927,
                "objective_score": -59.99981351062511
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.1715749740600586,
                "num_nodes_avg": 292.8,
                "path_length_avg": 230.01129347580567,
                "success_improvement": 0.0,
                "time_improvement": -1099.4859614471086,
                "length_improvement": 23.674471196345674,
                "objective_score": -325.1108941948634
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.1420062303543091,
                "num_nodes_avg": 218.8,
                "path_length_avg": 122.82926244082725,
                "success_improvement": 0.0,
                "time_improvement": -394.93676776456454,
                "length_improvement": 24.57543350207221,
                "objective_score": -113.56594362895491
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm with adaptive informed sampling biased towards both the start and goal positions. It alternately extends the smaller of the two trees, employing a dynamically shrinking rewiring radius proportional to the logarithm of explored nodes to optimize local costs continuously. The sampling strategy leverages heuristic goal and start biasing for efficient exploration and exploitation balance. After each successful extension, it attempts to connect the opposite tree directly to form a complete path. Dead-end nodes are pruned periodically to maintain efficiency. Upon path discovery, a shortcut smoothing procedure is applied iteratively to minimize path length while ensuring collision-free transitions. Together, these improvements lead to faster planning times, higher success rates, more optimal and smoother paths, and elevated robustness in cluttered environments.",
        "planning_mechanism": "The planning mechanism grows two RRT* trees simultaneously from start and goal points, alternating growth on the smaller tree to keep balance. Samples are drawn with bias toward the start and goal to focus search in promising regions. New nodes are generated via steering, validated by collision checks on nodes and edges, and inserted using rewiring with a shrinking radius to refine path costs effectively. After extension, direct connection attempts between trees attempt path completion. Periodic pruning removes dead branches, reducing computation. Once connected, the extracted path undergoes shortcut smoothing to reduce unnecessary waypoints and path length, improving smoothness and efficiency.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=25.0,\n                 radius_min: float=5.0, prune_interval: int=250, prune_threshold: int=100,\n                 smoothing_iterations: int=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if self._squared_distance(node.position, pos) <= r_sq]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Check node validity and edge collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            # Choose best parent minimizing cost among neighbors\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring for lower cost paths locally\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-10 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            last_node = nearest(tree, node.position)\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                # Check for collision at node position and edge\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            for node in nodes[:]:\n                if (not node.children) and node is not start_root and node is not goal_root:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed_nodes.append(node)\n                    except Exception:\n                        continue\n            return removed_nodes\n\n        def path_length(path):\n            if len(path) < 2:\n                return 0.0\n            total = 0.0\n            for i in range(len(path) - 1):\n                total += distance(path[i], path[i + 1])\n            return total\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def informed_sample(c_best, c_min, x_center):\n            # Adaptive informed sampling within ellipse defined by start and goal\n            while True:\n                if is_3d:\n                    # sample in unit ball 3D\n                    from random import uniform\n                    import numpy as np\n                    import math\n\n                    # Create rotation matrix aligning ellipse axis\n                    a1 = [(goal_position[d] - start_position[d]) / c_min for d in range(len(start_position))]\n                    I = np.eye(3)\n                    M = np.outer(a1, I[:, 0])\n                    U, _, Vt = np.linalg.svd(M)\n                    C = np.dot(U, Vt)\n                    # sample random point in unit ball\n                    while True:\n                        x_ball = np.random.normal(0, 1, 3)\n                        norm = np.linalg.norm(x_ball)\n                        if 0 < norm <= 1:\n                            break\n                    x_ball = (x_ball / norm) * (random.random() ** (1.0/3.0))\n                    L = np.diag([c_best / 2.0, math.sqrt(c_best ** 2 - c_min ** 2) / 2.0, math.sqrt(c_best ** 2 - c_min ** 2) / 2.0])\n                    rnd = np.dot(np.dot(C, L), x_ball) + np.array(x_center)\n                    sample_pt = tuple(rnd)\n                else:\n                    import math\n                    # 2D ellipse sampling\n                    while True:\n                        r1 = random.random()\n                        r2 = random.random()\n                        theta = 2 * math.pi * r2\n                        radius = r1 ** 0.5\n                        x_ball = (radius * math.cos(theta), radius * math.sin(theta))\n\n                        a = c_best / 2.0\n                        b = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n                        rot = math.atan2(goal_position[1] - start_position[1], goal_position[0] - start_position[0])\n                        x = x_ball[0] * a\n                        y = x_ball[1] * b\n\n                        # Rotate and translate\n                        cos_r = math.cos(rot)\n                        sin_r = math.sin(rot)\n                        sample_x = cos_r * x - sin_r * y + x_center[0]\n                        sample_y = sin_r * x + cos_r * y + x_center[1]\n                        sample_pt = (sample_x, sample_y)\n\n                        if 0 <= sample_x <= bounds[0] and 0 <= sample_y <= bounds[1]:\n                            if not self._is_in_obstacle(sample_pt, obstacles, is_3d):\n                                return sample_pt\n                    continue\n\n                # Verify sample within bounds and not in obstacle\n                if all(0 <= sample_pt[d] <= bounds[d] for d in range(len(bounds))) and not self._is_in_obstacle(sample_pt, obstacles, is_3d):\n                    return sample_pt\n\n        def sample_adaptive(c_best):\n            c_min = distance(start_position, goal_position)\n            x_center = tuple((start_position[d] + goal_position[d]) / 2.0 for d in range(len(start_position)))\n            if c_best < float('inf'):\n                return informed_sample(c_best, c_min, x_center)\n            else:\n                return sample_free()\n\n        # Keep track of best path cost found so far\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        for itr in range(self.max_iter):\n            # Sample state with adaptive informed sampling if path found else biased random\n            sample_pt = sample_adaptive(best_cost)\n\n            # Alternate growth on smaller tree for balanced progress\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                candidate_cost = new_node_start.cost + new_node_goal.cost\n                if candidate_cost + 1e-10 < best_cost:\n                    best_cost = candidate_cost\n                    best_start_node = new_node_start\n                    best_goal_node = new_node_goal\n\n                # Immediately extract path if desired or keep searching for improvements (can break early or keep going)\n                # For better path quality, continue search but here break for efficiency and as per previous code\n                success_state = True\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n                smoothed_path = path_smoothing(raw_path)\n                if path_length(smoothed_path) + 1e-8 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    @staticmethod\n    def _squared_distance(p1, p2):\n        return sum((a - b) ** 2 for a, b in zip(p1, p2))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 22.94459,
        "time_improvement": -89.0,
        "length_improvement": 19.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.006510114669799805,
                "num_nodes_avg": 74.9,
                "path_length_avg": 163.0264082947292,
                "success_improvement": 0.0,
                "time_improvement": 35.47202450160224,
                "length_improvement": 18.520968062095992,
                "objective_score": 14.34580096289987
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.030130410194396974,
                "num_nodes_avg": 194.7,
                "path_length_avg": 252.37764071734563,
                "success_improvement": 0.0,
                "time_improvement": -110.64263153069815,
                "length_improvement": 16.252560494398942,
                "objective_score": -29.942277360329655
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.08396587371826172,
                "num_nodes_avg": 173.5,
                "path_length_avg": 125.7449422235135,
                "success_improvement": 0.0,
                "time_improvement": -192.64771015297225,
                "length_improvement": 22.78503047199763,
                "objective_score": -53.237306951492144
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid planner combines the bidirectional rapid exploration and connection strategy of dual-tree RRT with the path optimality improvements from RRT*, including adaptive step sizing, dynamic neighbor radius rewiring, and goal-biased sampling. It grows two trees simultaneously from start and goal, tries to connect them with collision-checked edges, dynamically rewires to improve path costs, and applies path shortcut smoothing upon success, ensuring efficient exploration, higher success rates, and smooth, shorter paths.",
        "planning_mechanism": "The planner alternates expansion between two trees (start and goal), sampling points mostly free space but biased towards the goal. It uses adaptive step size for node extension and dynamically computes a radius for rewire neighborhood search. New nodes connect through the lowest-cost parents while ensuring no collisions. Trees attempt to connect once nodes are close enough. If connected, the algorithm extracts and smooths the path by shortcutting collision-free edges.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_and_propagate(self, new_cost):\n        self.cost = new_cost\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_cost_and_propagate(new_cost + dist)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, radius_constant: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Probability of sampling the goal\n        self.radius_constant = radius_constant      # Radius constant for rewiring\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n\n        nodes = tree_start + tree_goal\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        for _ in range(self.max_iter):\n            # Goal-biased sampling with randomness\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        break\n\n            # Alternate between trees\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                if not tree_a:\n                    continue\n                nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n                dist_to_sample = math.dist(nearest.position, sample)\n                if dist_to_sample == 0:\n                    continue\n\n                # Adaptive step size: don't overshoot sample\n                step = min(self.step_size, dist_to_sample)\n                new_pos = tuple(nearest.position[d] + (sample[d] - nearest.position[d]) * (step / dist_to_sample) for d in range(dim))\n\n                if not in_bounds(new_pos):\n                    continue\n                # Collision checks on new node and edge\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Dynamic neighbor radius (RRT*) for rewiring, scales with tree size and dimension\n                n_nodes = len(tree_a)+1\n                radius = min(self.radius_constant * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 6)\n\n                # Find neighbors within radius for better parenting\n                near_nodes = [node for node in tree_a if math.dist(node.position, new_pos) <= radius]\n\n                # Choose best parent by minimal cost + collision-free edge\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near_node in near_nodes:\n                    if near_node == nearest:\n                        continue\n                    cost_through_near = near_node.cost + math.dist(near_node.position, new_pos)\n                    if cost_through_near < min_cost:\n                        if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                            min_cost = cost_through_near\n                            best_parent = near_node\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                new_node.parent = best_parent\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors if better path available through new_node\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                    if new_cost < near_node.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                            # Remove old edge\n                            if near_node.parent and (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                            if near_node.parent and near_node in near_node.parent.children:\n                                near_node.parent.children.remove(near_node)\n                            # Reparent to new_node\n                            near_node.parent = new_node\n                            near_node.cost = new_cost\n                            new_node.add_child(near_node)\n                            edges.append((new_node, near_node))\n                            near_node.update_cost_and_propagate(new_cost)\n\n                # Try connecting trees if close and edge free\n                nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n                dist_between_trees = math.dist(nearest_other.position, new_node.position)\n                if dist_between_trees <= self.step_size:\n                    if not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                        # Build full path\n                        success_state = True\n                        if tree_a is tree_start:\n                            path_start = new_node.path_from_root()\n                            path_goal = nearest_other.path_from_root()\n                            path_goal.reverse()\n                            full_path = path_start + path_goal\n                        else:\n                            path_start = nearest_other.path_from_root()\n                            path_goal = new_node.path_from_root()\n                            path_goal.reverse()\n                            full_path = path_start + path_goal\n\n                        # Smooth path by shortcutting collision-free edges to reduce path length and improve smoothness\n                        extracted_path = self._smooth_path(full_path, obstacles, is_3d, bounds)\n\n                        return PlannerResult(True, extracted_path, nodes, edges)\n\n        # No path found\n        return PlannerResult(False, extracted_path, nodes, edges)\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds, max_iterations=200):\n        if len(path) < 3:\n            return path[:]\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def valid_edge(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        path = path[:]\n        for _ in range(max_iterations):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if valid_edge(path[i], path[j]):\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 26.48884,
        "time_improvement": -101.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.02938246726989746,
                "num_nodes_avg": 158.5,
                "path_length_avg": 164.47276628880394,
                "success_improvement": 0.0,
                "time_improvement": -191.23774683568234,
                "length_improvement": 17.79809223832267,
                "objective_score": -53.81170560304017
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02877089977264404,
                "num_nodes_avg": 268.1,
                "path_length_avg": 242.5897014915241,
                "success_improvement": 0.0,
                "time_improvement": -101.13825203556932,
                "length_improvement": 19.500529870248055,
                "objective_score": -26.441369636621182
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.03202950954437256,
                "num_nodes_avg": 347.8,
                "path_length_avg": 128.02929172435498,
                "success_improvement": 0.0,
                "time_improvement": -11.633002914192119,
                "length_improvement": 21.38230226695179,
                "objective_score": 0.7865595791327227
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This planner implements a streamlined bidirectional RRT* with adaptive informed sampling and efficient rewiring in both 2D and 3D. It incorporates essential collision and bounds checks, incremental tree growth from start and goal, periodic pruning, and shortcut path smoothing to balance exploration, path quality, and computational efficiency. The approach uses dynamic neighbor radius based on iteration and node count to optimize rewiring and refines paths progressively while maintaining robustness against obstacles and reducing search time.",
        "planning_mechanism": "The planning mechanism simultaneously grows two RRT* trees from start and goal, alternating expansions focused on samples drawn adaptively within an informed ellipsoid when a path is found to guide search in promising areas. Each extension uses steering with collision and bounds checks. Nearby nodes within a dynamic radius are rewired to minimize path cost while pruning removes non-promising nodes to maintain manageable complexity. Upon connection of the two trees, the path is extracted and shortcut-smoothed to enhance smoothness and shorten length, delivering an efficient and robust solution.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = 5.0\n        self.max_radius = 30.0\n        self.prune_interval = 200\n        self.prune_threshold = 300\n        self.smoothing_iterations = 50\n        self.collision_resolution = 1.0\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        import math\n        import random\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            n = max(n_nodes, 1)\n            r_iter = self.max_radius * (1 - (iteration / self.max_iter) ** 0.9)\n            r_log = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.min_radius, min(r_iter, r_log))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance_edge = dist(p1, p2)\n            steps = max(1, int(distance_edge / self.collision_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        # Ellipsoidal informed sampling to bias towards promising areas\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            I = np.eye(dim)\n            u = direction - I[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = I - 2 * np.outer(u, u)\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback\n\n        # KD-tree substitute: linear search for neighbors and nearest node (simplify for clarity)\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            result = [node for node in tree if sum((a - b) ** 2 for a, b in zip(node.position, point)) <= r2]\n            return result\n\n        # Prune nodes that cannot improve the best path\n        def prune_nodes(nodes, tree_start, tree_goal, best_cost):\n            to_remove = []\n            for node in nodes:\n                if node is root_start or node is root_goal:\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n\n        # Shortcut smoothing to improve path quality\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate expanding smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            nearest_a = nearest_node(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if (not in_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            neighbors = near_nodes(tree_a, new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in neighbors:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improvements\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt incremental connection from other tree\n            nearest_b = nearest_node(tree_b, new_node.position)\n            last_b = nearest_b\n            max_connect_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            connected = False\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if (not in_bounds(next_pos_b)) or is_in_obstacle(next_pos_b) or is_edge_in_obstacle(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                # Rewire neighbors around new_node_b\n                neighbors_b = near_nodes(tree_b, next_pos_b, r)\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is last_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and not is_edge_in_obstacle(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and not is_edge_in_obstacle(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Extract and merge path\n                    if tree_a is tree_start:\n                        path_from_start = connection_node.path_from_root()\n                        path_from_goal = new_node.path_from_root()\n                    else:\n                        path_from_start = new_node.path_from_root()\n                        path_from_goal = connection_node.path_from_root()\n\n                    merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic pruning to remove nodes that cannot improve path\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )",
        "objective": -1.08481,
        "time_improvement": -10.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.00862126350402832,
                "num_nodes_avg": 59.7,
                "path_length_avg": 160.531158757098,
                "success_improvement": 0.0,
                "time_improvement": 14.546408416754108,
                "length_improvement": 19.768069797921118,
                "objective_score": 8.317536484610455
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.026832151412963866,
                "num_nodes_avg": 241.5,
                "path_length_avg": 244.1143260176625,
                "success_improvement": 0.0,
                "time_improvement": -87.58440216349558,
                "length_improvement": 18.994607872132015,
                "objective_score": -22.47639907462227
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.016585564613342284,
                "num_nodes_avg": 163.0,
                "path_length_avg": 124.13203186042806,
                "success_improvement": 0.0,
                "time_improvement": 42.19404514297159,
                "length_improvement": 23.775454598287087,
                "objective_score": 17.413304462548894
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This improved planner implements an advanced bidirectional RRT* with enhanced informed sampling, adaptive neighbor radius rewiring, and lazy collision checking with caching. It further optimizes performance by early rejection of unpromising samples via quick bounding checks, an adaptive sampling fallback mechanism to avoid stagnation, caching of nearest neighbor searches, and efficient incremental path smoothing through shortcutting and cost-aware pruning. The planner maintains robust exploration-exploitation balance by switching between wide uniform sampling and heuristic-informed ellipsoidal sampling after an initial path is found. These improvements reduce search time, increase success rates, and yield higher quality, smoother, and shorter paths.",
        "planning_mechanism": "The planning mechanism simultaneously grows two trees from start and goal, alternating expansions each iteration. It samples points either uniformly or inside the heuristic-informed ellipsoid once a path is found, clamps samples to workspace bounds, and rejects collisions early. Nodes are connected only after thorough collision and edge checks with caching. The connection attempts between trees utilize incremental steering with lazy checks and adaptive rewiring based on dynamically computed neighbor radius. Upon connecting the two trees, the solution path is extracted and refined by iterative shortcutting with collision checks, improving path smoothness and length efficiently before returning the result.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self._edge_collision_cache = dict()\n        self._node_in_collision_cache = dict()\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n            # Clamp to bounds to avoid floating point slips\n            clamped = tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n            return clamped\n\n        def _is_in_obstacle_cached(pos):\n            key = tuple(round(c, 4) for c in pos)\n            cached = self._node_in_collision_cache.get(key)\n            if cached is not None:\n                return cached\n            val = self._is_in_obstacle(pos, obstacles, is_3d)\n            self._node_in_collision_cache[key] = val\n            return val\n\n        def sample_uniform_free():\n            attempt = 0\n            while attempt < 100:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not _is_in_obstacle_cached(p):\n                    return p\n                attempt += 1\n            # Fallback to informed sampling if uniform fails repeatedly\n            return sample_informed()\n\n        def sample_informed():\n            # Early fallback to uniform if no path found yet (avoid infinite loop)\n            if not path_found:\n                return sample_uniform_free()\n\n            c_current = c_max if c_max >= c_min else c_min\n            center_ = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n\n            if is_3d:\n                import numpy as np\n                c = c_current\n                center_np = np.array(center_)\n                start_np = np.array(start)\n                goal_np = np.array(goal)\n                diff = goal_np - start_np\n                length = np.linalg.norm(diff)\n                if length == 0:\n                    return start\n                a1 = diff / length\n\n                # Orthonormal basis via Gram-Schmidt\n                def orthonormal_basis(a1):\n                    bases = []\n                    temp = np.eye(3)\n                    for i in range(3):\n                        v = temp[:, i]\n                        if abs(np.dot(a1, v)) < 1 - 1e-3:\n                            e = v - np.dot(v, a1) * a1\n                            e /= np.linalg.norm(e)\n                            bases.append(e)\n                    if len(bases) < 2:\n                        bases = [np.array([0., 1., 0.]), np.array([0., 0., 1.])]\n                    return bases[:2]\n\n                e2, e3 = orthonormal_basis(a1)\n                C = np.column_stack((a1, e2, e3))\n                r1 = c / 2\n                r2 = math.sqrt(max(c ** 2 - c_min ** 2, 0)) / 2\n                r3 = r2\n\n                for _ in range(100):\n                    u = np.random.normal(0, 1, 3)\n                    norm_u = np.linalg.norm(u)\n                    if norm_u == 0:\n                        continue\n                    u /= norm_u\n                    radius = random.random() ** (1/3)\n                    u *= radius\n                    sample = center_np + C @ np.array([r1 * u[0], r2 * u[1], r3 * u[2]])\n                    sample_clamped = np.clip(sample, np.zeros(3), np.array(bounds))\n                    pt = tuple(sample_clamped)\n                    if not _is_in_obstacle_cached(pt):\n                        return pt\n                # fallback if no valid sample found\n                return sample_uniform_free()\n            else:\n                c = c_current\n                c1, c2 = center_\n                r1 = c / 2.0\n                r2 = math.sqrt(max(c ** 2 - c_min ** 2, 0)) / 2.0\n                dx = goal[0] - start[0]\n                dy = goal[1] - start[1]\n                length = math.hypot(dx, dy)\n                if length == 0:\n                    return start\n                cos_angle = dx / length\n                sin_angle = dy / length\n\n                for _ in range(100):\n                    theta = random.uniform(0, 2 * math.pi)\n                    rho = math.sqrt(random.uniform(0, 1))\n                    x_ball = rho * math.cos(theta)\n                    y_ball = rho * math.sin(theta)\n                    x_ell = r1 * x_ball\n                    y_ell = r2 * y_ball\n                    x_rot = cos_angle * x_ell - sin_angle * y_ell\n                    y_rot = sin_angle * x_ell + cos_angle * y_ell\n                    sample = (c1 + x_rot, c2 + y_rot)\n                    if in_bounds(sample) and not _is_in_obstacle_cached(sample):\n                        return sample\n                return sample_uniform_free()\n\n        def edge_cache_key(p1, p2):\n            return tuple(sorted([(round(c, 4)) for c in p1] + [(round(c,4)) for c in p2]))\n\n        def is_edge_collision_cached(p1, p2):\n            key = edge_cache_key(p1, p2)\n            return self._edge_collision_cache.get(key, None)\n\n        def cache_edge_collision(p1, p2, val):\n            key = edge_cache_key(p1, p2)\n            self._edge_collision_cache[key] = val\n\n        def node_nearest(tree, point, last_nearest=None):\n            # Cache nearest node if repeated for same point to reduce cost if desired\n            # Here linear search since no special structure; could use KD-tree\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                dist_ = distance(node.position, point)\n                if dist_ < best_dist:\n                    best = node\n                    best_dist = dist_\n            return best\n\n        def nodes_near(tree, pos, rad):\n            rad_sq = rad * rad\n            return [node for node in tree if (distance(node.position, pos) **2) <= rad_sq]\n\n        def neighbor_radius(nnodes):\n            if nnodes < 2:\n                return float('inf')\n            gamma_rrt_star = 30.0\n            unit_ball_volume = math.pi if dim == 2 else 4.0/3.0 * math.pi\n            val = gamma_rrt_star * ((math.log(nnodes) / nnodes) ** (1/dim))\n            return max(val, self.step_size)\n\n        def lazy_edge_collision_check(n1_pos, n2_pos):\n            cached = is_edge_collision_cached(n1_pos, n2_pos)\n            if cached is not None:\n                return cached\n            col = self._is_edge_in_obstacle(n1_pos, n2_pos, obstacles, is_3d, resolution=0.25)\n            cache_edge_collision(n1_pos, n2_pos, col)\n            return col\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        connection_start = None\n        connection_goal = None\n\n        best_cost = float('inf')\n        c_min = distance(start, goal)\n        c_max = float('inf')\n        path_found = False\n        informed_center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n\n        for it in range(self.max_iter):\n            # Sampling\n            if path_found:\n                q_rand = sample_informed()\n            else:\n                q_rand = sample_uniform_free()\n\n            # Alternate tree expansion\n            if it % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            nearest_node = node_nearest(tree_a, q_rand)\n            new_pos = steer(nearest_node.position, q_rand)\n\n            if _is_in_obstacle_cached(new_pos):\n                continue\n\n            # Edge collision check lazy\n            if lazy_edge_collision_check(nearest_node.position, new_pos):\n                continue\n\n            # Add new node\n            new_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Local rewiring in tree_a\n            radius = neighbor_radius(len(tree_a))\n            near = nodes_near(tree_a, new_pos, radius)\n\n            for node in near:\n                if node is nearest_node:\n                    continue\n                cost_path = new_node.cost + distance(new_node.position, node.position)\n                if cost_path + 1e-8 < node.cost:\n                    if not lazy_edge_collision_check(new_node.position, node.position):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_path)\n                        edges.append((new_node, node))\n\n            # Try connecting tree_b to new_node incrementally\n            connect_node_b = node_nearest(tree_b, new_node.position)\n            prev_node_b = connect_node_b\n            connected = False\n\n            while True:\n                next_pos_b = steer(prev_node_b.position, new_node.position)\n                if _is_in_obstacle_cached(next_pos_b):\n                    break\n\n                if lazy_edge_collision_check(prev_node_b.position, next_pos_b):\n                    break\n\n                cost_b = prev_node_b.cost + distance(prev_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=prev_node_b, cost=cost_b)\n                prev_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((prev_node_b, new_node_b))\n\n                # Local rewiring in tree_b\n                r_b = neighbor_radius(len(tree_b))\n                near_b = nodes_near(tree_b, next_pos_b, r_b)\n                for nb_node in near_b:\n                    if nb_node is prev_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + distance(new_node_b.position, nb_node.position)\n                    if cost_via_new_b + 1e-8 < nb_node.cost:\n                        if not lazy_edge_collision_check(new_node_b.position, nb_node.position):\n                            try:\n                                edges.remove((nb_node.parent, nb_node))\n                            except ValueError:\n                                pass\n                            nb_node.update_parent(new_node_b, cost_via_new_b)\n                            edges.append((new_node_b, nb_node))\n\n                dist_to_new_node = distance(new_node_b.position, new_node.position)\n                if dist_to_new_node <= self.step_size:\n                    # Final connection edge check\n                    if not lazy_edge_collision_check(new_node_b.position, new_node.position):\n                        final_cost = new_node_b.cost + dist_to_new_node\n                        connect_node_goal = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                        new_node_b.children.append(connect_node_goal)\n                        tree_b.append(connect_node_goal)\n                        nodes.append(connect_node_goal)\n                        edges.append((new_node_b, connect_node_goal))\n\n                        if tree_a is tree_start:\n                            connection_start = new_node\n                            connection_goal = connect_node_goal\n                        else:\n                            connection_start = connect_node_goal\n                            connection_goal = new_node\n\n                        connected = True\n                    break\n                prev_node_b = new_node_b\n\n            if connected:\n                path_start = connection_start.path_from_root()\n                path_goal = connection_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n\n                # Update current best path info\n                best_cost = 0.0\n                for i in range(len(merged_path) - 1):\n                    best_cost += distance(merged_path[i], merged_path[i + 1])\n                c_max = best_cost + 1e-6\n                informed_center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n                path_found = True\n\n                # Path smoothing by iterative shortcutting with early pruning\n                def smooth_path(path, max_trials=150):\n                    if len(path) < 3:\n                        return path\n                    smoothed = path[:]\n                    for _ in range(max_trials):\n                        if len(smoothed) < 3:\n                            break\n                        i = random.randint(0, len(smoothed) - 3)\n                        j = random.randint(i + 2, len(smoothed) - 1)\n                        if not lazy_edge_collision_check(smoothed[i], smoothed[j]):\n                            smoothed = smoothed[:i + 1] + smoothed[j:]\n                    return smoothed\n\n                merged_path = smooth_path(merged_path)\n\n                return PlannerResult(\n                    success=True,\n                    path=merged_path,\n                    nodes=nodes,\n                    edges=edges,\n                )\n\n        # Failed to find path\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.25):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 22.94595,
        "time_improvement": -90.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.022675609588623045,
                "num_nodes_avg": 85.6,
                "path_length_avg": 166.64793293133317,
                "success_improvement": 0.0,
                "time_improvement": -124.75966310296911,
                "length_improvement": 16.710964856993783,
                "objective_score": -34.085705959491975
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02847111225128174,
                "num_nodes_avg": 225.9,
                "path_length_avg": 242.95981943119415,
                "success_improvement": 0.0,
                "time_improvement": -99.04242818211367,
                "length_improvement": 19.377712216218352,
                "objective_score": -25.83718601139043
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.04152281284332275,
                "num_nodes_avg": 292.0,
                "path_length_avg": 126.20025917463163,
                "success_improvement": 0.0,
                "time_improvement": -44.72017689569982,
                "length_improvement": 22.50543843525649,
                "objective_score": -8.914965381658646
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e1",
        "algorithm_description": "This algorithm is an enhanced bidirectional PRM*-inspired planner that dynamically samples nodes with adaptive density around the current best path corridor and obstacles. It constructs two probabilistic roadmaps simultaneously from start and goal, using KD-tree accelerated nearest neighbor queries for fast connection attempts. The planner incrementally rewires to improve path cost and applies efficient lazy collision checking to minimize expensive collision tests. Once a connection between the two graphs is found, the resulting path is shortcut-smoothed for quality and smoothness. The adaptive sampling and rewiring ensure faster convergence, shorter paths, and higher success rates in both 2D and 3D environments.",
        "planning_mechanism": "The planner initializes two PRM* graphs from start and goal positions. At each iteration, it samples new nodes biased towards a corridor around the best-known path (or uniform if none yet), avoiding obstacles and out-of-bound positions. Using KD-tree queries, new nodes connect to neighbors within a radius proportional to log of nodes count, rewiring to improve cost while checking collisions lazily. The two graphs try to connect via newly added nodes, and upon success, path extraction and shortcut smoothing finalize the path. Periodic pruning discards nodes unlikely to contribute to better solutions, improving planning efficiency and robustness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]: 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from the root of its roadmap\n        self.children = []\n        self.valid = True               # For collision checks / pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float = 8.0,\n                 max_neighbor_radius: float = 35.0,\n                 prune_interval: int = 250,\n                 prune_threshold: int = 400,\n                 smoothing_iterations: int = 120,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            factor = math.log(n_nodes) / n_nodes\n            r = self.max_neighbor_radius * math.sqrt(factor)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree helper for nearest and radius search\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Adaptive sampling biased towards corridor around last best path or uniform if none\n        def adaptive_sample(best_path):\n            if best_path:\n                import numpy as np\n                # Sample near path nodes with some Gaussian noise scaled to step_size\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 1.2, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            # Fallback uniform random sampling\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            # Final fallback: unconstrained\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # Lazy collision checking cache: store edge collision results for reuse\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)  # Sorted tuple for symmetry\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) -1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def extract_path(node):\n            return node.path_from_root()\n\n        def prune_nodes(nodes_list, best_cost, root_start, root_goal):\n            removed = 0\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(rm_node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialize graph roots\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        best_path = []\n        c_best = float(\"inf\")\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            sample_point = adaptive_sample(best_path)\n\n            # Alternate expanding smaller tree for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(sample_point)\n            new_pos = steer(nearest_a.position, sample_point)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            # Choose parent minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for nbr in near_nodes:\n                cost_candidate = nbr.cost + dist(nbr.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(nbr.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = nbr\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for potential improvements\n            for nbr in near_nodes:\n                if nbr is best_parent:\n                    continue\n                c_new = new_node.cost + dist(new_node.position, nbr.position)\n                if c_new + 1e-12 < nbr.cost and can_connect(new_node.position, nbr.position):\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                    except ValueError:\n                        pass\n                    nbr.update_parent(new_node, c_new)\n                    edges.append((new_node, nbr))\n\n            # Try connecting tree_b to new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_connect_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes))\n                near_b_nodes = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_b_nodes:\n                    if nbr_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if c_via_new_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    connection_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=connection_cost)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if connection_cost + 1e-12 < c_best:\n                        c_best = connection_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodically prune unpromising nodes to speed up search\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                removed_start = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_goal = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -0.87076,
        "time_improvement": -12.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.013141536712646484,
                "num_nodes_avg": 84.4,
                "path_length_avg": 159.69086813692314,
                "success_improvement": 0.0,
                "time_improvement": -30.25834444034824,
                "length_improvement": 20.18803897343391,
                "objective_score": -5.03989553741769
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.020515084266662598,
                "num_nodes_avg": 207.7,
                "path_length_avg": 236.2902695479745,
                "success_improvement": 0.0,
                "time_improvement": -43.42158995257977,
                "length_improvement": 21.590894508385396,
                "objective_score": -8.708298084096851
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.017832279205322266,
                "num_nodes_avg": 158.0,
                "path_length_avg": 122.09045132245728,
                "success_improvement": 0.0,
                "time_improvement": 37.848849238961265,
                "length_improvement": 25.029108035481944,
                "objective_score": 16.360476378784767
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner that incorporates dynamic neighborhood radius adjustment, adaptive sampling biased towards start and goal regions, incremental rewiring for path cost minimization, collision-free node and edge verification, and final path shortcut smoothing for improved path quality and efficiency. It balances exploration and exploitation by alternating tree extensions and continuously optimizes the connection process to produce shorter and smoother paths with higher success rates.",
        "planning_mechanism": "The planner grows two trees from start and goal positions alternately. Each iteration samples a collision-free point, steers the nearest node in the active tree towards it within step limits while ensuring collision safety, and performs rewiring within a radius that adapts during iterations. It attempts to incrementally connect the opposite tree to the newly added node. Upon successful connection, the combined path is shortcut-smoothed for higher quality before returning.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 smoothing_iterations: int = 100, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Adaptive biased sampling: 10% goal, 10% start, 80% uniform random\n            r = random.random()\n            if r < 0.1:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    return goal_position\n            elif r < 0.2:\n                if not self._is_in_obstacle(start_position, obstacles, is_3d):\n                    return start_position\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback return (may be in obstacle but rare)\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / distance_between\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            # Clamp inside bounds strictly\n            new_pos = tuple(max(0, min(new_pos[d], bounds[d])) for d in range(len(bounds)))\n            return new_pos\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            return in_bounds(p1) and in_bounds(p2) and not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        def shortcut_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - position[d]) ** 2 for d in range(len(position))) <= r2]\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        nodes: List[Node] = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n        tree_a, tree_b = [start_root], [goal_root]\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for iteration in range(self.max_iter):\n            sample = sample_free()\n            r = neighbor_radius(iteration, len(nodes))\n\n            # Extend active tree toward sample point\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            neighbors = near_nodes(tree_a, new_pos, r)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                cost_via_node = node.cost + dist(node.position, new_pos)\n                if cost_via_node + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_via_node\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to possibly new_node for cost improvement\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt incremental connection from opposite tree to new_node\n            connect_node = nearest(tree_b, new_node.position)\n            curr_pos = connect_node.position\n            connected = False\n\n            while True:\n                next_pos = steer(curr_pos, new_node.position)\n                if not can_add_node(next_pos) or not can_connect(curr_pos, next_pos):\n                    break\n\n                neighbors_b = near_nodes(tree_b, next_pos, r)\n                min_cost_b = connect_node.cost + dist(curr_pos, next_pos)\n                best_parent_b = connect_node\n\n                for node_b in neighbors_b:\n                    if not can_connect(node_b.position, next_pos):\n                        continue\n                    cost_b = node_b.cost + dist(node_b.position, next_pos)\n                    if cost_b < min_cost_b:\n                        min_cost_b = cost_b\n                        best_parent_b = node_b\n\n                new_node_b = Node(next_pos, parent=best_parent_b, cost=min_cost_b)\n                best_parent_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((best_parent_b, new_node_b))\n\n                # Rewire neighbors of new_node_b for cost improvements\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is best_parent_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    # Successful connection found\n                    success_state = True\n\n                    path_start = new_node.path_from_root()\n                    path_goal = connection_node.path_from_root()\n                    combined_path = path_start + path_goal[::-1][1:]  # merge paths avoiding duplicate node\n\n                    extracted_path = shortcut_smoothing(combined_path)\n                    connected = True\n                    break\n\n                curr_pos = new_node_b.position\n                connect_node = new_node_b\n\n            if connected:\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # alternate trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 30.50429,
        "time_improvement": -116.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.013696694374084472,
                "num_nodes_avg": 93.3,
                "path_length_avg": 162.78166818583708,
                "success_improvement": 0.0,
                "time_improvement": -35.76104320865118,
                "length_improvement": 18.643286816201503,
                "objective_score": -6.999655599355053
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.041968274116516116,
                "num_nodes_avg": 313.0,
                "path_length_avg": 235.24636926182453,
                "success_improvement": 0.0,
                "time_improvement": -193.40150511288348,
                "length_improvement": 21.937295940048422,
                "objective_score": -53.63299234585536
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.06280975341796875,
                "num_nodes_avg": 326.8,
                "path_length_avg": 123.82039436627615,
                "success_improvement": 0.0,
                "time_improvement": -118.91191860537585,
                "length_improvement": 23.966818793054863,
                "objective_score": -30.88021182300178
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "This algorithm is an optimized bidirectional RRT* variant that efficiently grows two trees from start and goal points. It performs rewiring to guarantee asymptotic optimality while adaptively tuning exploration parameters for faster convergence and higher-quality paths. It incorporates adaptive radius and step size scaling based on problem dimensions and map bounds to improve success rate and path smoothness.",
        "planning_mechanism": "The planner alternates growing two trees by sampling, steering, rewiring nearby nodes within an adaptive radius, and attempts connection between the trees after each extension. Extensive collision checks ensure robustness. Upon successful connection, an optimal path is extracted by backtracking parents from both trees and smoothing the path using shortcutting.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size_init = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size                    # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start           # Tuple[float, ...]\n        goal_position = map.goal             # Tuple[float, ...]\n        obstacles = map.obstacles            # List of obstacles: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        \n        # Adaptive step size and radius scaling based on environment size and dimension\n        diag = math.dist((0,)*dim, bounds)\n        step_size = min(self.step_size_init, diag * 0.05)\n        search_radius = min(50.0, diag * 0.15)  # dynamic radius for rewiring\n\n        start_tree = [Node(start_position, parent=None, cost=0.0)]\n        goal_tree = [Node(goal_position, parent=None, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if distance(node.position, point) <= radius]\n\n        def extract_path(node_a, node_b):\n            path_from_start = []\n            cur = node_a\n            while cur is not None:\n                path_from_start.append(cur.position)\n                cur = cur.parent\n            path_from_start.reverse()\n\n            path_from_goal = []\n            cur = node_b\n            while cur is not None:\n                path_from_goal.append(cur.position)\n                cur = cur.parent\n\n            return path_from_start + path_from_goal\n\n        def is_in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def smooth_path(path):\n            # Shortcut smoothing: try to replace intermediate nodes by direct edges\n            if len(path) <= 2:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path)-1\n                while j > i+1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -=1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        for iteration in range(self.max_iter):\n            rand_point = None\n            # Adaptive biasing: with 10% probability sample the goal to speed convergence\n            if random.random() < 0.1:\n                rand_point = goal_position\n            else:\n                while True:\n                    rand_point = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if (not self._is_in_obstacle(rand_point, obstacles, is_3d)) and is_in_bounds(rand_point):\n                        break\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, rand_point)\n                new_pos = steer(nearest_node.position, rand_point, step_size)\n\n                if (not is_in_bounds(new_pos)\n                    or self._is_in_obstacle(new_pos, obstacles, is_3d)\n                    or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                    continue\n\n                near_nodes = near(tree_a, new_pos, search_radius)\n\n                min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n                min_parent = nearest_node\n\n                # Choose parent with minimal cost and collision-free edge\n                for near_node in near_nodes:\n                    if near_node == nearest_node:\n                        continue\n                    cost_candidate = near_node.cost + distance(near_node.position, new_pos)\n                    if cost_candidate < min_cost:\n                        if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                            min_cost = cost_candidate\n                            min_parent = near_node\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire near nodes to new_node if that shortens path and collision free\n                for near_node in near_nodes:\n                    if near_node == min_parent:\n                        continue\n                    cost_through_new = new_node.cost + distance(new_node.position, near_node.position)\n                    if cost_through_new < near_node.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                            # Rewire\n                            if near_node.parent:\n                                try:\n                                    edges.remove((near_node.parent, near_node))\n                                    near_node.parent.children.remove(near_node)\n                                except ValueError:\n                                    pass\n                            near_node.parent = new_node\n                            near_node.cost = cost_through_new\n                            new_node.add_child(near_node)\n                            edges.append((new_node, near_node))\n\n                # Try to connect to the other tree\n                connect_node = nearest(tree_b, new_node.position)\n                dist_connect = distance(new_node.position, connect_node.position)\n                if dist_connect <= step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    # Connect trees - unify parents and costs to create one path\n                    success_state = True\n                    path = extract_path(new_node, connect_node)\n                    # Smooth the resulting path to improve quality and path length\n                    extracted_path = smooth_path(path)\n                    return PlannerResult(\n                        success=success_state,\n                        path=extracted_path,\n                        nodes=nodes,\n                        edges=edges\n                    )\n\n        # Failed to find path in given iterations\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 64.30161,
        "time_improvement": -229.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.041902995109558104,
                "num_nodes_avg": 149.9,
                "path_length_avg": 167.81445107593092,
                "success_improvement": 0.0,
                "time_improvement": -315.3406781423399,
                "length_improvement": 16.127950300309244,
                "objective_score": -91.37661338264013
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.041944694519042966,
                "num_nodes_avg": 298.3,
                "path_length_avg": 228.90048490620657,
                "success_improvement": 0.0,
                "time_improvement": -193.23665941612285,
                "length_improvement": 24.04307506006509,
                "objective_score": -53.162382812823836
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.08005759716033936,
                "num_nodes_avg": 423.0,
                "path_length_avg": 119.35314515512133,
                "success_improvement": 0.0,
                "time_improvement": -179.0261263514597,
                "length_improvement": 26.70997892032407,
                "objective_score": -48.3658421213731
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "A simplified, generalized bidirectional RRT* planner that balances exploration and exploitation through alternate tree expansions with adaptive neighbor radius rewiring, rigorous collision checks for nodes and edges, path cost optimization, and randomized shortcut smoothing. It maintains path feasibility and robustness while enhancing planning efficiency, success rate, and path quality.",
        "planning_mechanism": "The planner grows two trees rooted at start and goal by iteratively sampling collision-free points within map bounds, steering towards samples within a fixed step size, rewiring neighbors to lower path costs, and attempting to connect the two trees incrementally. Upon connection, it reconstructs and smooths the path via randomized shortcutting before returning.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_radius: float = 5.0, max_radius: float = 30.0,\n                 smoothing_iters: int = 100, collision_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.smoothing_iters = smoothing_iters\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback: uniform random\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d_] + ratio * (to_pos[d_] - from_pos[d_]) for d_ in range(len(from_pos)))\n            # Clamp to bounds\n            return tuple(max(0, min(new_pos[d_], bounds[d_])) for d_ in range(len(bounds)))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes,1)\n            r_iter = self.max_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            if dist(p1, p2) < 1e-12:\n                return True\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if sum((node.position[d] - position[d])**2 for d in range(len(position))) <= radius_sq]\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path[:]\n            smoothed = path[:]\n            for _ in range(self.smoothing_iters):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if can_connect(smoothed[i], smoothed[j]):\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n        tree_a, tree_b = [start_root], [goal_root]\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for iteration in range(self.max_iter):\n            sample = sample_free()\n            radius = neighbor_radius(iteration, len(nodes))\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            neighbors = near_nodes(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                cost_thru_node = node.cost + dist(node.position, new_pos)\n                if cost_thru_node + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_thru_node\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            connect_node = nearest(tree_b, new_node.position)\n            curr_pos = connect_node.position\n            connected = False\n\n            while True:\n                next_pos = steer(curr_pos, new_node.position)\n                if not can_add_node(next_pos) or not can_connect(curr_pos, next_pos):\n                    break\n\n                neighbors_b = near_nodes(tree_b, next_pos, radius)\n\n                min_cost_b = connect_node.cost + dist(curr_pos, next_pos)\n                best_parent_b = connect_node\n                for node_b in neighbors_b:\n                    cost_b = node_b.cost + dist(node_b.position, next_pos)\n                    if cost_b + 1e-12 < min_cost_b and can_connect(node_b.position, next_pos):\n                        min_cost_b = cost_b\n                        best_parent_b = node_b\n\n                new_node_b = Node(next_pos, parent=best_parent_b, cost=min_cost_b)\n                best_parent_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((best_parent_b, new_node_b))\n\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is best_parent_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    path_start = new_node.path_from_root()\n                    path_goal = connection_node.path_from_root()\n                    combined_path = path_start + path_goal[::-1][1:]\n                    extracted_path = shortcut_smoothing(combined_path)\n                    connected = True\n                    break\n\n                curr_pos = new_node_b.position\n                connect_node = new_node_b\n\n            if connected:\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 7.72768,
        "time_improvement": -41.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.012247347831726074,
                "num_nodes_avg": 69.8,
                "path_length_avg": 157.58179279190188,
                "success_improvement": 0.0,
                "time_improvement": -21.395182864002873,
                "length_improvement": 21.242134559504606,
                "objective_score": -2.1701279472999406
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.0289870023727417,
                "num_nodes_avg": 230.0,
                "path_length_avg": 234.08323517595468,
                "success_improvement": 0.0,
                "time_improvement": -102.64903201073415,
                "length_improvement": 22.323263180317472,
                "objective_score": -26.330056967156747
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.02798898220062256,
                "num_nodes_avg": 212.2,
                "path_length_avg": 125.53899308665306,
                "success_improvement": 0.0,
                "time_improvement": 2.4495168357540735,
                "length_improvement": 22.911495648614675,
                "objective_score": 5.317154180449157
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "This improved planner implements a bidirectional RRT* with adaptive informed sampling biased towards start and goal, dynamic neighbor radius shrinking with tree growth for efficient rewiring, dead-end pruning, and aggressive iterative shortcut smoothing. Additionally, it employs heuristics based on path costs and Euclidean distances to bias sampling, balances tree growth by always extending the smaller tree, and carefully performs collision and edge feasibility checks to ensure robustness and path optimality. The combination improves planning efficiency, success rate, path length minimization, and smoothness while reducing search time and computational overhead.",
        "planning_mechanism": "The planner grows two trees simultaneously from start and goal, always extending the smaller. Sampling is adaptively biased using a heuristic that considers distance to start and goal, encouraging exploration near these points and informed regions. Each newly added node undergoes rewiring within a shrinking neighbor radius to optimize local cost, improving path quality. Dead-end nodes are pruned periodically to maintain tree compactness. Upon connecting the two trees, an iterative shortcut smoothing step refines the path to reduce length and enhance smoothness, ensuring collision-free shortcuts. Collision checks apply rigorously for nodes and edges, while boundary constraints are enforced, yielding efficient, robust, and high-quality paths.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 5.0, prune_interval: int = 200,\n                 prune_threshold: int = 100, smoothing_iterations: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def heuristic_sample():\n            # Adaptive sampling biased towards start and goal and around the informed ellipse when path found\n            p_bias = 0.9\n            if random.random() < self.goal_sample_rate:\n                # Biased sample: either start or goal with probability p_bias\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                # Uniform + informed sampling region bias\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            # Return nearest node and its distance\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = node\n            return min_node\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            return max(self.radius_min, self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1)))\n\n        def can_add_node(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            for d in range(len(pos)):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            prune_candidates = [node for node in nodes if node is not start_root and node is not goal_root and not node.children]\n            for node in prune_candidates:\n                try:\n                    if node.parent:\n                        node.parent.children.remove(node)\n                    nodes.remove(node)\n                    edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                    removed.append(node)\n                except Exception:\n                    continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            path_coords = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(path_coords) < 3:\n                    break\n                i = random.randint(0, len(path_coords) - 3)\n                j = random.randint(i + 2, len(path_coords) - 1)\n                p1, p2 = path_coords[i], path_coords[j]\n                if not can_connect(p1, p2):\n                    continue\n                path_coords = path_coords[:i+1] + path_coords[j:]\n            return path_coords\n\n        for itr in range(self.max_iter):\n            sample_pt = heuristic_sample()\n\n            # Always extend smaller tree to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                    prune_dead_nodes()\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n\n                # Combined raw path\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed_path = shortcut_smoothing(raw_path)\n                if path_length(smoothed_path) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -0.08789,
        "time_improvement": -14.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.010836625099182129,
                "num_nodes_avg": 78.1,
                "path_length_avg": 162.348637351029,
                "success_improvement": 0.0,
                "time_improvement": -7.412160054448005,
                "length_improvement": 18.8597114653641,
                "objective_score": 1.5482942767384187
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.023978519439697265,
                "num_nodes_avg": 137.5,
                "path_length_avg": 238.1851169434197,
                "success_improvement": 0.0,
                "time_improvement": -67.63457259294447,
                "length_improvement": 20.962120037036257,
                "objective_score": -16.09794777047609
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.0190171480178833,
                "num_nodes_avg": 96.5,
                "path_length_avg": 124.60039533384824,
                "success_improvement": 0.0,
                "time_improvement": 33.719205498325195,
                "length_improvement": 23.48785121091676,
                "objective_score": 14.81333189168091
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This planner integrates a bidirectional RRT* framework enhanced with adaptive informed sampling and dynamic neighbor radius for efficient rewiring. By growing two trees simultaneously from start and goal positions, it refines paths incrementally and prunes non-promising nodes to maintain manageable complexity. Collision and bounds checks guard against invalid expansions. The algorithm applies shortcut smoothing on extracted paths to ensure smooth and shorter trajectories, balancing exploration with path quality and computational speed across both 2D and 3D environments.",
        "planning_mechanism": "The planner alternates tree expansions between start and goal trees, sampling adaptively within informed ellipsoids when a path is found to bias exploration. Each new node is chosen via steering, verified for collisions and bounds, and connected with rewiring nearby nodes to minimize cost. Upon connecting the two trees, the merged path is shortcut-smoothed. Periodic pruning removes nodes that cannot improve paths, facilitating faster convergence and robustness against obstacles.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D position\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = 5.0\n        self.max_radius = 30.0\n        self.prune_interval = 200\n        self.prune_threshold = 300\n        self.smoothing_iterations = 50\n        self.collision_resolution = 1.0\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        import math\n        import random\n        import numpy as np\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            n = max(n_nodes, 1)\n            r_iter = self.max_radius * (1 - (iteration / self.max_iter) ** 0.9)\n            r_log = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.min_radius, min(r_iter, r_log))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance_edge = dist(p1, p2)\n            steps = max(1, int(distance_edge / self.collision_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            I = np.eye(dim)\n            u = direction - I[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = I - 2 * np.outer(u, u)\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((a - b) ** 2 for a, b in zip(node.position, point)) <= r2]\n\n        def prune_nodes(nodes_list, tree_start, tree_goal, best_cost):\n            to_remove = []\n            for node in nodes_list:\n                if node is root_start or node is root_goal:\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate expanding smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            nearest_a = nearest_node(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if (not in_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            neighbors = near_nodes(tree_a, new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in neighbors:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improvements\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt incremental connection from other tree\n            nearest_b = nearest_node(tree_b, new_node.position)\n            last_b = nearest_b\n            max_connect_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            connected = False\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if (not in_bounds(next_pos_b)) or is_in_obstacle(next_pos_b) or is_edge_in_obstacle(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                neighbors_b = near_nodes(tree_b, next_pos_b, r)\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is last_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and not is_edge_in_obstacle(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and not is_edge_in_obstacle(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_from_start = connection_node.path_from_root()\n                        path_from_goal = new_node.path_from_root()\n                    else:\n                        path_from_start = new_node.path_from_root()\n                        path_from_goal = connection_node.path_from_root()\n\n                    merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": -0.3229,
        "time_improvement": -12.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009643340110778808,
                "num_nodes_avg": 77.1,
                "path_length_avg": 163.31726940222234,
                "success_improvement": 0.0,
                "time_improvement": 4.4156292242104564,
                "length_improvement": 18.37559847618153,
                "objective_score": 4.999808462499443
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.026294636726379394,
                "num_nodes_avg": 248.9,
                "path_length_avg": 238.22040157765733,
                "success_improvement": 0.0,
                "time_improvement": -83.82662032985807,
                "length_improvement": 20.95041140166391,
                "objective_score": -20.95790381862464
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.01644265651702881,
                "num_nodes_avg": 155.1,
                "path_length_avg": 129.31015539791787,
                "success_improvement": 0.0,
                "time_improvement": 42.69212519974307,
                "length_improvement": 20.595774810858295,
                "objective_score": 16.92679252209458
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "An improved bidirectional RRT* planner combining adaptive goal biasing, dynamic neighbor radius rewiring, and rigorous collision checking. It alternates growth between start and goal trees, always extending the smaller tree to balance exploration. It incorporates heuristic sampling biased towards the goal, dynamic radius shrinking with node growth, and performs local rewiring to optimize path cost incrementally. Once trees are connected, the path is reconstructed and refined with randomized shortcut smoothing and final path simplification. The approach prioritizes reducing path length and planning time while ensuring high success and path quality.",
        "planning_mechanism": "A bidirectional RRT* variant grows two trees rooted at start and goal. It samples collision-free points with a goal bias, extends the smaller tree towards samples using fixed step size, and rewires neighbors within a dynamically calculated radius based on tree size to optimize paths locally. On successful tree connection, it backtracks from the connection nodes to form the full path, followed by a shortcut smoothing step to reduce path length and increase smoothness. Throughout, collision checks on nodes and edges guarantee feasibility, and alternating tree expansion balances exploration for better efficiency and success rates.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 40.0, radius_min: float = 5.0,\n                 smoothing_iters: int = 120, collision_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.smoothing_iters = smoothing_iters\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                # Bias towards goal mostly, occasionally start for balanced exploration\n                return goal_position if random.random() < 0.8 else start_position\n            else:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # Fallback uniform sample if unlucky\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d_] + ratio * (to_pos[d_] - from_pos[d_]) for d_ in range(len(from_pos)))\n            # Clamp to bounds rigorously\n            return tuple(max(0.0, min(new_pos[d_], bounds[d_])) for d_ in range(len(bounds)))\n\n        def radius_by_nodes(n_nodes):\n            # Decreases with more nodes; prevents overuse of large radius (faster local improvements)\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(self.radius_min, val)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if sum((node.position[d] - pos[d]) ** 2 for d in range(len(pos))) <= radius_sq]\n\n        def is_collision_free_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_collision_free_edge(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            if dist(p1, p2) < 1e-12:\n                return True\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not is_collision_free_node(new_pos) or not is_collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                cost_thru_node = node.cost + dist(node.position, new_pos)\n                if cost_thru_node + 1e-12 < min_cost and is_collision_free_edge(node.position, new_pos):\n                    min_cost = cost_thru_node\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better path costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and is_collision_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree or node is None:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not is_collision_free_node(new_pos) or not is_collision_free_edge(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if is_collision_free_edge(new_pos, node.position):\n                        final_node = Node(node.position, parent=new_node,\n                                          cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def shortcut_smoothing(path: list) -> list:\n            if len(path) < 3:\n                return path[:]\n            smoothed = path[:]\n            for _ in range(self.smoothing_iters):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if is_collision_free_edge(smoothed[i], smoothed[j]):\n                    smoothed = smoothed[:i + 1] + smoothed[j:]\n            return smoothed\n\n        # Initialization\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        for iteration in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Always extend smaller tree first for balanced and efficient growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                full_path = path_from_start + path_from_goal[::-1][1:]\n\n                # Use shortcut smoothing with collision checks to reduce path length and increase smoothness\n                extracted_path = shortcut_smoothing(full_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 24.56309,
        "time_improvement": -96.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.01574430465698242,
                "num_nodes_avg": 74.5,
                "path_length_avg": 160.02617751222635,
                "success_improvement": 0.0,
                "time_improvement": -56.056867916323995,
                "length_improvement": 20.02045457048235,
                "objective_score": -12.81296946080073
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.04121623039245605,
                "num_nodes_avg": 299.1,
                "path_length_avg": 238.03443525744714,
                "success_improvement": 0.0,
                "time_improvement": -188.14394412914302,
                "length_improvement": 21.012121318230268,
                "objective_score": -52.24075897509685
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.04126429557800293,
                "num_nodes_avg": 247.0,
                "path_length_avg": 126.12590632480143,
                "success_improvement": 0.0,
                "time_improvement": -43.81916220508034,
                "length_improvement": 22.55109556414326,
                "objective_score": -8.635529548695448
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e1",
        "algorithm_description": "This new planner integrates a bidirectional anytime RRT* approach with adaptive informed sampling and dynamic tree balancing. It uses a KD-tree for fast nearest neighbor queries and caching for collision checks. The planner incrementally grows two trees from start and goal positions, adaptively shrinking the sampling space based on the current best path cost (informed ellipsoid sampling). Nodes are rewired locally to improve path costs continuously. To enhance robustness and efficiency, periodic pruning removes nodes unlikely to contribute to better paths, and multiple path-smoothing iterations refine the final trajectory. This design achieves faster convergence, improved path quality, and higher success rates in complex 2D and 3D environments.",
        "planning_mechanism": "The planner maintains two trees growing bidirectionally, always extending the smaller tree towards samples biased within an informed ellipsoid based on the best known path cost. It utilizes KD-tree structures to perform efficient nearest neighbor and radius searches for rewiring and node connections, caching collision checks for speed. Upon a successful connection of the two trees, it applies intensive shortcut smoothing. Periodic pruning eliminates suboptimal nodes, thereby focusing the search efficiently and reducing overhead. This mechanism balances exploration with exploitation and dynamically adapts search to promising regions, ensuring high-quality, smooth, and efficient path planning.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checks etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 prune_interval: int = 150, prune_threshold: int = 250,\n                 smoothing_rounds: int = 120,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_rounds = smoothing_rounds\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree for efficient nearest and radius queries\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = np.array([p for p, n in points_nodes])\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, point):\n                if len(self.points) == 0:\n                    return None\n                diff = self.points - np.array(point)\n                dists = np.linalg.norm(diff, axis=1)\n                idx = np.argmin(dists)\n                return self.nodes[idx]\n\n            def radius_search(self, point, radius):\n                if len(self.points) == 0:\n                    return []\n                diff = self.points - np.array(point)\n                dists = np.linalg.norm(diff, axis=1)\n                idxs = np.where(dists <= radius)[0]\n                return [self.nodes[i] for i in idxs]\n\n        # Caches for collision checks for edges\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            rev_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return not edge_collision_cache[rev_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            coll = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = coll\n            return not coll\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        # Informed ellipsoidal sampling\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(15):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) * 0.5 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            # Compute rotation matrix via Householder reflection\n            id_mat = np.eye(dim)\n            e1 = np.zeros(dim)\n            e1[0] = 1.0\n            v = a1 - e1\n            s = np.linalg.norm(v)\n            if s > 1e-10:\n                u = v / s\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1**2 - (c_min / 2)**2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    scaled = x * radii\n                    sample = rot @ scaled + center\n                    point = tuple(float(coord) for coord in sample)\n                    if in_bounds(point) and not is_in_obstacle(point):\n                        return point\n\n            # Fallback uniform\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # last fallback\n\n        # Dynamic neighbor radius based on number of nodes and iteration progress\n        def neighbor_radius(iteration, n_nodes):\n            if n_nodes == 0:\n                return self.step_size * 2\n            r_iter = 50 * (1 - (iteration / self.max_iter) ** 0.95)\n            r_log = self.step_size + 40 * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.step_size, min(r_iter, r_log))\n\n        # Shortcut smoothing for path\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            path = path[:]\n            for _ in range(self.smoothing_rounds):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Prune nodes unlikely to improve best path\n        def prune_nodes(best_cost):\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except Exception:\n                        pass\n                try:\n                    nodes.remove(node)\n                except Exception:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n            return len(to_remove)\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            # Sample adaptive informed points\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Always extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            # Build KD-tree for tree_a for near/nearest queries\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            if nearest_a is None:\n                continue\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                c_tent = node.cost + dist(node.position, new_pos)\n                if c_tent + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = c_tent\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better cost\n            for neighbor in near_nodes_a:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except Exception:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt to connect tree_b to new_node incrementally\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            if nearest_b is None:\n                continue\n\n            last_node_b = nearest_b\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            connection_made = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except Exception:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_smoothing(merged_path)\n\n                    connection_made = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connection_made:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to reduce overhead and focus search\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 20.93857,
        "time_improvement": -84.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.01796424388885498,
                "num_nodes_avg": 78.8,
                "path_length_avg": 160.0910402281309,
                "success_improvement": 0.0,
                "time_improvement": -78.06080972501867,
                "length_improvement": 19.988036808501043,
                "objective_score": -19.420635555805394
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03698420524597168,
                "num_nodes_avg": 249.4,
                "path_length_avg": 237.07282046977184,
                "success_improvement": 0.0,
                "time_improvement": -158.55772516272054,
                "length_improvement": 21.331217637657083,
                "objective_score": -43.30107402128475
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.03332986831665039,
                "num_nodes_avg": 184.0,
                "path_length_avg": 124.12826160044786,
                "success_improvement": 0.0,
                "time_improvement": -16.165165806480026,
                "length_improvement": 23.777769765039213,
                "objective_score": -0.093995788936164
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid algorithm combines the asymptotically optimal rewiring and cost-aware mechanisms from the first algorithm with the efficient bidirectional tree growth and connection strategy of the second algorithm. It adds adaptive radius for rewiring to speed convergence and incorporates path smoothing via shortcutting at the end to enhance path quality and smoothness. The planner attempts to maintain balance between exploration (random sampling) and exploitation (cost optimization and rewiring), improving success rate and reducing search time.",
        "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternating expansions toward randomly sampled collision-free points. Each extension rewires nearby nodes within a dynamically computed radius to optimize path cost, and attempts are made to connect the two trees in a collision-free manner. Upon successful connection, the combined path is extracted, and a post-processing shortcut smoothing step refines the path for smoothness and shorter length.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        # Remove self from old parent's children list if exists\n        if self.parent:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root = Node(goal_position, parent=None, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            dist_val = dist(from_pos, to_pos)\n            if dist_val <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist_val\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def sample_free():\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def collision_free_edge(pos_a, pos_b):\n            return (not self._is_in_obstacle(pos_b, obstacles, is_3d)) and (not self._is_edge_in_obstacle(pos_a, pos_b, obstacles, is_3d))\n\n        def rewire(tree, new_node, radius):\n            neighbors = near_nodes(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-8 < neighbor.cost:\n                    if collision_free_edge(new_node.position, neighbor.position):\n                        neighbor.update_parent(new_node, potential_cost)\n\n        def connect_trees(node_from, tree_other):\n            nearest_other = nearest(tree_other, node_from.position)\n            # Try connecting by incremental steering from nearest_other toward node_from\n            current_pos = nearest_other.position\n            prev_node = nearest_other\n            while True:\n                new_pos = steer(current_pos, node_from.position)\n                if not collision_free_edge(current_pos, new_pos):\n                    return None\n                new_cost = prev_node.cost + dist(prev_node.position, new_pos)\n                new_node = Node(new_pos, parent=prev_node, cost=new_cost)\n                prev_node.add_child(new_node)\n                tree_other.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n\n                if dist(new_pos, node_from.position) <= self.step_size:\n                    # Final connecting node\n                    if collision_free_edge(new_pos, node_from.position):\n                        final_cost = new_node.cost + dist(new_pos, node_from.position)\n                        final_node = Node(node_from.position, parent=new_node, cost=final_cost)\n                        new_node.add_child(final_node)\n                        tree_other.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                prev_node = new_node\n                current_pos = new_pos\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            # Try shortcut smoothing by randomly attempting to connect non-consecutive points directly\n            if len(path) < 3:\n                return path\n            import random\n            max_attempts = max(100, len(path)*5)\n            smoothed = path[:]\n            for _ in range(max_attempts):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed)-3)\n                j = random.randint(i+2, len(smoothed)-1)\n                p1 = smoothed[i]\n                p2 = smoothed[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # shortcut possible -> remove intermediate points\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        for it in range(self.max_iter):\n            sample = sample_free()\n\n            # Alternate tree expansion per iteration for balanced growth\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n\n                if not collision_free_edge(nearest_node.position, new_pos):\n                    continue\n\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Adaptive rewiring radius decreases as number of nodes grows (like RRT*)\n                radius = min(30.0, 50.0 * ((math.log(len(tree_a)+1) / (len(tree_a)+1)) ** 0.5))\n\n                # Rewire near neighbors to improve local path cost\n                rewire(tree_a, new_node, radius)\n\n                # Try connecting to opposite tree and rewire opposite tree nearby nodes on connection\n                connected_node = connect_trees(new_node, tree_b)\n                if connected_node is not None:\n                    # Rewire around connecting node in opposite tree to improve path\n                    rewire(tree_b, connected_node, radius)\n                    success_state = True\n                    extracted_path = extract_path(new_node, connected_node)\n                    # Path smoothing by shortcutting\n                    extracted_path = shortcut_path(extracted_path)\n                    return PlannerResult(success_state, extracted_path, nodes, edges)\n\n        # If no path found after max_iter\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 4.75742,
        "time_improvement": -29.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.014185929298400879,
                "num_nodes_avg": 88.1,
                "path_length_avg": 164.1092800630312,
                "success_improvement": 0.0,
                "time_improvement": -40.6103186531681,
                "length_improvement": 17.979759160317187,
                "objective_score": -8.587143763886992
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.023843717575073243,
                "num_nodes_avg": 242.7,
                "path_length_avg": 242.25516288870887,
                "success_improvement": 0.0,
                "time_improvement": -66.69216857931012,
                "length_improvement": 19.611541096606793,
                "objective_score": -16.085342354471678
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.023023700714111327,
                "num_nodes_avg": 292.3,
                "path_length_avg": 126.42322177324938,
                "success_improvement": 0.0,
                "time_improvement": 19.75509817428814,
                "length_improvement": 22.36852596821227,
                "objective_score": 10.400234645928897
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This planner is an enhanced bidirectional informed RRT* variant integrating adaptive ellipsoidal sampling, KD-tree accelerated nearest neighbor and radius searches, collision caching, incremental rewiring, pruning, and shortcut smoothing to improve efficiency, path quality, robustness, and success rate in both 2D and 3D path planning tasks.",
        "planning_mechanism": "The planner alternates growth between two trees from start and goal, biasing sampling inside an adaptive ellipsoid around the best current path to focus search on promising regions. KD-trees speed up nearest neighbor and local rewiring to optimize costs. It incrementally extends connections, performs collision caching, prunes nodes unlikely to improve best solutions periodically, and applies shortcut smoothing to refine the final path for smoothness and length improvement.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Ellipsoidal informed sampling\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # No solution yet or marginal improvement: uniform sample\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))  # unit vector start->goal\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) * (c_min / 2), 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    x = x * radii\n                    p = rot @ x + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback last sample\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors for cost improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 3.31952,
        "time_improvement": -26.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.010067939758300781,
                "num_nodes_avg": 72.2,
                "path_length_avg": 161.84981114355097,
                "success_improvement": 0.0,
                "time_improvement": 0.207015852309783,
                "length_improvement": 19.109020009395124,
                "objective_score": 3.88390875757196
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.025036144256591796,
                "num_nodes_avg": 208.8,
                "path_length_avg": 234.63653959753782,
                "success_improvement": 0.0,
                "time_improvement": -75.02846046786841,
                "length_improvement": 22.139658054114502,
                "objective_score": -18.080606529537626
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.029380106925964357,
                "num_nodes_avg": 198.1,
                "path_length_avg": 122.48105292818816,
                "success_improvement": 0.0,
                "time_improvement": -2.398994200699506,
                "length_improvement": 24.78925511932657,
                "objective_score": 4.238152763655462
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This algorithm implements a simplified and generalized bidirectional RRT* planner with adaptive informed sampling inside an ellipsoidal region focused between start and goal. It balances exploration and exploitation by alternately growing two trees from the start and goal positions, dynamically adjusting neighbor search radius for efficient rewiring and pruning to maintain manageable complexity. The planner ensures collision-free node placement and edge connection, progressively improves path quality through shortcut path smoothing, and stops once a feasible, smooth path is found or iteration limit is reached.",
        "planning_mechanism": "The planner grows two trees from start and goal by sampling points informed by the current best path cost, steering towards these points while avoiding obstacles and boundaries. It connects nodes via collision-checked edges, rewires nearby nodes for cost improvement, and attempts to connect the two trees incrementally. Upon successful connection, the planner extracts, smooths, and returns the optimized path alongside the explored nodes and edges.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = 5.0\n        self.max_radius = 25.0\n        self.smoothing_iterations = 30\n        self.collision_resolution = 1.0\n        self.goal_sample_rate = 0.2  # probability to sample goal directly\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        import math\n        import random\n        import numpy as np\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            n = max(n_nodes, 1)\n            r_iter = self.max_radius * (1 - (iteration / self.max_iter) ** 0.9)\n            r_log = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.min_radius, min(r_iter, r_log))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance_edge = dist(p1, p2)\n            steps = max(1, int(distance_edge / self.collision_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # Uniform random sampling in bounds (with check)\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            I = np.eye(dim)\n            u = direction - I[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = I - 2 * np.outer(u, u)\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # Fallback uniform sampling\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if sum((a - b) ** 2 for a, b in zip(node.position, point)) <= radius_sq]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not is_edge_in_obstacle(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                q_rand = goal_pos\n            else:\n                q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate expand smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            nearest_a = nearest_node(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if (not in_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            neighbors = near_nodes(tree_a, new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in neighbors:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if improved\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try incremental connection from other tree\n            nearest_b = nearest_node(tree_b, new_node.position)\n            last_b = nearest_b\n            max_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if (not in_bounds(next_pos_b)) or is_in_obstacle(next_pos_b) or is_edge_in_obstacle(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.add_child(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                neighbors_b = near_nodes(tree_b, next_pos_b, r)\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b < neighbor_b.cost and not is_edge_in_obstacle(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and not is_edge_in_obstacle(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.add_child(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_from_start = connection_node.path_from_root()\n                        path_from_goal = new_node.path_from_root()\n                    else:\n                        path_from_start = new_node.path_from_root()\n                        path_from_goal = connection_node.path_from_root()\n\n                    merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                    if final_cost < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                break\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 10.41258,
        "time_improvement": -48.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.006945180892944336,
                "num_nodes_avg": 83.3,
                "path_length_avg": 162.7631822288285,
                "success_improvement": 0.0,
                "time_improvement": 31.159666884080572,
                "length_improvement": 18.652525919836677,
                "objective_score": 13.078405249191508
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.04181349277496338,
                "num_nodes_avg": 336.9,
                "path_length_avg": 243.25230759521227,
                "success_improvement": 0.0,
                "time_improvement": -192.31942395679675,
                "length_improvement": 19.280654748082156,
                "objective_score": -53.839696237422594
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.023754334449768065,
                "num_nodes_avg": 239.2,
                "path_length_avg": 127.34111422002702,
                "success_improvement": 0.0,
                "time_improvement": 17.20860779394743,
                "length_improvement": 21.8048847111195,
                "objective_score": 9.52355928040813
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This algorithm fuses the strengths of bidirectional PRM*-inspired adaptive sampling and balanced RRT* growth to yield an efficient, high-quality planner. It employs dynamic radius rewiring, KD-tree accelerated neighbor searches, and lazy collision checking to minimize expensive operations. Adaptive sampling biases new samples around the current best path corridor and obstacles, while alternating expansions of balanced trees enable rapid convergence. Periodic pruning removes unpromising nodes to maintain tractability. The planner incrementally improves paths by rewiring and applies intensive shortcut smoothing upon solution discovery, optimizing both path length and smoothness with reduced planning time and enhanced robustness across 2D/3D spaces.",
        "planning_mechanism": "The planner initializes two bidirectional trees from start and goal. It adaptively samples points biased around the best path corridor when available, otherwise uniformly, ensuring samples are free and in bounds. Using KD-trees, it efficiently finds neighbors within a dynamic radius based on node count to select parents minimizing costs and to rewire neighbors for local improvements. The planner alternately extends the smaller tree towards new samples, then aggressively tries to connect the opposite tree via iterative steering with collision checks. Lazy collision checking caches edge validations to avoid redundant costly operations. Periodic pruning eliminates dead or unpromising nodes to maintain efficiency. Upon successful connection, it extracts and shortcut-smooths the combined path to optimize length and smoothness before returning the final result.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=6.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, bisect\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos):\n            total_d = dist(from_pos, to_pos)\n            if total_d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / total_d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            val = self.max_neighbor_radius * math.sqrt(math.log(n_nodes)/n_nodes)\n            return max(self.min_neighbor_radius, min(val, self.max_neighbor_radius))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # Lazy collision checking cache for edges\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        # KD-tree like helper for fast nearest and radius query (simple linear for moderate scale)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [p for p,n in points_nodes]\n                self.nodes = [n for p,n in points_nodes]\n                self.dim = dim\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p,n in zip(self.points, self.nodes):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, r):\n                r2 = r*r\n                result = []\n                for p,n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for i in range(self.dim):\n                        delta = p[i] - pt[i]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(n)\n                return result\n\n        # Adaptive sampling biased around best path corridor with Gaussian noise, fallback uniform\n        def adaptive_sample(best_path):\n            if best_path:\n                import numpy as np\n                attempts = 40\n                for _ in range(attempts):\n                    base_point = best_path[random.randint(0, len(best_path)-1)]\n                    noise = np.random.normal(0, self.step_size*1.0, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            # goal bias and uniform fallback\n            if random.random() < self.goal_sample_rate:\n                if random.random() < 0.5:\n                    return goal_pos\n                else:\n                    return start_pos\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # Shortcut smoothing of path via collision-check verified shortcuts\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def extract_path(node):\n            return node.path_from_root()\n\n        def prune_nodes(tree_nodes, best_cost, root_start, root_goal):\n            removed_nodes = 0\n            to_remove = []\n            for node in tree_nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm in to_remove:\n                if rm.parent:\n                    try:\n                        rm.parent.children.remove(rm)\n                    except ValueError:\n                        pass\n                try:\n                    tree_nodes.remove(rm)\n                except ValueError:\n                    pass\n                removed_nodes += 1\n            return removed_nodes\n\n        # Main variables\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        nodes = [root_start, root_goal]\n        edges = []\n\n        best_path = []\n        c_best = float('inf')\n        success_state = False\n        extracted_path = []\n\n        # Main planner loop\n        for it in range(self.max_iter):\n            sample_point = adaptive_sample(best_path)\n\n            # Alternate expanding smaller tree for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(sample_point)\n            new_pos = steer(nearest_a.position, sample_point)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            # Choose parent with minimal cost that can connect\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for nbr in near_nodes:\n                candidate_cost = nbr.cost + dist(nbr.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(nbr.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for possible cost improvements\n            for nbr in near_nodes:\n                if nbr is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                if c_via_new + 1e-12 < nbr.cost and can_connect(new_node.position, nbr.position):\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                    except ValueError:\n                        pass\n                    nbr.update_parent(new_node, c_via_new)\n                    edges.append((new_node, nbr))\n\n            # Attempt to connect opposite tree toward new_node with iterative steering\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_connect_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 5\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes))\n                near_b_nodes = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_b_nodes:\n                    if nbr_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if c_via_new_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    connection_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=connection_cost)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n                    success_state = True\n\n                    # Extract combined path\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if connection_cost + 1e-12 < c_best:\n                        c_best = connection_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning of unpromising nodes to maintain efficiency\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                removed_start = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_goal = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 16.77877,
        "time_improvement": -70.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009657025337219238,
                "num_nodes_avg": 86.4,
                "path_length_avg": 166.61317672450994,
                "success_improvement": 0.0,
                "time_improvement": 4.279981850665,
                "length_improvement": 16.728335675104866,
                "objective_score": 4.629661690220473
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.028910040855407715,
                "num_nodes_avg": 273.7,
                "path_length_avg": 242.09832486199966,
                "success_improvement": 0.0,
                "time_improvement": -102.11099165770764,
                "length_improvement": 19.6635852599355,
                "objective_score": -26.70058044532519
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.06047048568725586,
                "num_nodes_avg": 296.6,
                "path_length_avg": 122.4452129476676,
                "success_improvement": 0.0,
                "time_improvement": -110.75882837344537,
                "length_improvement": 24.811263026402948,
                "objective_score": -28.26539590675302
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This implementation improves the bidirectional RRT* path planner by incorporating an adaptive dynamic goal bias that increases over time to balance exploration and exploitation, uses a caching incremental KD-tree for efficient nearest neighbor queries, performs early termination immediately upon connecting both trees, applies partial rewiring only on promising neighbors to reduce computation, and employs a refined path smoothing method with randomized shortcut attempts for better path quality and smoothness. It constrains sampling within map bounds and aggressively prunes connections that collide with obstacles to maintain robustness and reduce planning time.",
        "planning_mechanism": "The planner grows two trees simultaneously from start and goal states, alternating growth each iteration. It samples points with an adaptive goal bias, finds nearest neighbors efficiently via KD-tree, steers towards sampled points respecting step limits and map boundaries, checks collisions rigorously for nodes and edges, rewires local neighbors to optimize costs selectively, connects trees as soon as possible for early success, reconstructs the combined path, and finally smooths it through randomized shortcutting to produce a shorter and smoother path, thus improving efficiency, robustness, and path quality.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, neighbor_radius_factor: float = 2.5, max_goal_sample_rate: float = 0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius_factor = neighbor_radius_factor  # Multiplier on step_size for neighbor radius \n        self.max_goal_sample_rate = max_goal_sample_rate      # Upper bound for adaptive goal bias\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Adaptive goal sample rate increases up to max_goal_sample_rate over iterations to balance exploration and exploitation\n        def adaptive_goal_sample_rate(iter_idx):\n            ratio = min(iter_idx / (self.max_iter * 0.8), 1.0)\n            return 0.05 + ratio * (self.max_goal_sample_rate - 0.05)\n\n        # KD-Tree approximation with incremental brute-force and caching to speed nearest/near queries\n        class KDTree:\n            def __init__(self):\n                self.nodes = []\n                self.positions = []\n\n            def insert(self, node):\n                self.nodes.append(node)\n                self.positions.append(node.position)\n\n            def nearest(self, point):\n                best_node = None\n                best_dist_sq = float('inf')\n                for node_pos, node in zip(self.positions, self.nodes):\n                    dist_sq = 0.0\n                    for i in range(dim):\n                        diff = node_pos[i] - point[i]\n                        dist_sq += diff * diff\n                        if dist_sq > best_dist_sq:\n                            break\n                    else:\n                        if dist_sq < best_dist_sq:\n                            best_dist_sq = dist_sq\n                            best_node = node\n                return best_node\n\n            def near(self, point, radius):\n                radius_sq = radius * radius\n                neighbors = []\n                for node_pos, node in zip(self.positions, self.nodes):\n                    dist_sq = 0.0\n                    for i in range(dim):\n                        diff = node_pos[i] - point[i]\n                        dist_sq += diff * diff\n                        if dist_sq > radius_sq:\n                            break\n                    else:\n                        neighbors.append(node)\n                return neighbors\n\n        def sample_free(iter_idx):\n            p_goal_sample = adaptive_goal_sample_rate(iter_idx)\n            if random.random() < p_goal_sample:\n                # Direct goal sample with small noise to increase connection chances but avoid duplicates exactly on goal\n                if is_3d:\n                    noise = tuple(random.uniform(-0.1, 0.1) for _ in range(dim))\n                else:\n                    noise = (random.uniform(-0.1, 0.1), random.uniform(-0.1, 0.1)) if dim==2 else tuple(random.uniform(-0.1,0.1) for _ in range(dim))\n                goal_sample = tuple(max(0.0, min(bounds[d], goal_position[d] + noise[d])) for d in range(dim))\n                if not self._is_in_obstacle(goal_sample, obstacles, is_3d):\n                    return goal_sample\n            # Uniform random sample inside bounds with rejection sampling for obstacle avoidance\n            trial = 0\n            max_trials = 100\n            while True:\n                sample = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n                trial += 1\n                if trial > max_trials:\n                    # If stuck, return goal to bias connection\n                    return goal_position\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0.0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        # Initialize trees\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        kd_start = KDTree()\n        kd_goal = KDTree()\n        kd_start.insert(start_root)\n        kd_goal.insert(goal_root)\n\n        neighbor_radius = self.step_size * self.neighbor_radius_factor\n        success_state = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        tree_flag = True  # Toggle tree growing\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n\n            if tree_flag:\n                new_node = self._extend_tree(tree_start, kd_start, rand_point, obstacles, is_3d, nodes, edges,\n                                            in_bounds, steer, neighbor_radius)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n                connect_node = self._connect_tree(tree_goal, kd_goal, new_node.position, obstacles, is_3d, nodes, edges,\n                                                 in_bounds, steer, neighbor_radius)\n                if connect_node is not None:\n                    success_state = True\n                    connection_node_start = new_node\n                    connection_node_goal = connect_node\n                    break\n            else:\n                new_node = self._extend_tree(tree_goal, kd_goal, rand_point, obstacles, is_3d, nodes, edges,\n                                            in_bounds, steer, neighbor_radius)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n                connect_node = self._connect_tree(tree_start, kd_start, new_node.position, obstacles, is_3d, nodes, edges,\n                                                 in_bounds, steer, neighbor_radius)\n                if connect_node is not None:\n                    success_state = True\n                    connection_node_start = connect_node\n                    connection_node_goal = new_node\n                    break\n\n            tree_flag = not tree_flag\n\n        extracted_path = []\n        if success_state:\n            path_start = connection_node_start.path_from_root()\n            path_goal = connection_node_goal.path_from_root()\n            path_goal.reverse()\n            extracted_path = path_start + path_goal\n\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _extend_tree(self, tree, kd_tree, rand_point, obstacles, is_3d, nodes, edges,\n                     in_bounds_fn, steer_fn, neighbor_radius) -> Node:\n        import math\n\n        nearest_node = kd_tree.nearest(rand_point)\n        if nearest_node is None:\n            return None\n\n        new_pos = steer_fn(nearest_node.position, rand_point)\n        if not in_bounds_fn(new_pos):\n            return None\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            return None\n\n        near_nodes = kd_tree.near(new_pos, neighbor_radius)\n\n        min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n        best_parent = nearest_node\n\n        # Limit rewiring checks to subset with cost less than current min_cost + margin to reduce overhead\n        cost_margin = 5.0\n        for near_node in near_nodes:\n            edge_cost = math.dist(near_node.position, new_pos)\n            candidate_cost = near_node.cost + edge_cost\n            if candidate_cost + cost_margin < min_cost:\n                if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = candidate_cost\n                    best_parent = near_node\n\n        new_node = Node(new_pos)\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        kd_tree.insert(new_node)\n\n        # Rewire neighbors only if it reduces cost significantly (>= 1% improvement) to avoid excessive rewiring\n        for near_node in near_nodes:\n            if near_node is best_parent:\n                continue\n            potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n            if potential_cost + 0.01 * near_node.cost < near_node.cost:\n                if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent is not None:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.children.remove(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = potential_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n        return new_node\n\n    def _connect_tree(self, tree, kd_tree, target_pos, obstacles, is_3d, nodes, edges,\n                      in_bounds_fn, steer_fn, neighbor_radius) -> Node:\n        import math\n\n        nearest_node = kd_tree.nearest(target_pos)\n        if nearest_node is None:\n            return None\n\n        current_node = nearest_node\n\n        while True:\n            new_pos = steer_fn(current_node.position, target_pos)\n            if not in_bounds_fn(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            near_nodes = kd_tree.near(new_pos, neighbor_radius)\n            min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n            best_parent = current_node\n\n            for near_node in near_nodes:\n                cost_through_near = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_through_near < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_near\n                        best_parent = near_node\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            kd_tree.insert(new_node)\n\n            # Limited rewiring for efficiency using same cost improvement threshold as _extend_tree\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new + 0.01 * near_node.cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size * 0.5:\n                return new_node\n\n            current_node = new_node\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import random\n        import math\n\n        if len(path) < 3:\n            return path\n\n        smoothed_path = path[:]\n        max_attempts = 50\n        for _ in range(max_attempts):\n            if len(smoothed_path) < 3:\n                break\n            i = random.randint(0, len(smoothed_path) - 3)\n            j = random.randint(i + 2, len(smoothed_path) - 1)\n\n            if not self._is_edge_in_obstacle(smoothed_path[i], smoothed_path[j], obstacles, is_3d):\n                # Remove intermediate points between i and j\n                smoothed_path = smoothed_path[:i+1] + smoothed_path[j:]\n        return smoothed_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 23.64648,
        "time_improvement": -92.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.02005617618560791,
                "num_nodes_avg": 134.2,
                "path_length_avg": 172.3179664823574,
                "success_improvement": 0.0,
                "time_improvement": -98.79595232018453,
                "length_improvement": 13.877136585701205,
                "objective_score": -26.863358378915116
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02918541431427002,
                "num_nodes_avg": 255.4,
                "path_length_avg": 237.94861171987864,
                "success_improvement": 0.0,
                "time_improvement": -104.03613604353662,
                "length_improvement": 21.040600471534994,
                "objective_score": -27.002720718753984
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.05003442764282227,
                "num_nodes_avg": 318.2,
                "path_length_avg": 120.16420656975197,
                "success_improvement": 0.0,
                "time_improvement": -74.38585499172775,
                "length_improvement": 26.211938352579207,
                "objective_score": -17.073368827002483
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "This implementation refines the bidirectional RRT* approach by incorporating informed sampling biased adaptively toward both the start and goal regions to balance between exploration and exploitation. It employs a dynamically shrinking radius for neighborhood rewiring, continually optimizing path costs as nodes are added. The planner grows two trees simultaneously from start and goal, always extending the currently smaller tree to maintain balanced growth. After each extension, an attempt is made to directly connect the two trees to form a feasible path. Periodic pruning of dead-ends and low-potential nodes improves search efficiency. Finally, a robust shortcut smoothing procedure is applied to the extracted path to reduce length and improve smoothness, ensuring collision-free shortcuts. The algorithm improves planning speed, path optimality, and robustness in cluttered environments.",
        "planning_mechanism": "The planner alternates growth between two trees starting from start and goal points. Sampling uses adaptive informed bias toward start and goal. Extension is made by steering towards sampled points with collision checks. Neighboring nodes within a dynamically adaptive radius are rewired to reduce cost locally. After each extension, the planner attempts to directly connect to the opposing tree node, thus quickly identifying feasible paths. Dead nodes and unreachable branches are periodically pruned to enhance efficiency. Extracted paths are smoothed via collision-free shortcuts to ensure minimal length and improved smoothness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float=0.15, radius_const: float = 25.0,\n                 radius_min: float = 5.0, prune_interval: int = 250,\n                 prune_threshold: int = 100, smoothing_iters: int = 40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [n for n in tree if dist(n.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_const * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        # Adaptive Informed Sampling function biased towards start and goal\n        def sample_informed():\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                # Bias toward start or goal with probability split\n                if random.random() < p_goal_bias:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                while True:\n                    if is_3d:\n                        point = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        point = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(point, obstacles, is_3d):\n                        return point\n\n        def add_node(tree, new_parent, new_pos, new_cost):\n            new_node = Node(new_pos, parent=new_parent, cost=new_cost)\n            new_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((new_parent, new_node))\n            return new_node\n\n        def rewire(tree, new_node, radius):\n            near = near_nodes(tree, new_node.position, radius)\n\n            for neighbor in near:\n                if neighbor is new_node.parent:\n                    continue\n                dist_new_neighbor = dist(new_node.position, neighbor.position)\n                cost_via_new = new_node.cost + dist_new_neighbor\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    # Check edge collision\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Check node collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            # Check edge collision\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n\n            near = near_nodes(tree, new_pos, radius)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = add_node(tree, best_parent, new_pos, min_cost)\n            rewire(tree, new_node, radius)\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            current = nearest_node\n\n            while True:\n                new_pos = steer(current.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                    return None\n\n                cost_to_new = current.cost + dist(current.position, new_pos)\n                new_node = add_node(tree, current, new_pos, cost_to_new)\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    # Remove node & edges\n                    if node.parent:\n                        try:\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    try:\n                        nodes.remove(node)\n                    except ValueError:\n                        pass\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    removed.append(node)\n            return removed\n\n        def path_length(path):\n            if len(path) < 2:\n                return 0.0\n            return sum(dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if j <= i:\n                    continue\n                p1, p2 = path[i], path[j]\n                # Check collision free shortcut\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # Apply shortcut\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_informed()\n\n            # Always expand smaller tree\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                full_path = path_start + path_goal[::-1][1:]\n\n                smooth_path = shortcut_path(full_path)\n\n                if path_length(smooth_path) + 1e-10 < path_length(full_path):\n                    extracted_path = smooth_path\n                else:\n                    extracted_path = full_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -0.11103,
        "time_improvement": -13.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.007130169868469238,
                "num_nodes_avg": 83.7,
                "path_length_avg": 160.7808293289118,
                "success_improvement": 0.0,
                "time_improvement": 29.32606414655588,
                "length_improvement": 19.64328684583648,
                "objective_score": 12.72647661313406
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.021118903160095216,
                "num_nodes_avg": 196.9,
                "path_length_avg": 244.9828089725167,
                "success_improvement": 0.0,
                "time_improvement": -47.64290655132469,
                "length_improvement": 18.706415845625372,
                "objective_score": -10.551588796272334
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.03469939231872558,
                "num_nodes_avg": 147.5,
                "path_length_avg": 126.69999612621147,
                "success_improvement": 0.0,
                "time_improvement": -20.938391468987145,
                "length_improvement": 22.19856984232601,
                "objective_score": -1.841803472230942
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid planner integrates bidirectional RRT* tree growth with heuristic-informed ellipsoidal sampling, KD-tree accelerated neighbor searches, incremental rewiring, collision caching, and periodic pruning. It dynamically adapts neighbor radius, focuses sampling to promising regions based on best path cost, and performs post-connection path shortcut smoothing. This combination improves planning efficiency, path optimality, robustness, and success rate in both 2D and 3D environments.",
        "planning_mechanism": "The planner grows two trees from start and goal, alternating extensions toward ellipsoid-biased samples. It uses KD-trees for fast nearest neighbor and radius queries. After extending and rewiring, it attempts to incrementally connect the opposite tree with collision checks assisted by caching. Periodically, it prunes nodes unlikely to improve the current best path, reduces search complexity, and smooths the final path via shortcutting for improved smoothness and length.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...] (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration: int, n_nodes: int) -> float:\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree helper for nearest and radius search (brute force)\n        class KDTree:\n            def __init__(self, points_nodes: List[Tuple[Tuple[float, ...], Node]]):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Ellipsoidal informed sampling\n        def informed_sample(c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1**2 - (c_min / 2) ** 2, 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    x_scaled = x / norm_x * np.random.uniform(0,1)**(1/dim)  # Uniform inside unit ball\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + center\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            # fallback uniform\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # last fallback\n\n        edge_collision_cache = {}\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost: float) -> int:\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_position)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_position, cost=0.0)\n        root_goal = Node(goal_position, cost=0.0)\n        nodes: List[Node] = [root_start, root_goal]\n        edges: List[Tuple[Node, Node]] = []\n        tree_start: List[Node] = [root_start]\n        tree_goal: List[Node] = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_position, goal_position)\n        best_path: List[Tuple[float, ...]] = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_position, goal_position)\n\n            # Alternate tree extension: extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near neighbors\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connect other tree to new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to reduce complexity\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -1.57125,
        "time_improvement": -9.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.01206068992614746,
                "num_nodes_avg": 74.4,
                "path_length_avg": 163.69240063990296,
                "success_improvement": 0.0,
                "time_improvement": -19.54503776385068,
                "length_improvement": 18.188111489161447,
                "objective_score": -2.225889031322914
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.022300076484680176,
                "num_nodes_avg": 198.9,
                "path_length_avg": 230.79387416427326,
                "success_improvement": 0.0,
                "time_improvement": -55.9005258727738,
                "length_improvement": 23.41478444802912,
                "objective_score": -12.087200872226314
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.015093231201171875,
                "num_nodes_avg": 144.4,
                "path_length_avg": 123.69918383264796,
                "success_improvement": 0.0,
                "time_improvement": 47.39530056397553,
                "length_improvement": 24.041249362547966,
                "objective_score": 19.02684004170225
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This improved bidirectional RRT* algorithm integrates adaptive rewiring radius and dynamic parent selection for cost optimization, alternating tree expansion with efficient collision checking, and concludes with a robust path shortcutting step to enhance smoothness and minimize path length. These combined enhancements boost planning efficiency, robustness, success rate, and overall path quality.",
        "planning_mechanism": "The planner grows two trees from start and goal points, alternating expansions toward random collision-free samples. Each new node connects via the lowest cost parent within an adaptive radius, followed by rewiring neighbors to optimize costs. It attempts to connect the trees incrementally, ensuring collision-free edges. Upon connection, the combined path is extracted and refined via shortcut smoothing to produce a shorter, smoother route.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent and self in self.parent.children:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map: 'Map') -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def sample_free() -> Tuple[float, ...]:\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def collision_free_edge(pos_a: Tuple[float, ...], pos_b: Tuple[float, ...]) -> bool:\n            if self._is_in_obstacle(pos_b, obstacles, is_3d):\n                return False\n            return not self._is_edge_in_obstacle(pos_a, pos_b, obstacles, is_3d)\n\n        def rewire(tree: List[Node], new_node: Node, radius: float):\n            neighbors = near_nodes(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-8 < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    neighbor.update_parent(new_node, potential_cost)\n\n        def choose_parent(tree: List[Node], new_pos: Tuple[float, ...], radius: float) -> Tuple[Node, float]:\n            neighbors = near_nodes(tree, new_pos, radius)\n            min_cost = math.inf\n            best_parent = None\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n            if best_parent is None:\n                best_parent = nearest(tree, new_pos)\n                min_cost = best_parent.cost + dist(best_parent.position, new_pos)\n            return best_parent, min_cost\n\n        def connect_trees(node_from: Node, tree_other: List[Node], radius: float) -> Node or None:\n            nearest_other = nearest(tree_other, node_from.position)\n            current_pos = nearest_other.position\n            prev_node = nearest_other\n\n            while True:\n                new_pos = steer(current_pos, node_from.position)\n                if not collision_free_edge(current_pos, new_pos):\n                    return None\n\n                best_parent, new_cost = choose_parent(tree_other, new_pos, radius)\n                new_node = Node(new_pos, parent=best_parent, cost=new_cost)\n                best_parent.children.append(new_node)\n                tree_other.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewire(tree_other, new_node, radius)\n\n                if dist(new_pos, node_from.position) <= self.step_size:\n                    if collision_free_edge(new_pos, node_from.position):\n                        final_cost = new_node.cost + dist(new_pos, node_from.position)\n                        final_node = Node(node_from.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree_other.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                prev_node = new_node\n                current_pos = new_pos\n\n        def extract_path(node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            smoothed = path[:]\n            max_attempts = max(100, len(path)*5)\n            for _ in range(max_attempts):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed)-3)\n                j = random.randint(i+2, len(smoothed)-1)\n                p1 = smoothed[i]\n                p2 = smoothed[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        for iteration in range(self.max_iter):\n            sample = sample_free()\n\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                radius = min(30.0, 50.0 * ((math.log(len(tree_a) + 1) / (len(tree_a) + 1)) ** 0.5))\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n\n                if not collision_free_edge(nearest_node.position, new_pos):\n                    continue\n\n                best_parent, min_cost = choose_parent(tree_a, new_pos, radius)\n                new_node = Node(new_pos, cost=min_cost)\n                best_parent.children.append(new_node)\n                new_node.parent = best_parent\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewire(tree_a, new_node, radius)\n\n                connected_node = connect_trees(new_node, tree_b, radius)\n                if connected_node is not None:\n                    rewire(tree_b, connected_node, radius)\n                    success_state = True\n                    extracted_path = extract_path(new_node, connected_node)\n                    extracted_path = shortcut_path(extracted_path)\n                    return PlannerResult(success_state, extracted_path, nodes, edges)\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 13.55337,
        "time_improvement": -60.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.02235889434814453,
                "num_nodes_avg": 128.6,
                "path_length_avg": 167.2928752970426,
                "success_improvement": 0.0,
                "time_improvement": -121.6203953152029,
                "length_improvement": 16.3886288614737,
                "objective_score": -33.208392822266134
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.027738618850708007,
                "num_nodes_avg": 261.0,
                "path_length_avg": 234.00735959373688,
                "success_improvement": 0.0,
                "time_improvement": -93.92154411580869,
                "length_improvement": 22.34844126548253,
                "objective_score": -23.7067749816461
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.018079710006713868,
                "num_nodes_avg": 194.3,
                "path_length_avg": 120.8423377059049,
                "success_improvement": 0.0,
                "time_improvement": 36.986474392585805,
                "length_improvement": 25.795524983674362,
                "objective_score": 16.255047314510612
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* planner combining adaptive heuristics, incremental KD-tree nearest neighbor search, and prioritized rewiring for improved path planning efficiency and quality. It employs adaptive goal biasing to balance exploration and exploitation, rigorous collision checking for nodes and edges, aggressive pruning to reduce complexity, and randomized shortcut smoothing to improve path smoothness and length. The planner efficiently grows two trees from start and goal, alternating extensions, attempting early connections, and refining paths iteratively to maximize success rate and robustness in complex environments.",
        "planning_mechanism": "The planner initializes two trees at start and goal, alternately sampling points with an adaptive goal bias that increases over iterations to encourage goal-focused exploration. It uses an incremental KD-tree for fast nearest neighbor queries to extend trees towards sampled points, ensures nodes and edges are collision-free, and selectively rewires neighbors with significant cost improvement. Connection attempts are made upon each extension for early path discovery. Once a connection is found, the combined path is extracted and post-processed via randomized shortcut smoothing to produce a high-quality, smooth path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4500, step_size: float = 6.0, neighbor_radius_factor: float = 2.2, max_goal_sample_rate: float = 0.35,\n                 smoothing_attempts: int = 70, collision_check_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.max_goal_sample_rate = max_goal_sample_rate\n        self.smoothing_attempts = smoothing_attempts\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def adaptive_goal_sample_rate(iter_idx):\n            ratio = min(iter_idx / (self.max_iter * 0.8), 1.0)\n            return 0.07 + ratio * (self.max_goal_sample_rate - 0.07)\n\n        class KDTree:\n            def __init__(self):\n                self.nodes = []\n                self.positions = []\n\n            def insert(self, node):\n                self.nodes.append(node)\n                self.positions.append(node.position)\n\n            def nearest(self, point):\n                best_node = None\n                best_dist_sq = float('inf')\n                for node_pos, node in zip(self.positions, self.nodes):\n                    dist_sq = 0.0\n                    for i in range(dim):\n                        diff = node_pos[i] - point[i]\n                        dist_sq += diff * diff\n                        if dist_sq > best_dist_sq:\n                            break\n                    else:\n                        if dist_sq < best_dist_sq:\n                            best_dist_sq = dist_sq\n                            best_node = node\n                return best_node\n\n            def near(self, point, radius):\n                radius_sq = radius * radius\n                neighbors = []\n                for node_pos, node in zip(self.positions, self.nodes):\n                    dist_sq = 0.0\n                    for i in range(dim):\n                        diff = node_pos[i] - point[i]\n                        dist_sq += diff * diff\n                        if dist_sq > radius_sq:\n                            break\n                    else:\n                        neighbors.append(node)\n                return neighbors\n\n        def sample_free(iter_idx):\n            p_goal_sample = adaptive_goal_sample_rate(iter_idx)\n            if random.random() < p_goal_sample:\n                # Sample goal with small noise in bounds to reduce duplicates exactly on goal\n                noise = tuple(random.uniform(-0.08, 0.08) for _ in range(dim))\n                goal_sample = tuple(max(0.0, min(bounds[d], goal_position[d] + noise[d])) for d in range(dim))\n                if not self._is_in_obstacle(goal_sample, obstacles, is_3d):\n                    return goal_sample\n            # Uniform random free sample with rejection\n            trial = 0\n            max_trials = 120\n            while True:\n                sample = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n                trial += 1\n                if trial > max_trials:\n                    return goal_position\n\n        def steer(from_pos, to_pos):\n            dist_val = math.dist(from_pos, to_pos)\n            if dist_val <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist_val\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        success_state = False\n        extracted_path: list = []\n        nodes: list = []\n        edges: list = []\n\n        # Initialize trees\n        root_start = Node(start_position, cost=0.0)\n        root_goal = Node(goal_position, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes.extend([root_start, root_goal])\n\n        kd_start = KDTree()\n        kd_goal = KDTree()\n        kd_start.insert(root_start)\n        kd_goal.insert(root_goal)\n\n        neighbor_radius = self.step_size * self.neighbor_radius_factor\n\n        tree_flag = True  # alternate between start and goal trees\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n\n            if tree_flag:\n                new_node = self._extend_tree(tree_start, kd_start, rand_point, obstacles, is_3d, nodes, edges,\n                                            in_bounds, steer, neighbor_radius)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n                connect_node = self._connect_tree(tree_goal, kd_goal, new_node.position, obstacles, is_3d, nodes, edges,\n                                                 in_bounds, steer, neighbor_radius)\n                if connect_node is not None:\n                    success_state = True\n                    connection_node_start = new_node\n                    connection_node_goal = connect_node\n                    break\n            else:\n                new_node = self._extend_tree(tree_goal, kd_goal, rand_point, obstacles, is_3d, nodes, edges,\n                                            in_bounds, steer, neighbor_radius)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n                connect_node = self._connect_tree(tree_start, kd_start, new_node.position, obstacles, is_3d, nodes, edges,\n                                                 in_bounds, steer, neighbor_radius)\n                if connect_node is not None:\n                    success_state = True\n                    connection_node_start = connect_node\n                    connection_node_goal = new_node\n                    break\n\n            tree_flag = not tree_flag\n\n        if success_state:\n            path_start = connection_node_start.path_from_root()\n            path_goal = connection_node_goal.path_from_root()\n            path_goal.reverse()\n            extracted_path = path_start + path_goal[1:]\n\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _extend_tree(self, tree, kd_tree, rand_point, obstacles, is_3d, nodes, edges,\n                     in_bounds_fn, steer_fn, neighbor_radius) -> 'Node':\n        import math\n\n        nearest_node = kd_tree.nearest(rand_point)\n        if nearest_node is None:\n            return None\n\n        new_pos = steer_fn(nearest_node.position, rand_point)\n        if not in_bounds_fn(new_pos):\n            return None\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_check_resolution):\n            return None\n\n        near_nodes = kd_tree.near(new_pos, neighbor_radius)\n\n        min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n        best_parent = nearest_node\n\n        cost_margin = 4.0  # tighter margin favors more pruning\n\n        for near_node in near_nodes:\n            edge_cost = math.dist(near_node.position, new_pos)\n            candidate_cost = near_node.cost + edge_cost\n            if candidate_cost + cost_margin < min_cost:\n                if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, self.collision_check_resolution):\n                    min_cost = candidate_cost\n                    best_parent = near_node\n\n        new_node = Node(new_pos)\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        kd_tree.insert(new_node)\n\n        # Rewire neighbors only if cost improvement >= 1.5% for efficiency\n        for near_node in near_nodes:\n            if near_node is best_parent:\n                continue\n            potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n            if potential_cost + 0.015 * near_node.cost < near_node.cost:\n                if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, self.collision_check_resolution):\n                    if near_node.parent is not None:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        try:\n                            near_node.parent.children.remove(near_node)\n                        except ValueError:\n                            pass\n                    near_node.parent = new_node\n                    near_node.cost = potential_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n        return new_node\n\n    def _connect_tree(self, tree, kd_tree, target_pos, obstacles, is_3d, nodes, edges,\n                      in_bounds_fn, steer_fn, neighbor_radius) -> 'Node':\n        import math\n\n        nearest_node = kd_tree.nearest(target_pos)\n        if nearest_node is None:\n            return None\n\n        current_node = nearest_node\n\n        while True:\n            new_pos = steer_fn(current_node.position, target_pos)\n            if not in_bounds_fn(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d, self.collision_check_resolution):\n                return None\n\n            near_nodes = kd_tree.near(new_pos, neighbor_radius)\n            min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n            best_parent = current_node\n\n            for near_node in near_nodes:\n                cost_through_near = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_through_near < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, self.collision_check_resolution):\n                        min_cost = cost_through_near\n                        best_parent = near_node\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            kd_tree.insert(new_node)\n\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new + 0.015 * near_node.cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, self.collision_check_resolution):\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size * 0.45:\n                return new_node\n\n            current_node = new_node\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import random\n        if len(path) < 3:\n            return path\n        smoothed_path = path[:]\n        for _ in range(self.smoothing_attempts):\n            if len(smoothed_path) < 3:\n                break\n            i = random.randint(0, len(smoothed_path) - 3)\n            j = random.randint(i + 2, len(smoothed_path) - 1)\n            if not self._is_edge_in_obstacle(smoothed_path[i], smoothed_path[j], obstacles, is_3d, self.collision_check_resolution):\n                smoothed_path = smoothed_path[:i+1] + smoothed_path[j:]\n        return smoothed_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else None\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 11.20692,
        "time_improvement": -50.0,
        "length_improvement": 19.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.01647026538848877,
                "num_nodes_avg": 102.3,
                "path_length_avg": 178.56718444988107,
                "success_improvement": 0.0,
                "time_improvement": -63.25255933981795,
                "length_improvement": 10.753837509871376,
                "objective_score": -16.82500029997111
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.024542832374572755,
                "num_nodes_avg": 212.3,
                "path_length_avg": 235.55877423421785,
                "success_improvement": 0.0,
                "time_improvement": -71.57970181096917,
                "length_improvement": 21.83362940107772,
                "objective_score": -17.107184663075206
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.03325984477996826,
                "num_nodes_avg": 244.1,
                "path_length_avg": 121.42331719442411,
                "success_improvement": 0.0,
                "time_improvement": -15.921111564448342,
                "length_improvement": 25.438768578930336,
                "objective_score": 0.31142024645156585
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This planner combines the best heuristics from the previous two enhanced bidirectional RRT* variants: it employs an adaptive informed ellipse sampling based on the current best path cost to direct sampling efficiently, integrates dynamic radius rewiring to optimize local path costs, and uses lazy collision checking to reduce expensive collision calls while maintaining safety. It alternately grows two balanced trees from start and goal with goal/start bias to maintain exploration-exploitation balance, and applies iterative shortcut smoothing after path extraction to minimize path length and improve smoothness. Periodic pruning removes dead-end or low-potential branches to keep the search focused and computationally efficient, achieving improved planning efficiency, path quality, and success rate.",
        "planning_mechanism": "The planner grows two bidirectional trees alternately with adaptive informed sampling inside ellipses defined by the current best path cost. Each extension attempts to rewire nearby nodes within a dynamically shrinking radius to locally optimize path costs. Lazy collision checking defers edge feasibility checks until necessary to reduce overhead. Upon connecting the trees, the path is extracted and iteratively smoothed through shortcutting. Periodic pruning discards leaves to reduce complexity and enhance robustness and efficiency. The method ensures no nodes or edges cross obstacles or exceed map boundaries.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]: 2D or 3D coordinates\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Path cost from start root\n        self.children = []                # List of child nodes\n        self.valid = True                 # Validity flag for pruning or collision\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def is_leaf(self):\n        return len(self.children) == 0\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 radius_constant: float = 30.0, radius_min: float = 5.0,\n                 prune_interval: int = 250, prune_threshold: int = 120,\n                 smoothing_trials: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                    # Tuple[int,...]\n        start_pos = map.start                # Tuple[float,...]\n        goal_pos = map.goal                  # Tuple[float,...]\n        obstacles = map.obstacles            # List of obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def heuristic(a, b):\n            return math.dist(a, b)\n\n        def dynamic_radius(n):\n            if n == 0:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(r, self.radius_min)\n\n        def steer(from_p, to_p):\n            dist_p = heuristic(from_p, to_p)\n            if dist_p <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist_p\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(len(from_p)))\n\n        def nearest(tree, pt):\n            return min(tree, key=lambda n: heuristic(n.position, pt))\n\n        def near_nodes(tree, pos, radius):\n            rad_sq = radius * radius\n            return [n for n in tree if sum((n.position[d] - pos[d]) ** 2 for d in range(len(pos))) <= rad_sq]\n\n        # Informed ellipse sampling between start and goal with cost_best\n        def informed_sample(cost_best):\n            if cost_best == float('inf'):\n                # Uniform sampling with goal/start bias\n                p_goal_bias = 0.75\n                if random.random() < self.goal_sample_rate:\n                    return goal_pos if random.random() < p_goal_bias else start_pos\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            else:\n                c_min = heuristic(start_pos, goal_pos)\n                c_best = max(cost_best, c_min * 1.0001)  # safeguard numerical stability\n                center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(len(start_pos)))\n                vec = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(len(start_pos)))\n\n                # Build rotation matrix C and axis lengths L based on dimension\n                try:\n                    import numpy as np\n                except ImportError:\n                    # Fallback: uniform random in bounding box if numpy unavailable\n                    while True:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                        if not self._is_in_obstacle(sample, obstacles, is_3d):\n                            return sample\n\n                dim = len(start_pos)\n                L_diag = [c_best / 2] + [math.sqrt(c_best ** 2 - c_min ** 2) / 2] * (dim - 1)\n                L = np.diag(L_diag)\n                e1 = np.array(vec)\n                e1 /= np.linalg.norm(e1)\n\n                if dim == 2:\n                    e2 = np.array([-e1[1], e1[0]])\n                    C = np.column_stack((e1, e2))\n                else:\n                    a = np.array([1.0, 0.0, 0.0])\n                    if abs(np.dot(a, e1)) > 0.9:\n                        a = np.array([0.0, 1.0, 0.0])\n                    v2 = a - np.dot(a, e1) * e1\n                    v2 /= np.linalg.norm(v2)\n                    v3 = np.cross(e1, v2)\n                    C = np.column_stack((e1, v2, v3))\n\n                while True:\n                    sample_ball = np.random.uniform(-1, 1, dim)\n                    norm_ball = np.linalg.norm(sample_ball)\n                    if norm_ball > 1.0:\n                        continue\n                    sample_ellipse = np.dot(C, np.dot(L, sample_ball)) + np.array(center)\n                    sample_t = tuple(sample_ellipse)\n                    if all(0 <= sample_t[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        # With goal/start bias inside ellipse\n                        if random.random() < self.goal_sample_rate:\n                            return goal_pos if random.random() < 0.5 else start_pos\n                        return sample_t\n\n        lazy_checked_edges = dict()  # {(node_id, pos): bool}\n\n        def can_connect(node, pos):\n            key = (id(node), pos)\n            if key in lazy_checked_edges:\n                return lazy_checked_edges[key]\n            valid = (not self._is_edge_in_obstacle(node.position, pos, obstacles, is_3d)) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n            lazy_checked_edges[key] = valid\n            return valid\n\n        # Extend a tree toward sample_pt with rewiring and lazy collision checking\n        def try_extend(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if not can_connect(nearest_node, new_pos):\n                return None\n\n            r = dynamic_radius(len(tree))\n            near = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + heuristic(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + heuristic(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper via new_node\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + heuristic(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        # Attempt to connect tree toward node by incremental steps with collision checks\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + heuristic(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if heuristic(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d) and not self._is_in_obstacle(node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + heuristic(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        # Prune leaf nodes to reduce tree complexity and focus search\n        def prune_dead_branches():\n            removed = []\n            for node in nodes[:]:\n                if node.is_leaf() and node is not start_root and node is not goal_root:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smooth_path = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth_path) < 3:\n                    break\n                i = random.randint(0, len(smooth_path) - 3)\n                j = random.randint(i + 2, len(smooth_path) - 1)\n                p_i, p_j = smooth_path[i], smooth_path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    del smooth_path[i + 1:j]\n            return smooth_path\n\n\n        best_path_cost = float('inf')\n        best_path = []\n\n        # Alternate growing trees and bias sampling inside ellipses per current best cost\n        tree_turn = 0\n        for itr in range(self.max_iter):\n            sample_pt = informed_sample(best_path_cost)\n\n            # Alternate to extend smaller tree to balance exploration\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node = try_extend(tree_start, sample_pt)\n            if new_node is None:\n                tree_turn = 1 - tree_turn\n                continue\n\n            connect_node = try_connect(tree_goal, new_node)\n            if connect_node:\n                success = True\n                path_start = new_node.path_from_root()\n                path_goal = connect_node.path_from_root()\n                candidate_path = path_start + path_goal[::-1][1:]\n                candidate_cost = sum(heuristic(candidate_path[i], candidate_path[i + 1]) for i in range(len(candidate_path) - 1))\n                if candidate_cost < best_path_cost:\n                    best_path_cost = candidate_cost\n                    best_path = candidate_path\n\n                # Immediate shortcut smoothing after connection to accelerate convergence\n                best_path = shortcut_path(best_path)\n                best_path_cost = sum(heuristic(best_path[i], best_path[i + 1]) for i in range(len(best_path) - 1))\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to keep trees efficient\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_branches()\n\n            tree_turn = 1 - tree_turn\n\n        # In case no connection was made but nodes exist, attempt smoothing on last best found path\n        if success and not extracted_path and best_path:\n            extracted_path = shortcut_path(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 26.15628,
        "time_improvement": -101.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009508776664733886,
                "num_nodes_avg": 91.5,
                "path_length_avg": 160.25734497796296,
                "success_improvement": 0.0,
                "time_improvement": 5.749416290918719,
                "length_improvement": 19.904919292972554,
                "objective_score": 5.705808745870127
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.030540037155151366,
                "num_nodes_avg": 198.4,
                "path_length_avg": 243.74410876682495,
                "success_improvement": 0.0,
                "time_improvement": -113.50634630930652,
                "length_improvement": 19.11745848096694,
                "objective_score": -30.22841219659857
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.08465938568115235,
                "num_nodes_avg": 203.1,
                "path_length_avg": 125.61299415101368,
                "success_improvement": 0.0,
                "time_improvement": -195.06481937742487,
                "length_improvement": 22.866054537198142,
                "objective_score": -53.946234905787826
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This enhanced hybrid bidirectional RRT* planner uses adaptive goal biasing to dynamically balance exploration and exploitation. It always extends the smaller of two trees rooted at start and goal to promote balanced growth. Nearest neighbor searches are accelerated with KDTree when available, and adaptive radius rewiring shrinks with node count to enhance convergence speed. Collision checks are aggressively early-pruned. Upon connection, path reconstruction is followed by an efficient shortcut smoothing pass to reduce unnecessary waypoints. Post-success, pruning removes orphan nodes to keep tree complexity low. These optimizations collectively reduce planning time while improving path quality, smoothness, success rate, and robustness.",
        "planning_mechanism": "The planner initializes two trees and iteratively samples either near the goal or uniformly in the free space based on an adaptively tuned goal bias. Each iteration extends the smaller tree toward the sampled point with fixed step steering and validates new nodes and edges with obstacle collision checks. Local rewiring optimizes costs within an adaptive radius computed from the current node count. After each successful extension, the planner attempts to connect the opposite tree toward the new node to form a complete path. Upon connection, the merged path undergoes shortcut smoothing, and the trees prune unreachable nodes for efficiency. The final path is returned along with all explored nodes and edges.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate_start: float = 0.1, goal_sample_rate_end: float = 0.4,\n                 radius_constant: float = 25.0, radius_min: float = 2.0,\n                 kd_tree_leafsize: int = 40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = goal_sample_rate_start\n        self.goal_sample_rate_end = goal_sample_rate_end\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.kd_tree_leafsize = kd_tree_leafsize  # leafsize tuning for KDTree optimization\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        try:\n            from scipy.spatial import cKDTree as KDTree\n        except ImportError:\n            KDTree = None\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def sample_free(iteration: int) -> Tuple[float, ...]:\n            # Adaptive goal bias increases linearly from start to end rate\n            goal_bias = (self.goal_sample_rate_end - self.goal_sample_rate_start) * (iteration / self.max_iter) + self.goal_sample_rate_start\n            r = random.random()\n            if r < goal_bias:\n                # Weighted bias: 85% goal point, 15% start point to favor connection\n                return goal_position if random.random() < 0.85 else start_position\n            else:\n                for _ in range(40):\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return start_position  # fallback\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def radius_by_nodes(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(self.radius_min, val)\n\n        def build_kdtree(tree: List[Node]):\n            if KDTree is None or not tree:\n                return None\n            pts = [node.position for node in tree]\n            return KDTree(pts, leafsize=self.kd_tree_leafsize)\n\n        def nearest(tree: List[Node], kdtree, point: Tuple[float, ...]) -> Node:\n            if kdtree:\n                dist_, idx = kdtree.query(point)\n                return tree[idx]\n            else:\n                return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree: List[Node], kdtree, pos: Tuple[float, ...], radius: float) -> List[Node]:\n            if kdtree:\n                idxs = kdtree.query_ball_point(pos, radius)\n                return [tree[i] for i in idxs]\n            else:\n                r2 = radius * radius\n                return [node for node in tree if (dist(node.position, pos) <= radius)]\n\n        def try_extend(tree: List[Node], kdtree, point: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, kdtree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            # Early collision check: new node position\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            # Edge collision check\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, kdtree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            # Find lowest cost parent within radius\n            for node in neighbors:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost + 1e-12 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            best_parent.children.append(new_node)\n            new_node.parent = best_parent\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Batch rewiring neighbors through new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_thru_new + 1e-12 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.children.remove(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, cost_thru_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree: List[Node], kdtree, node: Node) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, kdtree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    # Final segment collision check\n                    if (not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d) and\n                            not self._is_in_obstacle(node.position, obstacles, is_3d)):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def smooth_path(path: List[Tuple[float, ...]], max_trials: int = 150) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if j >= len(path):\n                    continue\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        from collections import deque\n\n        def prune_redundant_nodes(tree: List[Node]):\n            if not tree:\n                return\n            root = tree[0]\n            queue = deque([root])\n            visited = set()\n            while queue:\n                cur = queue.popleft()\n                visited.add(cur)\n                for c in cur.children:\n                    if c not in visited:\n                        queue.append(c)\n            to_remove = [node for node in tree if node not in visited]\n            for node in to_remove:\n                try:\n                    tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n                except ValueError:\n                    pass\n\n        # Cache goal bias per iteration for efficiency\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n\n            # Always extend smaller tree for balance and efficiency\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            kdtree_start = build_kdtree(tree_start)\n            kdtree_goal = build_kdtree(tree_goal)\n\n            new_node_start = try_extend(tree_start, kdtree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, kdtree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                # Concatenate paths without duplicating the connection node\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                # Shortcut smoothing to improve path quality and reduce length\n                extracted_path = smooth_path(merged_path, max_trials=150)\n\n                # Prune unreachable nodes to reduce memory and speed subsequent operations\n                prune_redundant_nodes(tree_start)\n                prune_redundant_nodes(tree_goal)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool, resolution: float = 1.0) -> bool:\n        import math\n        distance = math.dist(from_pos, to_pos)\n        if distance == 0.0:\n            return self._is_in_obstacle(from_pos, obstacles, is_3d)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 0.15869,
        "time_improvement": -14.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.012440872192382813,
                "num_nodes_avg": 74.6,
                "path_length_avg": 161.6920486685267,
                "success_improvement": 0.0,
                "time_improvement": -23.313387970393908,
                "length_improvement": 19.18786817807873,
                "objective_score": -3.1564427555024257
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.021274399757385255,
                "num_nodes_avg": 262.8,
                "path_length_avg": 239.0558381698273,
                "success_improvement": 0.0,
                "time_improvement": -48.729988082439526,
                "length_improvement": 20.6731852763041,
                "objective_score": -10.484359369471036
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.020455050468444824,
                "num_nodes_avg": 223.5,
                "path_length_avg": 125.78227205147036,
                "success_improvement": 0.0,
                "time_improvement": 28.707659248093563,
                "length_improvement": 22.76210770884545,
                "objective_score": 13.164719316197157
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "This implementation enhances the bidirectional RRT* with an improved adaptive sampling strategy focusing more strongly near the optimal connection frontier, a refined dynamic and decaying rewiring radius tuned to minimize path length, and intelligent mutual rewiring of nodes across both trees for further cost reduction. It includes balanced tree growth, rigorous collision checks for nodes and edges, and aggressive pruning of dead-end nodes to keep the tree lean. The path shortcutting uses a multiscale random shortcut approach iteratively improving smoothness and total path length. These optimizations collectively improve planning efficiency, robustness, success rate, and ensure smoother, shorter paths in both 2D and 3D settings.",
        "planning_mechanism": "The planner grows two trees from start and goal, always extending the smaller tree first to maintain balanced exploration. Sampling switches adaptively between goal bias, start bias, and focused exploration near the trees' connection midpoints with increased probability as iterations progress. Each extension uses a dynamic, decaying radius for rewiring neighbors, optimizing paths locally. After extending one tree, the planner attempts to connect and rewire the opposite tree toward the new node. Periodic pruning removes nodes that do not contribute to solution progress. Upon successful connection, advanced multiscale path shortcutting and smoothing reduces the final path length and enhances smoothness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 3.0, prune_interval: int = 200,\n                 prune_threshold: int = 100, smoothing_iterations: int = 40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            new_pos = tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n            # Clamp within bounds\n            clamped = tuple(max(0, min(bounds[i], new_pos[i])) for i in range(dim))\n            return clamped\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, position) ** 2) <= radius_sq]\n\n        def radius_by_nodes_and_iter(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt(math.log(n_nodes) / n_nodes)\n            # Steeper decay with iterations to focus rewiring locally over time\n            decay_factor = math.exp(-7 * itr / self.max_iter)\n            radius = max(self.radius_min, base * decay_factor)\n            return radius\n\n        def is_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr):\n            # Adaptive heuristic sampling:\n            # Early iterations: bias strong towards goal and start\n            # Later iterations: focus exploration near midpoints of start & goal trees,\n            # and randomly sample free space less often\n            r = random.random()\n            n_start, n_goal = len(tree_start), len(tree_goal)\n            max_nodes = max(1, n_start + n_goal)\n\n            if r < self.goal_sample_rate:\n                r2 = random.random()\n                # Sample goal for convergence and start for diversification\n                if r2 < 0.65 and is_free_node(goal_position):\n                    return goal_position\n                elif r2 < 0.8 and is_free_node(start_position):\n                    return start_position\n                else:\n                    # Exploration near promising region (midpoints)\n                    if n_start > 15 and n_goal > 15:\n                        # Weight shrinkage of spread over iterations, less spread later\n                        spread = self.step_size * 4 * (1 - itr / self.max_iter)\n                        # Randomly pick pairs of nodes from both trees to find midpoints\n                        for _ in range(5):\n                            mid_s = random.choice(tree_start).position\n                            mid_g = random.choice(tree_goal).position\n                            mid = tuple((mid_s[i] + mid_g[i]) * 0.5 for i in range(dim))\n                            candidate = tuple(\n                                max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim)\n                            )\n                            if is_free_node(candidate):\n                                return candidate\n            # Fallback: uniform sampling in free space, limit attempts to avoid infinite loops\n            attempts = 0\n            while attempts < 150:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n                attempts += 1\n            return start_position\n\n        def try_extend(tree, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (not is_free_node(new_pos)) or (not is_free_edge(nearest_node.position, new_pos)):\n                return None\n\n            radius = radius_by_nodes_and_iter(len(tree), itr)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node, itr):\n            if not tree:\n                return None\n\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if (not is_free_node(new_pos)) or (not is_free_edge(last_node.position, new_pos)):\n                    return None\n\n                radius = radius_by_nodes_and_iter(len(tree), itr)\n                near = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in near:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-10 < min_cost:\n                        if is_free_edge(node.position, new_pos):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors for better costs\n                for neighbor in near:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-10 < neighbor.cost:\n                        if is_free_edge(new_node.position, neighbor.position):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if is_free_edge(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample = adaptive_sample(itr)\n\n            # Balanced tree growth: extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start, itr)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                shortcuted_path = shortcut_path(raw_path)\n                smoothed_path = smooth_path(shortcuted_path)\n\n                candidates = [raw_path, shortcuted_path, smoothed_path]\n                extracted_path = min(candidates, key=path_length)\n                break\n\n            # Periodic pruning to improve performance\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return type('PlannerResult', (), {})() if not success_state else \\\n            PlannerResult(\n                success=success_state,\n                path=extracted_path,\n                nodes=nodes,\n                edges=edges,\n            )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 3.03871,
        "time_improvement": -25.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.014606857299804687,
                "num_nodes_avg": 80.6,
                "path_length_avg": 161.9568680423742,
                "success_improvement": 0.0,
                "time_improvement": -44.782538827288285,
                "length_improvement": 19.055514000340313,
                "objective_score": -9.623658848118422
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.024406075477600098,
                "num_nodes_avg": 193.3,
                "path_length_avg": 230.43062073533875,
                "success_improvement": 0.0,
                "time_improvement": -70.62363010559125,
                "length_improvement": 23.535324225160036,
                "objective_score": -16.480024186645366
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.016912388801574706,
                "num_nodes_avg": 153.0,
                "path_length_avg": 124.81614388456349,
                "success_improvement": 0.0,
                "time_improvement": 41.0549591539453,
                "length_improvement": 23.355368603866236,
                "objective_score": 16.987561466956834
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e1",
        "algorithm_description": "This algorithm is an informed bidirectional RRT* variant leveraging heuristics to guide sampling within an informed ellipsoidal subset, which updates dynamically as better solutions are found. It incorporates rewiring for path optimality, a heuristic cost-to-go function to focus exploration, and lazy collision checking to reduce collision tests required. By restricting samples to a progressively shrinking ellipsoid around the current best path, it improves planning efficiency, path quality, and success rate while reducing search time and path length.",
        "planning_mechanism": "The planner grows two trees from start and goal positions bidirectionally. After the initial feasible path is found, the sampling space shrinks to an ellipsoid defined by the best cost so far. Iteratively, new samples are drawn from this ellipsoid, new nodes are extended and rewired for optimality, and attempts are made to connect the two trees. The algorithm terminates early upon reaching max iterations or converging to a near-optimal path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        new_parent.children.append(self)\n        self.cost = new_cost\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius  # rewiring radius\n\n    def plan(self, map) -> PlannerResult:\n        import random, math\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def line_cost(a, b):\n            return dist(a, b)\n\n        def heuristic_cost(node_pos):\n            # Estimated cost from node to goal (Euclidean)\n            return dist(node_pos, goal_position)\n\n        # Initialize trees\n        tree_start = [Node(start_position, cost=0.0)]\n        tree_goal = [Node(goal_position, cost=0.0)]\n        nodes = tree_start + tree_goal\n        edges = []\n        success_state = False\n        best_cost = float('inf')\n        best_connection = (None, None)\n        extracted_path = []\n\n        # Initial sampling bounds\n        lower_bounds = [0.0]*len(bounds)\n        upper_bounds = list(bounds)\n\n        # After initial solution, sample from ellipsoidal informed region\n        def sample_in_ellipsoid(c_best, c_min, start, goal):\n            # If no solution yet, uniform sample\n            if c_best == float('inf'):\n                while True:\n                    if is_3d:\n                        pt = tuple(random.uniform(lower_bounds[i], upper_bounds[i]) for i in range(3))\n                    else:\n                        pt = tuple(random.uniform(lower_bounds[i], upper_bounds[i]) for i in range(2))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n            # Sample from ellipsoid\n            # Reference: Informed RRT* (Gammell et al. 2014)\n            c = c_best\n            c_min = max(c_min, 1e-10)  # Avoid divide by zero\n\n            center = tuple((start[i] + goal[i]) / 2 for i in range(len(start)))\n            dist_start_goal = c_min\n\n            # Create rotation matrix from unit vector from start->goal\n            import numpy as np\n            a1 = np.array(goal) - np.array(start)\n            a1 = a1 / np.linalg.norm(a1)\n\n            dim = len(start)\n            id_matrix = np.eye(dim)\n            M = np.outer(a1, id_matrix[0])\n            U, _, VT = np.linalg.svd(M)\n            C = U @ np.diag([1] + [1]*(dim - 1)) @ VT\n\n            # Define ellipse axes lengths\n            r1 = c / 2.0\n            r2 = math.sqrt(c**2 - c_min**2) / 2.0\n            r = [r1] + [r2]*(dim-1)\n\n            while True:\n                # Sample unit ball\n                x = self._sample_unit_ball(dim)\n                # Scale\n                rand_ellipsoid = C @ (np.multiply(r, x)) + np.array(center)\n                pt = tuple(rand_ellipsoid.tolist())\n                if all(lower_bounds[i] <= pt[i] <= upper_bounds[i] for i in range(dim)):\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n\n        # Helpers for connecting and rewiring\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def steer(from_pos, to_pos, step_size=self.step_size):\n            d = dist(from_pos, to_pos)\n            if d <= step_size:\n                return to_pos\n            ratio = step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        # Extract final path by connecting two nodes from each tree\n        def extract_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        c_min = dist(start_position, goal_position)\n        c_best = float('inf')\n\n        for iter_i in range(self.max_iter):\n            rand_point = sample_in_ellipsoid(c_best, c_min, start_position, goal_position)\n            # Alternate trees per iteration for symmetry and better exploration\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                nearest = nearest_node(tree_a, rand_point)\n                new_pos = steer(nearest.position, rand_point)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Choose parent with minimum cost for new node (RRT* style)\n                near = near_nodes(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + line_cost(nearest.position, new_pos)\n                min_parent = nearest\n                for node_near in near:\n                    cost_near = node_near.cost + line_cost(node_near.position, new_pos)\n                    if cost_near < min_cost and not self._is_edge_in_obstacle(node_near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_near\n                        min_parent = node_near\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewiring\n                for node_near in near:\n                    if node_near == min_parent:\n                        continue\n                    new_cost = new_node.cost + line_cost(new_node.position, node_near.position)\n                    if new_cost < node_near.cost and not self._is_edge_in_obstacle(new_node.position, node_near.position, obstacles, is_3d):\n                        node_near.update_parent(new_node, new_cost)\n                        # Update edges\n                        try:\n                            edges.remove((node_near.parent, node_near))\n                        except ValueError:\n                            pass\n                        edges.append((new_node, node_near))\n\n                # Attempt to connect the other tree\n                nearest_other = nearest_node(tree_b, new_node.position)\n                dist_connect = dist(new_node.position, nearest_other.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                        # Connection found\n                        # Check if new path cost is better than best\n                        new_path_cost = new_node.cost + nearest_other.cost + dist_connect\n                        if new_path_cost < best_cost:\n                            best_cost = new_path_cost\n                            best_connection = (new_node, nearest_other)\n                            success_state = True\n\n            # Early exit if found solution and iterations limit is high\n            if success_state and iter_i > self.max_iter // 10:\n                break\n\n        if success_state and best_connection[0] and best_connection[1]:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n\n            # Optional: path smoothing via shortcutting\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_unit_ball(self, dim):\n        # Sample uniformly from unit ball in dim dimensions using Normal deviate method\n        import random, math\n        import numpy as np\n        vec = np.random.normal(0, 1, dim)\n        norm = np.linalg.norm(vec)\n        if norm == 0:\n            return self._sample_unit_ball(dim)  # Resample if zero vector\n        u = random.uniform(0, 1) ** (1/dim)\n        return (vec / norm) * u\n\n    def _smooth_path(self, path, obstacles, is_3d, max_iterations=100):\n        # Attempt shortcut smoothing to reduce unnecessary waypoints\n        import random\n        if len(path) < 3:\n            return path[:]\n        path = path[:]\n        for _ in range(max_iterations):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) -1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Remove intermediate points\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 192.63386,
        "time_improvement": -660.0,
        "length_improvement": 26.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.14361586570739746,
                "num_nodes_avg": 654.6,
                "path_length_avg": 152.4381496261331,
                "success_improvement": 0.0,
                "time_improvement": -1323.5142595165848,
                "length_improvement": 23.81287797564601,
                "objective_score": -392.29170225984626
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.06920173168182372,
                "num_nodes_avg": 538.0,
                "path_length_avg": 225.0003956901418,
                "success_improvement": 0.0,
                "time_improvement": -383.79145102549353,
                "length_improvement": 25.337256607845855,
                "objective_score": -110.0699839860789
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.10662848949432373,
                "num_nodes_avg": 706.9,
                "path_length_avg": 114.3997038803127,
                "success_improvement": 0.0,
                "time_improvement": -271.6341164064778,
                "length_improvement": 29.751690263379388,
                "objective_score": -75.53989686926747
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid planner combines the adaptive ellipsoidal informed sampling and KD-tree accelerated nearest neighbor and radius searches from Algorithm No.1 with the pruning, incremental rewiring, and shortcut smoothing strategies from both algorithms. It grows two bidirectional trees alternately, focusing sampling inside an adaptive informed ellipsoid around the current best path, while efficiently querying neighbors via KD-tree for rewiring and cost optimization. Collision caching avoids redundant checks. Nodes unlikely to improve the best found path are pruned periodically to reduce search complexity. Final extracted paths are shortcut-smoothed for improved smoothness and length, balancing exploration and exploitation to enhance planning efficiency, robustness, and path quality in both 2D and 3D environments.",
        "planning_mechanism": "The planner alternates between extending two trees rooted at start and goal using adaptive ellipsoidal informed sampling to bias search toward promising regions. It applies KD-tree for fast nearest neighbor and radius queries to enable efficient incremental rewiring to minimize path cost. It uses collision caching for rapid collision checks. Periodic pruning removes nodes that cannot yield better solutions. Upon connecting the trees, the merged path is shortcut-smoothed to improve smoothness and shorten length. This combination accelerates convergence, improves robustness against obstacles, and enhances final path quality and success rate.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / self.collision_check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return True\n            return False\n\n        # KDTree helper for fast neighbor search\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Collision cache for edges\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))  # unit vector start->goal\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1 * r1 - (c_min / 2) * (c_min / 2), 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    x = x * radii\n                    p = rot @ x + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback last sample\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            to_remove = []\n            for node in nodes:\n                if node is root_start or node is root_goal:\n                    continue\n                heuristic = dist(node.position, goal_position)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n\n        root_start = Node(start_position, cost=0.0)\n        root_goal = Node(goal_position, cost=0.0)\n        nodes = [root_start, root_goal]\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_position, goal_position)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_position, goal_position)\n\n            # Alternate expanding smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cost improvement\n            for neighbor in near_nodes_a:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_nodes_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -5.82745,
        "time_improvement": 6.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009006142616271973,
                "num_nodes_avg": 74.4,
                "path_length_avg": 169.31553680965735,
                "success_improvement": 0.0,
                "time_improvement": 10.731503275387798,
                "length_improvement": 15.377722078273504,
                "objective_score": 6.294995398271039
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.021878266334533693,
                "num_nodes_avg": 214.5,
                "path_length_avg": 235.5728362397851,
                "success_improvement": 0.0,
                "time_improvement": -52.95163803951964,
                "length_improvement": 21.828963151891685,
                "objective_score": -11.519698781477555
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.011098408699035644,
                "num_nodes_avg": 124.4,
                "path_length_avg": 127.74409591233731,
                "success_improvement": 0.0,
                "time_improvement": 61.318524439909226,
                "length_improvement": 21.557429676015406,
                "objective_score": 22.707043267175848
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "This planner is an optimized bidirectional informed RRT* variant integrating adaptive ellipsoidal sampling, KD-tree accelerated nearest neighbor searches, collision caching, incremental rewiring, pruning of non-promising nodes, and shortcut smoothing. It is tuned to improve planning efficiency, success rate, path smoothness, and quality in both 2D and 3D environments.",
        "planning_mechanism": "The planner grows two trees alternately from start and goal positions, sampling adaptively within an ellipsoidal region around the best path found so far to focus exploration on promising regions. KD-trees speed nearest neighbor and radius searches for rewiring and optimization. Collision checks are cached to reduce redundant computations. The planner periodically prunes nodes unlikely to improve the current best solution and applies aggressive shortcut smoothing to refine the final path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision or pruning state\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Ellipsoidal informed sampling with fallback uniform sampling\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                # Goal bias & uniform sampling when no good solution\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))  # unit vector start->goal\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) * (c_min / 2), 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    x = x * radii\n                    p = rot @ x + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            # Fallback uniform sampling if ellipsoid samples fail\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth direction based on tree sizes for balanced expansion\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring near neighbors for cost improvement with collision caching\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Prune nodes periodically for efficiency if sufficient nodes and improvement found\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 2.74527,
        "time_improvement": -24.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.007837724685668946,
                "num_nodes_avg": 76.0,
                "path_length_avg": 159.82318526489865,
                "success_improvement": 0.0,
                "time_improvement": 22.312811350896585,
                "length_improvement": 20.121908144637402,
                "objective_score": 10.718225034196456
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02756030559539795,
                "num_nodes_avg": 239.4,
                "path_length_avg": 238.00382583687002,
                "success_improvement": 0.0,
                "time_improvement": -92.6749506212966,
                "length_improvement": 21.022278559540542,
                "objective_score": -23.598029474480875
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.028953123092651366,
                "num_nodes_avg": 191.9,
                "path_length_avg": 122.81180579728087,
                "success_improvement": 0.0,
                "time_improvement": -0.9108200704491538,
                "length_improvement": 24.58615293281559,
                "objective_score": 4.643984565428372
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This algorithm combines the strengths of both provided planners by implementing an informed, bidirectional RRT* with adaptive informed ellipse sampling, dynamic goal biasing, and efficient KDTree-based neighbor searches. It incorporates lazy collision checking to minimize overhead, batch rewiring for local cost improvements, and periodic pruning of low-quality or dead-end branches to focus computational effort on promising paths. Upon connection, the path is shortcut-smoothed to reduce jaggedness and improve path quality. The architecture balances exploration with exploitation to enhance success rate, reduce planning time, and produce shorter, smoother paths.",
        "planning_mechanism": "The planner grows two trees bidirectionally from start and goal, sampling points within an adaptively shaped ellipsoidal heuristic informed region. Each iteration attempts to extend the smaller tree first toward the sampled point, selecting parents and rewiring neighbors within an adaptive radius using KDTree for efficient queries. Lazy collision checks delay expensive verifications until necessary. When a connection between trees is formed, the path is extracted, smoothed through shortcutting, and the planner prunes unpromising nodes periodically. This results in efficient convergence, improved path quality, and reduced computational time.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def is_leaf(self):\n        return len(self.children) == 0\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate_start=0.15, goal_sample_rate_end=0.4,\n                 radius_constant: float = 25.0, radius_min: float = 3.0,\n                 prune_interval: int = 250, prune_threshold: int = 200,\n                 shortcut_trials: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = goal_sample_rate_start\n        self.goal_sample_rate_end = goal_sample_rate_end\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.shortcut_trials = shortcut_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        from collections import deque\n\n        try:\n            from scipy.spatial import cKDTree as KDTree\n        except ImportError:\n            KDTree = None\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        # Initialize trees\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def dist_sq(a,b):\n            return sum((a[i]-b[i])**2 for i in range(len(a)))\n\n        # Adaptive radius per RRT* rewiring theory\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(self.radius_min, val)\n\n        def build_kdtree(tree):\n            if KDTree is None or not tree:\n                return None\n            pts = [node.position for node in tree]\n            return KDTree(pts)\n\n        def nearest(tree, kdtree, point):\n            if kdtree is not None:\n                _, idx = kdtree.query(point)\n                return tree[idx]\n            else:\n                return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, kdtree, pos, radius):\n            if kdtree is not None:\n                idxs = kdtree.query_ball_point(pos, radius)\n                return [tree[i] for i in idxs]\n            else:\n                r2 = radius * radius\n                return [n for n in tree if dist_sq(n.position, pos) <= r2]\n\n        def steer(from_pos, to_pos):\n            distance_ = dist(from_pos, to_pos)\n            if distance_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        # Informed ellipsoidal sampling between start and goal based on best path cost\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf'):\n                return uniform_sample()\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(len(start)))\n            diff = tuple(goal[d] - start[d] for d in range(len(start)))\n            length = dist(start, goal)\n            n = len(start)\n\n            # Sample unit n-sphere using Marsaglia method\n            def sample_unit_sphere(dim):\n                vec = [random.gauss(0,1) for _ in range(dim)]\n                norm = math.sqrt(sum(x*x for x in vec))\n                u = [x / norm for x in vec]\n                r = random.uniform(0,1) ** (1.0/dim)\n                return [r*x for x in u]\n\n            if c_best**2 - c_min**2 < 0:\n                radius_minor = 0.0\n            else:\n                radius_minor = math.sqrt(c_best**2 - c_min**2)/2\n\n            if n == 2:\n                L = [length/2, radius_minor]\n            elif n == 3:\n                L = [length/2, radius_minor, radius_minor]\n            else:\n                return uniform_sample()\n\n            unit_sample = sample_unit_sphere(n)\n            sample_scaled = tuple(unit_sample[i]*L[i] for i in range(n))\n\n            # Rotation to align with start-goal vector\n            if n == 2:\n                dx, dy = diff\n                theta = math.atan2(dy, dx)\n                cos_t, sin_t = math.cos(theta), math.sin(theta)\n                x_ellip = sample_scaled[0]*cos_t - sample_scaled[1]*sin_t\n                y_ellip = sample_scaled[0]*sin_t + sample_scaled[1]*cos_t\n                sample_rotated = (x_ellip, y_ellip)\n            elif n == 3:\n                length_nonzero = length if length > 0 else 1e-8\n                ux, uy, uz = 1.0, 0.0, 0.0\n                vx, vy, vz = (diff[d]/length_nonzero for d in range(3))\n                vx, vy, vz = float(vx), float(vy), float(vz)\n\n                kx = uy*vz - uz*vy\n                ky = uz*vx - ux*vz\n                kz = ux*vy - uy*vx\n                k_norm = math.sqrt(kx*kx + ky*ky + kz*kz)\n\n                if k_norm < 1e-6:\n                    if vx < 0:\n                        R = [[-1,0,0],[0,-1,0],[0,0,1]]\n                    else:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    kx /= k_norm\n                    ky /= k_norm\n                    kz /= k_norm\n                    cos_a = ux*vx + uy*vy + uz*vz\n                    sin_a = k_norm\n                    K = [\n                        [0, -kz, ky],\n                        [kz, 0, -kx],\n                        [-ky, kx, 0]\n                    ]\n                    I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                    K2 = [[sum(K[r][m]*K[m][c] for m in range(3)) for c in range(3)] for r in range(3)]\n                    R = [[I[r][c] + sin_a*K[r][c] + (1 - cos_a)*K2[r][c] for c in range(3)] for r in range(3)]\n\n                sample_rotated = tuple(\n                    R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2],\n                    R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2],\n                    R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                )\n            else:\n                return uniform_sample()\n\n            sample_global = tuple(center[d] + sample_rotated[d] for d in range(n))\n\n            # Clamp to bounds\n            clamped = tuple(max(0.0, min(sample_global[d], bounds[d])) for d in range(n))\n\n            if self._is_in_obstacle(clamped, obstacles, is_3d):\n                return uniform_sample()\n            return clamped\n\n        def uniform_sample(max_retry=50):\n            for _ in range(max_retry):\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return start_pos\n\n        lazy_checked_edges = set()  # Store edges checked to avoid redundant checks\n\n        # Extend tree towards point with rewiring\n        def try_extend(tree, kdtree, point):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, kdtree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, kdtree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            # Lazy collision checking: skip edge checks unless necessary\n            for node in neighbors:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    edge_candidate = (node, new_pos)\n                    if edge_candidate in lazy_checked_edges:\n                        min_cost = tentative_cost\n                        best_parent = node\n                    else:\n                        if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                            lazy_checked_edges.add(edge_candidate)\n                            min_cost = tentative_cost\n                            best_parent = node\n\n            # Confirm edge feasibility to best parent\n            if self._is_edge_in_obstacle(best_parent.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if cheaper path found via new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        # Try connecting opposite tree towards node incrementally\n        def try_connect(tree, kdtree, node):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, kdtree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if (not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d) and\n                        not self._is_in_obstacle(node.position, obstacles, is_3d)):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        # Shortcut smoothing to reduce path jaggedness and length\n        def smooth_path(path, max_trials):\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Prune dead-end and low-potential branches to reduce complexity\n        def prune_dead_branches():\n            removed = []\n            queue = deque([start_root, goal_root])\n            reachable = set()\n            while queue:\n                current = queue.popleft()\n                reachable.add(current)\n                for child in current.children:\n                    if child not in reachable:\n                        queue.append(child)\n\n            to_remove = [node for node in nodes if node not in reachable]\n\n            for node in to_remove:\n                try:\n                    nodes.remove(node)\n                except Exception:\n                    continue\n                # Remove from trees if present\n                for tree in [tree_start, tree_goal]:\n                    if node in tree:\n                        tree.remove(node)\n                try:\n                    if node.parent:\n                        node.parent.children.remove(node)\n                except Exception:\n                    pass\n\n                # Remove connected edges\n                edges[:] = [e for e in edges if e[0] != node and e[1] != node]\n                removed.append(node)\n\n            return len(removed)\n\n        # Initialization of best path cost and min cost heuristic\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n\n        # For dynamic goal bias interpolation\n        def goal_bias(iteration):\n            return ((self.goal_sample_rate_end - self.goal_sample_rate_start)*iteration/self.max_iter\n                    + self.goal_sample_rate_start)\n\n        for itr in range(self.max_iter):\n            gb_rate = goal_bias(itr)\n            if random.random() < gb_rate:\n                # Sample goal with higher probability, else start\n                rand_point = goal_pos if random.random() < 0.75 else start_pos\n            else:\n                rand_point = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            rand_point = tuple(max(0.0, min(rand_point[d], bounds[d])) for d in range(len(bounds)))\n\n            # Always extend smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            kdtree_start = build_kdtree(tree_start)\n            kdtree_goal = build_kdtree(tree_goal)\n\n            new_node_start = try_extend(tree_start, kdtree_start, rand_point)\n            if new_node_start is None:\n                # Skip this iteration if extension failed\n                continue\n\n            new_node_goal = try_connect(tree_goal, kdtree_goal, new_node_start)\n            if new_node_goal is not None:\n                # Connection found\n                success_state = True\n\n                # Combine paths avoiding duplicate node\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n\n                # Evaluate cost\n                total_cost = sum(dist(merged_path[i], merged_path[i+1]) for i in range(len(merged_path)-1))\n                if total_cost + 1e-9 < c_best:\n                    c_best = total_cost\n                    extracted_path = merged_path\n\n                # Run shortcut smoothing immediately upon connection\n                extracted_path = smooth_path(extracted_path, self.shortcut_trials)\n\n                # Prune disconnected nodes periodically or immediately (keep complexity low)\n                prune_dead_branches()\n\n                # Break to return best found path early for efficiency\n                break\n\n            # Periodic pruning for efficiency if busy search tree\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_branches()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 15.28756,
        "time_improvement": -66.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.011576533317565918,
                "num_nodes_avg": 73.3,
                "path_length_avg": 156.274129124881,
                "success_improvement": 0.0,
                "time_improvement": -14.746098365614577,
                "length_improvement": 21.89569229167649,
                "objective_score": -0.044691051349074584
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03883960247039795,
                "num_nodes_avg": 309.3,
                "path_length_avg": 239.02827921944194,
                "success_improvement": 0.0,
                "time_improvement": -171.52886466484986,
                "length_improvement": 20.682330268402747,
                "objective_score": -47.32219334577441
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.03190631866455078,
                "num_nodes_avg": 198.6,
                "path_length_avg": 123.23471948179215,
                "success_improvement": 0.0,
                "time_improvement": -11.203643612667538,
                "length_improvement": 24.32645845377667,
                "objective_score": 1.5041986069550735
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This improved planner integrates bidirectional RRT* with adaptive sampling biased around the current best path corridor and obstacles, dynamically adjusts neighbor radius based on node count for efficient rewiring, and uses lazy collision checking with caching to minimize computational cost. It balances tree growth by expanding the smaller tree per iteration and aggressively attempts to connect the opposite tree using iterative steering. Periodic pruning removes nodes that cannot improve the current best path, and intensive shortcut smoothing refines the final path for smoothness and optimality. Additional heuristics accelerate convergence and enhance robustness in complex, cluttered, 2D or 3D environments.",
        "planning_mechanism": "The planning mechanism begins with two trees rooted at start and goal. It adaptively samples new points biased around the best path or uniformly otherwise, checks for collision-free validity, and extends the smaller tree toward the sample using steering with fixed step size. Neighbors within a dynamic search radius found via KD-tree enable parent selection and rewiring for path cost improvements. The opposite tree attempts connection via iterative steering and collision checking. The best path updates upon successful connection, followed by shortcut smoothing. Periodic pruning eliminates nodes unlikely to improve the solution, keeping the search efficient and focused on promising areas.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=6.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=150,\n                 prune_threshold: int=250,\n                 smoothing_iterations: int=150,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos):\n            total_d = dist(from_pos, to_pos)\n            if total_d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / total_d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            val = self.max_neighbor_radius * math.sqrt(math.log(n_nodes)/n_nodes)\n            return max(self.min_neighbor_radius, min(val, self.max_neighbor_radius))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # Lazy collision checking cache for edges\n        edge_collision_cache = {}\n\n        def canonical_edge_key(p1, p2):\n            return (p1, p2) if p1 < p2 else (p2, p1)\n\n        def can_connect(p1, p2):\n            key = canonical_edge_key(p1, p2)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [p for p,n in points_nodes]\n                self.nodes = [n for p,n in points_nodes]\n                self.dim = dim\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p,n in zip(self.points, self.nodes):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, r):\n                r2 = r*r\n                result = []\n                for p,n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for i in range(self.dim):\n                        delta = p[i] - pt[i]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(n)\n                return result\n\n        def adaptive_sample(best_path):\n            if best_path:\n                import numpy as np\n                attempts = 30\n                for _ in range(attempts):\n                    base_point = best_path[random.randint(0, len(best_path)-1)]\n                    noise = np.random.normal(0, self.step_size*0.9, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if random.random() < 0.6 else start_pos\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_nodes(tree_nodes, best_cost, root_start, root_goal):\n            removed_nodes = 0\n            to_remove = []\n            dist_goal = dist\n            for node in tree_nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist_goal(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for rm in to_remove:\n                if rm.parent:\n                    try:\n                        rm.parent.children.remove(rm)\n                    except ValueError:\n                        pass\n                try:\n                    tree_nodes.remove(rm)\n                except ValueError:\n                    pass\n                removed_nodes += 1\n            return removed_nodes\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        nodes = [root_start, root_goal]\n        edges = []\n\n        best_path = []\n        c_best = float('inf')\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            sample_point = adaptive_sample(best_path)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(sample_point)\n            new_pos = steer(nearest_a.position, sample_point)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for nbr in near_nodes:\n                candidate_cost = nbr.cost + dist(nbr.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(nbr.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nbr in near_nodes:\n                if nbr is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                if c_via_new + 1e-12 < nbr.cost and can_connect(new_node.position, nbr.position):\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                    except ValueError:\n                        pass\n                    nbr.update_parent(new_node, c_via_new)\n                    edges.append((new_node, nbr))\n\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_connect_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 4\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes))\n                near_b_nodes = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_b_nodes:\n                    if nbr_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if c_via_new_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    connection_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=connection_cost)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if connection_cost + 1e-12 < c_best:\n                        c_best = connection_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 1.20402,
        "time_improvement": -18.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.007881546020507812,
                "num_nodes_avg": 56.6,
                "path_length_avg": 155.97707175226145,
                "success_improvement": 0.0,
                "time_improvement": 21.878456172191814,
                "length_improvement": 22.044158711345755,
                "objective_score": 10.972368593926696
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.022196197509765626,
                "num_nodes_avg": 235.0,
                "path_length_avg": 244.48665407327107,
                "success_improvement": 0.0,
                "time_improvement": -55.17430473952214,
                "length_improvement": 18.871056826862365,
                "objective_score": -12.778080056484168
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.03454205989837646,
                "num_nodes_avg": 238.3,
                "path_length_avg": 127.75089409516185,
                "success_improvement": 0.0,
                "time_improvement": -20.3900380664788,
                "length_improvement": 21.553255182231712,
                "objective_score": -1.8063603834972977
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid planner combines bidirectional tree growth with informed ellipsoidal sampling, adaptive neighbor radius, KD-tree accelerated nearest neighbor searches, periodic node pruning, collision caching, incremental rewiring, and shortcut smoothing. It unifies the efficiency and asymptotic optimality of RRT* variants with the fast convergence of bidirectional search to improve planning efficiency, path quality, robustness, and success rate in both 2D and 3D environments.",
        "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling adaptively in an ellipsoidal informed region based on the current best path cost to bias samples to promising areas. Trees perform rewiring for local path optimization using neighbors found via KD-tree radius searches. Collision checks are cached to avoid redundant computations. Periodic pruning removes nodes unlikely to improve solutions, and the final path is aggressively shortcut-smoothed for quality and smoothness. The planning stops early upon successfully connecting the trees and improving the best path cost.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision/pruning state\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to map bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree for accelerated neighbor search (brute-force for simplicity)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Ellipsoidal informed sampling with fallback uniform sampling\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                # Goal bias & uniform sampling when no good solution\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))  # unit vector start->goal\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) * (c_min / 2), 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    x = x * radii\n                    p = rot @ x + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            # Fallback uniform sampling if ellipsoid samples fail\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialize roots\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth direction for balanced expansion\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors to improve path cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Try connecting the other tree towards new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    # Retrieve paths according to tree order\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning for efficiency if enough nodes and solution found\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -2.73225,
        "time_improvement": -5.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.010381293296813966,
                "num_nodes_avg": 80.0,
                "path_length_avg": 161.56607835697952,
                "success_improvement": 0.0,
                "time_improvement": -2.898930890735342,
                "length_improvement": 19.25082692902676,
                "objective_score": 2.98048611858475
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.026044535636901855,
                "num_nodes_avg": 231.1,
                "path_length_avg": 236.64448292717498,
                "success_improvement": 0.0,
                "time_improvement": -82.07815586168962,
                "length_improvement": 21.47335452559473,
                "objective_score": -20.328775853387942
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.008422541618347167,
                "num_nodes_avg": 104.8,
                "path_length_avg": 127.41733327110765,
                "success_improvement": 0.0,
                "time_improvement": 70.64477020095212,
                "length_improvement": 21.758081622243104,
                "objective_score": 25.545047384734257
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This planner is a streamlined, bidirectional RRT* variant combining adaptive informed sampling biased within an ellipsoidal region, dynamic neighborhood radius, and incremental rewiring. It leverages efficient collision checking and pruning to enhance path quality, success rate, and search speed in both 2D and 3D environments. Shortcut smoothing is applied post planning to refine the path smoothness and length.",
        "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling points inside an adaptively sized ellipsoid around the best path to focus exploration. Using a dynamic radius based on iterations and node count, it connects and rewires nodes incrementally while checking collision constraints rigorously. Periodic pruning removes nodes unlikely to improve solutions. Once a connection between two trees is found, shortcut smoothing improves the path before returning the result.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Total cost from root node\n        self.children = []\n        self.valid = True               # For collision check status\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_radius: float = 5.0, max_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_iterations: int = 100,\n                 collision_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / self.collision_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        def informed_sample(c_best, c_min):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            rot = id_mat\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n\n            r1 = c_best / 2.0\n            r_else = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_else] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    sample = rot @ (x * radii) + np.array(center)\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        class KDTreeSimple:\n            def __init__(self, points_nodes):\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = self.nodes[i]\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    dist_sq = sum((p[d] - pt[d]) ** 2 for d in range(dim))\n                    if dist_sq <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        nodes = []\n        edges = []\n\n        root_start = Node(start, cost=0.0)\n        root_goal = Node(goal, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes.extend([root_start, root_goal])\n\n        c_min = dist(start, goal)\n        c_best = float('inf')\n        best_path = []\n        success = False\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            rev_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return not edge_collision_cache[rev_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_nodes(best_cost):\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                estimate = dist(node.position, goal)\n                if node.cost + estimate >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n                try:\n                    nodes.remove(node)\n                except ValueError:\n                    pass\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTreeSimple([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTreeSimple([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_cand_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_cand_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_cand_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                break\n\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                edge_collision_cache.clear()\n\n        final_path = best_path if success else []\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": 11.52169,
        "time_improvement": -53.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.015595316886901855,
                "num_nodes_avg": 101.8,
                "path_length_avg": 165.23104835574372,
                "success_improvement": 0.0,
                "time_improvement": -54.580107572620975,
                "length_improvement": 17.41911014949183,
                "objective_score": -12.890210241887925
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.0384274959564209,
                "num_nodes_avg": 270.9,
                "path_length_avg": 235.47690133379328,
                "success_improvement": 0.0,
                "time_improvement": -168.64781525281063,
                "length_improvement": 21.860797599322087,
                "objective_score": -46.22218505597877
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.0100982666015625,
                "num_nodes_avg": 117.5,
                "path_length_avg": 121.27447277077366,
                "success_improvement": 0.0,
                "time_improvement": 64.80433696935654,
                "length_improvement": 25.53016802159066,
                "objective_score": 24.547334695125095
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This improved bidirectional RRT* planner integrates dynamic adaptive sampling biased towards start, goal, and promising midpoints with gradually decaying exploration bias, uses a refined rewiring radius adapting to iteration and tree size for balanced optimization, and performs fast spatial hashing neighbor queries for efficient rewiring. Balanced growth of two trees with mutual rewiring, dead-end pruning, and early collision rejection accelerates planning. After tree connection, advanced iterative shortcutting and smoothing improve path quality and reduce length, while strict collision and boundary checks guarantee feasibility in bounded 2D/3D environments. The algorithm emphasizes minimizing planning time, boosting success rate, and producing smooth, near-optimal paths.",
        "planning_mechanism": "The planner grows two balanced RRT* trees from start and goal by sampling with adaptive bias shifting from goal/start toward midpoint exploration. Nodes extend within step-size constraints using collision-free checks for both nodes and edges. Fast neighbor queries with spatial hashing enable efficient local rewiring within a dynamically adjusted radius that accounts for exploration versus refinement trade-offs. Periodic pruning removes dead-ends to maintain computational efficiency. Upon successful tree connection, advanced shortcutting and smoothing heuristics iteratively refine path quality. The method balances planning efficiency, path smoothness, and optimality while ensuring robustness in 2D/3D bounded obstacle environments.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 3.0, prune_interval: int = 200,\n                 prune_threshold: int = 100, smoothing_iterations: int = 40,\n                 search_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.search_resolution = search_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        import math\n        import random\n        from collections import defaultdict\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_within_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[i] <= bounds[i] for i in range(dim))\n\n        def is_free_node(pos: Tuple[float, ...]) -> bool:\n            if not is_within_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def is_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            if not is_within_bounds(p1) or not is_within_bounds(p2):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.search_resolution):\n                return False\n            return True\n\n        class SpatialHash:\n            def __init__(self, cell_size: float):\n                self.cell_size = cell_size\n                self.hash_table = defaultdict(list)\n\n            def _hash(self, pos: Tuple[float, ...]) -> Tuple[int, ...]:\n                return tuple(int(pos[i] // self.cell_size) for i in range(len(pos)))\n\n            def insert(self, node: Node):\n                key = self._hash(node.position)\n                self.hash_table[key].append(node)\n\n            def remove(self, node: Node):\n                key = self._hash(node.position)\n                if node in self.hash_table.get(key, []):\n                    self.hash_table[key].remove(node)\n                    if not self.hash_table[key]:\n                        del self.hash_table[key]\n\n            def near(self, pos: Tuple[float, ...], radius: float) -> List[Node]:\n                radius_cells = int(math.ceil(radius / self.cell_size))\n                base_key = self._hash(pos)\n                keys_to_check = []\n                if dim == 2:\n                    for dx in range(-radius_cells, radius_cells + 1):\n                        for dy in range(-radius_cells, radius_cells + 1):\n                            keys_to_check.append((base_key[0] + dx, base_key[1] + dy))\n                else:\n                    for dx in range(-radius_cells, radius_cells + 1):\n                        for dy in range(-radius_cells, radius_cells + 1):\n                            for dz in range(-radius_cells, radius_cells + 1):\n                                keys_to_check.append((base_key[0] + dx, base_key[1] + dy, base_key[2] + dz))\n                result = []\n                for key in keys_to_check:\n                    for node in self.hash_table.get(key, []):\n                        if dist(node.position, pos) <= radius:\n                            result.append(node)\n                return result\n\n        def radius_by_nodes_and_iter(n_nodes: int, itr: int) -> float:\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt(math.log(n_nodes) / n_nodes)\n            decay = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay)\n\n        def adaptive_sample(itr: int) -> Tuple[float, ...]:\n            r = random.random()\n            bias_decay = 1 - itr / self.max_iter\n            # Bias toward goal/start or midpoint shifting over iterations for exploration refinement\n            if r < self.goal_sample_rate:\n                sr = random.random()\n                if sr < 0.6 and is_free_node(goal_position):\n                    return goal_position\n                elif sr < 0.85 and is_free_node(start_position):\n                    return start_position\n                if len(tree_start) > 15 and len(tree_goal) > 15:\n                    mid_s = random.choice(tree_start).position\n                    mid_g = random.choice(tree_goal).position\n                    midpoint = tuple((mid_s[i] + mid_g[i]) / 2 for i in range(dim))\n                    spread = self.step_size * 5 * bias_decay\n                    for _ in range(7):\n                        candidate = tuple(\n                            max(0, min(bounds[d], midpoint[d] + random.uniform(-spread, spread)))\n                            for d in range(dim)\n                        )\n                        if is_free_node(candidate):\n                            return candidate\n            # Uniform sampling with rejection\n            for _ in range(75):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n            return start_position\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        # Initialize data structures\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes: List[Node] = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        cell_size = self.step_size * 1.5\n        hash_start = SpatialHash(cell_size)\n        hash_goal = SpatialHash(cell_size)\n        hash_start.insert(start_root)\n        hash_goal.insert(goal_root)\n\n        def try_extend(tree: List[Node], tree_hash: SpatialHash, target: Tuple[float, ...], itr: int) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, target)\n            new_pos = steer(nearest_node.position, target)\n            if not is_free_node(new_pos):\n                return None\n            if not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes_and_iter(len(tree), itr)\n            near_nodes = tree_hash.near(new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near_nodes:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost and is_free_edge(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            tree_hash.insert(new_node)\n\n            # Try rewiring neighbors for cost improvement\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect_and_rewire(tree: List[Node], tree_hash: SpatialHash, target_node: Node, itr: int) -> Node or None:\n            if not tree:\n                return None\n            last_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos):\n                    return None\n                if not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes_and_iter(len(tree), itr)\n                near_nodes_ = tree_hash.near(new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n\n                for node in near_nodes_:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-10 < min_cost and is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                tree_hash.insert(new_node)\n\n                for neighbor in near_nodes_:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-10 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        tree_hash.insert(final_node)\n                        return final_node\n                    return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            # Remove nodes with no children except start/goal roots\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        hash_start.remove(node)\n                        hash_goal.remove(node)\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path: List[Tuple[float, ...]]) -> float:\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def smooth_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if is_free_edge(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            sample = adaptive_sample(itr)\n\n            # Extend the smaller tree for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n                hash_start, hash_goal = hash_goal, hash_start\n\n            new_node_start = try_extend(tree_start, hash_start, sample, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, hash_goal, new_node_start, itr)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                # Advanced smoothing and shortcutting for quality\n                shortcuted_path = shortcut_path(raw_path)\n                smoothed_path = smooth_path(shortcuted_path)\n\n                candidates = [raw_path, shortcuted_path, smoothed_path]\n                extracted_path = min(candidates, key=path_length)\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) !=6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) !=4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -0.71088,
        "time_improvement": -13.0,
        "length_improvement": 23.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.014388227462768554,
                "num_nodes_avg": 72.6,
                "path_length_avg": 153.10938511332458,
                "success_improvement": 0.0,
                "time_improvement": -42.61548932308653,
                "length_improvement": 23.47740093072545,
                "objective_score": -8.089166610780868
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02143435478210449,
                "num_nodes_avg": 206.3,
                "path_length_avg": 236.15937859139632,
                "success_improvement": 0.0,
                "time_improvement": -49.84823861789634,
                "length_improvement": 21.63432855601618,
                "objective_score": -10.627605874165667
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.013490009307861327,
                "num_nodes_avg": 142.6,
                "path_length_avg": 122.50835528802918,
                "success_improvement": 0.0,
                "time_improvement": 52.98303752385907,
                "length_improvement": 24.77248982566236,
                "objective_score": 20.84940922229019
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid planner combines the bidirectional tree growth of RRT-Connect with the adaptive, cost-aware rewiring and roadmap construction of a PRM*-inspired algorithm. It grows two trees simultaneously from start and goal positions with adaptive sampling biased near the current best path, dynamically adjusting connection radius, lazy collision checking, and rewiring to improve path quality and efficiency. Periodic pruning removes nodes unlikely to improve the solution, and shortcut smoothing refines the final path, enhancing success rate, path length, and smoothness across 2D/3D maps.",
        "planning_mechanism": "The planner alternates expanding two trees with adaptive sampling biased near the best path corridor or uniform otherwise. New nodes are connected with neighbors in adaptive radius, rewiring to minimize cost, with lazy collision checks cached for efficiency. The two trees attempt connection with incremental extension steps, and when connected, the path is shortcut-smoothed. Periodic node pruning speeds convergence by removing unpromising nodes, producing efficient, robust, and high-quality paths.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float = 8.0,\n                 max_neighbor_radius: float = 35.0,\n                 prune_interval: int = 250,\n                 prune_threshold: int = 400,\n                 smoothing_iterations: int = 120,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp within bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            factor = math.log(n_nodes) / n_nodes\n            r = self.max_neighbor_radius * math.sqrt(factor)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        # KD-tree helper for nearest and radius search (naive O(n))\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best = self.nodes[i]\n                        best_dist = d\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        # Adaptive sampling biased towards corridor around last best path or uniform if none\n        def adaptive_sample(best_path):\n            if best_path:\n                import numpy as np\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 1.2, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            # fallback uniform sampling\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            # final fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_nodes(nodes_list, best_cost, root_start, root_goal):\n            removed = 0\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(rm_node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialize roots and graphs\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        best_path: List[Tuple[float, ...]] = []\n        c_best = float('inf')\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for it in range(self.max_iter):\n            sample_point = adaptive_sample(best_path)\n\n            # Alternate expanding smaller tree for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            if not tree_a:\n                continue\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(sample_point)\n            new_pos = steer(nearest_a.position, sample_point)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            # Choose parent minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for nbr in near_nodes:\n                cost_candidate = nbr.cost + dist(nbr.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(nbr.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = nbr\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for potential cost improvement\n            for nbr in near_nodes:\n                if nbr is best_parent:\n                    continue\n                c_new = new_node.cost + dist(new_node.position, nbr.position)\n                if c_new + 1e-12 < nbr.cost and can_connect(new_node.position, nbr.position):\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                    except ValueError:\n                        pass\n                    nbr.update_parent(new_node, c_new)\n                    edges.append((new_node, nbr))\n\n            # Attempt to connect the other tree to new_node incrementally\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_connect_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes))\n                near_b_nodes = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_b_nodes:\n                    if nbr_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if c_via_new_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, nbr_b))\n\n                # Check if reached close enough to new_node\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    connection_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=connection_cost)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if connection_cost + 1e-12 < c_best:\n                        c_best = connection_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to remove nodes unlikely to improve best solution\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 0.68324,
        "time_improvement": -15.0,
        "length_improvement": 19.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.010347294807434081,
                "num_nodes_avg": 79.4,
                "path_length_avg": 163.65471316877972,
                "success_improvement": 0.0,
                "time_improvement": -2.561939332066658,
                "length_improvement": 18.20694732499583,
                "objective_score": 2.872807665379169
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02134273052215576,
                "num_nodes_avg": 210.7,
                "path_length_avg": 241.35899656225337,
                "success_improvement": 0.0,
                "time_improvement": -49.20769057679325,
                "length_improvement": 19.90891940238089,
                "objective_score": -10.780523292561796
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.02678365707397461,
                "num_nodes_avg": 191.7,
                "path_length_avg": 131.39710291349533,
                "success_improvement": 0.0,
                "time_improvement": 6.650457321253329,
                "length_improvement": 19.31426331646022,
                "objective_score": 5.857989859668043
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This algorithm integrates bidirectional RRT* with informed ellipsoidal sampling, adaptive neighbor radius, KD-tree accelerated neighbor search, collision caching, periodic pruning, incremental rewiring, and aggressive path shortcut smoothing. It aims to achieve fast convergence, high-quality, smooth, and robust path planning in both 2D and 3D environments, while reducing search time and improving success rates.",
        "planning_mechanism": "The planner alternately grows two trees from start and goal positions, biased by ellipsoidal informed sampling based on the current best path cost. KD-tree structures accelerate nearest neighbor and radius searches for efficient rewiring and local optimization. Collision checks are cached to minimize repeated computations. Periodic pruning removes nodes unlikely to help improve the solution, and the best path is shortcut-smoothed to enhance smoothness and reduce path length. The planning terminates early once a satisfactory connecting path is found.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision/pruning etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) * (c_min / 2), 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    x = x * radii\n                    p = rot @ x + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree growth for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Incremental rewiring neighbors\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Connect other tree towards new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -2.43652,
        "time_improvement": -6.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.007726073265075684,
                "num_nodes_avg": 73.3,
                "path_length_avg": 164.5787043153917,
                "success_improvement": 0.0,
                "time_improvement": 23.419495410675967,
                "length_improvement": 17.745145430857118,
                "objective_score": 10.574877709374213
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.025020694732666014,
                "num_nodes_avg": 218.8,
                "path_length_avg": 236.9837400124963,
                "success_improvement": 0.0,
                "time_improvement": -74.92045236726086,
                "length_improvement": 21.36077754710711,
                "objective_score": -18.20398020075684
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.018914246559143068,
                "num_nodes_avg": 152.4,
                "path_length_avg": 124.45601646326448,
                "success_improvement": 0.0,
                "time_improvement": 34.07784973006122,
                "length_improvement": 23.576508534984686,
                "objective_score": 14.938656626015302
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This implementation improves the bidirectional RRT* planner by implementing adaptive step sizing based on distance to samples, incorporating informed sampling via elliptical heuristic biasing to focus growth near the least-cost path estimate, and efficiently balancing tree expansions. It applies dynamic neighborhood radius shrinking with logarithmic scaling for rewiring, rigorous collision checks on nodes and edges, and path shortcut smoothing post planning to enhance path quality and smoothness. By refining sampling and steering strategies and optimizing rewiring, it reduces planning time and increases success rates while producing shorter, smoother paths.",
        "planning_mechanism": "The planner grows two trees from start and goal by alternately extending the smaller tree toward adaptively sampled points biased via an elliptical heuristic around the best path estimate. Steer step size adapts to proximity, preventing overshoot and promoting efficient expansions. New nodes connect via lowest-cost parent within a dynamically shrinking radius, enabling local rewiring to optimize costs incrementally. Trees attempt connection via direct motions checked for collisions. After successful connection, the path is extracted and shortcut smoothed to eliminate unnecessary detours and improve smoothness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]: 2D (x,y) or 3D (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from start/root to this node\n        self.children = []\n        self.valid = True               # For collision checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 radius_const: float = 30.0,\n                 radius_min: float = 5.0,\n                 smoothing_iter: int = 50):\n        self.max_iter = max_iter\n        self.step_size_base = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.smoothing_iter = smoothing_iter\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size          # Tuple[int,...] (W,H) or (W,H,D)\n        start_position = map.start # Tuple\n        goal_position = map.goal   # Tuple\n        obstacles = map.obstacles  # List of tuples\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Store best path cost found so far, used for informed sampling\n        best_path_cost = math.inf\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, adapt_step=None):\n            dist = distance(from_pos, to_pos)\n            max_step = adapt_step if adapt_step is not None else self.step_size_base\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (sum((node.position[d] - pos[d])**2 for d in range(len(pos))) <= radius_sq)]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_const\n            return max(self.radius_min,\n                       self.radius_const * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n        \n        def collision_free(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def edge_collision_free(pos1, pos2):\n            return not self._is_edge_in_obstacle(pos1, pos2, obstacles, is_3d, resolution=max(0.25, self.step_size_base/5))\n\n        def add_node(tree, new_node, parent_node):\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n\n        def informed_sample():\n            # If no solution found yet, sample uniformly with goal bias\n            if best_path_cost == math.inf:\n                return uniform_sample()\n            # Ellipse parameters for 2D or 3D informed sampling:\n            c_best = best_path_cost\n            c_min = distance(start_position, goal_position)\n            if c_best <= c_min:\n                # path cost equals minimum distance: sample goal to speed convergence\n                return goal_position if random.random() < 0.9 else uniform_sample()\n            \n            # Compute center point and rotated frame\n            center = tuple((start_position[d] + goal_position[d]) / 2.0 for d in range(len(bounds)))\n            a1 = tuple((goal_position[d] - start_position[d]) / c_min for d in range(len(bounds)))  # unit vector from start to goal\n\n            # Build orthonormal basis via Gram-Schmidt or direct (for dim=2 or 3)\n            # For simplicity, generate random samples in ellipse aligned to axis of direction\n            dim = len(bounds)\n            r1 = c_best / 2.0  # major axis length\n            r2 = math.sqrt(c_best**2 - c_min**2) / 2.0 # minor axis radius in 2D or max minor radius in 3D, else approximate\n            \n            def sample_unit_ball():\n                if dim == 2:\n                    # Uniform in unit circle\n                    while True:\n                        x = random.uniform(-1,1)\n                        y = random.uniform(-1,1)\n                        if x*x + y*y <= 1:\n                            return (x, y)\n                else:\n                    # 3D uniform unit ball sampling\n                    import random as rnd\n                    import math\n                    while True:\n                        x, y, z = rnd.uniform(-1,1), rnd.uniform(-1,1), rnd.uniform(-1,1)\n                        if x*x + y*y + z*z <= 1:\n                            return (x,y,z)\n            sample_ball = sample_unit_ball()\n            \n            # Scale sample_ball to ellipse axes\n            if dim ==2:\n                # Rotate sample so major axis aligns with a1 unit vector\n                # build rotation angle from (1,0) to a1\n                ang = math.atan2(a1[1], a1[0])\n                x_ball, y_ball = sample_ball\n                x_ellipse = r1 * x_ball\n                y_ellipse = r2 * y_ball\n                cos_ang = math.cos(ang)\n                sin_ang = math.sin(ang)\n                # rotate back\n                sample_rotated = (\n                    center[0] + cos_ang * x_ellipse - sin_ang * y_ellipse,\n                    center[1] + sin_ang * x_ellipse + cos_ang * y_ellipse\n                )\n                # Clamp sample in map bounds\n                sample_clamped = tuple(min(max(sample_rotated[d], 0.0), bounds[d]) for d in range(dim))\n                # Avoid obstacles\n                if collision_free(sample_clamped):\n                    return sample_clamped\n                else:\n                    # fallback uniform sample\n                    return uniform_sample()\n            else:\n                # 3D: approximate ellipse with scaling on axes aligned with a1 and orthogonal\n                # To build orthonormal basis {a1, a2, a3}\n                import numpy as np\n                a1_vec = np.array(a1)\n                # find random vector not colinear for a2\n                if abs(a1_vec[0]) < 0.9:\n                    temp = np.array([1,0,0])\n                else:\n                    temp = np.array([0,1,0])\n                a2_vec = temp - a1_vec * np.dot(temp, a1_vec)\n                a2_vec /= np.linalg.norm(a2_vec)\n                a3_vec = np.cross(a1_vec, a2_vec)\n                r3 = r2  # approximate equal minor axis\n                \n                sample_ball_np = np.array(sample_ball)\n                scale = np.array([r1, r2, r3])\n                ellip_point = a1_vec*sample_ball_np[0]*scale[0] + a2_vec*sample_ball_np[1]*scale[1] + a3_vec*sample_ball_np[2]*scale[2]\n                sample_final = tuple(center[d] + ellip_point[d] for d in range(dim))\n                sample_clamped = tuple(min(max(sample_final[d], 0.0), bounds[d]) for d in range(dim))\n                if collision_free(sample_clamped):\n                    return sample_clamped\n                else:\n                    return uniform_sample()\n\n        def uniform_sample():\n            for _ in range(100):  # max 100 tries to find free sample\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                if collision_free(p):\n                    return p\n            # fallback\n            return start_position\n\n        def sample_point():\n            # Use goal bias or informed sampling\n            if random.random() < self.goal_sample_rate:\n                if random.random() < 0.85:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                return informed_sample()\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            dist_to_sample = distance(nearest_node.position, point)\n            \n            # Adaptive step sizing: reduce step if close to sample for finer resolution near goal or obstacles\n            adapt_step = min(self.step_size_base, dist_to_sample * 0.9)\n\n            new_pos = steer(nearest_node.position, point, adapt_step=adapt_step)\n\n            # Bounds check\n            for d in range(len(new_pos)):\n                if new_pos[d] < 0 or new_pos[d] > bounds[d]:\n                    return None\n\n            if not collision_free(new_pos) or not edge_collision_free(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = radius_by_nodes(n_nodes)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + distance(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if edge_collision_free(node.position, new_pos):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes to new_node if it reduces cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-9 < neighbor.cost:\n                    if edge_collision_free(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            # Attempt to connect node to tree by greedy extension along path\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                dist_to_goal = distance(last_node.position, node.position)\n                if dist_to_goal <= 0.1:\n                    # Close enough\n                    return last_node\n\n                adapt_step = min(self.step_size_base, dist_to_goal * 0.9)\n                new_pos = steer(last_node.position, node.position, adapt_step=adapt_step)\n\n                for d in range(len(new_pos)):\n                    if new_pos[d] < 0 or new_pos[d] > bounds[d]:\n                        return None\n\n                if not collision_free(new_pos) or not edge_collision_free(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                last_node = new_node\n\n                if distance(new_pos, node.position) <= adapt_step:\n                    if edge_collision_free(new_pos, node.position):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Remove duplicate connection position\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if edge_collision_free(p_i, p_j):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            rand_point = sample_point()\n            # Expand smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                path = extract_path(new_node_start, new_node_goal)\n                path_cost = 0.0\n                for k in range(len(path) - 1):\n                    path_cost += distance(path[k], path[k+1])\n                if path_cost < best_path_cost:\n                    best_path_cost = path_cost\n                    extracted_path = shortcut_path(path)\n                    success_state = True\n                    # Stop early on first connection since path improved\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 13.67438,
        "time_improvement": -58.0,
        "length_improvement": 19.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009960055351257324,
                "num_nodes_avg": 105.3,
                "path_length_avg": 166.49204749160407,
                "success_improvement": 0.0,
                "time_improvement": 1.2763614364442395,
                "length_improvement": 16.78887490147799,
                "objective_score": 3.74068341122887
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.040338969230651854,
                "num_nodes_avg": 322.0,
                "path_length_avg": 243.38332989947048,
                "success_improvement": 0.0,
                "time_improvement": -182.01098415714512,
                "length_improvement": 19.237177114847455,
                "objective_score": -50.755859824174046
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.027082610130310058,
                "num_nodes_avg": 232.0,
                "path_length_avg": 127.7603507376911,
                "success_improvement": 0.0,
                "time_improvement": 5.60851106969216,
                "length_improvement": 21.547448234041028,
                "objective_score": 5.992042967715853
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e1",
        "algorithm_description": "This planner introduces a guided bidirectional RRT* with adaptive dynamic obstacle-informed sampling and lazy edge collision checking integrated with batch rewiring and progressive path shortcutting. The algorithm maintains two trees from start and goal, strategically sampling near detected obstacle boundaries to enhance exploration in complex regions, while using lazy collision checks to defer expensive edge validations until necessary. Batch rewiring improves local connectivity periodically, and a progressive smoothing strategy refines the final path iteratively for better smoothness and length. This combination boosts planning speed, robustness, and path quality for both 2D and 3D maps.",
        "planning_mechanism": "The planner alternately grows two trees from start and goal nodes. It samples points biased toward obstacle boundaries and the corridor between trees, aiming to better explore challenging regions. New nodes are connected to near neighbors with lazy collision checking cached and validated only when a potentially better path is found, reducing redundant checks. Periodic batch rewiring consolidates local improvements. The trees attempt incremental connection, and after successful connection, a progressive shortcut smoothing iteratively refines the path. The planner prunes nodes unlikely to improve the best solution to keep search complexity in check.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position                  # Tuple[float, ...] (2D or 3D)\n        self.parent = parent                      # Node or None\n        self.cost = cost                          # Cost from root to this node\n        self.children = []\n        self.valid = True                         # For collision status if needed\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def heuristic_cost_to(self, pos):\n        return math.dist(self.position, pos)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 batch_rewire_interval: int = 100,\n                 prune_interval: int = 250,\n                 smoothing_iterations_init: int = 50,\n                 smoothing_iterations_batch: int = 30,\n                 neighbor_radius_min: float = 6.0,\n                 neighbor_radius_max: float = 30.0,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.batch_rewire_interval = batch_rewire_interval\n        self.prune_interval = prune_interval\n        self.smoothing_iterations_init = smoothing_iterations_init\n        self.smoothing_iterations_batch = smoothing_iterations_batch\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # --- Helper Functions ---\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp within bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def is_in_obstacle(p):\n            return self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree (naive) helper for neighbor searches\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best = self.nodes[i]\n                        best_dist = d\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Adaptive neighbor radius dependent on number of nodes and iteration\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            r_iter = self.neighbor_radius_max * (1 - (iteration/self.max_iter)**0.95)\n            r_nodes = self.neighbor_radius_min + (self.neighbor_radius_max - self.neighbor_radius_min) * math.sqrt(math.log(n_nodes + 1)/n_nodes)\n            return max(self.neighbor_radius_min, min(r_iter, r_nodes))\n\n        # Lazy collision cache for edges, stores edge->bool(collision)\n        edge_collision_cache = {}\n\n        def edge_key(p1, p2):\n            return (p1, p2) if p1 < p2 else (p2, p1)\n\n        def can_connect(p1, p2):\n            key = edge_key(p1, p2)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            # Lazy collision checking deferred elsewhere; for now do quick check\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        # Sampling biased toward obstacle boundaries and corridor between trees\n        def boundary_informed_sample():\n            # Attempt obstacle boundary sampling\n            for _ in range(30):\n                # Sample uniformly first\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_in_obstacle(sample):\n                    continue\n                # Check close to obstacle surfaces by jittering slightly outwards\n                offset = [random.uniform(-self.step_size, self.step_size) for _ in range(dim)]\n                near_point = tuple(sample[d] + offset[d] for d in range(dim))\n                if not in_bounds(near_point):\n                    continue\n                # Identify if near obstacle boundary by checking local neighbors\n                if not is_in_obstacle(near_point):\n                    return near_point\n            # Fallback uniform sample\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # Progressive shortcut smoothing for path refinement\n        def progressive_shortcut_path(path, iterations):\n            if len(path) < 3:\n                return path\n            for _ in range(iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Prune nodes unlikely to improve best path to reduce search complexity\n        def prune_nodes(nodes_list, best_cost, root_start, root_goal):\n            removed = 0\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_position)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(rm_node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n\n        # Batch rewiring to optimize local connectivity\n        def batch_rewire(tree_nodes, iteration):\n            if len(tree_nodes) <= 1:\n                return\n            kdtree = KDTree([(n.position, n) for n in tree_nodes])\n            radius = neighbor_radius(len(tree_nodes), iteration)\n            for node in tree_nodes:\n                near_nodes = kdtree.radius_search(node.position, radius)\n                for nbr in near_nodes:\n                    if nbr is node or nbr is node.parent:\n                        continue\n                    c_via_node = node.cost + dist(node.position, nbr.position)\n                    if c_via_node + 1e-12 < nbr.cost and can_connect(node.position, nbr.position):\n                        try:\n                            # Remove old edge\n                            edges.remove((nbr.parent, nbr))\n                        except (ValueError, NameError):\n                            pass\n                        nbr.update_parent(node, c_via_node)\n                        edges.append((node, nbr))\n\n        # Initialize trees\n        root_start = Node(start_position, cost=0.0)\n        root_goal = Node(goal_position, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            # Sample point biased to obstacle boundary and corridor between trees\n            if (it % 5) == 0 and len(best_path) >= 3:\n                # Sample near best path corridor for refinement\n                base_pt = best_path[random.randint(0, len(best_path) - 1)]\n                noise = [random.gauss(0, self.step_size) for _ in range(dim)]\n                sample = tuple(min(max(base_pt[d] + noise[d], 0), bounds[d]) for d in range(dim))\n                if is_in_obstacle(sample):\n                    sample = boundary_informed_sample()\n            else:\n                sample = boundary_informed_sample()\n\n            # Alternate expanding smaller tree for better balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            if not tree_a:\n                continue\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(sample)\n            new_pos = steer(nearest_a.position, sample)\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(len(nodes), it)\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            # Choose parent minimizing cost (lazy collision for edges)\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for nbr in near_nodes:\n                cost_candidate = nbr.cost + dist(nbr.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost:\n                    # defer collision check for lazy evaluation, cache on success only\n                    best_parent = nbr\n                    min_cost = cost_candidate\n\n            # Confirm edge collision for best_parent-new_pos\n            if not can_connect(best_parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost improved (lazy collision checking)\n            for nbr in near_nodes:\n                if nbr is best_parent:\n                    continue\n                c_new = new_node.cost + dist(new_node.position, nbr.position)\n                if c_new + 1e-12 < nbr.cost:\n                    # Check edge collision only if better cost\n                    if can_connect(new_node.position, nbr.position):\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.update_parent(new_node, c_new)\n                        edges.append((new_node, nbr))\n\n            # Attempt incremental connection to other tree\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            max_connect_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            connected = False\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_b_nodes = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_b_nodes:\n                    if nbr_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if c_via_new_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, nbr_b))\n\n                # Check if connected within step_size\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    connect_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=connect_cost)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if connect_cost + 1e-12 < c_best:\n                        c_best = connect_cost\n                        best_path = progressive_shortcut_path(merged_path, self.smoothing_iterations_init)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Batch rewiring at intervals for both trees\n            if it > 0 and it % self.batch_rewire_interval == 0:\n                batch_rewire(tree_start, it)\n                batch_rewire(tree_goal, it)\n\n            # Periodic pruning to reduce search tree size\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > 250 and c_best < float('inf'):\n                removed_s = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_g = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n            # Progressive smoothing of best path every 500 iterations\n            if success_state and it % 500 == 0 and best_path:\n                best_path = progressive_shortcut_path(best_path, self.smoothing_iterations_batch)\n                extracted_path = best_path\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 9.46305,
        "time_improvement": -46.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.015555047988891601,
                "num_nodes_avg": 100.4,
                "path_length_avg": 160.47926016880558,
                "success_improvement": 0.0,
                "time_improvement": -54.18096399436615,
                "length_improvement": 19.79400821352656,
                "objective_score": -12.295487555604533
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.030246663093566894,
                "num_nodes_avg": 216.1,
                "path_length_avg": 238.44289020185434,
                "success_improvement": 0.0,
                "time_improvement": -111.45535915193638,
                "length_improvement": 20.876582149030188,
                "objective_score": -29.261291315774876
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.02040393352508545,
                "num_nodes_avg": 140.4,
                "path_length_avg": 126.19365812367366,
                "success_improvement": 0.0,
                "time_improvement": 28.88581801381229,
                "length_improvement": 22.509491878198684,
                "objective_score": 13.167643779783424
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* planner featuring adaptive step sizing, informed elliptical sampling biased around the current best path cost, dynamic neighborhood radius shrinking for efficient rewiring, and rigorous collision and edge checks. The planner balances tree expansions from start and goal nodes, incorporates path shortcut smoothing post-planning to produce smoother and shorter paths, and stops early upon finding a valid improved path to maximize planning efficiency and success rate.",
        "planning_mechanism": "The planner grows two trees alternately from start and goal, sampling points primarily inside an informed elliptical region around the best known path cost or uniformly otherwise. Each extension uses adaptive step sizes depending on the proximity to the sample, ensuring fine resolution near obstacles and goal regions. New nodes are attached via lowest-cost parents within a shrinking neighborhood radius, enabling incremental path cost optimization with rewiring. Trees attempt connection through direct collision-free motions. Upon tree connection, the combined path is extracted and shortcut-smoothed to reduce unnecessary detours.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float = 0.2, radius_const: float = 30.0,\n                 radius_min: float = 5.0, smoothing_iter: int = 50):\n        self.max_iter = max_iter\n        self.step_size_base = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.smoothing_iter = smoothing_iter\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_path_cost = math.inf\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, adapt_step=None):\n            dist = distance(from_pos, to_pos)\n            max_step = adapt_step if adapt_step is not None else self.step_size_base\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (sum((node.position[d] - pos[d])**2 for d in range(len(pos))) <= radius_sq)]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_const\n            return max(self.radius_min,\n                       self.radius_const * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        def collision_free(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def edge_collision_free(pos1, pos2):\n            res = max(0.25, self.step_size_base / 5)\n            return not self._is_edge_in_obstacle(pos1, pos2, obstacles, is_3d, resolution=res)\n\n        def uniform_sample():\n            for _ in range(100):\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                if collision_free(p):\n                    return p\n            return start_position\n\n        def informed_sample():\n            if best_path_cost == math.inf:\n                return uniform_sample()\n\n            c_best = best_path_cost\n            c_min = distance(start_position, goal_position)\n            if c_best <= c_min:\n                # Path cost equals minimum distance, bias strongly towards goal\n                if random.random() < 0.9:\n                    return goal_position\n                else:\n                    return uniform_sample()\n\n            dim = len(bounds)\n            center = tuple((start_position[d] + goal_position[d]) / 2.0 for d in range(dim))\n            a1 = tuple((goal_position[d] - start_position[d]) / c_min for d in range(dim))\n\n            r1 = c_best / 2.0\n            r2_val = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n\n            def sample_unit_ball():\n                if dim == 2:\n                    while True:\n                        x = random.uniform(-1, 1)\n                        y = random.uniform(-1, 1)\n                        if x * x + y * y <= 1:\n                            return (x, y)\n                else:\n                    while True:\n                        x = random.uniform(-1, 1)\n                        y = random.uniform(-1, 1)\n                        z = random.uniform(-1, 1)\n                        if x * x + y * y + z * z <= 1:\n                            return (x, y, z)\n\n            sample_ball = sample_unit_ball()\n\n            if dim == 2:\n                import math as m\n                ang = m.atan2(a1[1], a1[0])\n                x_ball, y_ball = sample_ball\n                x_ellipse = r1 * x_ball\n                y_ellipse = r2_val * y_ball\n                cos_ang = m.cos(ang)\n                sin_ang = m.sin(ang)\n                sample_rotated = (\n                    center[0] + cos_ang * x_ellipse - sin_ang * y_ellipse,\n                    center[1] + sin_ang * x_ellipse + cos_ang * y_ellipse\n                )\n                sample_clamped = tuple(min(max(sample_rotated[d], 0.0), bounds[d]) for d in range(dim))\n                if collision_free(sample_clamped):\n                    return sample_clamped\n                else:\n                    return uniform_sample()\n            else:\n                import numpy as np\n                a1_vec = np.array(a1)\n                if abs(a1_vec[0]) < 0.9:\n                    temp = np.array([1,0,0])\n                else:\n                    temp = np.array([0,1,0])\n                a2_vec = temp - a1_vec * np.dot(temp, a1_vec)\n                a2_vec /= np.linalg.norm(a2_vec)\n                a3_vec = np.cross(a1_vec, a2_vec)\n                r3 = r2_val\n\n                sample_ball_np = np.array(sample_ball)\n                scale = np.array([r1, r2_val, r3])\n                ellip_point = a1_vec*sample_ball_np[0]*scale[0] + a2_vec*sample_ball_np[1]*scale[1] + a3_vec*sample_ball_np[2]*scale[2]\n                sample_final = tuple(center[d] + ellip_point[d] for d in range(dim))\n                sample_clamped = tuple(min(max(sample_final[d], 0.0), bounds[d]) for d in range(dim))\n                if collision_free(sample_clamped):\n                    return sample_clamped\n                else:\n                    return uniform_sample()\n\n        def sample_point():\n            # Goal bias sampling or informed sampling\n            if random.random() < self.goal_sample_rate:\n                if random.random() < 0.85:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                return informed_sample()\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            dist_to_sample = distance(nearest_node.position, point)\n            adapt_step = min(self.step_size_base, dist_to_sample * 0.9)\n\n            new_pos = steer(nearest_node.position, point, adapt_step=adapt_step)\n\n            # Check bounds\n            for d in range(len(new_pos)):\n                if new_pos[d] < 0 or new_pos[d] > bounds[d]:\n                    return None\n\n            if not collision_free(new_pos) or not edge_collision_free(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = radius_by_nodes(n_nodes)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + distance(node.position, new_pos)\n                if temp_cost < min_cost and edge_collision_free(node.position, new_pos):\n                    min_cost = temp_cost\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-9 < neighbor.cost:\n                    if edge_collision_free(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                dist_to_goal = distance(last_node.position, node.position)\n                if dist_to_goal <= 0.1:\n                    return last_node\n\n                adapt_step = min(self.step_size_base, dist_to_goal * 0.9)\n                new_pos = steer(last_node.position, node.position, adapt_step=adapt_step)\n\n                for d in range(len(new_pos)):\n                    if new_pos[d] < 0 or new_pos[d] > bounds[d]:\n                        return None\n\n                if not collision_free(new_pos) or not edge_collision_free(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                last_node = new_node\n\n                if distance(new_pos, node.position) <= adapt_step:\n                    if edge_collision_free(new_pos, node.position):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if edge_collision_free(p_i, p_j):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            rand_point = sample_point()\n\n            # Expand smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                path = extract_path(new_node_start, new_node_goal)\n                path_cost = sum(distance(path[k], path[k+1]) for k in range(len(path)-1))\n                if path_cost < best_path_cost:\n                    best_path_cost = path_cost\n                    extracted_path = shortcut_path(path)\n                    success_state = True\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance_val / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 15.88998,
        "time_improvement": -66.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.01166067123413086,
                "num_nodes_avg": 93.4,
                "path_length_avg": 162.00360832502164,
                "success_improvement": 0.0,
                "time_improvement": -15.580069761506401,
                "length_improvement": 19.032153656317195,
                "objective_score": -0.867590197188481
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.04047954082489014,
                "num_nodes_avg": 332.0,
                "path_length_avg": 251.30012996732512,
                "success_improvement": 0.0,
                "time_improvement": -182.99372452933972,
                "length_improvement": 16.61011501506681,
                "objective_score": -51.57609435578855
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.028690695762634277,
                "num_nodes_avg": 234.9,
                "path_length_avg": 123.98941495576157,
                "success_improvement": 0.0,
                "time_improvement": 0.003822436204791025,
                "length_improvement": 23.863029969139195,
                "objective_score": 4.773752724689277
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "This planner implements an advanced bidirectional RRT* algorithm enhanced with ellipsoidal informed sampling, adaptive neighbor radius, KD-tree acceleration, collision caching, incremental rewiring, aggressive periodic pruning, and intensive path shortcut smoothing. These enhancements aim to yield fast convergence, high-quality smooth paths, increased success rates, and reduced computational overhead in both 2D and 3D obstacle-laden environments.",
        "planning_mechanism": "The planner grows two trees alternately from start and goal positions, sampling points biased by an ellipsoidal informed distribution centered on the current best-known path cost. KD-trees enable efficient nearest neighbor and radius queries used for rewiring and local optimization. Collision checks on nodes and edges are cached to avoid redundant computations. Periodic pruning removes nodes unlikely to improve the solution, and intensive shortcutting refines the final path to improve smoothness and length. Early termination occurs once a sufficiently good connecting path is found.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision/etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 150, prune_threshold: int = 200,\n                 smoothing_iterations: int = 200, collision_check_resolution: float = 0.5,\n                 goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / self.collision_check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        d_ += delta * delta\n                        if d_ > best_dist * best_dist:\n                            break\n                    curr_dist = d_ ** 0.5\n                    if curr_dist < best_dist:\n                        best_dist = curr_dist\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            # Bias samples around informed ellipsoid informed by best cost:\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback uniform\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) ** 2, 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    x_scaled = x / norm_x * np.random.uniform() ** (1 / dim)\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + center\n                    p_tuple = tuple(float(c) for c in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            # fallback uniform sampling\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate balanced tree growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Incremental rewiring neighbors for local optimality\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Connect other tree towards new_node incrementally\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Aggressive pruning to reduce complexity and speed up\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": 30.61648,
        "time_improvement": -115.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.024819111824035643,
                "num_nodes_avg": 100.5,
                "path_length_avg": 167.97242850863591,
                "success_improvement": 0.0,
                "time_improvement": -146.00596470332454,
                "length_improvement": 16.04899469784288,
                "objective_score": -40.59199047142878
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.036669230461120604,
                "num_nodes_avg": 231.0,
                "path_length_avg": 236.40004372520366,
                "success_improvement": 0.0,
                "time_improvement": -156.35572667950095,
                "length_improvement": 21.554467722555064,
                "objective_score": -42.59582445933927
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.04124429225921631,
                "num_nodes_avg": 192.5,
                "path_length_avg": 126.50881029594893,
                "success_improvement": 0.0,
                "time_improvement": -43.749444292562615,
                "length_improvement": 22.315969459335395,
                "objective_score": -8.661639395901705
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This algorithm implements an advanced bidirectional RRT* planner that synergizes adaptive informed sampling focused inside an ellipsoidal heuristic region, dynamic neighborhood radius adjustment, balanced tree growth, dead-end pruning, and enhanced rewiring strategies. It uses adaptive step sizing for finer navigation near obstacles and goal, performs rigorous collision and edge checks, and includes iterative shortcut smoothing to produce efficient, smooth, and shorter paths quickly. The planner halts early on improved solutions to maximize efficiency and success rate.",
        "planning_mechanism": "The planner grows two trees from start and goal positions, always expanding the smaller tree to maintain balance. Sampling points are biased within an informed ellipsoidal region derived from the current best path cost or uniform otherwise, guiding the search intelligently. For each sampled point, an adaptive step-sized extension is attempted with rewiring of nearby nodes within a shrinking neighborhood to optimize path costs. Periodic pruning eliminates dead-ends, minimizing computational overhead. Upon successful tree connection, the combined path is extracted and shortcut-smoothed iteratively, reducing detours and further improving quality.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float = 0.2, radius_const: float = 30.0,\n                 radius_min: float = 5.0, prune_interval: int = 200,\n                 prune_threshold: int = 100, smoothing_iter: int = 50):\n        self.max_iter = max_iter\n        self.step_size_base = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iter = smoothing_iter\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D or 3D\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_path_cost = math.inf\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, adapt_step=None):\n            dist = distance(from_pos, to_pos)\n            max_step = adapt_step if adapt_step is not None else self.step_size_base\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (sum((node.position[d] - pos[d])**2 for d in range(len(pos))) <= radius_sq)]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_const\n            return max(self.radius_min,\n                       self.radius_const * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        def collision_free(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def edge_collision_free(pos1, pos2):\n            res = max(0.25, self.step_size_base / 5)\n            return not self._is_edge_in_obstacle(pos1, pos2, obstacles, is_3d, resolution=res)\n\n        def uniform_sample():\n            for _ in range(100):\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                if collision_free(p):\n                    return p\n            return start_position\n\n        def informed_sample():\n            if best_path_cost == math.inf:\n                return uniform_sample()\n\n            c_best = best_path_cost\n            c_min = distance(start_position, goal_position)\n            if c_best <= c_min:\n                # Path cost equals minimum distance, bias strongly towards goal\n                if random.random() < 0.9:\n                    return goal_position\n                else:\n                    return uniform_sample()\n\n            dim = len(bounds)\n            center = tuple((start_position[d] + goal_position[d]) / 2.0 for d in range(dim))\n            a1 = tuple((goal_position[d] - start_position[d]) / c_min for d in range(dim))\n            r1 = c_best / 2.0\n            r2_val = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n\n            def sample_unit_ball():\n                if dim == 2:\n                    while True:\n                        x = random.uniform(-1, 1)\n                        y = random.uniform(-1, 1)\n                        if x * x + y * y <= 1:\n                            return (x, y)\n                else:\n                    while True:\n                        x = random.uniform(-1, 1)\n                        y = random.uniform(-1, 1)\n                        z = random.uniform(-1, 1)\n                        if x * x + y * y + z * z <= 1:\n                            return (x, y, z)\n\n            sample_ball = sample_unit_ball()\n\n            if dim == 2:\n                import math as m\n                ang = m.atan2(a1[1], a1[0])\n                x_ball, y_ball = sample_ball\n                x_ellipse = r1 * x_ball\n                y_ellipse = r2_val * y_ball\n                cos_ang = m.cos(ang)\n                sin_ang = m.sin(ang)\n                sample_rotated = (\n                    center[0] + cos_ang * x_ellipse - sin_ang * y_ellipse,\n                    center[1] + sin_ang * x_ellipse + cos_ang * y_ellipse\n                )\n                sample_clamped = tuple(min(max(sample_rotated[d], 0.0), bounds[d]) for d in range(dim))\n                if collision_free(sample_clamped):\n                    return sample_clamped\n                else:\n                    return uniform_sample()\n            else:\n                import numpy as np\n                a1_vec = np.array(a1)\n                if abs(a1_vec[0]) < 0.9:\n                    temp = np.array([1,0,0])\n                else:\n                    temp = np.array([0,1,0])\n                a2_vec = temp - a1_vec * np.dot(temp, a1_vec)\n                a2_vec /= np.linalg.norm(a2_vec)\n                a3_vec = np.cross(a1_vec, a2_vec)\n                r3 = r2_val\n\n                sample_ball_np = np.array(sample_ball)\n                scale = np.array([r1, r2_val, r3])\n                ellip_point = a1_vec*sample_ball_np[0]*scale[0] + a2_vec*sample_ball_np[1]*scale[1] + a3_vec*sample_ball_np[2]*scale[2]\n                sample_final = tuple(center[d] + ellip_point[d] for d in range(dim))\n                sample_clamped = tuple(min(max(sample_final[d], 0.0), bounds[d]) for d in range(dim))\n                if collision_free(sample_clamped):\n                    return sample_clamped\n                else:\n                    return uniform_sample()\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                if random.random() < 0.85:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                return informed_sample()\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            dist_to_sample = distance(nearest_node.position, point)\n            adapt_step = min(self.step_size_base, dist_to_sample * 0.9)\n\n            new_pos = steer(nearest_node.position, point, adapt_step=adapt_step)\n\n            # Check bounds\n            for d in range(len(new_pos)):\n                if new_pos[d] < 0 or new_pos[d] > bounds[d]:\n                    return None\n\n            if not collision_free(new_pos) or not edge_collision_free(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = radius_by_nodes(n_nodes)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + distance(node.position, new_pos)\n                if temp_cost + 1e-12 < min_cost and edge_collision_free(node.position, new_pos):\n                    min_cost = temp_cost\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-12 < neighbor.cost and edge_collision_free(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                dist_to_goal = distance(last_node.position, node.position)\n                if dist_to_goal <= 0.1:\n                    return last_node\n\n                adapt_step = min(self.step_size_base, dist_to_goal * 0.9)\n                new_pos = steer(last_node.position, node.position, adapt_step=adapt_step)\n\n                for d in range(len(new_pos)):\n                    if new_pos[d] < 0 or new_pos[d] > bounds[d]:\n                        return None\n\n                if not collision_free(new_pos) or not edge_collision_free(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                last_node = new_node\n\n                if distance(new_pos, node.position) <= adapt_step:\n                    if edge_collision_free(new_pos, node.position):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if edge_collision_free(p_i, p_j):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += distance(path[i], path[i + 1])\n            return length\n\n        for itr in range(self.max_iter):\n            rand_point = sample_point()\n\n            # Expand smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                path = extract_path(new_node_start, new_node_goal)\n                path_cost = sum(distance(path[k], path[k+1]) for k in range(len(path)-1))\n\n                if path_cost + 1e-9 < best_path_cost:\n                    best_path_cost = path_cost\n                    extracted_path = shortcut_path(path)\n                    success_state = True\n                    # Early termination for efficiency & improved path\n                    break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance_val / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 13.85888,
        "time_improvement": -60.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009521675109863282,
                "num_nodes_avg": 79.0,
                "path_length_avg": 158.7059756085607,
                "success_improvement": 0.0,
                "time_improvement": 5.621567459754784,
                "length_improvement": 20.680278792818076,
                "objective_score": 5.82252599649005
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03948616981506348,
                "num_nodes_avg": 220.8,
                "path_length_avg": 246.21481229144337,
                "success_improvement": 0.0,
                "time_improvement": -176.04903701110916,
                "length_improvement": 18.29759546387822,
                "objective_score": -49.1551920105571
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.03161466121673584,
                "num_nodes_avg": 199.1,
                "path_length_avg": 123.66741174733474,
                "success_improvement": 0.0,
                "time_improvement": -10.187124871512125,
                "length_improvement": 24.060759336912902,
                "objective_score": 1.7560144059289433
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid planner combines the strengths of bidirectional RRT* with adaptive informed ellipsoidal sampling, efficient KD-tree based neighbor search, collision caching, dynamic neighbor radius, periodic pruning, incremental rewiring, and aggressive shortcut smoothing to achieve fast, robust, and high-quality path planning in both 2D and 3D environments. It balances exploration and exploitation by alternating expansions between start and goal trees, leveraging heuristics to prune non-promising nodes and maintain manageable search complexity while caching collision checks to reduce computational overhead.",
        "planning_mechanism": "The planner grows two trees simultaneously from start and goal, sampling adaptively within ellipsoids defined by the best path length found so far. It uses KD-trees for fast nearest-neighbor and radius searches to connect and rewire nodes optimally. Collision checks for nodes and edges are cached to avoid redundant computations. Periodic pruning removes nodes that cannot improve the solution. Upon connecting the two trees, the combined path is shortcut-smoothed multiple times to enhance smoothness and reduce length. The process repeats until max iterations or successful convergence.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval: int=200, prune_threshold: int=300,\n                 smoothing_iterations: int=100, collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / self.collision_check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.dim = dim\n                self.points = [p for p, n in pts_nodes]\n                self.nodes = [n for p, n in pts_nodes]\n\n            def nearest(self, query_point):\n                best_node = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = 0.0\n                    for dd in range(self.dim):\n                        diff = p[dd] - query_point[dd]\n                        d += diff*diff\n                        if d > best_dist*best_dist:\n                            break\n                    if d < best_dist*best_dist:\n                        best_node = self.nodes[i]\n                        best_dist = d**0.5\n                return best_node\n\n            def radius_search(self, query_point, radius):\n                r2 = radius*radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for dd in range(self.dim):\n                        delta = p[dd] - query_point[dd]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            rev_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return not edge_collision_cache[rev_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)], dtype=np.float64)\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)], dtype=np.float64)\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1*r1 - (c_min/2)*(c_min/2), 0))\n            radii = np.array([r1] + [r_others]*(dim-1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x <= 1 and norm_x > 1e-10:\n                    x_ball = (x_ball / norm_x) * (random.uniform(0,1)**(1/dim))\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n            return len(to_remove)\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n\n        best_path = []\n        success_state = False\n        extracted_path: list = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree to balance growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Incremental rewiring\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 11.53701,
        "time_improvement": -54.0,
        "length_improvement": 23.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.010166501998901368,
                "num_nodes_avg": 68.3,
                "path_length_avg": 156.30355469998824,
                "success_improvement": 0.0,
                "time_improvement": -0.7699288205768154,
                "length_improvement": 21.880985672061716,
                "objective_score": 4.145218488239299
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.028364133834838868,
                "num_nodes_avg": 214.7,
                "path_length_avg": 231.63823696291087,
                "success_improvement": 0.0,
                "time_improvement": -98.29453875707345,
                "length_improvement": 23.134596305376345,
                "objective_score": -24.861442366046766
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.04665830135345459,
                "num_nodes_avg": 209.5,
                "path_length_avg": 123.02630402294139,
                "success_improvement": 0.0,
                "time_improvement": -62.61898371392887,
                "length_improvement": 24.454438100669513,
                "objective_score": -13.894807494044759
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm incorporating adaptive informed sampling, dynamic neighbor radius rewiring, and path shortcut smoothing for efficient, high-quality path generation in 2D and 3D environments. It balances exploration and exploitation by growing two trees from start and goal, connecting them incrementally while pruning non-promising nodes to reduce computational overhead and improve convergence.",
        "planning_mechanism": "The planner alternates expansions between the two trees, sampling adaptively within an informed ellipsoid once a path is found to bias search towards promising regions. Nodes are steered, collision-checked, and connected with rewiring of nearby nodes for path cost minimization. Upon connecting trees, the merged path undergoes shortcut smoothing. Periodic pruning removes nodes unlikely to improve the solution, enhancing speed and success robustness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = 5.0\n        self.max_radius = 30.0\n        self.prune_interval = 200\n        self.prune_threshold = 300\n        self.smoothing_iterations = 50\n        self.collision_resolution = 1.0\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        import math\n        import random\n        import numpy as np\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            n = max(n_nodes, 1)\n            r_iter = self.max_radius * (1 - (iteration / self.max_iter) ** 0.9)\n            r_log = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.min_radius, min(r_iter, r_log))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance_edge = dist(p1, p2)\n            steps = max(1, int(distance_edge / self.collision_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            I = np.eye(dim)\n            u = direction - I[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = I - 2 * np.outer(u, u)\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((a - b) ** 2 for a, b in zip(node.position, point)) <= r2]\n\n        def prune_nodes(nodes_list, tree_start, tree_goal, best_cost):\n            to_remove = []\n            for node in nodes_list:\n                if node is root_start or node is root_goal:\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            nearest_a = nearest_node(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if (not in_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            neighbors = near_nodes(tree_a, new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in neighbors:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            nearest_b = nearest_node(tree_b, new_node.position)\n            last_b = nearest_b\n            max_connect_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            connected = False\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if (not in_bounds(next_pos_b)) or is_in_obstacle(next_pos_b) or is_edge_in_obstacle(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                neighbors_b = near_nodes(tree_b, next_pos_b, r)\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is last_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and not is_edge_in_obstacle(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and not is_edge_in_obstacle(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_from_start = connection_node.path_from_root()\n                        path_from_goal = new_node.path_from_root()\n                    else:\n                        path_from_start = new_node.path_from_root()\n                        path_from_goal = connection_node.path_from_root()\n\n                    merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": -1.72076,
        "time_improvement": -9.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.008452510833740235,
                "num_nodes_avg": 73.2,
                "path_length_avg": 163.2466271311899,
                "success_improvement": 0.0,
                "time_improvement": 16.219077597859886,
                "length_improvement": 18.410904804265574,
                "objective_score": 8.547904240211082
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.024390578269958496,
                "num_nodes_avg": 240.9,
                "path_length_avg": 235.6754897795363,
                "success_improvement": 0.0,
                "time_improvement": -70.5152886466485,
                "length_improvement": 21.794899234478425,
                "objective_score": -16.795606747098862
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.02050516605377197,
                "num_nodes_avg": 166.5,
                "path_length_avg": 123.35847354432505,
                "success_improvement": 0.0,
                "time_improvement": 28.532990532822687,
                "length_improvement": 24.250466004311317,
                "objective_score": 13.40999036070907
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This improved planner implements a bidirectional informed RRT* with enhanced lazy collision checking and efficient planning heuristics. It uses adaptive ellipse sampling based on current best path cost, dynamic neighborhood radius shrinking for rewiring, and periodic pruning of dead branches for focused search. Additionally, it minimizes redundant collision checks and performs incremental path smoothing via shortcutting. These improvements aim to reduce computation time while enhancing path quality, success rate, and smoothness.",
        "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternately sampling points inside an informed ellipse that shrinks as better paths are found. Each extension performs efficient lazy collision checks to avoid unnecessary validations. Local rewiring with a dynamically decreasing radius optimizes paths continuously. When trees connect, the candidate path is shortcut-smoothed. Periodic pruning removes unpromising leaves to concentrate search effort, balancing exploration and exploitation to speed convergence and improve path quality.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag for collision or pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        curr = self\n        while curr:\n            path.append(curr.position)\n            curr = curr.parent\n        return path[::-1]\n\n    def is_leaf(self):\n        return len(self.children) == 0\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float=0.15,\n                 radius_constant: float=30.0, radius_min: float=5.0,\n                 prune_interval: int=250, prune_threshold: int=150,\n                 smoothing_trials: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def heuristic(a, b):\n            return math.dist(a, b)\n\n        def dynamic_radius(n):\n            if n == 0:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(r, self.radius_min)\n\n        def steer(from_p, to_p):\n            dist = heuristic(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(len(from_p)))\n\n        def nearest(tree, point):\n            # Use squared dist for efficiency if desired\n            return min(tree, key=lambda n: (n.position[0]-point[0])**2 + (n.position[1]-point[1])**2 if not is_3d else sum((n.position[d]-point[d])**2 for d in range(3)))\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            return [n for n in tree if sum((n.position[d] - pos[d]) ** 2 for d in range(len(pos))) <= r2]\n\n        def _sample_uniform():\n            if is_3d:\n                return tuple(random.uniform(0, bounds[d]) for d in range(3))\n            else:\n                return (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n\n        def informed_sample(cost_best):\n            c_min = heuristic(start_pos, goal_pos)\n            dim = len(start_pos)\n            if cost_best == float('inf') or cost_best < c_min:\n                # Uniform sampling over map free space\n                for _ in range(100):\n                    p = _sample_uniform()\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return _sample_uniform()  # fallback\n            else:\n                c_best = cost_best * 1.0001  # small inflation to avoid numerical issues\n                center = tuple((start_pos[d] + goal_pos[d]) / 2.0 for d in range(dim))\n                vec = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n                L_diag = [c_best / 2.0] + [math.sqrt(c_best ** 2 - c_min ** 2) / 2.0] * (dim - 1)\n                L = np.diag(L_diag)\n                e1 = np.array(vec)\n                # Construct C rotation matrix to align unit circle to ellipse\n                if dim == 2:\n                    e2 = np.array([-e1[1], e1[0]])\n                    C = np.column_stack((e1, e2))\n                else:\n                    a = np.array([1.0] + [0.0]*(dim-1))\n                    if abs(np.dot(a, e1)) > 0.9:\n                        a = np.array([0.0, 1.0] + [0.0]*(dim-2))\n                    v2 = a - np.dot(a, e1)*e1\n                    v2 /= np.linalg.norm(v2)\n                    v3 = np.cross(e1, v2)\n                    C = np.column_stack((e1, v2, v3))\n                for _ in range(200):\n                    sample_ball = np.random.uniform(-1,1,dim)\n                    norm_ball = np.linalg.norm(sample_ball)\n                    if norm_ball > 1.0 or norm_ball == 0.0:\n                        continue\n                    sample = np.dot(C, np.dot(L, sample_ball)) + np.array(center)\n                    sample_t = tuple(sample)\n                    if all(0 <= sample_t[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n                # Fallback to uniform if ellipse sampling fails\n                for _ in range(100):\n                    p = _sample_uniform()\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return _sample_uniform()\n\n        lazy_checked_edges = dict()  # keys: (node_id, pos tuple) \u2192 bool collision free or not\n\n        def edge_key(parent_node, point):\n            # Uses id and point rounded for cache key\n            key_pos = tuple(round(coord, 3) for coord in point)\n            return (id(parent_node), key_pos)\n\n        def try_extend(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not self._pos_in_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n\n            n_nodes = len(tree)\n            r = dynamic_radius(n_nodes)\n            near = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + heuristic(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + heuristic(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    key = edge_key(node, new_pos)\n                    if key not in lazy_checked_edges:\n                        collision_free = not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d)\n                        lazy_checked_edges[key] = collision_free\n                    if lazy_checked_edges[key]:\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            # Check final edge from best_parent to new_pos\n            if self._is_edge_in_obstacle(best_parent.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + heuristic(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except Exception:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not self._pos_in_bounds(new_pos, bounds):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + heuristic(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if heuristic(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d) and not self._is_in_obstacle(node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node, cost=new_node.cost + heuristic(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_branches():\n            removed = []\n            # Collect leaves excluding roots\n            leaves = [node for node in nodes if node.is_leaf() and node not in (start_root, goal_root)]\n            for node in leaves:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except Exception:\n                        pass\n                try:\n                    nodes.remove(node)\n                except Exception:\n                    pass\n                edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                removed.append(node)\n            return removed\n\n        def shortcut_path(path_raw):\n            if len(path_raw) < 3:\n                return path_raw[:]\n            smooth_path = path_raw[:]\n            for _ in range(self.smoothing_trials):\n                n_pts = len(smooth_path)\n                if n_pts < 3:\n                    break\n                i = random.randint(0, n_pts - 3)\n                j = random.randint(i + 2, n_pts - 1)\n                pt_i = smooth_path[i]\n                pt_j = smooth_path[j]\n                if not self._is_edge_in_obstacle(pt_i, pt_j, obstacles, is_3d):\n                    del smooth_path[i + 1:j]\n            return smooth_path\n\n        best_path_cost = float('inf')\n        best_path = []\n\n        tree_turn = 0\n        for itr in range(self.max_iter):\n            sample_pt = informed_sample(best_path_cost)\n\n            if tree_turn == 0:\n                new_node = try_extend(tree_start, sample_pt)\n                if new_node is None:\n                    tree_turn = 1\n                    continue\n                connect_node = try_connect(tree_goal, new_node)\n                if connect_node:\n                    success = True\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    candidate_path = path_start + path_goal[::-1][1:]\n                    candidate_cost = sum(heuristic(candidate_path[i], candidate_path[i + 1]) for i in range(len(candidate_path) - 1))\n                    if candidate_cost < best_path_cost:\n                        best_path_cost = candidate_cost\n                        best_path = candidate_path\n                    # Early stopping on good path found, could continue to find better if desired\n                    break\n            else:\n                new_node = try_extend(tree_goal, sample_pt)\n                if new_node is None:\n                    tree_turn = 0\n                    continue\n                connect_node = try_connect(tree_start, new_node)\n                if connect_node:\n                    success = True\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    candidate_path = path_start + path_goal[::-1][1:]\n                    candidate_cost = sum(heuristic(candidate_path[i], candidate_path[i + 1]) for i in range(len(candidate_path) - 1))\n                    if candidate_cost < best_path_cost:\n                        best_path_cost = candidate_cost\n                        best_path = candidate_path\n                    break\n\n            tree_turn = 1 - tree_turn\n\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_branches()\n\n        if success and best_path:\n            extracted_path = shortcut_path(best_path)\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _pos_in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 6.52476,
        "time_improvement": -36.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.012595558166503906,
                "num_nodes_avg": 87.0,
                "path_length_avg": 164.12260868721376,
                "success_improvement": 0.0,
                "time_improvement": -24.846628666496517,
                "length_improvement": 17.97309764205878,
                "objective_score": -3.8593690715371993
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.035122013092041014,
                "num_nodes_avg": 216.1,
                "path_length_avg": 240.3180421555253,
                "success_improvement": 0.0,
                "time_improvement": -145.539082097824,
                "length_improvement": 20.254343291588192,
                "objective_score": -39.61085597102956
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.010518193244934082,
                "num_nodes_avg": 114.4,
                "path_length_avg": 123.00330787317095,
                "success_improvement": 0.0,
                "time_improvement": 63.3407593851196,
                "length_improvement": 24.468559121939933,
                "objective_score": 23.895939639923867
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "This improved planner implements a bidirectional RRT* path planning algorithm enhanced with adaptive informed sampling biased towards an ellipsoidal subset that contains the optimal path, dynamic rewiring with a neighborhood radius that shrinks as more nodes are added, and progressive pruning of dead-end nodes to reduce computational load. It integrates a two-tree growth strategy by alternating expansions from start and goal points, always extending the smaller tree for balanced search. The planner enforces strict collision checks on nodes and edges, dynamically rewires to minimize path cost, and applies iterative shortcut smoothing on the final solution to produce a shorter, smoother path. This combination improves path quality, search efficiency, robustness, and success rate.",
        "planning_mechanism": "The planner grows two rapidly-exploring random trees from start and goal, alternately extending the smaller tree by sampling promising points inside an adaptively updated ellipsoidal informed sampling region which focuses search towards the optimum path. New nodes are only added after collision-free checks and neighborhood rewiring ensures lower cost connections. Periodic pruning removes dead-end nodes to maintain computational efficiency. When a connection between the two trees is found, the resulting path is shortcut-smoothed iteratively. Dynamic neighborhood radius optimizes rewiring and balanced growth accelerates convergence and robustness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_from_parent(self):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n            self.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        self.remove_from_parent()\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 5.0, prune_interval: int = 150,\n                 prune_threshold: int = 80, smoothing_iterations: int = 75):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d in range(len(pos)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        # Dynamic neighborhood radius adapted to number of nodes\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        # For informed sampling: generate samples inside an ellipsoid between start and goal\n        def informed_sample(c_best, start, goal):\n            # If no current path, fallback to uniform random sampling\n            if c_best == float('inf'):\n                return uniform_sample()\n            # Compute ellipsoid parameters\n            center = tuple((start[d] + goal[d]) / 2 for d in range(len(start)))\n            a1 = [goal[d] - start[d] for d in range(len(start))]\n            c = c_best / 2.0\n            if dist(start, goal) == 0:\n                return uniform_sample()\n            # Unit vector along start-goal line\n            e1 = [v / dist(start, goal) for v in a1]\n            # Create orthonormal basis using Gram-Schmidt for 2D or 3D\n            # Here, only support 2D or 3D\n            import numpy as np\n            nd = len(start)\n            # Build rotation matrix (R) from e1\n            if nd == 2:\n                # Find orthogonal vector for 2D\n                e2 = [-e1[1], e1[0]]\n                R = np.array([e1, e2]).T\n                L = np.diag([c, math.sqrt(c**2 - (dist(start, goal)/2)**2)])\n            else:\n                # For 3D, use Householder or QR decomposition to get orthonormal basis\n                basis = np.eye(3)\n                basis[:,0] = e1\n                # Generate e2 and e3 orthogonal vectors\n                tmp = np.array([0., 0., 0.])\n                if abs(e1[0]) < abs(e1[1]):\n                    tmp[0] = 1\n                else:\n                    tmp[1] = 1\n                v = tmp - np.dot(tmp, e1)*np.array(e1)\n                e2 = v / np.linalg.norm(v)\n                e3 = np.cross(e1, e2)\n                R = np.column_stack((e1, e2, e3))\n                L = np.diag([c, math.sqrt(c**2 - (dist(start, goal)/2)**2), math.sqrt(c**2 - (dist(start, goal)/2)**2)])\n            while True:\n                # Sample ball point\n                ball_point = random_ball(nd)\n                sample = center + R.dot(L.dot(ball_point))\n                sample_tuple = tuple(sample.tolist())\n                if in_bounds(sample_tuple) and not _is_in_obstacle(sample_tuple):\n                    return sample_tuple\n\n        def random_ball(nd):\n            # Sample uniformly from unit n-ball\n            import numpy as np\n            x = np.random.normal(0, 1, nd)\n            x /= np.linalg.norm(x)\n            r = random.random() ** (1.0 / nd)\n            return r * x\n\n        def uniform_sample():\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not _is_in_obstacle(sample) and in_bounds(sample):\n                    return sample\n\n        def sample_free(c_best):\n            # With some probability, sample goal or start to bias growth\n            p_bias = 0.8\n            if random.random() < self.goal_sample_rate:\n                if random.random() < p_bias:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                # If have current best path cost, sample informed\n                if c_best < float('inf'):\n                    return informed_sample(c_best, start_position, goal_position)\n                else:\n                    return uniform_sample()\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not _is_in_obstacle(pos)\n\n        def can_connect(p1, p2):\n            return not _is_edge_in_obstacle(p1, p2)\n\n        # Extend tree towards sample_pt and add node with optimal parent from neighbors\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors with better cost connections via new_node\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    # Remove old edge\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        # Attempt connecting a node from one tree to the other tree via incremental steps\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            # Removes nodes without children (dead ends) except roots\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        best_path_cost = float('inf')\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free(best_path_cost)\n\n            # Always extend smaller tree for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                raw_len = path_length(raw_path)\n                smooth_len = path_length(smoothed)\n                if smooth_len + 1e-12 < raw_len:\n                    extracted_path = smoothed\n                    best_path_cost = smooth_len\n                else:\n                    extracted_path = raw_path\n                    best_path_cost = raw_len\n                # Continue to search for potentially better paths after finding first solution\n                # Optionally can break here to return first found path\n                # Comment line below to keep searching:\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": -0.734,
        "time_improvement": -11.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.011141252517700196,
                "num_nodes_avg": 71.4,
                "path_length_avg": 165.68620850192954,
                "success_improvement": 0.0,
                "time_improvement": -10.431613872897948,
                "length_improvement": 17.191625483198443,
                "objective_score": 0.3088409347703047
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.021133065223693848,
                "num_nodes_avg": 200.9,
                "path_length_avg": 241.53488985526354,
                "success_improvement": 0.0,
                "time_improvement": -47.7419139768816,
                "length_improvement": 19.850552057025173,
                "objective_score": -10.352463781659445
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.021182537078857422,
                "num_nodes_avg": 153.9,
                "path_length_avg": 127.07238336560461,
                "success_improvement": 0.0,
                "time_improvement": 26.172137597731805,
                "length_improvement": 21.969901644353897,
                "objective_score": 12.24562160819032
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid planner combines strengths of both given bidirectional RRT* variants by integrating adaptive informed sampling with an ellipse-based heuristic, dynamically shrinking neighbor radius for rewiring, balanced tree growth, incremental attempts to connect opposing trees, and periodic pruning of non-promising and dead nodes. After identifying a path, a robust shortcut smoothing is applied to enhance smoothness and path optimality. The approach balances exploration and exploitation, improves efficiency, robustness, and path quality in 2D and 3D cluttered environments.",
        "planning_mechanism": "The planner grows two trees simultaneously from start and goal, sampling adaptively within ellipsoids informed by best path cost to focus search. It always expands the smaller tree, steering to sampled points within bounds and collision-free constraints. Rewiring occurs locally within a dynamically updated radius adjusting with iterations and node count. After each extension, incremental connections to the opposite tree are attempted to quickly find feasible paths. Non-promising and dead-end nodes are periodically pruned to maintain efficiency. The found path is shortcut-smoothed with collision checking, producing shorter, smoother trajectories.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = 5.0\n        self.max_radius = 30.0\n        self.prune_interval = 200\n        self.prune_threshold = 300\n        self.smoothing_iters = 50\n        self.collision_resolution = 1.0\n        self.connect_steps_factor = 5  # max incremental connect steps multiplier\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                    # Tuple[int, ...]: (W,H) or (W,H,D)\n        start = map.start                    # Tuple[float, ...]\n        goal = map.goal                      # Tuple[float, ...]\n        obstacles = map.obstacles            # List of obstacle tuples\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        root_start = Node(start, cost=0.0)\n        root_goal = Node(goal, cost=0.0)\n        nodes.extend([root_start, root_goal])\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = math.dist(start, goal)\n        best_path = []\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp to bounds strictly\n            new_p = tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n            return new_p\n\n        def radius_by_iteration_and_nodes(iteration, n_nodes):\n            n = max(n_nodes, 1)\n            r_iter = self.max_radius * (1 - (iteration / self.max_iter)**0.9)\n            r_log = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.min_radius, min(r_iter, r_log))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance_edge = dist(p1, p2)\n            steps = max(1, int(distance_edge / self.collision_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def informed_sample(c_best, c_min, start, goal):\n            # If no path or path close to min dist, sample uniformly\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Ellipsoidal sampling inside informed subset (L2 ball scaled with best cost)\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            I = np.eye(dim)\n            u_vec = direction - I[:, 0]\n            norm_u = np.linalg.norm(u_vec)\n            if norm_u > 1e-10:\n                u_vec /= norm_u\n                rot = I - 2 * np.outer(u_vec, u_vec)\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1**2 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r_other]*(dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # fallback uniform sampling\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius*radius\n            return [node for node in tree if sum((node.position[d]-point[d])**2 for d in range(dim)) <= r2]\n\n        def prune_dead_and_loose(nodes_list, tree_s, tree_g, c_best_current):\n            # Remove dead nodes (no children) and nodes not promising (based on heuristic and cost)\n            remove_cands = []\n            for node in nodes_list:\n                if node is root_start or node is root_goal:\n                    continue\n                # Dead node detection\n                if not node.children:\n                    remove_cands.append(node)\n                    continue\n                # Non-promising pruning (cost + heuristic)\n                h_cost = dist(node.position, goal)\n                if node.cost + h_cost >= c_best_current:\n                    remove_cands.append(node)\n\n            for node in remove_cands:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_s:\n                    try: tree_s.remove(node)\n                    except ValueError: pass\n                if node in tree_g:\n                    try: tree_g.remove(node)\n                    except ValueError: pass\n\n        def shortcut_path(path: list):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start, goal)\n\n            # Alternate tree expansion: always expand smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            nearest_a = nearest_node(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if (not in_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_a.position, new_pos):\n                continue\n\n            r = radius_by_iteration_and_nodes(itr, len(nodes))\n            neighbors = near_nodes(tree_a, new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in neighbors:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improvements\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connection attempt from other tree (tree_b) to new_node\n            nearest_b = nearest_node(tree_b, new_node.position)\n            last_b = nearest_b\n            max_connect_steps = int(dist(last_b.position, new_node.position) / self.step_size) * self.connect_steps_factor + 1\n            connected = False\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if (not in_bounds(next_pos_b)) or is_in_obstacle(next_pos_b) or is_edge_in_obstacle(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                # Rewire neighbors in tree_b around new_node_b\n                neighbors_b = near_nodes(tree_b, next_pos_b, r)\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is last_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and not is_edge_in_obstacle(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                # Check if connection close enough to new_node\n                if dist(new_node_b.position, new_node.position) <= self.step_size and not is_edge_in_obstacle(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Extract paths from start and goal trees accordingly\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning for efficiency and robustness\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_dead_and_loose(nodes, tree_start, tree_goal, c_best)\n\n        if success_state and extracted_path:\n            # One last smoothing pass in case of leftover improvements\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": -1.19616,
        "time_improvement": -10.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009530758857727051,
                "num_nodes_avg": 64.9,
                "path_length_avg": 155.86985190731778,
                "success_improvement": 0.0,
                "time_improvement": 5.531529743167997,
                "length_improvement": 22.097746159305405,
                "objective_score": 6.079008154811481
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02357330322265625,
                "num_nodes_avg": 217.3,
                "path_length_avg": 242.70226598899868,
                "success_improvement": 0.0,
                "time_improvement": -64.80169346034288,
                "length_improvement": 19.463177161759553,
                "objective_score": -15.547872605750952
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.020624661445617677,
                "num_nodes_avg": 169.4,
                "path_length_avg": 125.21244109141927,
                "success_improvement": 0.0,
                "time_improvement": 28.11651117937945,
                "length_improvement": 23.112018245511393,
                "objective_score": 13.057357002916113
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This improved planner integrates bidirectional RRT* search with informed ellipsoidal sampling, adaptive neighbor radius, KD-tree accelerated nearest and radius queries, collision caching, incremental rewiring, and adaptive pruning. Additionally, it applies post-processing shortcut smoothing to refine the found path, aiming to enhance planning efficiency, path quality, success rate, and robustness in 2D and 3D environments.",
        "planning_mechanism": "The planner grows two trees from start and goal, alternating expansions using ellipsoid-biased sampling focused on promising regions. KD-trees enable efficient neighbor search and rewiring within a dynamic radius that shrinks over iterations. Collision checks leverage caching for efficiency. The planner prunes non-promising nodes periodically to reduce search space complexity and smooths the resulting path via shortcutting before returning it.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-12:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(0.0, r1**2 - (c_min / 2.0) ** 2)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    u_ball = x / norm_x * np.random.uniform(0, 1) ** (1/dim)\n                    p = rot @ (u_ball * radii) + center\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            # fallback uniform\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_position)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_position, cost=0.0)\n        root_goal = Node(goal_position, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_position, goal_position)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_position, goal_position)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 4.66147,
        "time_improvement": -29.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.012890052795410157,
                "num_nodes_avg": 80.4,
                "path_length_avg": 161.6637851572127,
                "success_improvement": 0.0,
                "time_improvement": -27.765646711850962,
                "length_improvement": 19.201994009378822,
                "objective_score": -4.489295211679524
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.027151322364807128,
                "num_nodes_avg": 216.3,
                "path_length_avg": 240.3728949365362,
                "success_improvement": 0.0,
                "time_improvement": -89.8157361802135,
                "length_improvement": 20.2361412830966,
                "objective_score": -22.89749259744473
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.019553017616271973,
                "num_nodes_avg": 150.5,
                "path_length_avg": 131.52691055731262,
                "success_improvement": 0.0,
                "time_improvement": 31.851529930090965,
                "length_improvement": 19.23455360341238,
                "objective_score": 13.402369699709766
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "This enhanced bidirectional RRT* planner integrates adaptive sampling biased toward start, goal, and dynamic midpoints with gradually decaying exploration bias to improve search efficiency and path quality. It uses a dynamically adjusted rewiring radius based on iteration and tree size, fast spatial hashing for neighbor queries, balanced tree growth, pruning of dead ends, and early collision rejection. After connecting the two trees, advanced shortcutting and smoothing heuristics refine the path to achieve smoothness and near-optimality, guaranteeing robustness, reduced planning time, and higher success rates in bounded 2D/3D obstacle environments.",
        "planning_mechanism": "The planner grows two RRT* trees from start and goal simultaneously with adaptive bias sampling transitioning from goal/start focus to midpoint exploration. Nodes are extended respecting step size and validated by quick collision and boundary checks. Spatial hashing accelerates neighborhood queries for efficient rewiring. Dead-end pruning maintains manageable tree size. Tree connection triggers iterative shortcutting and smoothing to optimize path length and smoothness. The method balances exploration and exploitation dynamically for efficient, reliable, and high-quality path planning.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position       # Tuple[float, ...] (2D or 3D)\n        self.parent = parent           # Node or None\n        self.cost = cost               # Total path cost from root\n        self.children = []\n        self.valid = True              # Validity flag (for collisions etc.)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0,\n                 goal_sample_rate=0.15, radius_constant=30.0,\n                 radius_min=3.0, prune_interval=200,\n                 prune_threshold=100, smoothing_iterations=40,\n                 search_resolution=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.search_resolution = search_resolution\n\n    def plan(self, map):\n        import math\n        import random\n        from collections import defaultdict\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_within_bounds(pos):\n            return all(0 <= pos[i] <= bounds[i] for i in range(dim))\n\n        def is_free_node(pos):\n            if not is_within_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def is_free_edge(p1, p2):\n            if not is_within_bounds(p1) or not is_within_bounds(p2):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.search_resolution):\n                return False\n            return True\n\n        class SpatialHash:\n            def __init__(self, cell_size):\n                self.cell_size = cell_size\n                self.hash_table = defaultdict(list)\n\n            def _hash(self, pos):\n                return tuple(int(pos[i] // self.cell_size) for i in range(len(pos)))\n\n            def insert(self, node):\n                key = self._hash(node.position)\n                self.hash_table[key].append(node)\n\n            def remove(self, node):\n                key = self._hash(node.position)\n                if node in self.hash_table.get(key, []):\n                    self.hash_table[key].remove(node)\n                    if not self.hash_table[key]:\n                        del self.hash_table[key]\n\n            def near(self, pos, radius):\n                radius_cells = int(math.ceil(radius / self.cell_size))\n                base_key = self._hash(pos)\n                keys_to_check = []\n                if dim == 2:\n                    for dx in range(-radius_cells, radius_cells + 1):\n                        for dy in range(-radius_cells, radius_cells + 1):\n                            keys_to_check.append((base_key[0] + dx, base_key[1] + dy))\n                else:\n                    for dx in range(-radius_cells, radius_cells + 1):\n                        for dy in range(-radius_cells, radius_cells + 1):\n                            for dz in range(-radius_cells, radius_cells + 1):\n                                keys_to_check.append((base_key[0] + dx, base_key[1] + dy, base_key[2] + dz))\n                result = []\n                for key in keys_to_check:\n                    for node in self.hash_table.get(key, []):\n                        if dist(node.position, pos) <= radius:\n                            result.append(node)\n                return result\n\n        def radius_by_nodes_and_iter(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt(math.log(n_nodes) / n_nodes)\n            decay = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay)\n\n        def adaptive_sample(itr):\n            r = random.random()\n            bias_decay = 1 - itr / self.max_iter\n            # Bias toward goal/start or midpoint shifting over iterations for exploration refinement\n            if r < self.goal_sample_rate:\n                sr = random.random()\n                if sr < 0.6 and is_free_node(goal_position):\n                    return goal_position\n                elif sr < 0.85 and is_free_node(start_position):\n                    return start_position\n                if len(tree_start) > 15 and len(tree_goal) > 15:\n                    mid_s = random.choice(tree_start).position\n                    mid_g = random.choice(tree_goal).position\n                    midpoint = tuple((mid_s[i] + mid_g[i]) / 2 for i in range(dim))\n                    spread = self.step_size * 5 * bias_decay\n                    for _ in range(7):\n                        candidate = tuple(\n                            max(0, min(bounds[d], midpoint[d] + random.uniform(-spread, spread)))\n                            for d in range(dim)\n                        )\n                        if is_free_node(candidate):\n                            return candidate\n            # Uniform sampling with rejection\n            for _ in range(75):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n            return start_position\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        cell_size = self.step_size * 1.5\n        hash_start = SpatialHash(cell_size)\n        hash_goal = SpatialHash(cell_size)\n        hash_start.insert(start_root)\n        hash_goal.insert(goal_root)\n\n        def try_extend(tree, tree_hash, target, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, target)\n            new_pos = steer(nearest_node.position, target)\n            if not is_free_node(new_pos):\n                return None\n            if not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes_and_iter(len(tree), itr)\n            near_nodes = tree_hash.near(new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near_nodes:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost and is_free_edge(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            tree_hash.insert(new_node)\n\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect_and_rewire(tree, tree_hash, target_node, itr):\n            if not tree:\n                return None\n            last_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos):\n                    return None\n                if not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes_and_iter(len(tree), itr)\n                near_nodes_ = tree_hash.near(new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n\n                for node in near_nodes_:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-10 < min_cost and is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                tree_hash.insert(new_node)\n\n                for neighbor in near_nodes_:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-10 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        tree_hash.insert(final_node)\n                        return final_node\n                    return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        hash_start.remove(node)\n                        hash_goal.remove(node)\n                        removed.append(node)\n                    except Exception:\n                        pass\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if is_free_edge(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            sample = adaptive_sample(itr)\n\n            # Balanced growth: extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n                hash_start, hash_goal = hash_goal, hash_start\n\n            new_node_start = try_extend(tree_start, hash_start, sample, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, hash_goal, new_node_start, itr)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]  # concatenate without duplicate node\n\n                shortcuted_path = shortcut_path(raw_path)\n                smoothed_path = smooth_path(shortcuted_path)\n\n                candidates = [raw_path, shortcuted_path, smoothed_path]\n                extracted_path = min(candidates, key=path_length)\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 2.34021,
        "time_improvement": -23.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.013739061355590821,
                "num_nodes_avg": 78.4,
                "path_length_avg": 159.68692206302808,
                "success_improvement": 0.0,
                "time_improvement": -36.18098289992344,
                "length_improvement": 20.190011183238987,
                "objective_score": -6.816292633329234
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.022696256637573242,
                "num_nodes_avg": 178.9,
                "path_length_avg": 238.68157118477416,
                "success_improvement": 0.0,
                "time_improvement": -58.67023360085339,
                "length_improvement": 20.79737972396036,
                "objective_score": -13.441594135463946
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.020851445198059083,
                "num_nodes_avg": 128.4,
                "path_length_avg": 121.81686837022878,
                "success_improvement": 0.0,
                "time_improvement": 27.32609784938106,
                "length_improvement": 25.19710444906457,
                "objective_score": 13.237250244627232
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This planner implements a bidirectional informed RRT* algorithm simplified for generalization, combining efficient ellipse sampling, adaptive neighborhood radius, lazy collision checking, incremental rewiring, and periodic pruning. It balances exploration and exploitation to rapidly find high-quality, smooth, and feasible paths in 2D or 3D spaces.",
        "planning_mechanism": "The planner alternates expanding two trees from start and goal within an informed ellipsoidal sampling region that shrinks based on the current best path cost. New nodes are connected via collision-checked edges, and local rewiring optimizes the tree connectivity. Periodic pruning removes unpromising nodes to focus the search, while shortcut smoothing refines the best found path before returning.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]: 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision/pruning status\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except Exception:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def is_leaf(self):\n        return len(self.children) == 0\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_radius: float = 5.0, max_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_trials: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp to bounds\n            new_p = tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n            return new_p\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        # KDTree substitute: brute force for simplicity and generality\n        def nearest_node(tree, point):\n            best = None\n            bd = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < bd:\n                    bd = d\n                    best = node\n            return best\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d]-pos[d])**2 for d in range(dim)) <= r2]\n\n        def ellipse_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback uniform sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)  # Householder reflection\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2_val = math.sqrt(max(r1*r1 - (c_min/2)*(c_min/2), 0))\n            radii = np.array([r1] + [r2_val]*(dim-1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-10:\n                    x = x / norm_x\n                    x = x * np.power(np.random.uniform(0,1), 1/dim)  # Uniform in unit ball\n                    p = rot @ (x * radii) + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n            # fallback uniform\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth_path = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth_path) < 3:\n                    break\n                i = random.randint(0, len(smooth_path) - 3)\n                j = random.randint(i + 2, len(smooth_path) -1)\n                p1, p2 = smooth_path[i], smooth_path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    smooth_path = smooth_path[:i+1] + smooth_path[j:]\n            return smooth_path\n\n        def prune_nodes(best_cost):\n            to_remove = []\n            h = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + h(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except Exception:\n                        pass\n                try:\n                    nodes.remove(node)\n                except Exception:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n            return len(to_remove)\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = ellipse_sample(c_best, c_min, start_pos, goal_pos)\n            # Alternate tree growth for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            nearest_a = nearest_node(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not in_bounds(new_pos) or is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes_a = near_nodes(tree_a, new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near_nodes_a:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Connect other tree toward new node\n            nearest_b = nearest_node(tree_b, new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not in_bounds(next_pos_b) or is_in_obstacle(next_pos_b):\n                    break\n                if is_edge_in_obstacle(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_nodes_b = near_nodes(tree_b, next_pos_b, r)\n                for neighbor_b in near_nodes_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if new_cost_b + 1e-12 < neighbor_b.cost and not is_edge_in_obstacle(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and not is_edge_in_obstacle(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -5.68873,
        "time_improvement": 4.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009312152862548828,
                "num_nodes_avg": 77.3,
                "path_length_avg": 161.23883571484998,
                "success_improvement": 0.0,
                "time_improvement": 7.698342927903654,
                "length_improvement": 19.414379656271496,
                "objective_score": 6.192378809625396
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02024998664855957,
                "num_nodes_avg": 227.4,
                "path_length_avg": 236.57062578872734,
                "success_improvement": 0.0,
                "time_improvement": -41.56828428798828,
                "length_improvement": 21.497862822829855,
                "objective_score": -8.170912721830511
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.015281963348388671,
                "num_nodes_avg": 149.1,
                "path_length_avg": 121.9467869215883,
                "success_improvement": 0.0,
                "time_improvement": 46.73750915099538,
                "length_improvement": 25.117326632104614,
                "objective_score": 19.044718071719537
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This improved planner utilizes an optimized bidirectional RRT* framework with adaptive sampling heuristics biased between start, goal, and intermediate promising areas. It employs a dynamically decaying rewiring radius and balanced tree growth by always extending the smaller tree first. Spatial hashing accelerates neighbor searches, and edge collision checking uses adaptive resolution for efficiency. The planner prunes dead-end nodes regularly to reduce search space overhead. After a successful connection, advanced shortcutting and iterative smoothing produce high-quality paths, minimizing planning time while maximizing success rate and path smoothness in both 2D and 3D bounded environments.",
        "planning_mechanism": "The planner grows two trees from start and goal with balanced expansions, sampling adaptively towards goal, start, and midpoint areas. Each extension rewires nearby nodes within a dynamically shrinking radius to improve path cost. Dead-end nodes are periodically pruned to optimize graph size. After connecting both trees, the path undergoes shortcutting and smoothing to ensure collision-free, optimal navigation paths with reduced length and complexity.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For potential future use (collision, pruning)\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0,\n                 radius_min: float=3.0, prune_interval: int=200, prune_threshold: int=50,\n                 smoothing_iterations: int=30, search_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.search_resolution = search_resolution\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        import random\n        import math\n        from collections import defaultdict\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            # Approximate nearest by hashing acceleration will be used for near()\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        class SpatialHash:\n            def __init__(self, cell_size):\n                self.cell_size = cell_size\n                self.hash_table = defaultdict(list)\n\n            def _hash(self, pos):\n                return tuple(int(pos[i] // self.cell_size) for i in range(dim))\n\n            def insert(self, node):\n                key = self._hash(node.position)\n                self.hash_table[key].append(node)\n\n            def remove(self, node):\n                key = self._hash(node.position)\n                if node in self.hash_table.get(key, []):\n                    self.hash_table[key].remove(node)\n                    if not self.hash_table[key]:\n                        del self.hash_table[key]\n\n            def near(self, position, radius):\n                radius_cells = int(math.ceil(radius / self.cell_size))\n                base_key = self._hash(position)\n                keys_to_check = []\n                for dx in range(-radius_cells, radius_cells + 1):\n                    for dy in range(-radius_cells, radius_cells + 1):\n                        if dim == 2:\n                            keys_to_check.append((base_key[0] + dx, base_key[1] + dy))\n                        else:\n                            for dz in range(-radius_cells, radius_cells + 1):\n                                keys_to_check.append((base_key[0] + dx, base_key[1] + dy, base_key[2] + dz))\n                result = []\n                for k in keys_to_check:\n                    if k in self.hash_table:\n                        for node in self.hash_table[k]:\n                            if dist(position, node.position) <= radius:\n                                result.append(node)\n                return result\n\n        cell_size = max(self.step_size * 1.5, 1.0)\n        hash_start = SpatialHash(cell_size)\n        hash_goal = SpatialHash(cell_size)\n        hash_start.insert(start_root)\n        hash_goal.insert(goal_root)\n\n        def radius_by_nodes_and_iter(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt(math.log(n_nodes) / n_nodes)\n            decay_factor = math.exp(-6 * itr / self.max_iter)\n            radius = max(self.radius_min, base * decay_factor)\n            return radius\n\n        def _is_free_node(pos):\n            if not self._within_bounds(pos, bounds):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def _is_free_edge(p1, p2):\n            if not self._within_bounds(p1, bounds) or not self._within_bounds(p2, bounds):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.search_resolution)\n\n        def adaptive_sample(itr):\n            r = random.random()\n            bias_decay = 1 - itr / self.max_iter\n            # Bias sampling to goal, start, or midpoint region adaptively\n            if r < self.goal_sample_rate:\n                s_r = random.random()\n                if s_r < 0.6 and _is_free_node(goal_position):\n                    return goal_position\n                elif s_r < 0.85 and _is_free_node(start_position):\n                    return start_position\n                elif len(tree_start) > 15 and len(tree_goal) > 15:\n                    mid_s = random.choice(tree_start).position\n                    mid_g = random.choice(tree_goal).position\n                    mid = tuple((mid_s[i] + mid_g[i]) * 0.5 for i in range(dim))\n                    spread = self.step_size * 5 * bias_decay\n                    for _ in range(8):\n                        candidate = tuple(\n                            min(max(0, mid[d] + random.uniform(-spread, spread)), bounds[d]) for d in range(dim)\n                        )\n                        if _is_free_node(candidate):\n                            return candidate\n            for _ in range(75):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if _is_free_node(sample):\n                    return sample\n            return start_position  # safe fallback\n\n        def try_extend(tree, tree_hash, point, itr):\n            if not tree:\n                return None\n            n_node = nearest(tree, point)\n            new_pos = steer(n_node.position, point)\n            if not _is_free_node(new_pos) or not _is_free_edge(n_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes_and_iter(len(tree), itr)\n            near_nodes = tree_hash.near(new_pos, radius)\n\n            min_cost = n_node.cost + dist(n_node.position, new_pos)\n            best_parent = n_node\n\n            for node in near_nodes:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and _is_free_edge(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            tree_hash.insert(new_node)\n\n            # Mutual rewiring attempt to optimize paths\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-12 < neighbor.cost and _is_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except Exception:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect_and_rewire(tree, tree_hash, target_node, itr):\n            if not tree:\n                return None\n            last_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not _is_free_node(new_pos) or not _is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes_and_iter(len(tree), itr)\n                near_nodes = tree_hash.near(new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n\n                for node in near_nodes:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-12 < min_cost and _is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                tree_hash.insert(new_node)\n\n                for neighbor in near_nodes:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-12 < neighbor.cost and _is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except Exception:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if _is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        tree_hash.insert(final_node)\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            # Collect dead-end nodes with no children except start/goal roots\n            dead_ends = [node for node in nodes if node is not start_root and node is not goal_root and not node.children]\n            for node in dead_ends:\n                try:\n                    if node.parent and node in node.parent.children:\n                        node.parent.children.remove(node)\n                    nodes.remove(node)\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    hash_start.remove(node)\n                    hash_goal.remove(node)\n                    removed.append(node)\n                except Exception:\n                    pass\n            return removed\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if _is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def path_length(path):\n            return sum(dist(path[i], path[i + 1]) for i in range(len(path) - 1))\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            path = list(path)\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if _is_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Main planning loop\n        for itr in range(self.max_iter):\n            sample = adaptive_sample(itr)\n\n            # Always extend smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n                hash_start, hash_goal = hash_goal, hash_start\n\n            new_node_start = try_extend(tree_start, hash_start, sample, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, hash_goal, new_node_start, itr)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                shortcuted_path = shortcut_path(raw_path)\n                smoothed_path = smooth_path(shortcuted_path)\n\n                candidates = [raw_path, shortcuted_path, smoothed_path]\n                extracted_path = min(candidates, key=path_length)\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        for i, v in enumerate(pos):\n            if not (0 <= v <= bounds[i]):\n                return False\n        return True",
        "objective": 6.05909,
        "time_improvement": -34.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.0153336763381958,
                "num_nodes_avg": 71.6,
                "path_length_avg": 160.52284872641798,
                "success_improvement": 0.0,
                "time_improvement": -51.986737751562075,
                "length_improvement": 19.772223071383166,
                "objective_score": -11.641576711191988
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.025638389587402343,
                "num_nodes_avg": 191.8,
                "path_length_avg": 242.93669356008786,
                "success_improvement": 0.0,
                "time_improvement": -79.23877624155145,
                "length_improvement": 19.38538616263446,
                "objective_score": -19.89455563993854
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.020666122436523438,
                "num_nodes_avg": 153.6,
                "path_length_avg": 122.40432813257601,
                "success_improvement": 0.0,
                "time_improvement": 27.972006471550692,
                "length_improvement": 24.83636876581188,
                "objective_score": 13.358875694627585
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e1",
        "algorithm_description": "This algorithm combines the strengths of informed sampling, lazy collision checking, and bidirectional tree growth with an adaptive dynamic neighbor radius. It integrates a fast approximate nearest neighbor KD-tree for efficient rewiring, incremental path cost updates, and a heuristic-guided pruning mechanism to discard suboptimal branches early. After a valid connection between start and goal trees is found, an aggressive segment-wise path smoothing with collision-aware shortcuts is applied to optimize path length and smoothness while ensuring robustness in both 2D and 3D environments. The algorithm prioritizes balancing exploration and exploitation, achieving high success rates, reduced search times, and high-quality paths.",
        "planning_mechanism": "The planner grows two trees from start and goal positions alternately using informed ellipsoidal sampling constrained by the current best path cost. It employs lazy collision checking: nodes are added optimistically, and edges are checked on-demand, reducing unnecessary collision tests. KD-tree structures speed up nearest neighbor and radius queries. An adaptive neighbor radius shrinks as the graph grows and iterations increase, improving local rewiring quality. The trees connect by steering toward nodes in the opposite tree, and on successful connection, a collision-free path is extracted. A post-processing step aggressively shortcuts path segments by attempting direct connections between non-consecutive nodes, enhancing smoothness and reducing path length while ensuring no collisions occur.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost from root\n        self.children = []\n        self.valid = True               # For potential future flags\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.1,\n                 smoothing_iterations: int=150,\n                 prune_interval: int=250,\n                 prune_factor: float=0.95):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n        self.smoothing_iterations = smoothing_iterations\n        self.prune_interval = prune_interval\n        self.prune_factor = prune_factor\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clip to bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def heuristic(p):\n            # Euclidean heuristic from position p to goal\n            return dist(p, goal_pos)\n\n        def informed_sample(c_best, c_min, start, goal):\n            # Ellipsoidal informed sampling centered at midpoint with axes scaled by current best path\n            if c_best == float('inf') or random.random() < self.goal_sample_rate:\n                for _ in range(10):\n                    rand_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(rand_pt, obstacles, is_3d):\n                        return rand_pt\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])  # Unit direction vector along line start-goal\n\n            # Calculate rotation matrix using Householder transformation\n            id_mat = np.eye(dim)\n            e1 = np.zeros(dim)\n            e1[0] = 1.0\n            v = a1 - e1\n            s = np.linalg.norm(v)\n            if s > 1e-10:\n                u = v / s\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1**2 - (c_min / 2.0)**2, 0))\n            radii = np.array([r1] + [r_other]*(dim-1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1,1,dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    x_ellipse = x_ball * radii\n                    sample = rot @ x_ellipse + np.array(center)\n                    sample_t = tuple(float(v) for v in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n            # Fallback uniform sampling\n            for _ in range(10):\n                rand_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(rand_pt, obstacles, is_3d):\n                    return rand_pt\n            # Final fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        class KDTree:\n            # Simple KDTree wrapper for neighbor queries using exact linear scan to avoid dependency\n            def __init__(self, data_nodes):\n                self.dim = dim\n                self.points = [node.position for node in data_nodes]\n                self.nodes = data_nodes\n\n            def nearest(self, point):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, point)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, point, radius):\n                r2 = radius * radius\n                result = []\n                for p, n in zip(self.points, self.nodes):\n                    diff_sqd = 0.0\n                    for d_ in range(self.dim):\n                        diff = p[d_] - point[d_]\n                        diff_sqd += diff * diff\n                        if diff_sqd > r2:\n                            break\n                    if diff_sqd <= r2:\n                        result.append(n)\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(p):\n            if not in_bounds(p):\n                return False\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return False\n            return True\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes,1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 1.1)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius)*math.sqrt(math.log(c+1)/c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2,len(path)-1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1,p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_nodes(best_cost):\n            # Prune nodes whose cost + heuristic >= best_cost * prune_factor\n            to_remove = []\n            h = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + h(node.position) >= best_cost * self.prune_factor:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try: node.parent.children.remove(node)\n                    except ValueError: pass\n                try:\n                    nodes.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n\n        # Initialize trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth direction\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree(tree_a)\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for near_node in near_nodes:\n                cost_cand = near_node.cost + dist(near_node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(near_node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors around new_node\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-12 < near_node.cost and can_connect(new_node.position, near_node.position):\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                    except ValueError:\n                        pass\n                    near_node.update_parent(new_node, new_cost)\n                    edges.append((new_node, near_node))\n\n            # Connect tree_b toward new_node\n            kdtree_b = KDTree(tree_b)\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_b.position, new_node.position)//self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = merged_path\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                # Aggressive path smoothing before return\n                extracted_path = shortcut_path(best_path)\n                break\n\n            # Periodic pruning to improve efficiency\n            if iteration > 0 and iteration % self.prune_interval == 0 and c_best < float('inf'):\n                prune_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = shortcut_path(best_path) if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 0.08611,
        "time_improvement": -15.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009737563133239747,
                "num_nodes_avg": 65.6,
                "path_length_avg": 161.6019305614488,
                "success_improvement": 0.0,
                "time_improvement": 3.4816946941553364,
                "length_improvement": 19.232908341826366,
                "objective_score": 4.891090076611874
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.021660804748535156,
                "num_nodes_avg": 214.8,
                "path_length_avg": 233.90771499280368,
                "success_improvement": 0.0,
                "time_improvement": -51.43135735180139,
                "length_improvement": 22.38150671519905,
                "objective_score": -10.953105862500607
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.027735424041748048,
                "num_nodes_avg": 187.0,
                "path_length_avg": 123.73608896707222,
                "success_improvement": 0.0,
                "time_improvement": 3.3332474670127934,
                "length_improvement": 24.018587386808765,
                "objective_score": 5.8036917174655915
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid planner combines bidirectional RRT* with informed ellipsoidal sampling, an adaptive neighbor radius based on iteration and node count, KD-tree accelerated nearest neighbor and radius searches, collision caching for pruning redundant checks, incremental rewiring for path cost improvement, and periodic pruning of non-promising nodes. Additionally, it features an aggressive shortcut smoothing step applied to the best path found. The algorithm balances exploration and exploitation, ensuring fast convergence, improved path quality, robustness, and higher success rate in both 2D and 3D environments.",
        "planning_mechanism": "The planner grows two trees rooted at start and goal alternatively towards informed samples within an ellipsoidal domain shaped by the current best path cost. KD-trees speed up nearest neighbor and radius queries for efficient rewiring. Collision checks are cached to minimize redundant computations. After each successful connection, the best path is shortcut-smoothed aggressively. Periodic pruning removes nodes unlikely to yield better solutions, reducing search complexity and improving planner responsiveness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=150,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle tuples\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                # Uniform sampling with rejection inside obstacles\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) * (c_min / 2), 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    # Uniform sampling inside unit ball\n                    radius_factor = np.random.uniform(0,1) ** (1/dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Balance tree extension: smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new node\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connect opposite tree towards new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -6.37314,
        "time_improvement": 7.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009961986541748047,
                "num_nodes_avg": 73.0,
                "path_length_avg": 164.05118532208425,
                "success_improvement": 0.0,
                "time_improvement": 1.2572195596895708,
                "length_improvement": 18.00879435346506,
                "objective_score": 3.9789247385998836
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02033553123474121,
                "num_nodes_avg": 203.2,
                "path_length_avg": 232.0172630653562,
                "success_improvement": 0.0,
                "time_improvement": -42.16632914135226,
                "length_improvement": 23.008822621561247,
                "objective_score": -8.048134218093427
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.010979962348937989,
                "num_nodes_avg": 114.1,
                "path_length_avg": 124.8312232300356,
                "success_improvement": 0.0,
                "time_improvement": 61.73134755002613,
                "length_improvement": 23.346108977351303,
                "objective_score": 23.1886260604781
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This planner integrates bidirectional RRT* search with adaptive informed ellipsoidal sampling, KD-tree accelerated neighbor searches, collision caching, incremental rewiring, balanced tree expansion, and periodic pruning. It emphasizes efficiency and robustness by dynamically adjusting neighbor radius, aggressively pruning non-promising nodes, and caching collision results. The planner applies repeated shortcut smoothing on discovered paths to improve smoothness and path length, aiming for faster convergence and higher path quality in both 2D and 3D cluttered spaces.",
        "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling adaptively within an ellipsoidal informed subset shaped by the current best path cost to bias sampling towards promising regions. Nearest neighbors and near nodes are found efficiently via a KD-tree structure. Nodes are added only after thorough collision checking for positions and edges, and rewiring in local neighborhoods improves path optimality incrementally. When trees are close enough, incremental connections are attempted along edges with collision checks and rewiring for smooth connectivity. Periodic pruning removes dead-end and non-promising nodes to boost efficiency. Final found paths undergo iterative shortcut smoothing to enhance trajectory smoothness and reduce length.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio*(to_pos[d]-from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1**2 - (c_min / 2)**2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    sample = rot @ (x * radii) + center\n                    sample_t = tuple(float(coord) for coord in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            reverse_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            elif reverse_key in edge_collision_cache:\n                return not edge_collision_cache[reverse_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        # KD-tree substitute for nearest and radius searches, brute-force for clarity & correctness\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius*radius\n                res = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        diff = p[d_] - pt[d_]\n                        sqd += diff*diff\n                        if sqd > r2:\n                            break\n                    else:\n                        res.append(n)\n                return res\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_nonpromising_nodes(nodes_list, tree_s, tree_g, best_cost):\n            # Remove dead-end (no children) and nodes with cost+heuristic >= best_cost\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                if not node.children:\n                    to_remove.append(node)\n                    continue\n                h_cost = dist(node.position, goal_pos)\n                if node.cost + h_cost >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_s:\n                    try:\n                        tree_s.remove(node)\n                    except ValueError:\n                        pass\n                if node in tree_g:\n                    try:\n                        tree_g.remove(node)\n                    except ValueError:\n                        pass\n            return len(to_remove)\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree expansion for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(itr, len(nodes))\n            near_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors in tree_a\n            for neighbor in near_a:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Incrementally connect tree_b to new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Extract and merge paths according to expansion order\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning for efficiency & robustness\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nonpromising_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        if success_state and extracted_path:\n            # Final smoothing\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -3.8343,
        "time_improvement": -1.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.011786651611328126,
                "num_nodes_avg": 69.6,
                "path_length_avg": 165.00672698196314,
                "success_improvement": 0.0,
                "time_improvement": -16.828781820416122,
                "length_improvement": 17.531223816043198,
                "objective_score": -1.5423897829161968
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02196238040924072,
                "num_nodes_avg": 211.6,
                "path_length_avg": 240.82774028752243,
                "success_improvement": 0.0,
                "time_improvement": -53.539682142827374,
                "length_improvement": 20.085208207536294,
                "objective_score": -12.044863001340953
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.009235286712646484,
                "num_nodes_avg": 107.8,
                "path_length_avg": 124.20167944050509,
                "success_improvement": 0.0,
                "time_improvement": 67.81209568388785,
                "length_improvement": 23.73268678847898,
                "objective_score": 25.09016606286215
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "This planner implements an adaptive bidirectional RRT* algorithm with enhanced informed sampling, dynamic neighbor radius adjustment, and periodic path shortcut smoothing. It improves planning efficiency and path quality by balancing exploration and exploitation, pruning non-promising nodes, and intelligently rewiring the trees to minimize overall path cost while ensuring collision-free connections.",
        "planning_mechanism": "The planner grows two trees from start and goal, alternately expanding them through sampled points biased within an informed ellipsoid after a feasible path is found. It dynamically adjusts neighbor radius for rewiring, performs collision checks on nodes and edges, prunes nodes unlikely to improve the solution at intervals, and refines the final path through shortcut smoothing to ensure smooth and optimized paths.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = 5.0\n        self.max_radius = 30.0\n        self.prune_interval = 150\n        self.prune_threshold = 250\n        self.smoothing_iterations = 50\n        self.collision_resolution = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            n = max(n_nodes, 1)\n            r_iter = self.max_radius * (1 - (iteration / self.max_iter) ** 0.9)\n            r_log = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.min_radius, min(r_iter, r_log))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance_edge = dist(p1, p2)\n            steps = max(1, int(distance_edge / self.collision_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            I = np.eye(dim)\n            u = direction - I[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = I - 2 * np.outer(u, u)\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((a - b) ** 2 for a, b in zip(node.position, point)) <= r2]\n\n        def prune_nodes(nodes_list, tree_start, tree_goal, best_cost):\n            to_remove = []\n            for node in nodes_list:\n                if node is root_start or node is root_goal:\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree expansion\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            nearest_a = nearest_node(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            # Collision and bounds checks\n            if (not in_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            neighbors = near_nodes(tree_a, new_pos, r)\n\n            # Choose best parent minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in neighbors:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better path via new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt connection from tree_b to new_node incrementally\n            nearest_b = nearest_node(tree_b, new_node.position)\n            last_b = nearest_b\n            max_connect_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            connected = False\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if (not in_bounds(next_pos_b)) or is_in_obstacle(next_pos_b) or is_edge_in_obstacle(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                neighbors_b = near_nodes(tree_b, next_pos_b, r)\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is last_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and not is_edge_in_obstacle(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                # Check if we can connect new_node_b directly to new_node\n                if dist(new_node_b.position, new_node.position) <= self.step_size and not is_edge_in_obstacle(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic pruning to reduce search space and improve speed\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -1.63515,
        "time_improvement": -8.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.00947272777557373,
                "num_nodes_avg": 77.8,
                "path_length_avg": 163.7737858499551,
                "success_improvement": 0.0,
                "time_improvement": 6.10673132367259,
                "length_improvement": 18.147435943411075,
                "objective_score": 5.461506585783992
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.019690179824829103,
                "num_nodes_avg": 203.3,
                "path_length_avg": 241.18177500808025,
                "success_improvement": 0.0,
                "time_improvement": -37.65465743264079,
                "length_improvement": 19.96772750972755,
                "objective_score": -7.3028517278467255
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.02638061046600342,
                "num_nodes_avg": 195.3,
                "path_length_avg": 127.59143182722558,
                "success_improvement": 0.0,
                "time_improvement": 8.055202626512253,
                "length_improvement": 21.651174620913228,
                "objective_score": 6.746795712136322
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This planner implements a simplified bidirectional RRT* path planning algorithm with adaptive informed sampling within an ellipsoidal region, dynamic neighborhood rewiring, and iterative shortcut smoothing to efficiently generate high-quality, collision-free paths in 2D or 3D environments. It balances exploration and exploitation by extending the smaller of two trees grown from start and goal, applies strict collision and edge checks before adding nodes or edges, and prunes unnecessary nodes to maintain computational efficiency. The final path is smoothed to reduce unnecessary detours and improve smoothness and length.",
        "planning_mechanism": "The planner alternates tree expansions, sampling points biased towards an informed ellipsoid once a solution path is found, dynamically adapts neighborhood radius for rewiring, connects and rewires nodes to reduce path cost, prunes unpromising nodes periodically, and applies shortcut smoothing to the resulting path upon successful connection of the two trees.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = 5.0\n        self.max_radius = 30.0\n        self.prune_interval = 150\n        self.prune_threshold = 100\n        self.smoothing_iterations = 50\n        self.collision_resolution = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            clamped = tuple(max(0.0, min(new_pos[d], bounds[d])) for d in range(dim))\n            return clamped\n\n        def neighbor_radius(iteration: int, n_nodes: int) -> float:\n            n = max(n_nodes, 1)\n            r_iter = self.max_radius * (1 - (iteration / self.max_iter) ** 0.9)\n            r_log = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.min_radius, min(r_iter, r_log))\n\n        def is_in_obstacle(p: Tuple[float, ...]) -> bool:\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            distance_edge = dist(p1, p2)\n            steps = max(1, int(distance_edge / self.collision_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def informed_sample(c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            if c_best == float('inf') or c_best <= c_min * 1.00001:\n                # Uniform random sampling\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            I = np.eye(dim)\n            u = direction - I[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = I - 2 * np.outer(u, u)  # Householder transform\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            # Fallback uniform samples if informed fails\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def nearest_node(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree if sum((node.position[d]-point[d])**2 for d in range(dim)) <= r_sq]\n\n        def prune_nodes(nodes_list: List[Node], tree_start: List[Node], tree_goal: List[Node], best_cost: float):\n            to_remove = []\n            for node in nodes_list:\n                if node is root_start or node is root_goal:\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            length = len(path)\n            if length < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes.extend([root_start, root_goal])\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        edges: List[Tuple[Node, Node]] = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path: List[Tuple[float, ...]] = []\n\n        for itr in range(self.max_iter):\n            sample_pt = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Always extend smaller tree for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            nearest_a = nearest_node(tree_a, sample_pt)\n            new_pos = steer(nearest_a.position, sample_pt)\n\n            if (not in_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_a.position, new_pos):\n                continue\n\n            radius = neighbor_radius(itr, len(nodes))\n            neighbors = near_nodes(tree_a, new_pos, radius)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in neighbors:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try connecting other tree towards new_node incrementally\n            nearest_b = nearest_node(tree_b, new_node.position)\n            last_b = nearest_b\n            max_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos = steer(last_b.position, new_node.position)\n                if (not in_bounds(next_pos)) or is_in_obstacle(next_pos) or is_edge_in_obstacle(last_b.position, next_pos):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos)\n                new_node_b = Node(next_pos, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                neighbors_b = near_nodes(tree_b, next_pos, radius)\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_b_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_b_via_new + 1e-12 < neighbor_b.cost and not is_edge_in_obstacle(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_b_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and not is_edge_in_obstacle(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_a = connection_node.path_from_root()\n                        path_b = new_node.path_from_root()\n                    else:\n                        path_a = new_node.path_from_root()\n                        path_b = connection_node.path_from_root()\n\n                    merged_path = path_a + path_b[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": -0.43573,
        "time_improvement": -13.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.00977623462677002,
                "num_nodes_avg": 70.0,
                "path_length_avg": 160.08831471550397,
                "success_improvement": 0.0,
                "time_improvement": 3.098384520129689,
                "length_improvement": 19.98939899351573,
                "objective_score": 4.927395154742053
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.021201300621032714,
                "num_nodes_avg": 210.2,
                "path_length_avg": 240.65853603597742,
                "success_improvement": 0.0,
                "time_improvement": -48.218949754564925,
                "length_improvement": 20.141355902633524,
                "objective_score": -10.437413745842772
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.026948428153991698,
                "num_nodes_avg": 194.1,
                "path_length_avg": 122.18374856757812,
                "success_improvement": 0.0,
                "time_improvement": 6.076177829703829,
                "length_improvement": 24.971817906657144,
                "objective_score": 6.817216930242577
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This planner integrates the bidirectional anytime RRT* framework with adaptive informed ellipsoidal sampling, lazy collision checking, KD-tree accelerated nearest neighbor queries, and dynamic neighborhood radius based on node density. It incorporates batch rewiring for path cost improvement, periodic pruning of low-potential nodes, and intensive shortcut smoothing at the end. The algorithm balances exploration and exploitation, adapting the sample domain to the current best path cost, ensuring fast convergence, minimal path length, and high success rate, while maintaining computational efficiency and robust collision avoidance in 2D and 3D spaces.",
        "planning_mechanism": "The planning mechanism grows two trees simultaneously from the start and goal, extending the smaller one towards samples drawn within an informed ellipse shaped by the best path cost. It uses KD-trees for efficient nearest and radius queries, performs lazy collision checks when rewiring neighbors, and prunes unpromising nodes periodically to focus search efforts. Upon successful connection, extensive shortcut smoothing refines the path and reduces jaggedness. The strategy adaptively controls neighborhood size and exploration-exploitation trade-off to optimize both performance and path quality.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag for collision/pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def is_leaf(self):\n        return len(self.children) == 0\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 prune_interval: int = 150, prune_threshold: int = 200,\n                 smoothing_rounds: int = 100, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_rounds = smoothing_rounds\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(dim))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree for fast nearest and radius neighbor queries\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                if points_nodes:\n                    self.points = np.array([p for p, n in points_nodes])\n                    self.nodes = [n for p, n in points_nodes]\n                else:\n                    self.points = np.empty((0, dim))\n                    self.nodes = []\n\n            def nearest(self, point):\n                if len(self.points) == 0:\n                    return None\n                diff = self.points - np.array(point)\n                dists = np.linalg.norm(diff, axis=1)\n                idx = np.argmin(dists)\n                return self.nodes[idx]\n\n            def radius_search(self, point, radius):\n                if len(self.points) == 0:\n                    return []\n                diff = self.points - np.array(point)\n                dists = np.linalg.norm(diff, axis=1)\n                idxs = np.where(dists <= radius)[0]\n                return [self.nodes[i] for i in idxs]\n\n        # Caches for collision checks to speed up repeated checks\n        node_collision_cache = {}\n        edge_collision_cache = {}\n\n        def can_add_node(pos):\n            if pos in node_collision_cache:\n                return node_collision_cache[pos] is False\n            if not in_bounds(pos) or is_in_obstacle(pos):\n                node_collision_cache[pos] = True\n                return False\n            node_collision_cache[pos] = False\n            return True\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            rev_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return not edge_collision_cache[rev_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            coll = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = coll\n            return not coll\n\n        # Informed ellipsoidal sampling with fallback random sampling\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) * 0.5 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            e1 = np.zeros(dim)\n            e1[0] = 1.0\n            v = a1 - e1\n            s = np.linalg.norm(v)\n            if s > 1e-10:\n                u = v / s\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    sample = rot @ (radii * x) + center\n                    point = tuple(float(coord) for coord in sample)\n                    if in_bounds(point) and not is_in_obstacle(point):\n                        return point\n            # Fallback uniform sample\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        # Dynamic radius shrinking with number of nodes and iteration count for rewiring\n        def neighbor_radius(iteration, n_nodes):\n            if n_nodes == 0:\n                return self.step_size * 3\n            r_iter = 40 * (1 - (iteration / self.max_iter) ** 0.9)\n            r_log = self.step_size + 30 * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.step_size, min(r_iter, r_log))\n\n        # Shortcut smoothing by shortcutting edges along path\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path[:]\n            path = path[:]\n            for _ in range(self.smoothing_rounds):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Prune low-potential nodes unlikely to improve best path\n        def prune_nodes(best_cost):\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except Exception:\n                        pass\n                try:\n                    nodes.remove(node)\n                except Exception:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n            return len(to_remove)\n\n        # Initialize trees and nodes\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Always extend smaller tree first for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            # Build KD-tree for tree_a\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            if nearest_a is None:\n                continue\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                c_tent = node.cost + dist(node.position, new_pos)\n                if c_tent + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = c_tent\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node for optimized paths\n            for neighbor in near_nodes_a:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except Exception:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt connection from tree_b incrementally toward new_node (stepped connection)\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            if nearest_b is None:\n                continue\n\n            last_node_b = nearest_b\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            connection_made = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except Exception:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Update best path if improved\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_smoothing(merged_path)\n\n                    connection_made = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connection_made:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to reduce overhead and refocus search\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                node_collision_cache.clear()\n                edge_collision_cache.clear()\n\n        # If connected but no extracted path yet, fallback copy best path\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 0.3064,
        "time_improvement": -15.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.01530156135559082,
                "num_nodes_avg": 75.5,
                "path_length_avg": 158.3303862890627,
                "success_improvement": 0.0,
                "time_improvement": -51.66841543071586,
                "length_improvement": 20.867994724727637,
                "objective_score": -11.32692568426923
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.019670820236206053,
                "num_nodes_avg": 188.9,
                "path_length_avg": 233.0507547630685,
                "success_improvement": 0.0,
                "time_improvement": -37.51931394854613,
                "length_improvement": 22.665875111680055,
                "objective_score": -6.722619162227827
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.016363692283630372,
                "num_nodes_avg": 137.4,
                "path_length_avg": 128.32497309545965,
                "success_improvement": 0.0,
                "time_improvement": 42.96734060648767,
                "length_improvement": 21.200736092948045,
                "objective_score": 17.13034940053591
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This improved planner leverages bidirectional RRT* enhanced with goal and start adaptive informed sampling to guide exploration more efficiently. It incorporates dynamic neighbor radius rewiring for cost optimality and balances tree growth by always extending the smaller tree. Collision checks are performed lazily and aggressively prunes dead-end nodes periodically to maintain manageable tree size and reduce computation. A carefully implemented iterative shortcut smoothing refines the final path to be shorter and smoother, improving overall path quality and success rate. The planner uses efficient nearest neighbor search via incremental tree size and introduces early termination upon optimal connection to save planning time.",
        "planning_mechanism": "The planner initializes two trees rooted at the start and goal. In each iteration, it samples points biased adaptively toward start or goal to guide exploration. The smaller tree is always extended, promoting balanced bidirectional growth. Nodes are created after collision checks and connected via dynamically sized radius-based rewiring, improving path cost. After connecting the two trees, the planner extracts the combined path and applies iterative randomized shortcut smoothing. Periodic pruning removes dead-end leaf nodes to reduce search complexity. These combined enhancements optimize planning speed, path length, and smoothness while ensuring robust feasibility checks throughout.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.18, radius_constant: float = 30.0,\n                 radius_min: float = 5.0, prune_interval: int = 100,\n                 prune_threshold: int = 100, smoothing_iterations: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        import math\n        import random\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            # Adaptive bias: 60% towards goal, 40% towards start when goal_sample_rate triggers\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < 0.6 else start_position\n            attempts = 0\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d)):\n                    return p\n                attempts += 1\n                if attempts > 30:\n                    # Fallback bias to avoid stalling\n                    return goal_position if random.random() < 0.6 else start_position\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d_] + (to_pos[d_] - from_pos[d_]) * ratio for d_ in range(len(from_pos)))\n            # Clamp to bounds strictly\n            clamped = tuple(max(0, min(new_pos[d_], bounds[d_])) for d_ in range(len(bounds)))\n            return clamped\n\n        def nearest(tree, point):\n            # Efficient linear search as nodes remain moderate due to pruning\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            result = []\n            px = pos\n            for node in tree:\n                dx = node.position[0] - px[0]\n                dy = node.position[1] - px[1]\n                if len(bounds) == 2:\n                    if dx * dx + dy * dy <= r2:\n                        result.append(node)\n                else:\n                    dz = node.position[2] - px[2]\n                    if dx * dx + dy * dy + dz * dz <= r2:\n                        result.append(node)\n            return result\n\n        def radius_dynamic(n):\n            if n <= 1:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n) / n)\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def can_connect(p1, p2):\n            if dist(p1, p2) < 1e-9:\n                return True\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            # Remove leaf nodes except roots to control tree size and prune dead-ends rapidly\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            total = 0.0\n            for i in range(len(path) - 1):\n                total += dist(path[i], path[i + 1])\n            return total\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path[:]\n            path = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    # Shortcut the path segment\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Balance growth by always extending smaller tree\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                # Prune periodically to maintain efficiency\n                if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                    prune_dead_nodes()\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n\n                raw_path = path_start + path_goal[::-1][1:]  # joint path\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 4.92071,
        "time_improvement": -31.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.015637302398681642,
                "num_nodes_avg": 77.3,
                "path_length_avg": 161.88671941326749,
                "success_improvement": 0.0,
                "time_improvement": -54.996266152435524,
                "length_improvement": 19.090573610934523,
                "objective_score": -12.68076512354375
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.029185771942138672,
                "num_nodes_avg": 95.7,
                "path_length_avg": 237.0559897685307,
                "success_improvement": 0.0,
                "time_improvement": -104.03863623105065,
                "length_improvement": 21.336802633736855,
                "objective_score": -26.94423034256782
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.009496164321899415,
                "num_nodes_avg": 94.7,
                "path_length_avg": 123.83143260487927,
                "success_improvement": 0.0,
                "time_improvement": 66.90285444578414,
                "length_improvement": 23.960040649597865,
                "objective_score": 24.862864463654816
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "This improved bidirectional RRT* planner enhances path quality and planning efficiency by integrating adaptive goal/start bias sampling with an informed sampling heuristic biased towards the current best path. It dynamically adjusts neighbor search radius using the number of nodes, applies rigorous node and edge collision checks, rewires locally for cost optimality, and periodically prunes dead-end nodes to keep the trees efficient. Upon successful connection of the trees, an iterative shortcut smoothing using collision-aware shortcuts further minimizes the path length and smoothness. The planner balances exploration and exploitation by always extending the smaller tree first and uses heuristic-informed sampling to reduce search space and improve success rate.",
        "planning_mechanism": "The planner grows two bidirectional trees rooted at the start and goal, alternating growth of the smaller tree. Sampling is adaptively biased either towards the goal/start positions or the informed ellipse around the current best path thus focusing search. Extension includes collision checks and neighbor rewiring for path cost improvement. Once trees connect, the combined path undergoes shortcut smoothing. Periodic pruning of dead-end nodes reduces tree complexity, promoting faster subsequent expansions.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 20.0,\n                 radius_min: float = 5.0, prune_interval: int = 150,\n                 prune_threshold: int = 150, smoothing_iterations: int = 75):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        import random\n        import math\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def can_add_node(pos):\n            if not in_bounds(pos) or self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        # Informed sampling ellipse calculation for 2D/3D to bias sampling near best_path length\n        def informed_sample(best_path_length, start, goal):\n            # If no best path found yet, sample uniformly\n            if best_path_length is None:\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            c_best = best_path_length\n            c_min = dist(start, goal)\n            if c_best < float('inf'):\n                # Build informed sampling ellipse parameters\n                center = tuple((start[i] + goal[i]) / 2 for i in range(len(bounds)))\n                diff = [goal[i] - start[i] for i in range(len(bounds))]\n                if is_3d:\n                    # 3D: ellipse inside ellipsoid\n                    import numpy as np\n\n                    def sample_unit_ball():\n                        # Sample uniformly inside unit ball\n                        while True:\n                            p = np.random.uniform(-1,1,3)\n                            if np.linalg.norm(p) <= 1:\n                                return p\n\n                    a1 = np.array(diff) / c_min if c_min > 0 else np.array([1,0,0])\n                    U, _, _ = np.linalg.svd(a1.reshape(-1,1))\n                    L = np.diag([c_best/2.0] + [math.sqrt(c_best**2 - c_min**2)/2.0]*(len(bounds)-1))\n                    r = sample_unit_ball()\n                    sample = np.dot(U, np.dot(L, r)) + np.array(center)\n                    sample_tuple = tuple(sample.tolist())\n                    if in_bounds(sample_tuple) and not self._is_in_obstacle(sample_tuple, obstacles, is_3d):\n                        return sample_tuple\n                    # fallback to uniform if not successful\n                    return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                else:\n                    # 2D case\n                    x_len = c_best / 2.0\n                    y_len = math.sqrt(c_best**2 - c_min**2) / 2.0 if c_best > c_min else 0.0\n                    angle = math.atan2(diff[1], diff[0])\n\n                    while True:\n                        # Sample point in unit circle\n                        theta = random.uniform(0, 2 * math.pi)\n                        r = math.sqrt(random.uniform(0,1))\n                        x_ball = r * math.cos(theta)\n                        y_ball = r * math.sin(theta)\n                        # Scale and rotate to ellipse\n                        x_ellipse = x_len * x_ball\n                        y_ellipse = y_len * y_ball\n\n                        # Rotation\n                        sample_x = math.cos(angle) * x_ellipse - math.sin(angle) * y_ellipse + center[0]\n                        sample_y = math.sin(angle) * x_ellipse + math.cos(angle) * y_ellipse + center[1]\n                        sample_point = (sample_x, sample_y)\n                        if in_bounds(sample_point) and not self._is_in_obstacle(sample_point, obstacles, is_3d):\n                            return sample_point\n            # Default fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def sample_free(best_path_length):\n            # Adaptive biasing towards goal or start or informed sampling\n            prob = random.random()\n            if prob < self.goal_sample_rate:\n                # bias 70% goal, 30% start to break symmetry\n                return goal_position if random.random() < 0.7 else start_position\n            elif prob < self.goal_sample_rate + 0.15 and best_path_length is not None and best_path_length < float('inf'):\n                # informed sample bias near best path for better path quality\n                return informed_sample(best_path_length, start_position, goal_position)\n            else:\n                # uniform random sample in free space\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            to_remove = [node for node in nodes if node is not start_root and node is not goal_root and not node.children]\n            for node in to_remove:\n                try:\n                    if node.parent:\n                        node.parent.children.remove(node)\n                    nodes.remove(node)\n                    edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                    removed.append(node)\n                except Exception:\n                    continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    # Remove intermediate nodes between i+1 and j-1\n                    path = path[:i+1] + path[j:]\n            return path\n\n        best_path_length = None\n\n        for itr in range(self.max_iter):\n\n            # Always extend the smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            sample_pt = sample_free(best_path_length)\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                # prune occasionally to maintain efficiency\n                if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                    prune_dead_nodes()\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                path_len_raw = path_length(raw_path)\n                best_path_length = path_len_raw if best_path_length is None else min(best_path_length, path_len_raw)\n\n                smoothed_path = shortcut_smoothing(raw_path)\n                path_len_smoothed = path_length(smoothed_path)\n\n                if path_len_smoothed + 1e-12 < path_len_raw:\n                    extracted_path = smoothed_path\n                    best_path_length = path_len_smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 7.62076,
        "time_improvement": -38.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.012272286415100097,
                "num_nodes_avg": 84.4,
                "path_length_avg": 164.77457625294045,
                "success_improvement": 0.0,
                "time_improvement": -21.642373025550857,
                "length_improvement": 17.64725051909275,
                "objective_score": -2.9632618038467062
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03176336288452149,
                "num_nodes_avg": 155.0,
                "path_length_avg": 244.88901923294526,
                "success_improvement": 0.0,
                "time_improvement": -122.05865439907994,
                "length_improvement": 18.73753845426328,
                "objective_score": -32.87008862887132
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.020570755004882812,
                "num_nodes_avg": 118.1,
                "path_length_avg": 126.37388973369407,
                "success_improvement": 0.0,
                "time_improvement": 28.304392228488624,
                "length_improvement": 22.398818812311294,
                "objective_score": 12.971081431008846
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid path planner synergizes bidirectional RRT* growth with ellipsoidal informed sampling, adaptive neighbor radius, KD-tree accelerated neighbor search, collision caching, incremental rewiring, and dynamic pruning. It optimizes exploration by focusing samples within promising regions, rewires locally for path cost improvement, aggressively smooths found paths, prunes nodes unlikely to contribute to better solutions, and terminates early upon successfully connecting start and goal trees, aiming for efficient, high-quality, robust, and smooth paths in 2D and 3D environments.",
        "planning_mechanism": "The planner alternately grows two trees from start and goal positions using ellipsoidal informed sampling biased by the current best solution cost. Efficient KD-tree radius and nearest neighbor searches accelerate rewiring and local optimization. Collision checks are cached to reduce redundant computations. Periodic pruning removes nodes whose cost plus heuristic exceeds the current best path cost, improving efficiency. Aggressive shortcut smoothing refines the final path. Expansion stops as soon as a satisfactory connection between trees is found, prioritizing planning speed and path quality.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision/pruning etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=120,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree acceleration (brute-force)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Ellipsoidal informed sampling with fallback uniform & goal bias\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(15):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p): return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))  # unit vector start->goal\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) * (c_min / 2), 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    x = x * radii\n                    p = rot @ x + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p): \n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            path = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialize tree roots\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float(\"inf\")\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path: list = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree selection for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Incremental rewiring in tree_a\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Attempt connecting tree_b toward new_node by incremental extension & rewiring\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning accelerates convergence and memory usage\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 0.06148,
        "time_improvement": -15.0,
        "length_improvement": 23.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009427666664123535,
                "num_nodes_avg": 72.7,
                "path_length_avg": 154.28035357860705,
                "success_improvement": 0.0,
                "time_improvement": 6.553375114614937,
                "length_improvement": 22.89216214653693,
                "objective_score": 6.544444963691867
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.026660346984863283,
                "num_nodes_avg": 231.8,
                "path_length_avg": 235.57003780298646,
                "success_improvement": 0.0,
                "time_improvement": -86.38331208173948,
                "length_improvement": 21.829891767896804,
                "objective_score": -21.54901527094248
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.01898953914642334,
                "num_nodes_avg": 161.2,
                "path_length_avg": 124.7801116182216,
                "success_improvement": 0.0,
                "time_improvement": 33.81543117495873,
                "length_improvement": 23.377494586020404,
                "objective_score": 14.8201282696917
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This planner combines the adaptive informed sampling strategy of bidirectional informed RRT* with KD-tree accelerated neighbor queries and lazy collision checking inspired by bidirectional PRM*. It dynamically samples within an ellipsoidal informed domain biased by the current best solution, employs efficient rewiring with adaptive neighborhood radius, and leverages pruning to discard unpromising nodes. This hybrid approach enhances exploration-exploitation balance, reduces collision checks, improves path quality and smoothness, and accelerates convergence in both 2D and 3D spaces.",
        "planning_mechanism": "The planner grows two roadmaps simultaneously from start and goal positions by sampling informed ellipsoidal regions around the best path found so far or uniform if none, using KD-tree for efficient neighbor searches. Nodes are connected and rewired using lazy collision checking, prioritizing low-cost edges. Trees attempt connection via incremental steering steps and, upon success, extract and shortcut smooth the combined path. Periodic pruning discards nodes unlikely to improve the solution, enhancing planning efficiency and success rate.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position            # Tuple[float, ...] (2D or 3D)\n        self.parent = parent                # Node or None\n        self.cost = cost                   # Cost from root/start of tree\n        self.children: List[Node] = []     # For rewiring and pruning\n        self.valid = True                  # Mark node as valid or pruned\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_trials: int=50,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            factor = math.log(n_nodes) / n_nodes\n            r = self.max_neighbor_radius * (factor ** 0.5)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        # KD-tree helper for nearest and radius search (brute-force for portability)\n        class KDTree:\n            def __init__(self, points_nodes: List[Tuple[Tuple[float, ...], Node]]):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # Edge collision cache for lazy collision checking\n        edge_collision_cache = {}\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def ellipse_sample(c_best: float, c_min: float,\n                           start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            # Informed sampling inside ellipse around current best path\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback uniform\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)  # Householder reflection\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r2]*(dim-1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1,1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.power(np.random.uniform(0,1), 1/dim)  # Uniform in unit ball\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n\n            # fallback uniform\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def adaptive_sample(best_path: List[Tuple[float, ...]]) -> Tuple[float, ...]:\n            # Sample near path with Gaussian noise with fallback to ellipse sampling\n            if best_path:\n                import numpy as np\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            # fallback to ellipse sample with worst cost if available\n            return ellipse_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth)-3)\n                j = random.randint(i+2, len(smooth)-1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i+1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(nodes_list: List[Node], best_cost: float, root_s: Node, root_g: Node) -> int:\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialize roots\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path)\n\n            # Alternate growth of smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(len(nodes))\n            near_nodes_a = kdtree_a.radius_search(new_pos, r)\n\n            # Choose parent minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Try connecting tree_b to new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes))\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic pruning\n            if (it > 0 and it % self.prune_interval == 0 and\n                len(nodes) > self.prune_threshold and c_best < float('inf')):\n                removed_s = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_g = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -7.12118,
        "time_improvement": 10.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.007959723472595215,
                "num_nodes_avg": 63.1,
                "path_length_avg": 166.1777904320498,
                "success_improvement": 0.0,
                "time_improvement": 21.103564642826754,
                "length_improvement": 16.94593755936249,
                "objective_score": 9.720256904720525
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.01784951686859131,
                "num_nodes_avg": 199.8,
                "path_length_avg": 235.0571101756468,
                "success_improvement": 0.0,
                "time_improvement": -24.786525656090877,
                "length_improvement": 22.000098507762036,
                "objective_score": -3.035937995274855
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.019048786163330077,
                "num_nodes_avg": 157.5,
                "path_length_avg": 125.4230613012865,
                "success_improvement": 0.0,
                "time_improvement": 33.60893652346104,
                "length_improvement": 22.982684748678,
                "objective_score": 14.67921790677391
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "This planner is an enhanced bidirectional RRT* variant that utilizes adaptive informed sampling within an ellipsoidal subset defined by the current best path cost, lazy collision checks, KD-tree accelerated nearest and radius neighbor searches, and incremental rewiring with an adaptive neighbor radius. It balances exploration and exploitation via alternating tree expansion, employs a heuristic-guided pruning mechanism to remove non-promising nodes periodically, and applies aggressive collision-aware shortcut smoothing for path optimization. The design aims to maximize success rate, path quality, smoothness, and efficiency in both 2D and 3D environments.",
        "planning_mechanism": "The planner grows two trees from start and goal positions alternately using ellipsoidal informed samples biased by the current best path cost. New nodes are added only after confirming collision-free status and connectivity with parents, with incremental rewiring applied to improve path costs locally. Trees attempt connection via steering toward nearest nodes in the opposite tree, and on successful connection, the combined path undergoes aggressive segment-wise smoothing. Pruning removes nodes unlikely to contribute to better paths, maintaining computational efficiency and robustness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Accumulated path cost from root\n        self.children = []\n        self.valid = True               # For collision checking flags\n    \n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_iterations: int = 150,\n                 collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.12):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clip to bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def heuristic(p):\n            return dist(p, goal_pos)\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or random.random() < self.goal_sample_rate:\n                for _ in range(10):\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1**2 - (c_min/2.0)**2, 0))\n            radii = np.array([r1] + [r_others]*(dim-1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    x_ellipse = x_ball * radii\n                    sample = rot @ x_ellipse + center\n                    sample_t = tuple(float(v) for v in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n\n            # Fallback uniform sampling\n            for _ in range(10):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        class KDTree:\n            def __init__(self, nodes_list):\n                self.dim = dim\n                self.points = [node.position for node in nodes_list]\n                self.nodes = nodes_list\n\n            def nearest(self, point):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, point)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, point, radius):\n                r2 = radius * radius\n                result = []\n                for p, n in zip(self.points, self.nodes):\n                    diff_sq = 0.0\n                    for d_ in range(self.dim):\n                        diff = p[d_] - point[d_]\n                        diff_sq += diff * diff\n                        if diff_sq > r2:\n                            break\n                    else:\n                        result.append(n)\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 1.0)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_nodes(nodes_list, tree_s, tree_g, best_cost):\n            h = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                if not node.children and (node.cost + h(node.position) >= best_cost * 1.01):\n                    to_remove.append(node)\n                    continue\n                if node.cost + h(node.position) >= best_cost * 0.98:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_s:\n                    try: tree_s.remove(node)\n                    except ValueError: pass\n                if node in tree_g:\n                    try: tree_g.remove(node)\n                    except ValueError: pass\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree expansion for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree(tree_a)\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for near in near_nodes:\n                cost_cand = near.cost + dist(near.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(near.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-12 < near.cost and can_connect(new_node.position, near.position):\n                    try:\n                        edges.remove((near.parent, near))\n                    except ValueError:\n                        pass\n                    near.update_parent(new_node, new_cost)\n                    edges.append((new_node, near))\n\n            # Incrementally connect tree_b toward new_node\n            kdtree_b = KDTree(tree_b)\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b_nodes = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b_nodes:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = merged_path\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                # Aggressive final shortcut smoothing\n                extracted_path = shortcut_path(best_path)\n                break\n\n            # Periodic pruning to remove non-promising nodes and maintain efficiency\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = shortcut_path(best_path) if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -2.05071,
        "time_improvement": -7.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009228992462158202,
                "num_nodes_avg": 56.1,
                "path_length_avg": 161.33118873166296,
                "success_improvement": 0.0,
                "time_improvement": 8.522625225685093,
                "length_improvement": 19.368222506119096,
                "objective_score": 6.430432068929347
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.0187880277633667,
                "num_nodes_avg": 207.4,
                "path_length_avg": 235.26781767077213,
                "success_improvement": 0.0,
                "time_improvement": -31.34768440966405,
                "length_improvement": 21.93017863232764,
                "objective_score": -5.018269596433687
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.028017711639404298,
                "num_nodes_avg": 203.4,
                "path_length_avg": 129.9941932905919,
                "success_improvement": 0.0,
                "time_improvement": 2.349385626476522,
                "length_improvement": 20.175734337620487,
                "objective_score": 4.739962555467054
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This planner implements a simplified bidirectional informed RRT* algorithm combining heuristic ellipsoidal sampling, incremental rewiring, collision caching, and periodic pruning. It focuses search within an adaptive ellipsoidal domain defined by the best path cost found so far, uses KD-tree accelerated neighbor queries for efficient rewiring, and applies shortcut smoothing to improve path quality. The planner balances exploration and exploitation, prunes suboptimal nodes to reduce complexity, and ensures collision-free node placement and edge connections, targeting efficient, robust, and high-quality path planning in 2D or 3D environments.",
        "planning_mechanism": "The planner grows two trees rooted at start and goal positions, alternately extending the smaller tree toward sampled points biased inside an informed ellipsoid. Neighbors within a dynamic radius are searched via KD-tree to find optimal parent nodes and allow rewiring for cost reduction. Collision caches speed up validation, and nodes unlikely to improve the current best path are pruned periodically. Upon connecting the trees, the path is shortcut-smoothed to enhance smoothness and shorten length. This mechanism accelerates convergence, improves success rates, and enhances final solution quality.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List['Node'] = []\n        self.valid = True\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_iterations: int = 100, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d_] + ratio * (to_pos[d_] - from_pos[d_]) for d_ in range(dim))\n            return tuple(max(0, min(new_p[d_], bounds[d_])) for d_ in range(dim))\n\n        def neighbor_radius(iteration: int, n_nodes: int) -> float:\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes: List[Tuple[Tuple[float, ...], Node]]):\n                self.points = [p for p, _ in points_nodes]\n                self.nodes = [n for _, n in points_nodes]\n                self.dim = dim\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best_node = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = 0.0\n                    for d_ in range(self.dim):\n                        diff = p[d_] - pt[d_]\n                        d += diff * diff\n                        if d > best_dist * best_dist:  # early break\n                            break\n                    if d < best_dist * best_dist:\n                        best_dist = math.sqrt(d)\n                        best_node = self.nodes[i]\n                return best_node\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                r_sq = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r_sq:\n                            break\n                    if sqd <= r_sq:\n                        result.append(self.nodes[i])\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            if not in_bounds(pos) or is_in_obstacle(pos):\n                return False\n            return True\n\n        def informed_sample(c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            rot = id_mat\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    x = x * radii\n                    p = rot @ x + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost: float):\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        edges: List[Tuple[Node, Node]] = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path: List[Tuple[float, ...]] = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near_nodes_a:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_nodes_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles, is_3d: bool) -> bool:\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles, is_3d: bool, resolution: float = 1.0) -> bool:\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 9.89691,
        "time_improvement": -47.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.012067699432373047,
                "num_nodes_avg": 71.4,
                "path_length_avg": 159.73296090832199,
                "success_improvement": 0.0,
                "time_improvement": -19.61451568688616,
                "length_improvement": 20.167001410863307,
                "objective_score": -1.850954423893187
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03041536808013916,
                "num_nodes_avg": 222.5,
                "path_length_avg": 240.551110797702,
                "success_improvement": 0.0,
                "time_improvement": -112.63478094190398,
                "length_improvement": 20.17700323105087,
                "objective_score": -29.755033636361016
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.031632089614868165,
                "num_nodes_avg": 183.6,
                "path_length_avg": 122.22229348620654,
                "success_improvement": 0.0,
                "time_improvement": -10.247868368592536,
                "length_improvement": 24.94814900463433,
                "objective_score": 1.915269290349106
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "The planner implements an enhanced bidirectional RRT* algorithm that integrates adaptive informed sampling within an ellipsoidal region once a feasible path is found, dynamic neighbor radius shrinking, and balanced tree extension. It includes rigorous collision and edge checking, periodic pruning of unpromising and dead-end nodes, and iterative shortcut smoothing for path refinement. By combining goal-start biased sampling, neighborhood rewiring, and efficient pruning strategies, the planner optimizes both planning speed and path quality in 2D and 3D environments.",
        "planning_mechanism": "The planner alternates growth between two trees rooted at start and goal positions, extending the smaller tree for balanced expansion. Initially, it samples uniformly, switching to adaptive informed sampling using ellipsoidal sampling when a solution exists. Each extension steers toward sampled points within bounds, conducts extensive collision checks, and rewires neighbors to minimize path cost. After connecting trees, shortcut smoothing refines the path. Periodic pruning removes dead or costly nodes to maintain computational efficiency, resulting in faster convergence to shorter, smoother paths.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] for 2D or 3D coords\n        self.parent = parent            # Parent node or None\n        self.cost = cost                # Cost from root node\n        self.children = []\n        self.valid = True               # For collision validity\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 prune_interval: int=150, prune_threshold: int=100,\n                 smoothing_iterations: int=50, collision_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_resolution = collision_resolution\n        self.min_radius = 5.0\n        self.max_radius = 30.0\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio*(to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp within bounds\n            clamped = tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n            return clamped\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            d_edge = dist(p1, p2)\n            steps = max(1, int(d_edge / self.collision_resolution))\n            for i in range(steps +1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])* i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def neighbor_radius(iter, n_nodes):\n            n = max(n_nodes, 1)\n            r_iter = self.max_radius * (1 - (iter / self.max_iter)**0.9)\n            r_log = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(n+1)/n)\n            return max(self.min_radius, min(r_iter, r_log))\n\n        def uniform_sample():\n            for _ in range(20):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            # fallback random if all fail\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best <= c_min * 1.00001:\n                return uniform_sample()\n\n            center = np.array([(start[d] + goal[d])/2 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d])/c_min for d in range(dim)])\n            I = np.eye(dim)\n            u = direction - I[:,0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = I - 2 * np.outer(u,u)\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1**2 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r_other]*(dim-1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1,1,dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(v) for v in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            return uniform_sample()\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            r_sq = radius*radius\n            return [node for node in tree if sum((node.position[d]-point[d])**2 for d in range(dim)) <= r_sq]\n\n        def prune_nodes(all_nodes, tree_start, tree_goal, best_cost):\n            to_remove = []\n            for node in all_nodes:\n                if node is root_start or node is root_goal:\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    all_nodes.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n                node.valid = False\n\n        def prune_dead_end_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is root_start or node is root_goal:\n                    continue\n                if not node.children and node.valid:\n                    if node.parent:\n                        try:\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    try:\n                        nodes.remove(node)\n                    except ValueError:\n                        pass\n                    edges[:] = [(p,c) for (p,c) in edges if p != node and c != node]\n                    node.valid = False\n                    removed.append(node)\n            return removed\n\n        def shortcut_path(path):\n            length = len(path)\n            if length < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes.extend([root_start, root_goal])\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        for itr in range(self.max_iter):\n            sample_pt = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth of smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            nearest_a = nearest(tree_a, sample_pt)\n            new_pos = steer(nearest_a.position, sample_pt)\n\n            if (not in_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_a.position, new_pos):\n                continue\n\n            radius = neighbor_radius(itr, len(nodes))\n            neighbors = near_nodes(tree_a, new_pos, radius)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in neighbors:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Connect tree_b towards new_node incrementally\n            nearest_b = nearest(tree_b, new_node.position)\n            last_b = nearest_b\n            max_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos = steer(last_b.position, new_node.position)\n                if (not in_bounds(next_pos)) or is_in_obstacle(next_pos) or is_edge_in_obstacle(last_b.position, next_pos):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos)\n                new_node_b = Node(next_pos, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b = near_nodes(tree_b, next_pos, radius)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_b_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_b_via_new + 1e-12 < neighbor_b.cost and not is_edge_in_obstacle(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_b_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and not is_edge_in_obstacle(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_a = connection_node.path_from_root()\n                        path_b = new_node.path_from_root()\n                    else:\n                        path_a = new_node.path_from_root()\n                        path_b = connection_node.path_from_root()\n\n                    merged_path = path_a + path_b[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n                prune_dead_end_nodes()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": -5.84788,
        "time_improvement": 5.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009490442276000977,
                "num_nodes_avg": 65.4,
                "path_length_avg": 158.71176529717673,
                "success_improvement": 0.0,
                "time_improvement": 5.931145960355036,
                "length_improvement": 20.67738516209536,
                "objective_score": 5.914820820525582
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.020306205749511717,
                "num_nodes_avg": 207.6,
                "path_length_avg": 236.37021311919233,
                "success_improvement": 0.0,
                "time_improvement": -41.96131376519905,
                "length_improvement": 21.56436652684394,
                "objective_score": -8.275520824190927
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.013994884490966798,
                "num_nodes_avg": 150.9,
                "path_length_avg": 125.90527752025034,
                "success_improvement": 0.0,
                "time_improvement": 51.22338732662966,
                "length_improvement": 22.686574941040437,
                "objective_score": 19.904331186196984
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e1",
        "algorithm_description": "This algorithm presents an Enhanced Bi-directional Informed RRT* with adaptive multi-resolution sampling, KD-tree accelerated nearest neighbor search, collision caching, and dynamic replanning with lazy collision checking. It integrates visibility graph inspired edge batching for local shortcutting, and applies path smoothing via spline interpolation to produce high-quality, smooth, and robust paths efficiently while reducing computational overhead and improving success rates in complex 2D/3D environments.",
        "planning_mechanism": "The planner grows two trees simultaneously from start and goal using an informed sampling strategy within an adaptive ellipsoidal region to focus search around promising path costs. It employs KD-tree structures for scalable nearest neighbor and radius queries. An edge-cache maintains collision results for faster pruning and rewiring decisions. Instead of immediate full collision checks on all rewires, lazy evaluation delays some checks until necessary, improving efficiency. Local shortcut edges connecting visibility neighbors are added to accelerate convergence. Once trees connect, a spline-smoothed path is extracted and further refined by shortcutting, ensuring smooth, shorter paths with reduced vertices.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]: 2D or 3D coords\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from root\n        self.children = []\n        self.valid = True                 # For collision and pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def is_leaf(self):\n        return len(self.children) == 0\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float=4.0,\n                 min_radius: float=5.0, max_radius: float=25.0,\n                 prune_interval: int=150, prune_threshold: int=250,\n                 smoothing_trials: int=75, collision_check_resolution: float=0.5,\n                 goal_sample_prob: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_prob = goal_sample_prob\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n        from collections import deque\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_radius * (1.0 - (iteration / self.max_iter) ** 0.98)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree substitute brute force for simplicity\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = self.nodes[i]\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Cached collision results for edges and nodes\n        edge_collision_cache = {}\n        node_collision_cache = {}\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if pos in node_collision_cache:\n                return not node_collision_cache[pos]\n            coll = is_in_obstacle(pos)\n            node_collision_cache[pos] = coll\n            return not coll\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            inv_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if inv_key in edge_collision_cache:\n                return not edge_collision_cache[inv_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            coll = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = coll\n            return not coll\n\n        def ellipse_sample(c_best, c_min, start, goal):\n            # Sample either uniformly or inside ellipsoid around best path\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_prob:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if can_add_node(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            diff = tuple(goal[d] - start[d] for d in range(dim))\n            a1 = tuple(diff[d] / c_min for d in range(dim))  # Unit vector along line\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2_val = math.sqrt(max(r1*r1 - (c_min/2)*(c_min/2), 0))\n            radii = np.array([r1] + [r2_val]*(dim-1))\n\n            tries = 100\n            for _ in range(tries):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-10:\n                    unit_x = x / norm_x\n                    scale = np.power(np.random.uniform(0, 1), 1/dim)\n                    sample = unit_x * scale * radii\n                    p = rot @ sample + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and can_add_node(p_tuple):\n                        return p_tuple\n            # fallback uniform\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if can_add_node(p):\n                    return p\n            return p  # last attempt\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth_path = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth_path) < 3:\n                    break\n                i = random.randint(0, len(smooth_path) - 3)\n                j = random.randint(i+2, len(smooth_path) - 1)\n                p1, p2 = smooth_path[i], smooth_path[j]\n                if can_connect(p1, p2):\n                    smooth_path = smooth_path[:i+1] + smooth_path[j:]\n            return smooth_path\n\n        def spline_smooth(path):\n            # If path length less than 4 or environment 1D, return path\n            if len(path) < 4 or dim < 2:\n                return path[:]\n            try:\n                import scipy.interpolate\n            except ImportError:\n                return path[:]\n\n            pts = np.array(path)\n            t = np.linspace(0, 1, len(pts))\n            splines = []\n            for d_ in range(dim):\n                spl = scipy.interpolate.UnivariateSpline(t, pts[:, d_], k=3, s=1e-1)\n                splines.append(spl)\n            fine_t = np.linspace(0, 1, max(len(pts)*5, 100))\n            smooth_pts = []\n            for ft in fine_t:\n                coord = tuple(float(spl(ft)) for spl in splines)\n                if not in_bounds(coord) or is_in_obstacle(coord):\n                    # fallback to original path on any invalid spline point\n                    return path[:]\n                smooth_pts.append(coord)\n            return smooth_pts\n\n        def prune_nodes(current_best_cost):\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= current_best_cost - 1e-8:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n            return len(to_remove)\n\n        # Visibility based edge batching for local shortcutting (connect within neighbor radius)\n        def add_visibility_edges(new_node, tree_nodes, radius):\n            if len(tree_nodes) < 2:\n                return\n            kdtree = KDTree([(n.position, n) for n in tree_nodes])\n            near = kdtree.radius_search(new_node.position, radius)\n            for neighbor in near:\n                if neighbor is new_node or neighbor is new_node.parent:\n                    continue\n                if can_connect(new_node.position, neighbor.position):\n                    cost_candidate = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_candidate + 1e-12 < neighbor.cost:\n                        try: edges.remove((neighbor.parent, neighbor))\n                        except ValueError: pass\n                        neighbor.update_parent(new_node, cost_candidate)\n                        edges.append((new_node, neighbor))\n                    elif neighbor.cost + 1e-12 < new_node.cost:\n                        cost_candidate = neighbor.cost + dist(neighbor.position, new_node.position)\n                        if cost_candidate + 1e-12 < new_node.cost and can_connect(neighbor.position, new_node.position):\n                            try: edges.remove((new_node.parent, new_node))\n                            except ValueError: pass\n                            new_node.update_parent(neighbor, cost_candidate)\n                            edges.append((neighbor, new_node))\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        # To limit repeated KD-tree rebuilds, update only once per iteration\n        for it in range(self.max_iter):\n            q_rand = ellipse_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_a:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Visibility edges local shortcutting\n            add_visibility_edges(new_node, tree_a, r)\n\n            # Rewire neighbors lazily with collision caching; do minimal checks here\n            for neighbor in near_a:\n                if neighbor is best_parent or neighbor is new_node:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, potential_cost)\n                    edges.append((new_node, neighbor))\n\n            # Connect other tree towards new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            for _step in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n\n                        # Shortcut and spline smooth\n                        shortcuted = shortcut_path(merged_path)\n                        smoothed = spline_smooth(shortcuted)\n                        best_path = smoothed if smoothed else shortcuted\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                edge_collision_cache.clear()\n                node_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 37.7429,
        "time_improvement": -140.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.017691659927368163,
                "num_nodes_avg": 77.0,
                "path_length_avg": 159.2966342497898,
                "success_improvement": 0.0,
                "time_improvement": -75.35896926901663,
                "length_improvement": 20.385073281045408,
                "objective_score": -18.530676124495905
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.0584583044052124,
                "num_nodes_avg": 285.0,
                "path_length_avg": 237.22321480336223,
                "success_improvement": 0.0,
                "time_improvement": -308.68381795301315,
                "length_improvement": 21.281311709705044,
                "objective_score": -88.34888304396293
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.03943338394165039,
                "num_nodes_avg": 183.9,
                "path_length_avg": 123.09702866575098,
                "success_improvement": 0.0,
                "time_improvement": -37.437854250507506,
                "length_improvement": 24.41100890946026,
                "objective_score": -6.349154493260198
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid planner synergizes the anytime informed bidirectional RRT* and adaptive lazy-collision bidirectional PRM* concepts to maximize efficiency, solution quality, and robustness. It leverages informed ellipsoidal sampling biased by the current best path, uses KD-tree accelerated neighbor searches, applies lazy collision checking with caching, adaptively adjusts neighbor radius, and prunes nodes that cannot improve the solution. Bidirectional asynchronous tree growth prioritizes the smaller tree for extension, with incremental backward connection attempts, iterative rewiring for cost improvements, and periodic aggressive pruning. Final paths undergo shortcut smoothing to enhance smoothness and quality, yielding faster convergence to shorter, smoother, and more reliable paths in both 2D and 3D environments.",
        "planning_mechanism": "The planner initializes two trees from start and goal, expanding the smaller tree each iteration by sampling in an evolving informed ellipsoid or adaptively near the best path. It efficiently connects and rewires neighbors using cached lazy collision checks and KD-tree queries, while incremental multi-step connection attempts link the trees. Periodic pruning discards nodes unlikely to improve the best path, maintaining manageable search space and high efficiency. Upon successfully connecting trees, the planner extracts and iteratively smooths the path with shortcutting to optimize quality before returning.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position             # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent                 # Node or None\n        self.cost = cost                    # Path cost from root\n        self.children: List[Node] = []      # For rewiring & pruning\n        self.valid = True                   # Mark valid/pruned\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_trials: int = 100, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math, random, numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes: int, iteration: int) -> float:\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            const_factor = max(n_nodes,1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration/self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(const_factor+1)/const_factor)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree helper (brute-force for portability)\n        class KDTree:\n            def __init__(self, points_nodes: List[Tuple[Tuple[float, ...], Node]]):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        edge_collision_cache = {}\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        # Informed ellipsoidal sample inside evolving domain biased by current best cost c_best\n        def informed_sample(c_best: float, c_min: float,\n                            start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)  # Householder reflection\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r2]*(dim-1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.power(np.random.uniform(0,1), 1/dim)  # Uniform in unit ball\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        # Adaptive sampling: sample near best known path with Gaussian noise, fallback to informed_sample\n        def adaptive_sample(best_path: List[Tuple[float, ...]], c_best: float, c_min: float) -> Tuple[float, ...]:\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size*0.5, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        # Shortcut smoothing by attempting to replace path segments with direct edges\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth)-3)\n                j = random.randint(i+2, len(smooth)-1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i+1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(nodes_list: List[Node], best_cost: float, root_s: Node, root_g: Node) -> int:\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialize roots and data structures\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            # Parent selection minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Connect tree_b to new_node incrementally\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _step in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                # Check connection to new_node position\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic pruning when a good path exists and node count is high\n            if (it > 0 and it % self.prune_interval == 0 and\n                len(nodes) > self.prune_threshold and c_best < float('inf')):\n                removed_s = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_g = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -3.32505,
        "time_improvement": -3.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.00928337574005127,
                "num_nodes_avg": 67.8,
                "path_length_avg": 158.71141409519754,
                "success_improvement": 0.0,
                "time_improvement": 7.9835805234948705,
                "length_improvement": 20.677560689468976,
                "objective_score": 6.530586294942257
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.019699525833129884,
                "num_nodes_avg": 196.3,
                "path_length_avg": 239.21164857839057,
                "success_improvement": 0.0,
                "time_improvement": -37.719995666341646,
                "length_improvement": 20.621482111442084,
                "objective_score": -7.191702277614077
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.022746777534484862,
                "num_nodes_avg": 159.5,
                "path_length_avg": 126.85899801843861,
                "success_improvement": 0.0,
                "time_improvement": 20.720263315996654,
                "length_improvement": 22.1009331020634,
                "objective_score": 10.636265615211677
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner that integrates informed ellipsoidal sampling, adaptive neighbor radius, KD-tree accelerated nearest neighbor searches, collision caching, incremental rewiring, periodic pruning, and aggressive shortcut smoothing. It focuses on improving planning efficiency, path quality, robustness, success rate, and path smoothness in both 2D and 3D spaces.",
        "planning_mechanism": "The planner grows two trees from start and goal by alternately sampling points inside an informed ellipsoidal domain based on the best path cost. It uses KD-trees for efficient nearest neighbor and radius searches, caches collision checks to minimize redundant tests, and dynamically adjusts neighbor radius for rewiring. After successful connections, it aggressively smooths the path and periodically prunes nodes unlikely to improve solutions, thereby reducing computational overhead and boosting convergence speed and solution quality.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=150,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle tuples\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                # Uniform sampling with rejection inside obstacles\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) * (c_min / 2), 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    # Uniform sampling inside unit ball\n                    radius_factor = np.random.uniform(0,1) ** (1/dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Balance tree extension: extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node_ in near_nodes:\n                candidate_cost = node_.cost + dist(node_.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node_.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node_\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connect opposite tree towards new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to reduce search space and improve efficiency\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -4.01111,
        "time_improvement": -1.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.008940935134887695,
                "num_nodes_avg": 64.8,
                "path_length_avg": 155.6068476254887,
                "success_improvement": 0.0,
                "time_improvement": 11.377837015190611,
                "length_improvement": 22.229193171498764,
                "objective_score": 7.859189738856937
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02347726821899414,
                "num_nodes_avg": 211.7,
                "path_length_avg": 233.929666318002,
                "success_improvement": 0.0,
                "time_improvement": -64.130309773233,
                "length_improvement": 22.37422252285186,
                "objective_score": -14.764248427399524
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.014677858352661133,
                "num_nodes_avg": 137.3,
                "path_length_avg": 127.9558261152494,
                "success_improvement": 0.0,
                "time_improvement": 48.84300672831869,
                "length_improvement": 21.42741457658537,
                "objective_score": 18.93838493381268
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This planner implements a streamlined bidirectional RRT* algorithm with informed ellipsoidal sampling, adaptive neighbor radius, efficient collision checking, incremental rewiring, and periodic pruning to optimize path quality and planning speed. It is designed for general 2D/3D environments, balancing exploration and exploitation for robust and smooth path generation.",
        "planning_mechanism": "The planner grows two trees from start and goal, alternately expanding toward adaptively sampled points within an informed ellipsoid once a preliminary path is found. Nearest neighbor and radius searches are done directly for simplicity, with strict collision checks on nodes and edges. Incremental rewiring improves path cost locally. When the two trees connect, the combined path undergoes shortcut smoothing. Periodic pruning removes nodes unlikely to yield better solutions, accelerating convergence and improving success rates.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D point\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking or pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = 5.0\n        self.max_radius = 30.0\n        self.prune_interval = 200\n        self.prune_threshold = 300\n        self.smoothing_iterations = 50\n        self.collision_resolution = 1.0\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                    # Tuple[int, ...]\n        start_pos = map.start                # Tuple[float, ...]\n        goal_pos = map.goal                  # Tuple[float, ...]\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        import math\n        import random\n        import numpy as np\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            length = dist(p1, p2)\n            steps = max(1, int(length / self.collision_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def neighbor_radius(iteration, n_nodes):\n            n = max(n_nodes, 1)\n            r_iter = self.max_radius * (1 - (iteration / self.max_iter) ** 0.9)\n            r_log = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.min_radius, min(r_iter, r_log))\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            I = np.eye(dim)\n            u = a1 - I[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = I - 2 * np.outer(u, u)\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1**2 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r_others] * (dim-1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n            return p\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((a - b)**2 for a,b in zip(node.position, point)) <= r2]\n\n        def prune_nodes(nodes_list, tree_start, tree_goal, best_cost):\n            to_remove = []\n            for node in nodes_list:\n                if node is root_start or node is root_goal:\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n\n        for iter_count in range(self.max_iter):\n            sample = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            nearest_a = nearest_node(tree_a, sample)\n            new_pos = steer(nearest_a.position, sample)\n\n            if (not in_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_a.position, new_pos):\n                continue\n\n            radius = neighbor_radius(iter_count, len(nodes))\n            neighbors = near_nodes(tree_a, new_pos, radius)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in neighbors:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            nearest_b = nearest_node(tree_b, new_node.position)\n            last_node_b = nearest_b\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not in_bounds(next_pos_b) or is_in_obstacle(next_pos_b) or is_edge_in_obstacle(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = radius\n                neighbors_b = near_nodes(tree_b, next_pos_b, radius_b)\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new + 1e-12 < neighbor_b.cost and not is_edge_in_obstacle(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and not is_edge_in_obstacle(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            if iter_count > 0 and iter_count % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": -7.23208,
        "time_improvement": 10.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.007624602317810059,
                "num_nodes_avg": 74.4,
                "path_length_avg": 161.42554980527825,
                "success_improvement": 0.0,
                "time_improvement": 24.42527105842762,
                "length_improvement": 19.32106174847733,
                "objective_score": 11.19179366722375
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.018499875068664552,
                "num_nodes_avg": 204.4,
                "path_length_avg": 235.10113718615062,
                "success_improvement": 0.0,
                "time_improvement": -29.333199989999258,
                "length_improvement": 21.985488856176815,
                "objective_score": -4.402862225764413
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.018863773345947264,
                "num_nodes_avg": 168.3,
                "path_length_avg": 125.14108614416223,
                "success_improvement": 0.0,
                "time_improvement": 34.253764891920625,
                "length_improvement": 23.155834481621554,
                "objective_score": 14.907296363900498
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This planner implements a highly optimized bidirectional RRT* algorithm integrating adaptive informed sampling that balances bias towards start and goal, dynamically shrinking neighbor radius for efficient rewiring, and aggressive pruning of dead nodes to maintain search space efficiency. It alternates growth on the smaller tree to balance exploration, uses strict collision and edge checks for safety and robustness, and applies an advanced multi-iteration shortcut smoothing method post path extraction to minimize path length and improve path smoothness. These combined strategies reduce planning time, increase success rates, and produce shorter, smoother paths with robustness in both 2D and 3D environments.",
        "planning_mechanism": "The planner grows two RRT* trees simultaneously from start and goal points, sampling points adaptively biased towards both roots to focus search on promising regions. Each iteration extends the smaller tree towards sampled points, rewires neighbors using a dynamically reduced radius, then attempts to connect the other tree to form a full path. Dead-end nodes are periodically pruned to avoid unnecessary growth. Once a feasible path is found, extensive randomized shortcut smoothing is applied to iteratively improve path quality while ensuring collision-free connectivity, resulting in efficient, high-quality path planning.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=25.0,\n                 radius_min: float=4.0, prune_interval: int=200,\n                 prune_threshold: int=100, smoothing_iterations: int=80,\n                 edge_resolution: float=0.25):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.edge_resolution = edge_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def dist_sq(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return sum((a[d] - b[d])**2 for d in range(len(a)))\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def sample_free() -> Tuple[float, ...]:\n            p_bias = 0.75\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: dist_sq(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree if dist_sq(node.position, pos) <= r_sq]\n\n        def radius_dynamic(n_nodes: int) -> float:\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.edge_resolution)\n\n        def add_node(parent: Node, new_pos: Tuple[float, ...], cost_to_new: float, tree: List[Node]) -> Node:\n            new_node = Node(new_pos, parent=parent, cost=cost_to_new)\n            parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node\n\n        def try_extend(tree: List[Node], sample_pt: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = add_node(best_parent, new_pos, min_cost, tree)\n\n            # Rewire neighbors for local optimization\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree: List[Node], target_node: Node) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, target_node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not can_add_node(new_pos) or not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = add_node(last_node, new_pos, new_cost, tree)\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if can_connect(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    if node.parent:\n                        try:\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    try:\n                        nodes.remove(node)\n                    except ValueError:\n                        pass\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    if node in tree_start:\n                        tree_start.remove(node)\n                    if node in tree_goal:\n                        tree_goal.remove(node)\n                    removed.append(node)\n            return removed\n\n        def path_length(path: List[Tuple[float, ...]]) -> float:\n            total = 0.0\n            for i in range(len(path) - 1):\n                total += dist(path[i], path[i + 1])\n            return total\n\n        def shortcut_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            smoothed_path = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(smoothed_path) < 3:\n                    break\n                i = random.randint(0, len(smoothed_path) - 3)\n                j = random.randint(i + 2, len(smoothed_path) - 1)\n                p1 = smoothed_path[i]\n                p2 = smoothed_path[j]\n                if can_connect(p1, p2):\n                    smoothed_path = smoothed_path[:i+1] + smoothed_path[j:]\n            return smoothed_path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Alternate growth on the smaller tree\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                    prune_dead_nodes()\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed_path = shortcut_smoothing(raw_path)\n                if path_length(smoothed_path) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 56.61114,
        "time_improvement": -202.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.03484635353088379,
                "num_nodes_avg": 88.2,
                "path_length_avg": 163.0556780735417,
                "success_improvement": 0.0,
                "time_improvement": -245.39555152237003,
                "length_improvement": 18.506339307971885,
                "objective_score": -69.91739759511663
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.06296405792236329,
                "num_nodes_avg": 143.7,
                "path_length_avg": 238.73741435960497,
                "success_improvement": 0.0,
                "time_improvement": -340.18368044269994,
                "length_improvement": 20.77884906929281,
                "objective_score": -97.89933431895142
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.03466134071350098,
                "num_nodes_avg": 90.5,
                "path_length_avg": 128.44805978648338,
                "success_improvement": 0.0,
                "time_improvement": -20.805769551968933,
                "length_improvement": 21.125153449792457,
                "objective_score": -2.016700175632188
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "This improved planner implements a bidirectional RRT* algorithm incorporating adaptive goal/start bias sampling with dynamic neighbor radius rewiring to minimize path cost. It balances growth by always extending the smaller tree, rigorously applies collision and edge feasibility checks, and optimizes the found path with iterative shortcut smoothing. Additionally, it performs periodic pruning of dead-end nodes to keep tree sizes manageable and improves convergence speed and path quality. The rewiring step carefully updates parents to ensure minimal-cost routes, enhancing path optimality and robustness.",
        "planning_mechanism": "The planner grows two trees rooted at start and goal, alternately extending the smaller tree towards biased random samples favoring start or goal positions. It uses a dynamic neighbor radius for local rewiring to improve path costs continuously. Periodic pruning removes dead-end nodes to maintain efficiency, while shortcut smoothing is applied after path connection to reduce length and improve smoothness. This combination balances exploration versus exploitation, leading to faster convergence, increased success rate, and shorter, smoother paths.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=20.0,\n                 radius_min: float=5.0, prune_interval: int=150,\n                 prune_threshold: int=150, smoothing_iterations: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        import random\n        import math\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            # Adaptive bias towards goal and start to promote faster connections\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < 0.6 else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            if not in_bounds(pos) or self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            to_remove = [node for node in nodes if node not in (start_root, goal_root) and not node.children]\n            for node in to_remove:\n                try:\n                    if node.parent:\n                        node.parent.children.remove(node)\n                    nodes.remove(node)\n                    edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                    removed.append(node)\n                except Exception:\n                    continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend smaller tree to balance exploration/exploitation\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed_path = shortcut_smoothing(raw_path)\n                if path_length(smoothed_path) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -4.59249,
        "time_improvement": 1.0,
        "length_improvement": 21.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.004982614517211914,
                "num_nodes_avg": 68.5,
                "path_length_avg": 157.43983697259313,
                "success_improvement": 0.0,
                "time_improvement": 50.6125400561495,
                "length_improvement": 21.313082713587217,
                "objective_score": 19.44637855956229
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.026825737953186036,
                "num_nodes_avg": 179.7,
                "path_length_avg": 240.30043302847486,
                "success_improvement": 0.0,
                "time_improvement": -87.53956546741006,
                "length_improvement": 20.260186595686807,
                "objective_score": -22.209832321085653
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.01701357364654541,
                "num_nodes_avg": 144.0,
                "path_length_avg": 127.59148971666832,
                "success_improvement": 0.0,
                "time_improvement": 40.70229786583415,
                "length_improvement": 21.651139073308062,
                "objective_score": 16.540917174411856
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e1",
        "algorithm_description": "This planner leverages a hybrid anytime RRT*-based algorithm with adaptive heuristic-biased sampling and dynamic tree balancing. It integrates a dynamic neighbor radius based on iteration count and node density, collision caching for efficient repeated checks, and bidirectional incremental rewiring with asymmetrical tree growth prioritizing the smaller tree. To enhance performance and path quality, the algorithm incorporates a multi-resolution shortcut smoothing with adaptive node pruning guided by heuristic cost-to-go estimates and cost improvements. The approach emphasizes robust rapid convergence toward the optimum path with minimal computational overhead, ensuring smoother, shorter, and feasible paths in both 2D and 3D spaces.",
        "planning_mechanism": "The planner alternately extends two trees rooted at start and goal by sampling points weighted by a heuristic-informed mechanism that biases sampling nearer the current best path and goal vicinities. It adaptively calculates neighbor radius for rewiring to optimize local paths while collision caches eliminate redundant checks. Extending nodes occur only if collision-free at node and edge levels, and trees attempt connections incrementally, rewiring neighbors to improve costs. Periodic pruning removes nodes unlikely to improve the path. After finding a connection, a multi-pass shortcut smoothing process refines path quality. The planner balances exploration and exploitation dynamically, aiming for fast convergence to a high-quality, smooth path within bounded iterations.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision/validation flags\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        # Parameters for adaptive radius and pruning\n        self.min_neighbor_radius = 3.5\n        self.max_neighbor_radius = 25.0\n        self.prune_interval = 150\n        self.prune_threshold = 250\n        self.smoothing_passes = 3\n        self.shortcut_iterations_per_pass = 75\n        self.collision_check_resolution = 1.0\n        self.goal_sample_rate = 0.18  # Bias towards goal\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def heuristic(p):\n            return dist(p, goal_pos)\n\n        def adaptive_neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            decay_factor = 1.0 - (iteration / self.max_iter) ** 1.05\n            r_iter = self.max_neighbor_radius * decay_factor\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or random.random() < self.goal_sample_rate:\n                for _ in range(15):\n                    sample_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample_pt, obstacles, is_3d):\n                        return sample_pt\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center_np = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            vec = a1 - id_mat[:, 0]\n            norm_vec = np.linalg.norm(vec)\n            if norm_vec > 1e-10:\n                u = vec / norm_vec\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_orth = math.sqrt(max(r1**2 - (c_min/2.0)**2, 0))\n            radii = np.array([r1] + [r_orth] * (dim - 1))\n\n            for _ in range(120):\n                x_ball = np.random.uniform(-1, 1, size=dim)\n                norm_x = np.linalg.norm(x_ball)\n                if 1e-15 < norm_x <= 1.0:\n                    radius_scale = np.random.uniform() ** (1/dim)\n                    x_scaled = (x_ball / norm_x) * radius_scale\n                    sample_ellipse = x_scaled * radii\n                    sample_np = rot @ sample_ellipse + center_np\n                    sample = tuple(float(v) for v in sample_np)\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            # Fallback uniform random sampling\n            for _ in range(15):\n                sample_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample_pt, obstacles, is_3d):\n                    return sample_pt\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        class KDTree:\n            def __init__(self, nodes_list):\n                self.dim = dim\n                self.points = [node.position for node in nodes_list]\n                self.nodes = nodes_list\n\n            def nearest(self, point):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, point)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, point, radius):\n                r2 = radius * radius\n                result = []\n                for p, n in zip(self.points, self.nodes):\n                    diff_sq = 0.0\n                    for d_ in range(self.dim):\n                        diff = p[d_] - point[d_]\n                        diff_sq += diff * diff\n                        if diff_sq > r2:\n                            break\n                    else:\n                        result.append(n)\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]  # True if free\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos): \n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def shortcut_path(path):\n            path = list(path)\n            if len(path) < 3:\n                return path\n\n            for _ in range(self.smoothing_passes):\n                num_iterations = self.shortcut_iterations_per_pass\n                attempts = 0\n                while attempts < num_iterations and len(path) >= 3:\n                    i = random.randint(0, len(path) - 3)\n                    j = random.randint(i + 2, len(path) - 1)\n                    if can_connect(path[i], path[j]):\n                        path = path[:i + 1] + path[j:]\n                    attempts += 1\n            return path\n\n        def prune_nodes(nodes_list, tree_s, tree_g, best_cost):\n            h = lambda p: dist(p, goal_pos)\n            to_remove = []\n            threshold_upper = best_cost * 1.005\n            threshold_lower = best_cost * 0.99\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                est_cost = node.cost + h(node.position)\n                if est_cost > threshold_upper or (not node.children and est_cost >= threshold_lower):\n                    to_remove.append(node)\n\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_s:\n                    try: tree_s.remove(node)\n                    except ValueError: pass\n                if node in tree_g:\n                    try: tree_g.remove(node)\n                    except ValueError: pass\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Always grow smaller tree first to balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree(tree_a)\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = adaptive_neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + dist(near_node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(near_node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near neighbors to go via the new node if cheaper\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_via_new + 1e-12 < near_node.cost and can_connect(new_node.position, near_node.position):\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                    except ValueError:\n                        pass\n                    near_node.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, near_node))\n\n            # Incremental connection attempts from opposite tree toward new_node\n            kdtree_b = KDTree(tree_b)\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = merged_path\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                # Multi-pass shortcut smoothing for improved path quality\n                extracted_path = shortcut_path(best_path)\n                break\n\n            # Periodic pruning for efficiency and robustness\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = shortcut_path(best_path) if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -6.4631,
        "time_improvement": 7.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009128785133361817,
                "num_nodes_avg": 69.5,
                "path_length_avg": 158.07584947840263,
                "success_improvement": 0.0,
                "time_improvement": 9.515875941733066,
                "length_improvement": 20.99520977621579,
                "objective_score": 7.053804737763079
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.018969392776489256,
                "num_nodes_avg": 220.7,
                "path_length_avg": 236.91172981208757,
                "success_improvement": 0.0,
                "time_improvement": -32.615612837629484,
                "length_improvement": 21.384672967816226,
                "objective_score": -5.5077492577255995
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.015922069549560547,
                "num_nodes_avg": 157.2,
                "path_length_avg": 126.28001688452363,
                "success_improvement": 0.0,
                "time_improvement": 44.50653595042799,
                "length_improvement": 22.456462396697518,
                "objective_score": 17.8432532644679
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This hybrid path planning algorithm synergizes adaptive informed ellipsoidal sampling, bidirectional tree growth, dynamic neighbor radius rewiring, goal/start biased sampling, incremental connection attempts, and periodic pruning. It balances exploration and exploitation by always extending the smaller tree, focuses sampling within an informed subset when a solution is found, and applies rigorous collision and edge feasibility checks. After path discovery, the algorithm performs iterative shortcut smoothing to improve smoothness and optimality while pruning non-promising and dead-end nodes to maintain computational efficiency and robustness. This integrated approach aims to enhance planning efficiency, path quality, robustness, and success rate in both 2D and 3D cluttered environments.",
        "planning_mechanism": "The planner grows two trees from start and goal with bidirectional RRT*-inspired rewiring and adaptive informed ellipsoidal sampling to focus search in promising areas. Goal/start biased sampling promotes faster connections. Expansion always occurs on the smaller tree to balance growth. Incremental connection attempts between trees help accelerate feasible path discovery. Periodic pruning removes dead-end and non-promising nodes. After path extraction, iterative shortcut smoothing refines the trajectory for smoothness and length optimization. Collision checking ensures nodes and edges lie in free space, preventing invalid expansions.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 prune_interval: int = 150, prune_threshold: int = 200,\n                 smoothing_iterations: int = 50, collision_resolution: float = 1.0,\n                 connect_steps_factor: int = 5,\n                 radius_max: float = 30.0, radius_min: float = 5.0,\n                 radius_constant: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_resolution = collision_resolution\n        self.connect_steps_factor = connect_steps_factor\n        self.radius_max = radius_max\n        self.radius_min = radius_min\n        self.radius_constant = radius_constant\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size              # Tuple[int, ...] (W,H) or (W,H,D)\n        start = map.start              # Tuple[float, ...]\n        goal = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles      # Obstacles list (2D or 3D)\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root_start = Node(start, cost=0.0)\n        root_goal = Node(goal, cost=0.0)\n        nodes.extend([root_start, root_goal])\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = math.dist(start, goal)\n        best_path = []\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp strictly\n            new_p = tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n            return new_p\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance_edge = dist(p1, p2)\n            steps = max(1, int(distance_edge / self.collision_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def radius_by_iteration_and_nodes(iteration, n_nodes):\n            n = max(n_nodes, 1)\n            r_iter = self.radius_max * (1 - (iteration / self.max_iter) ** 0.9)\n            r_log = self.radius_min + (self.radius_max - self.radius_min) * math.sqrt(math.log(n + 1) / n)\n            return max(self.radius_min, min(r_iter, r_log))\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def informed_sample(c_best, c_min, start, goal):\n            # If no path or path close to min dist, sample uniformly with goal/start bias\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # Goal/start bias sampling for efficiency\n                for _ in range(10):\n                    if random.random() < self.goal_sample_rate:\n                        p = goal if random.random() < 0.6 else start\n                    else:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Ellipsoidal informed sampling inside ellipsoid subset defined by c_best\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            # Construct rotation matrix for ellipse principal axis alignment\n            I = np.eye(dim)\n            u_vec = direction - I[:, 0]\n            norm_u = np.linalg.norm(u_vec)\n            if norm_u > 1e-10:\n                u_vec /= norm_u\n                rot = I - 2 * np.outer(u_vec, u_vec)\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # fallback uniform sampling\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - point[d]) ** 2 for d in range(dim)) <= r2]\n\n        def prune_dead_and_nonpromising(nodes_list, tree_s, tree_g, c_best_current):\n            remove_cands = []\n            for node in nodes_list:\n                if node is root_start or node is root_goal:\n                    continue\n                # Dead node detection: no children\n                if not node.children:\n                    remove_cands.append(node)\n                    continue\n                # Heuristic cost pruning (cost + heuristic)\n                h_cost = dist(node.position, goal)\n                if node.cost + h_cost >= c_best_current:\n                    remove_cands.append(node)\n            for node in remove_cands:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_s:\n                    try:\n                        tree_s.remove(node)\n                    except ValueError:\n                        pass\n                if node in tree_g:\n                    try:\n                        tree_g.remove(node)\n                    except ValueError:\n                        pass\n\n        def shortcut_path(path: list):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Planning main loop\n        for itr in range(self.max_iter):\n            sample_pt = informed_sample(c_best, c_min, start, goal)\n\n            # Always extend smaller tree to balance exploration/exploitation\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            nearest_a = nearest_node(tree_a, sample_pt)\n            new_pos = steer(nearest_a.position, sample_pt)\n\n            if (not in_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_a.position, new_pos):\n                continue\n\n            r = radius_by_iteration_and_nodes(itr, len(nodes))\n            neighbors = near_nodes(tree_a, new_pos, r)\n\n            # Choose best parent from neighbors minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in neighbors:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors locally in tree_a\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connection attempt from other tree (tree_b)\n            nearest_b = nearest_node(tree_b, new_node.position)\n            last_b = nearest_b\n            max_connect_steps = int(dist(last_b.position, new_node.position) / self.step_size) * self.connect_steps_factor + 1\n            connected = False\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if (not in_bounds(next_pos_b)) or is_in_obstacle(next_pos_b) or is_edge_in_obstacle(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                # Rewire neighbors in tree_b around new_node_b\n                neighbors_b = near_nodes(tree_b, next_pos_b, r)\n                for neighbor_b in neighbors_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and not is_edge_in_obstacle(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                # Check if close enough to connect\n                if dist(new_node_b.position, new_node.position) <= self.step_size and not is_edge_in_obstacle(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Extract full path from start to goal\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning of dead and non-promising nodes to improve efficiency\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_dead_and_nonpromising(nodes, tree_start, tree_goal, c_best)\n\n        if success_state and extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 9.25748,
        "time_improvement": -45.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.00981605052947998,
                "num_nodes_avg": 88.5,
                "path_length_avg": 158.95333344852241,
                "success_improvement": 0.0,
                "time_improvement": 2.703731011730895,
                "length_improvement": 20.556651721884293,
                "objective_score": 4.922449647896127
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03134276866912842,
                "num_nodes_avg": 270.7,
                "path_length_avg": 240.42870944172887,
                "success_improvement": 0.0,
                "time_improvement": -119.11826720337359,
                "length_improvement": 20.21762014198492,
                "objective_score": -31.691956132615093
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.034293508529663085,
                "num_nodes_avg": 240.8,
                "path_length_avg": 123.32504919577585,
                "success_improvement": 0.0,
                "time_improvement": -19.523757687459323,
                "length_improvement": 24.27099056783716,
                "objective_score": -1.002929192670365
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This planner merges the bidirectional RRT* approach with adaptive ellipsoidal informed sampling, KD-tree assisted neighbor search, collision caching, dynamic rewiring, and progressive pruning of suboptimal nodes. It emphasizes balanced tree growth, fast neighbor retrieval, and iterative shortcut smoothing to efficiently find high-quality, smooth paths in both 2D and 3D environments.",
        "planning_mechanism": "The planner grows two trees from start and goal, alternately extending the smaller tree towards samples biased inside an ellipsoidal informed set defined by the current best path. KD-trees accelerate nearest and radius neighbor searches for rewiring. Collision checks are cached to reduce redundant computation. After each new node addition and rewiring, the opposite tree tries incremental connection. Periodic pruning removes nodes unlikely to improve solutions. Finally, the best path is shortcut-smoothed iteratively for improved quality and smoothness.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position          # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Path cost from root\n        self.children = []\n        self.valid = True                 # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_from_parent(self):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n            self.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        self.remove_from_parent()\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval: int=200, prune_threshold: int=300,\n                 smoothing_iterations: int=100, collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(from_pos[d_] + ratio * (to_pos[d_] - from_pos[d_]) for d_ in range(dim))\n            return tuple(max(0, min(new_pos[d_], bounds[d_])) for d_ in range(dim))\n\n        def neighbor_radius(iteration: int, n_nodes: int) -> float:\n            c = max(n_nodes,1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c+1)/c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def _is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def _is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-Tree substitute for simplicity (brute force)\n        class KDTree:\n            def __init__(self, pts_nodes: List[Tuple[Tuple[float, ...], Node]]):\n                self.dim = dim\n                self.points = [p for p,n in pts_nodes]\n                self.nodes = [n for p,n in pts_nodes]\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt,p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                r2 = radius*radius\n                result = []\n                for i,p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best: float, c_min: float,\n                            start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not _is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d]+goal[d])/2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - np.array([1 if d==0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2*np.outer(u,u)\n            else:\n                rot = id_mat\n\n            r1 = c_best/2.0\n            val = max(r1**2 - (c_min/2)**2,0)\n            r_others = math.sqrt(val) if val>0 else 0.0\n            radii = np.array([r1] + [r_others]*(dim-1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    x_scaled = x/norm_x * (random.uniform(0,1)**(1/dim))\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + center\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not _is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not _is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = _is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and not _is_in_obstacle(pos)\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost: float) -> int:\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_position)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_position, cost=0.0)\n        root_goal = Node(goal_position, cost=0.0)\n        nodes: List[Node] = [root_start, root_goal]\n        edges: List[Tuple[Node, Node]] = []\n        tree_start: List[Node] = [root_start]\n        tree_goal: List[Node] = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_position, goal_position)\n        best_path: List[Tuple[float, ...]] = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_position, goal_position)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connect opposite tree\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 4.94049,
        "time_improvement": -31.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.011316800117492675,
                "num_nodes_avg": 78.3,
                "path_length_avg": 160.73744750936106,
                "success_improvement": 0.0,
                "time_improvement": -12.171634101844237,
                "length_improvement": 19.664968662283727,
                "objective_score": 0.2815035019034746
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.025171446800231933,
                "num_nodes_avg": 232.3,
                "path_length_avg": 234.5763235176912,
                "success_improvement": 0.0,
                "time_improvement": -75.97436474402247,
                "length_improvement": 22.159639786608256,
                "objective_score": -18.360381465885087
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.03008854389190674,
                "num_nodes_avg": 217.1,
                "path_length_avg": 124.43530379349541,
                "success_improvement": 0.0,
                "time_improvement": -4.86812179611291,
                "length_improvement": 23.589227361975116,
                "objective_score": 3.25740893356115
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This planner implements a simplified and generalized bidirectional informed RRT* algorithm that balances exploration and exploitation through adaptive informed ellipsoidal sampling, efficient neighbor selection, lazy collision checking, incremental rewiring, and periodic pruning. It aims to improve path quality, smoothness, success rate, and planning efficiency in both 2D and 3D environments.",
        "planning_mechanism": "The planner grows two trees alternately from start and goal positions within an adaptively shrinking ellipsoidal sampling region informed by the best path found so far. Nodes are steered towards sampled points with careful bound and collision checks. Neighborhood radius adapts dynamically with tree growth for effective rewiring aimed at lowering path cost. Trees attempt incremental connection via collision-checked edges, and periodic pruning removes nodes unlikely to improve the best path. The final path undergoes shortcut smoothing to enhance smoothness and reduce length.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...] (2D or 3D)\n        self.parent = parent              # Parent Node or None\n        self.cost = cost                  # Cost from root\n        self.children = []\n        self.valid = True                 # For pruning or collision status\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_from_parent(self):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n            self.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        self.remove_from_parent()\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 150, prune_threshold: int = 300,\n                 smoothing_trials: int = 50, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(src, dest):\n            d = dist(src, dest)\n            if d <= self.step_size:\n                new_p = dest\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(src[d] + ratio * (dest[d] - src[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(min(max(new_p[d], 0), bounds[d]) for d in range(dim))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            factor = math.log(n_nodes) / n_nodes\n            r = self.max_neighbor_radius * (factor ** 0.5)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        class KDTree:\n            def __init__(self, nodes):\n                self.nodes = nodes\n                self.points = [node.position for node in nodes]\n\n            def nearest(self, point):\n                best_node = None\n                best_dist = float('inf')\n                for node in self.nodes:\n                    d = dist(point, node.position)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = node\n                return best_node\n\n            def radius_search(self, point, radius):\n                radius_sq = radius * radius\n                res = []\n                for node in self.nodes:\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = node.position[d_] - point[d_]\n                        sqd += delta * delta\n                        if sqd > radius_sq:\n                            break\n                    else:\n                        res.append(node)\n                return res\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not (in_bounds(p1) and in_bounds(p2)):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def ellipse_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)  # Householder reflection\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.power(np.random.uniform(0, 1), 1 / dim)  # Uniform in unit ball\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p_tuple  # fallback\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i + 2, len(smooth) - 1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i + 1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(tree_nodes, best_cost, root_s, root_g):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in tree_nodes:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    tree_nodes.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = ellipse_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree(tree_a)\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(len(nodes))\n            near_nodes_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better via new_node\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Attempt connect other tree incrementally\n            kdtree_b = KDTree(tree_b)\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes))\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            # Optional: could continue searching for better paths after first success\n\n            # Periodic pruning for efficiency\n            if (it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n            if connected:\n                # Break early or continue to improve paths (choice here: break)\n                break\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -11.12807,
        "time_improvement": 24.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.006794548034667969,
                "num_nodes_avg": 67.8,
                "path_length_avg": 164.9801412286517,
                "success_improvement": 0.0,
                "time_improvement": 32.65273327094499,
                "length_improvement": 17.544511120019376,
                "objective_score": 13.304722205287373
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.015869450569152833,
                "num_nodes_avg": 198.3,
                "path_length_avg": 243.29064806763898,
                "success_improvement": 0.0,
                "time_improvement": -10.943820786558996,
                "length_improvement": 19.267932082215065,
                "objective_score": 0.5704401804753148
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.014382410049438476,
                "num_nodes_avg": 157.7,
                "path_length_avg": 125.82457365547616,
                "success_improvement": 0.0,
                "time_improvement": 49.8727378033124,
                "length_improvement": 22.73613197569439,
                "objective_score": 19.509047736132597
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This planner implements an improved bidirectional informed RRT* algorithm combining adaptive informed ellipse sampling, balanced tree growth, lazy collision checking, dynamic neighborhood rewiring radius, periodic pruning of low-potential branches, and iterative shortcut smoothing. It integrates incremental lazy edge validation to reduce collision check overhead, applies heuristic-driven guidance to sample efficiently within promising regions, and employs pruning to focus search and reduce planning time while improving path quality, success rate, and smoothness in both 2D and 3D maps.",
        "planning_mechanism": "The planner grows two trees bidirectionally from start and goal, alternately expanding the smaller tree for balanced growth. Sampling is done using an informed ellipse bounded by the current best path cost, concentrating exploration on promising areas. Nodes are added after collision and lazy edge collision checks. Dynamic rewiring optimizes path costs locally. Dead-end and low-potential branches are pruned periodically to enhance efficiency. On successful connection, the path is extracted and smoothed with shortcutting to reduce length and jaggedness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def is_leaf(self):\n        return len(self.children) == 0\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float = 0.15,\n                 radius_constant: float = 30.0, radius_min: float = 5.0,\n                 prune_interval: int = 300, prune_threshold: int = 150,\n                 smoothing_trials: int = 60):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_pos = map.goal                # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n\n        success = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def heuristic(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def steer(from_p, to_p):\n            dist = heuristic(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(len(from_p)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: heuristic(n.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            dim = len(pos)\n            result = []\n            for n in tree:\n                dist_sq = 0.0\n                for d in range(dim):\n                    dist_sq += (n.position[d] - pos[d])**2\n                    if dist_sq > r2:\n                        break\n                if dist_sq <= r2:\n                    result.append(n)\n            return result\n\n        def dynamic_radius(n):\n            if n <= 1:\n                return self.radius_constant\n            return max(self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1)), self.radius_min)\n\n        # Informed sampling inside an ellipse between start and goal based on best cost\n        def informed_sample(cost_best):\n            if cost_best == float('inf'):\n                # Uniform random sampling in bounds avoiding obstacles\n                if random.random() < self.goal_sample_rate:\n                    return goal_pos\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                        return p\n            else:\n                c_min = heuristic(start_pos, goal_pos)\n                c_best = max(cost_best, c_min * 1.0001)  # safeguard\n\n                center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(len(start_pos)))\n                vec = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(len(start_pos)))\n\n                import numpy as np\n\n                dim = len(start_pos)\n                # Ellipse axes lengths\n                L_diag = [c_best / 2] + [math.sqrt(c_best ** 2 - c_min ** 2) / 2] * (dim - 1)\n                L = np.diag(L_diag)\n\n                e1 = np.array(vec)\n                # Orthonormal basis matrix C:\n                if dim == 2:\n                    e2 = np.array([-e1[1], e1[0]])\n                    C = np.column_stack((e1, e2))\n                else:\n                    # Gram-Schmidt for 3D basis\n                    a = np.array([1., 0., 0.])\n                    if abs(np.dot(a, e1)) > 0.9:\n                        a = np.array([0., 1., 0.])\n                    v2 = a - np.dot(a, e1) * e1\n                    v2 /= np.linalg.norm(v2)\n                    v3 = np.cross(e1, v2)\n                    C = np.column_stack((e1, v2, v3))\n\n                while True:\n                    sample_in_unit_ball = np.random.uniform(-1, 1, dim)\n                    if np.linalg.norm(sample_in_unit_ball) > 1.0:\n                        continue\n                    sample = C @ (L @ sample_in_unit_ball) + np.array(center)\n                    sample_t = tuple(float(x) for x in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n\n        # Lazy edge collision cache\n        lazy_checked_edges = set()\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            if not (in_bounds(p1) and in_bounds(p2)):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def try_extend(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = dynamic_radius(n_nodes)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + heuristic(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            # Lazy collision checking for selecting parent\n            for node in near:\n                tentative_cost = node.cost + heuristic(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    edge_check_key = (node, new_pos)\n                    if edge_check_key not in lazy_checked_edges:\n                        if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                            lazy_checked_edges.add(edge_check_key)\n                        else:\n                            continue\n                    else:\n                        # Already verified free\n                        pass\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            # Final edge check before adding new node and edge\n            if self._is_edge_in_obstacle(best_parent.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if cheaper path found via new_node\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + heuristic(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + heuristic(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                dist_to_goal = heuristic(new_pos, node.position)\n                if dist_to_goal <= self.step_size:\n                    if not self._is_in_obstacle(node.position, obstacles, is_3d) and \\\n                       not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + dist_to_goal)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_branches():\n            removed = []\n            for node in nodes[:]:\n                # prune leaf nodes except roots\n                if node.is_leaf() and node is not start_root and node is not goal_root:\n                    # Also prune nodes with no potential: heuristic + cost > current best path cost\n                    if hasattr(self, 'best_path_cost') and node.cost + heuristic(node.position, goal_pos) >= getattr(self, 'best_path_cost', float('inf')):\n                        try:\n                            if node.parent:\n                                node.parent.children.remove(node)\n                            nodes.remove(node)\n                            edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                            removed.append(node)\n                        except Exception:\n                            pass\n            return removed\n\n        def shortcut_path(raw_path):\n            if len(raw_path) < 3:\n                return raw_path\n            smoothed = raw_path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                p_i = smoothed[i]\n                p_j = smoothed[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    smoothed = smoothed[:i + 1] + smoothed[j:]\n            return smoothed\n\n        best_path_cost = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n\n        tree_turn = 0  # 0:start tree grows, 1:goal tree grows\n\n        for itr in range(self.max_iter):\n            sample_pt = informed_sample(best_path_cost)\n\n            # Grow the smaller tree to balance exploration\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n                tree_turn = 1 - tree_turn  # flip turn accordingly\n\n            if tree_turn == 0:\n                new_node = try_extend(tree_start, sample_pt)\n                if new_node:\n                    connect_node = try_connect(tree_goal, new_node)\n                    if connect_node:\n                        success = True\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n                        candidate_path = path_start + path_goal[::-1][1:]\n                        candidate_cost = sum(heuristic(candidate_path[i], candidate_path[i + 1]) for i in range(len(candidate_path) - 1))\n                        if candidate_cost < best_path_cost:\n                            best_path_cost = candidate_cost\n                            best_path = candidate_path\n                            self.best_path_cost = best_path_cost\n                            # Improve path by shortcutting after each improvement\n                            best_path = shortcut_path(best_path)\n                            extracted_path = best_path\n                        break\n                tree_turn = 1\n            else:\n                new_node = try_extend(tree_goal, sample_pt)\n                if new_node:\n                    connect_node = try_connect(tree_start, new_node)\n                    if connect_node:\n                        success = True\n                        path_goal = new_node.path_from_root()\n                        path_start = connect_node.path_from_root()\n                        candidate_path = path_start + path_goal[::-1][1:]\n                        candidate_cost = sum(heuristic(candidate_path[i], candidate_path[i + 1]) for i in range(len(candidate_path) - 1))\n                        if candidate_cost < best_path_cost:\n                            best_path_cost = candidate_cost\n                            best_path = candidate_path\n                            self.best_path_cost = best_path_cost\n                            best_path = shortcut_path(best_path)\n                            extracted_path = best_path\n                        break\n                tree_turn = 0\n\n            # Periodic pruning to limit tree size and focus on promising branches\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_branches()\n\n        # Final smoothing on path if found\n        if success and extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 41.03117,
        "time_improvement": -150.0,
        "length_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.010256791114807129,
                "num_nodes_avg": 71.2,
                "path_length_avg": 160.07642757461787,
                "success_improvement": 0.0,
                "time_improvement": -1.664870638724253,
                "length_improvement": 19.995340072277386,
                "objective_score": 3.4996068228382016
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.038149333000183104,
                "num_nodes_avg": 300.2,
                "path_length_avg": 246.08398367861372,
                "success_improvement": 0.0,
                "time_improvement": -166.70316940437198,
                "length_improvement": 18.341008823744055,
                "objective_score": -46.34274905656278
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.10965025424957275,
                "num_nodes_avg": 448.0,
                "path_length_avg": 127.02817943359605,
                "success_improvement": 0.0,
                "time_improvement": -282.16592530793463,
                "length_improvement": 21.997045521496815,
                "objective_score": -80.25036848808102
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This implementation is an optimized bidirectional informed RRT* planner that accelerates convergence by adaptive ellipsoidal sampling focused on the current best path, efficient nearest neighbor and radius searches via KD-tree, collision caching with fast lookup to avoid redundant checks, incremental rewiring for path cost improvements, periodic pruning of nodes unlikely to improve the best solution, and shortcut smoothing to refine the final path for reduced length and improved smoothness. These enhancements collectively minimize planning time while maximizing path quality, robustness, and success rate in both 2D and 3D environments.",
        "planning_mechanism": "The planner builds two trees rooted at the start and goal positions, grows them alternately, and biases sampling within a dynamically adapting ellipsoid enclosing the current shortest path estimate. Connections between nodes are made only after collision and obstacle intersection checks. A KD-tree accelerates neighbor queries for rewiring and extension steps. Pruning removes nodes that cannot improve the known best cost, and shortcut smoothing refines the final path. Collision checks are cached to avoid redundant expensive computations, further speeding up the search.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision status\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            # Householder reflection matrix to rotate unit vector a1 to x-axis\n            v = a1_np - np.array([1] + [0]*(dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + np.array(center)\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors for cost improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -2.91188,
        "time_improvement": -5.0,
        "length_improvement": 22.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009558582305908203,
                "num_nodes_avg": 72.5,
                "path_length_avg": 157.12652174772785,
                "success_improvement": 0.0,
                "time_improvement": 5.2557449262210625,
                "length_improvement": 21.4696746515466,
                "objective_score": 5.870658408175639
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.020438408851623534,
                "num_nodes_avg": 202.2,
                "path_length_avg": 233.96171182835747,
                "success_improvement": 0.0,
                "time_improvement": -42.88554974956454,
                "length_improvement": 22.36358873836805,
                "objective_score": -8.392947177195751
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.022094321250915528,
                "num_nodes_avg": 176.4,
                "path_length_avg": 127.3519737102936,
                "success_improvement": 0.0,
                "time_improvement": 22.994280472087492,
                "length_improvement": 21.798216329909117,
                "objective_score": 11.257927407608072
            }
        ],
        "success_rate": 1.0
    }
]