{
     "operator": "e1",
     "algorithm": "This algorithm, named \"Balanced RRT*\", improves on classic RRT* by balancing incremental exploration with heuristic informed rewiring and lazy collision checking. \n    \n    Key features:\n    - Uses a Forest graph structure for efficient tree rewiring.\n    - Introduces goal-biased sampling to speed convergence.\n    - Uses adaptive sampling radius based on the current graph size.\n    - Employs lazy collision checking to reduce expensive validity checks.\n    - Early path quality improvements by local rewiring with cost and smoothness considerations.\n    - Time limit of 60 seconds for planning, marking failure if exceeded.\n    \n    This approach aims to improve planning efficiency, reduce search time, increase success rate,\n    and produce smoother, shorter paths via rewiring and heuristic sampling.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = None\n        self._max_dist = 15.0\n        self._max_radius = 30.0\n        self._lambda_star = 40.0\n        self._time_limit = 60.0  # seconds\n        self._init_graph()\n        self._init_displays()\n\n    def _init_graph(self):\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n    def _get_random_sample(self) -> Point:\n        # Goal biasing: sample goal fairly often to speed convergence\n        goal_bias_prob = 0.15\n        if torch.rand(1).item() < goal_bias_prob:\n            return self._get_grid().goal.position\n        # Uniform random sample within map size\n        size = self._get_grid().size\n        while True:\n            coords = [torch.randint(0, size[i], (1,)).item() for i in range(size.n_dim)]\n            pt = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(pt):\n                return pt\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _steer(self, from_v: Vertex, to_p: Point, max_dist: float) -> Vertex:\n        vec = to_p.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_dist:\n            return Vertex(to_p)\n        direction = vec / dist\n        new_pos = from_v.position.to_tensor() + max_dist * direction\n        new_point = Point.from_tensor(new_pos)\n        return Vertex(new_point)\n\n    def _vertices_within_radius(self, v: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], v.position, radius)\n\n    def _valid_path(self, p1: Point, p2: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        path: List[Vertex] = [goal_vertex]\n        while path[-1].parents:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n        path.reverse()\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        max_iterations = 12000\n        iter = 0\n\n        while iter < max_iterations:\n            iter += 1\n            elapsed = time.time() - start_time\n            if elapsed > self._time_limit:\n                # Planning failed due to timeout\n                break\n\n            q_rand = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_rand)\n            if q_nearest.position == q_rand:\n                continue\n\n            q_new = self._steer(q_nearest, q_rand, self._max_dist)\n\n            # Lazy collision checking: only check when connection to nearest vertex\n            if not self._valid_path(q_nearest.position, q_new.position):\n                continue\n\n            # Calculate adaptive radius based on graph size and map dims\n            n = max(self._graph.size, 1)\n            dim = self._get_grid().size.n_dim\n            rad = min(self._lambda_star * ((torch.log(torch.tensor(float(n))) / n) ** (1.0 / dim)), self._max_radius)\n\n            near_vertices = self._vertices_within_radius(q_new, rad)\n\n            # Find parent with minimum cost and collision-free edge\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._distance(q_nearest.position, q_new.position)\n            for q_near in near_vertices:\n                if self._valid_path(q_near.position, q_new.position):\n                    c_new = q_near.cost + self._distance(q_near.position, q_new.position)\n                    if c_new < c_min:\n                        q_min = q_near\n                        c_min = c_new\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewiring: check if q_new can improve cost to neighbors\n            for q_near in near_vertices:\n                if q_near is q_min:\n                    continue\n                if self._valid_path(q_new.position, q_near.position):\n                    c_through_new = q_new.cost + self._distance(q_new.position, q_near.position)\n                    if c_through_new < q_near.cost:\n                        # Remove previous edge\n                        parent_old = next(iter(q_near.parents), None)\n                        if parent_old:\n                            self._graph.remove_edge(parent_old, q_near)\n                        q_near.cost = c_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            # If within goal radius, construct path\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            # Mark a key frame occasionally\n            if iter % 50 == 0:\n                self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm": "Improved RRT* inspired path planning algorithm with adaptive sampling, efficient rewiring, and goal biasing.\n    The algorithm balances exploration and exploitation using dynamic radius adjustment based on the number of vertices.\n    It integrates goal bias sampling to accelerate convergence and performs iterative rewiring over a neighborhood for shorter paths.\n    Timed-out searches are terminated as failures. The approach aims at improved planning efficiency, path quality,\n    robustness, success rate, and path smoothness compared to classical RRT*.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_iterations = 15000\n        self._max_distance = 12.0  # max edge length\n        self._lambda_rrt_star = 40.0  # constant for radius calculation\n        self._goal_sample_rate = 0.1  # goal bias probability\n        self._max_radius = 60.0  # max search radius for neighbors\n        self._dimension = self._get_grid().size.n_dim\n        self._timeout_seconds = 60  # time limit for path search\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Goal biasing: sample goal with probability _goal_sample_rate\n        if torch.rand(1).item() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n\n        # Uniform random sample within map bounds and valid region\n        while True:\n            sample_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item()\n                             for i in range(self._dimension)]\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        direction_normalized = direction / dist\n        new_position_tensor = q_near.position.to_tensor() + max_dist * direction_normalized\n        new_position = Point.from_tensor(new_position_tensor)\n        return Vertex(new_position)\n\n    def _extract_path(self, last_vertex: Vertex) -> None:\n        # Backtrack from last_vertex to start using parents\n        path = [last_vertex]\n        current = last_vertex\n        while current.parents:\n            # Select parent with minimal cost\n            current = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            path.append(current)\n        path.reverse()\n\n        # Move agent along resolved path; show keyframes\n        for vertex in path:\n            self.move_agent(vertex.position)\n            # Support ROS waypoint publish if applicable\n            grid = self._get_grid()\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        for iteration in range(self._max_iterations):\n\n            if time.time() - start_time > self._timeout_seconds:\n                # Fail gracefully if time exceeded\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_distance)\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Dynamic radius calculation inspired by RRT*\n            card_v = max(self._graph.size, 1)\n            log_card_v = torch.log(torch.tensor(float(card_v)))\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), self._max_radius)\n\n            # Find neighbors within radius\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent minimizing cost + cost to q_new\n            q_min = q_nearest\n            cost_min = (q_nearest.cost if q_nearest.cost is not None else float('inf')) + \\\n                       torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            for q_near in neighbors:\n                line_to_new = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_to_new):\n                    cost = (q_near.cost if q_near.cost is not None else float('inf')) + \\\n                           torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                    if cost < cost_min:\n                        q_min = q_near\n                        cost_min = cost\n\n            q_new.cost = cost_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewiring neighbors to potentially improve paths through q_new\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_from_new = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_from_new):\n                    continue\n                new_cost = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if q_near.cost is None or new_cost < q_near.cost:\n                    # Rewire: remove old parent edges and add new edge q_new->q_near\n                    old_parents = list(q_near.parents)\n                    for p in old_parents:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = None  # reset before setting new cost\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n            # Early termination if q_new is in goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm": "This improved path planning algorithm is an enhanced RRT* variant designed to increase planning efficiency,\n    success rate, and path quality. It adaptively tunes the sampling radius, uses goal biasing to speed convergence, \n    and implements rewiring for path optimization making paths shorter and smoother. \n    Collision-free checks use Bresenham's line validation, while planning is time-boxed at 60 seconds for robustness.\n    The method balances exploration and exploitation for better performance across maps with various search area sizes.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services, \n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / dist\n            new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(new_pos)\n\n    def _get_random_sample(self, goal_sample_rate: float) -> Point:\n        # goal_sample_rate in [0,1] probability to return goal point directly\n        if np.random.rand() < goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, max_step_len: float) -> Optional[Vertex]:\n        new_vertex = self._get_new_vertex(from_vertex, to_point, max_step_len)\n        line_seq = self._get_grid().get_line_sequence(from_vertex.position, new_vertex.position)\n        if self._get_grid().is_valid_line_sequence(line_seq):\n            return new_vertex\n        return None\n\n    def _near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        # vertices within radius from q_new\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _choose_parent(self, q_near_vertices: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        # Choose parent with minimum cost to reach q_new and valid path\n        min_cost = float(\"inf\")\n        best_parent = None\n        for q_near in q_near_vertices:\n            new_cost = (q_near.cost if q_near.cost is not None else 0.0) + \\\n                self._get_grid().get_movement_cost(q_near.position, q_new.position)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if self._get_grid().is_valid_line_sequence(line_seq) and new_cost < min_cost:\n                min_cost = new_cost\n                best_parent = q_near\n\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, q_near_vertices: List[Vertex], q_new: Vertex) -> None:\n        # For each near vertex, try to improve cost via q_new\n        for q_near in q_near_vertices:\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = (q_new.cost if q_new.cost is not None else 0.0) + \\\n                self._get_grid().get_movement_cost(q_new.position, q_near.position)\n            if q_near.cost is None or new_cost < q_near.cost:\n                # Remove old parent's edge to q_near\n                parents_to_remove = list(q_near.parents)\n                for p in parents_to_remove:\n                    self._graph.remove_edge(p, q_near)\n                # Add edge from q_new to q_near\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _extract_path(self, q_last: Vertex) -> None:\n        path: List[Vertex] = []\n        current = q_last\n        # Walk parents until start or None\n        while current is not None:\n            path.append(current)\n            if len(current.parents) > 0:\n                current = next(iter(current.parents))\n            else:\n                current = None\n\n        path.reverse()\n\n        # Animate path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iter = 20000\n        max_step_len = max(self._get_grid().size.width, self._get_grid().size.height) / 30.0\n        goal_sample_rate = 0.1  # 10% samples at goal to bias growth toward goal\n        search_radius = max_step_len * 2.5  # radius for neighbor search in rewiring\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        start_time = time.time()\n\n        for i in range(max_iter):\n            if time.time() - start_time > 60:  # Timeout at 60 seconds\n                break  # Treat as failure\n\n            q_sample = self._get_random_sample(goal_sample_rate)\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue  # same point, discard\n\n            q_new = self._steer(q_near, q_sample, max_step_len)\n            if q_new is None:\n                continue\n\n            near_vertices = self._near_vertices(q_new, search_radius)\n            parent = self._choose_parent(near_vertices, q_new)\n            if parent is None:\n                # If no better parent, connect to nearest vertex if valid\n                if not self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                ):\n                    continue\n                q_new.cost = (q_near.cost if q_near.cost is not None else 0.0) + \\\n                    self._get_grid().get_movement_cost(q_near.position, q_new.position)\n                parent = q_near\n\n            self._graph.add_edge(parent, q_new)\n\n            # Rewire near vertices for optimization\n            self._rewire(near_vertices, q_new)\n\n            # Check if goal is reached by q_new\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new directly to goal vertex with edge if free\n                goal_vertex = self._graph.root_vertex_goal\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    goal_cost = (q_new.cost if q_new.cost is not None else 0.0) + \\\n                        self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n                    if goal_vertex.cost is None or goal_cost < goal_vertex.cost:\n                        # Remove old edges of goal vertex for new connection\n                        parents_to_remove = list(goal_vertex.parents)\n                        for p in parents_to_remove:\n                            self._graph.remove_edge(p, goal_vertex)\n\n                        self._graph.add_edge(q_new, goal_vertex)\n                        goal_vertex.cost = goal_cost\n\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm": "This improved path planning algorithm is an enhanced RRT* variant designed to balance efficient exploration and\n    path quality. \n\n    Key improvements:\n    - Uses goal biasing for sample selection to speed convergence towards the goal.\n    - Employs a rewiring step (RRT*) to improve path optimality and smoothness after adding each vertex.\n    - Dynamically sets the neighborhood radius for rewiring based on the number of vertices and map size.\n    - Limits maximum edge length to avoid overshooting and adheres to map constraints.\n    - Applies early termination on success or if planning duration exceeds 60 seconds.\n    - Prunes redundant edges and only connects to valid states ensuring robustness.\n    \n    This algorithm improves planning efficiency, path quality, robustness, and reduces search time compared to\n    traditional RRT.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _goal_sample_rate: float  # Probability to sample goal versus random sample\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex: Vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True  # Enable removals for rewiring\n\n        # Heuristic max distance: set proportionally to map diagonal (to adapt varying map sizes)\n        map_size_tensor = torch.tensor(self._get_grid().size.values, dtype=torch.float32)\n        diag = torch.norm(map_size_tensor)\n        self._max_dist = max(1.0, diag.item() * 0.1)  # max edge length ~10% of diagonal min 1.0\n        self._goal_sample_rate = 0.15  # 15% samples biased towards goal\n\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Goal biasing with a sampled probability:\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= self._max_dist:\n            # Already close enough, return vertex at q_sample\n            return Vertex(q_sample)\n        direction_normalized = direction / dist\n        new_point_tensor = q_near.position.to_tensor() + direction_normalized * self._max_dist\n        q_new_point = Point.from_tensor(new_point_tensor)\n        return Vertex(q_new_point)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"Extract path from q_new to start by backtracking parents, add path animation.\"\"\"\n        goal_v = Vertex(self._get_grid().goal.position)\n        # Add final edge to goal vertex (straightline check)\n        line_seq = self._get_grid().get_line_sequence(q_new.position, goal_v.position)\n        if self._get_grid().is_valid_line_sequence(line_seq):\n            self._graph.add_edge(q_new, goal_v)\n        else:\n            # fallback: if direct edge invalid, just use q_new as end\n            goal_v = q_new\n\n        path: List[Vertex] = [goal_v]\n\n        # Backtrack through parents (assume tree structure)\n        while len(path[-1].parents) != 0:\n            # Get parent with lowest cost to follow shortest path (RRT* improvement)\n            parent = min(path[-1].parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            path.append(parent)\n\n        path.pop()  # Remove the root extra duplicate\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_near_vertices(self, verts: List[Vertex], q_new: Vertex) -> List[Vertex]:\n        \"\"\"Returns list of vertices within radius for rewiring.\"\"\"\n        n = len(self._graph.root_vertices) + max(1, self._graph.size)\n        # RRT* suggested radius for 2D: gamma * (log(n)/n) ** (1/dim)\n        dim = self._get_grid().size.n_dim\n        gamma_rrt_star = self._max_dist * 2.0  # scaling factor\n        radius = gamma_rrt_star * (np.log(n) / n) ** (1.0 / dim)\n        neighbors = self._graph.get_vertices_within_radius(verts, q_new.position, radius)\n        return neighbors\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        \"\"\"Choose the best parent for q_new based on cost and valid connection.\"\"\"\n        min_cost = float(\"inf\")\n        best_parent = None\n        for v_near in near_vertices:\n            # Check line validity between v_near.position and q_new.position\n            line_seq = self._get_grid().get_line_sequence(v_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            # Compute cost to come through v_near\n            move_cost = self._get_grid().get_movement_cost(v_near.position, q_new.position)\n            total_cost = (v_near.cost if v_near.cost is not None else 0.0) + move_cost\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_parent = v_near\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"Attempt to improve paths of neighbors by rewiring through q_new.\"\"\"\n        for v_near in near_vertices:\n            if v_near == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            move_cost = self._get_grid().get_movement_cost(q_new.position, v_near.position)\n            new_cost = (q_new.cost if q_new.cost is not None else 0.0) + move_cost\n            if v_near.cost is None or new_cost < v_near.cost:\n                # Rewire edge: remove old parent edges and add new parent edge q_new -> v_near\n                for p in list(v_near.parents):\n                    self._graph.remove_edge(p, v_near)\n                self._graph.add_edge(q_new, v_near)\n                v_near.cost = new_cost\n\n    def _init_vertex_cost(self, vertex: Vertex) -> None:\n        if vertex == self._graph.root_vertex_start:\n            vertex.cost = 0.0\n        else:\n            vertex.cost = float('inf')\n\n    def _find_path_internal(self) -> None:\n        max_iterations = 15000\n        start_time = time.time()\n        self._init_vertex_cost(self._graph.root_vertex_start)\n\n        for _ in range(max_iterations):\n\n            if time.time() - start_time > 60:\n                # Fail condition: timeout exceeded\n                break\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample)\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Initialize q_new cost temporarily to inf\n            self._init_vertex_cost(q_new)\n\n            near_vertices = self._get_near_vertices([self._graph.root_vertex_start] + self._graph.root_vertices, q_new)\n\n            parent_vertex = self._choose_parent(near_vertices, q_new)\n            if parent_vertex is None:\n                # fallback to connecting to nearest vertex with valid edge only\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    parent_vertex = q_near\n                    q_new.cost = (parent_vertex.cost if parent_vertex.cost is not None else 0.0) + \\\n                        self._get_grid().get_movement_cost(parent_vertex.position, q_new.position)\n                else:\n                    continue\n\n            self._graph.add_edge(parent_vertex, q_new)\n            self._graph.root_vertices.append(q_new)\n\n            # Rewire neighbors to improve paths\n            self._rewire(q_new, near_vertices)\n\n            # Check if goal reached from q_new to goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e2",
     "algorithm": "This algorithm is a hybrid bidirectional RRT variant enhanced with intelligent sampling,\n    goal biasing, rewiring steps inspired by RRT*, and shortcut path smoothing.\n    It grows two trees from start and goal and attempts to connect them for rapid convergence.\n    By combining goal bias sampling and neighborhood rewiring within a variable radius,\n    it improves path quality, smoothness, and robustness. Time-check logic aborts search if >60s.\n    The algorithm uses a cyclic graph structure for flexible rewiring and path improvements,\n    balancing exploration and exploitation to yield shorter, smoother paths efficiently.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _max_dist: float = 15.0\n    _iterations: int = 15000\n    _goal_sample_rate: float = 0.1\n    _rewire_radius_factor: float = 20.0  # Tunable based on map size\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_v = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_v = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = gen_cyclic_graph(self._services, start_v, goal_v, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # With goal biasing to speed up convergence\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= self._max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        dir_norm = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + self._max_dist * dir_norm\n        q_new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(q_new_pos, store_connectivity=True)\n\n    def _line_is_free(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _nearest_vertex(self, vertices: List[Vertex], point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(vertices, point)\n\n    def _get_neighborhood(self, vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(vertices, point, radius)\n\n    def _rewire(self, q_new: Vertex, neighborhood: List[Vertex]) -> None:\n        # Rewire nearby vertices if it improves cost\n        for q_near in neighborhood:\n            if q_near == q_new:\n                continue\n            if not self._line_is_free(q_new.position, q_near.position):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, q_near.position)\n            if q_near.cost is None or new_cost < q_near.cost:\n                # Remove old parent edges\n                for p in set(q_near.parents):\n                    self._graph.remove_edge(p, q_near)\n                # Add new edge\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _update_cost(self, q_new: Vertex, q_near: Vertex) -> None:\n        if q_near.cost is None:\n            q_new.cost = self._get_grid().get_distance(q_near.position, q_new.position)\n        else:\n            q_new.cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n\n    def _extract_path(self, connection_vertex_start: Vertex, connection_vertex_goal: Vertex) -> None:\n        # Trace path from start tree root to connection_vertex_start:\n        path_start = [connection_vertex_start]\n        while path_start[-1].parents:\n            # Take first parent - forests are trees so unique parent expected\n            for p in path_start[-1].parents:\n                path_start.append(p)\n                break\n        path_start.reverse()\n\n        # Trace path from connection_vertex_goal to goal tree root:\n        path_goal = [connection_vertex_goal]\n        while path_goal[-1].children:\n            # Take first child - unique child expected for root side\n            for c in path_goal[-1].children:\n                path_goal.append(c)\n                break\n\n        # Combine path (start to goal)\n        full_path = path_start + path_goal\n\n        # Shortcut smoothing to reduce unnecessary nodes\n        full_path = self._shortcut_path(full_path)\n\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempt to shortcut path by skipping intermediate nodes if line is free\n        if len(path) < 3:\n            return path\n        shortened_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1  # Try to jump as far as possible\n            while next_idx > idx + 1:\n                if self._line_is_free(path[idx].position, path[next_idx].position):\n                    break\n                next_idx -= 1\n            shortened_path.append(path[next_idx])\n            idx = next_idx\n        return shortened_path\n\n    def _try_connect_trees(self, q_new: Vertex, other_tree_vertices: List[Vertex]) -> Optional[Tuple[Vertex, Vertex]]:\n        # Attempt to connect q_new node to nearest node in other tree\n        q_near_other = self._nearest_vertex(other_tree_vertices, q_new.position)\n        if q_near_other.position == q_new.position:\n            return None\n        if not self._line_is_free(q_new.position, q_near_other.position):\n            return None\n        return q_new, q_near_other\n\n    def _find_path_internal(self) -> None:\n        start_time = time.perf_counter()\n        start_tree_vertices = [self._graph.root_vertex_start]\n        goal_tree_vertices = [self._graph.root_vertex_goal]\n\n        # Initialize costs for root vertices\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = 0.0\n\n        for i in range(self._iterations):\n            # Timeout check\n            if time.perf_counter() - start_time > 60.0:\n                # Failed to find path within 60 seconds\n                break\n\n            # Sample random point with goal biasing\n            q_sample = self._get_random_sample()\n\n            # Alternate tree extension to grow from start then goal\n            if i % 2 == 0:\n                tree_vertices_1 = start_tree_vertices\n                tree_vertices_2 = goal_tree_vertices\n                root_vertex_1 = self._graph.root_vertex_start\n                root_vertex_2 = self._graph.root_vertex_goal\n            else:\n                tree_vertices_1 = goal_tree_vertices\n                tree_vertices_2 = start_tree_vertices\n                root_vertex_1 = self._graph.root_vertex_goal\n                root_vertex_2 = self._graph.root_vertex_start\n\n            # Extend tree 1 toward sample\n            q_near_1 = self._nearest_vertex(tree_vertices_1, q_sample)\n            q_new_1 = self._get_new_vertex(q_near_1, q_sample)\n\n            # Check if line is free between q_near_1 and q_new_1\n            if not self._line_is_free(q_near_1.position, q_new_1.position):\n                self.key_frame()\n                continue\n\n            # Update cost & add vertex\n            self._update_cost(q_new_1, q_near_1)\n            self._graph.add_edge(q_near_1, q_new_1)\n            tree_vertices_1.append(q_new_1)\n\n            # Rewire neighbors around q_new_1 (RRT* style)\n            radius = min(self._rewire_radius_factor * np.sqrt(np.log(len(tree_vertices_1)+1) / (len(tree_vertices_1)+1)), self._max_dist*2)\n            neighborhood = self._get_neighborhood(tree_vertices_1, q_new_1.position, radius)\n            self._rewire(q_new_1, neighborhood)\n\n            # Attempt to connect the other tree to q_new_1\n            conn = self._try_connect_trees(q_new_1, tree_vertices_2)\n            if conn is not None:\n                # Add edge between connection vertices for cyclic graph\n                self._graph.add_edge(conn[1], conn[0])  # Connect other tree node to q_new_1\n                # Extract path between start and goal through these connection vertices\n                if root_vertex_1 == self._graph.root_vertex_start:\n                    self._extract_path(q_new_1, conn[1])\n                else:\n                    self._extract_path(conn[1], q_new_1)\n                return  # Success, path found; exit _find_path_internal\n\n            # Visualization key frame\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m3",
     "algorithm": "This algorithm implements an improved bidirectional RRT* variant with rewiring and adaptive step size control,\n    combined with heuristic biasing towards the goal to enhance path quality, planning efficiency, and path smoothness.\n    It grows two trees from start and goal, attempts to connect them continuously, and performs rewiring to optimize paths.\n    It also uses time-limited execution to ensure robustness by stopping if planning exceeds 60 seconds.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _start_time: float\n    _timeout_seconds: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._iterations = 20000\n        self._max_dist = 12.0\n        self._timeout_seconds = 60.0\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            [],\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Samples a random valid point within the map with heuristic bias towards the goal.\n        With probability 0.2, sample the goal explicitly to improve convergence speed.\n        \"\"\"\n        goal_pos = self._graph.root_vertex_goal.position\n        if np.random.rand() < 0.2:\n            return goal_pos\n        sz = self._get_grid().size\n        while True:\n            rand_coords = [np.random.randint(0, sz[i]) for i in range(sz.n_dim)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        \"\"\"\n        Attempts to create a new vertex in direction from from_vertex to to_point,\n        but no farther than max_dist. Returns the new vertex without edges.\n        \"\"\"\n        from_pos = from_vertex.position.to_tensor()\n        dir_vec = to_point.to_tensor() - from_pos\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(to_point, store_connectivity=True)\n        dir_unit = dir_vec / dist\n        new_pos_tensor = from_pos + dir_unit * max_dist\n        new_point = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_point, store_connectivity=True)\n\n    def _near_vertices(self, tree_vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        \"\"\"\n        Returns vertices in tree_vertices that are within radius of point.\n        \"\"\"\n        return self._graph.get_vertices_within_radius(tree_vertices, point, radius)\n\n    def _choose_parent(self, near_vertices: List[Vertex], new_vertex: Vertex) -> Optional[Vertex]:\n        \"\"\"\n        Chooses the best parent from near_vertices for new_vertex by minimizing cost plus traversal cost.\n        Returns the selected parent or None if no valid connection found.\n        \"\"\"\n        best_parent = None\n        best_cost = float('inf')\n        for vertex in near_vertices:\n            if vertex.position == new_vertex.position:\n                continue\n            line_seq = self._get_grid().get_line_sequence(vertex.position, new_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_vertex = vertex.cost + self._get_grid().get_movement_cost(vertex.position, new_vertex.position)\n            if cost_through_vertex < best_cost:\n                best_cost = cost_through_vertex\n                best_parent = vertex\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], new_vertex: Vertex) -> None:\n        \"\"\"\n        Tries to rewire near_vertices through new_vertex if it reduces cost and path is valid.\n        \"\"\"\n        for vertex in near_vertices:\n            if vertex is new_vertex:\n                continue\n            line_seq = self._get_grid().get_line_sequence(new_vertex.position, vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = new_vertex.cost + self._get_grid().get_movement_cost(new_vertex.position, vertex.position)\n            if new_cost < vertex.cost:\n                # update edge connections in graph\n                # Remove old parents' edge to vertex\n                for p in list(vertex.parents):\n                    if p in self._graph.root_vertices or p in self._graph.root_vertices:\n                        self._graph.remove_edge(p, vertex)\n                        vertex.parents.remove(p)\n                # Add new edge from new_vertex to vertex\n                self._graph.add_edge(new_vertex, vertex)\n                vertex.cost = new_cost\n                # Update connectivity to maintain consistency with our storage\n                if new_vertex.connectivity is not None and vertex.connectivity is not None:\n                    vertex.connectivity[self._graph.root_vertex_goal] = new_vertex.connectivity.get(self._graph.root_vertex_goal, new_vertex)\n\n    def _can_connect(self, from_vertex: Vertex, to_vertex: Vertex) -> bool:\n        \"\"\"\n        Checks if direct connection line is valid between two vertices.\n        \"\"\"\n        line_seq = self._get_grid().get_line_sequence(from_vertex.position, to_vertex.position)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _extract_path(self) -> None:\n        \"\"\"\n        Extracts the path by traversing parents from goal to start and moves the agent accordingly.\n        \"\"\"\n        goal_vertex = self._graph.root_vertex_goal\n        path = []\n        current = goal_vertex\n        # Trace parents until root start is reached\n        while current.parents:\n            path.append(current)\n            # Pick the parent with minimal cost (usually one)\n            current = min(current.parents, key=lambda v: v.cost if v.cost is not None else float('inf'))\n        path.append(current)  # Append start\n        path.reverse()\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _try_connect_trees(self) -> bool:\n        \"\"\"\n        Attempts to connect the two trees by checking nearest vertices from either tree\n        to see if a valid line sequence connects them. If so, path is extracted and True returned.\n        \"\"\"\n        start_roots = self._graph.root_vertex_start\n        goal_roots = self._graph.root_vertex_goal\n\n        start_vertices = self._graph.root_vertices[0].connectivity.keys() if self._graph.root_vertices else []\n        goal_vertices = self._graph.root_vertices[1].connectivity.keys() if len(self._graph.root_vertices) > 1 else []\n\n        # Because we store trees as root_vertices and edges, we iterate over actual vertices in roots:\n        start_all = [start_roots] + list(start_roots.children)\n        goal_all = [goal_roots] + list(goal_roots.children)\n\n        # Check for any connection between start_all and goal_all vertices that can be connected by valid line\n        for v_start in start_all:\n            for v_goal in goal_all:\n                if self._can_connect(v_start, v_goal):\n                    # Connect these two vertices in graph\n                    self._graph.add_edge(v_start, v_goal)\n                    self._graph.add_edge(v_goal, v_start)\n                    # Set cost if needed\n                    dist = self._get_grid().get_distance(v_start.position, v_goal.position)\n                    if v_start.cost is None:\n                        v_start.cost = 0.0\n                    if v_goal.cost is None or v_goal.cost > v_start.cost + dist:\n                        v_goal.cost = v_start.cost + dist\n                    # Mark goal vertex cost if not set\n                    if self._graph.root_vertex_goal.cost is None:\n                        self._graph.root_vertex_goal.cost = float('inf')\n                    # Extract path\n                    self._extract_path()\n                    return True\n        return False\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n\n        # Initialize costs for root vertices\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = 0.0\n\n        for iteration in range(self._iterations):\n\n            # Time limit check for robust failure\n            if time.time() - self._start_time > self._timeout_seconds:\n                # Failed to find path in time\n                break\n\n            # Alternate trees: 0 for start tree, 1 for goal tree\n            tree_index = iteration % 2\n            tree_root = self._graph.root_vertices[tree_index]\n            other_tree_root = self._graph.root_vertices[1 - tree_index]\n\n            # Sample random point with goal biasing\n            q_rand = self._get_random_sample()\n\n            # Nearest vertex in current tree to q_rand\n            q_near = self._graph.get_nearest_vertex([tree_root], q_rand)\n            q_new = self._steer(q_near, q_rand, self._max_dist)\n\n            # Check if path between q_near and q_new is valid\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                self.key_frame()\n                continue\n\n            # Gather near vertices for rewiring within adaptive radius\n            dimension = self._get_grid().size.n_dim\n            gamma_rrt_star = 30.0  # tuning parameter for radius scaling\n            radius = min(self._max_dist, gamma_rrt_star * (np.log(len(self._graph.root_vertices) + 1) / (len(self._graph.root_vertices) + 1))**(1/dimension))\n\n            near_vertices = self._near_vertices([tree_root], q_new.position, radius)\n            if q_near not in near_vertices:\n                near_vertices.append(q_near)  # Ensure q_near in near_vertices\n\n            # Choose best parent and set cost\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                self.key_frame()\n                continue\n\n            q_new.cost = best_parent.cost + self._get_grid().get_movement_cost(best_parent.position, q_new.position)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Add new vertex to the tree root's connectivity - simulate tree structure\n            tree_root.connectivity[q_new] = q_new\n\n            # Rewire nearby vertices for potential cost improvement\n            self._rewire(near_vertices, q_new)\n\n            # Try to connect the newly added vertex to the other tree\n            q_new_near_other_tree = self._graph.get_nearest_vertex([other_tree_root], q_new.position)\n            if self._can_connect(q_new, q_new_near_other_tree):\n                # Add connection edges in both directions\n                self._graph.add_edge(q_new, q_new_near_other_tree)\n                self._graph.add_edge(q_new_near_other_tree, q_new)\n\n                # Check goal reach condition\n                if self._get_grid().is_goal_reached(q_new.position) or self._get_grid().is_goal_reached(q_new_near_other_tree.position):\n                    self._extract_path()\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm": "An improved RRT*-inspired path planning algorithm that incorporates adaptive sampling,\n    informed search radius, path smoothing via shortcutting, and time-based termination to ensure\n    timely results and higher path quality. Starting from a forest graph, it iteratively samples valid points,\n    extends towards them within a max step size, re-wires neighbors to improve cost, and attempts\n    early path extraction once the goal region is reachable. Stops with failure if planning exceeds 60 seconds.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _max_radius: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _start_vertex: Vertex\n    _goal_vertex: Vertex\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._start_vertex = Vertex(self._get_grid().agent.position)\n        self._start_vertex.cost = 0.0\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, self._start_vertex, self._goal_vertex, [])\n        self._max_dist = 12.0  # Max extension length for new vertex\n        self._max_radius = 40.0  # Max neighbor radius for rewiring\n        self._lambda_rrt_star = 40.0  # Constant for adaptive neighborhood radius\n        self._dimension = self._get_grid().size.n_dim\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Adaptive informed sampling: with 70% probability, sample inside an ellipsoidal informed region\n        # around the path between start and goal to improve convergence.\n        if torch.rand(1).item() < 0.7:\n            return self._informed_sample()\n        else:\n            while True:\n                sample_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _informed_sample(self) -> Point:\n        start = self._start_vertex.position.to_tensor()\n        goal = self._goal_vertex.position.to_tensor()\n        c_min = torch.norm(start - goal).item()\n\n        # If start and goal are very close, perform uniform sampling instead\n        if c_min < 1e-5:\n            while True:\n                coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n                sample = Point(*coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Define ellipsoid parameters\n        center = (start + goal) / 2\n        a1 = (goal - start) / c_min  # Unit vector from start to goal\n\n        # Create orthonormal basis with a1 as first axis\n        # For 2D, simply rotate a1 by 90 degree to get a2\n        if self._dimension == 2:\n            a2 = torch.tensor([-a1[1].item(), a1[0].item()])\n            basis = torch.stack([a1, a2], dim=1)  # 2x2 matrix\n        else:\n            # For higher dims, build an orthonormal basis via Gram-Schmidt or identity fallback\n            basis = torch.eye(self._dimension)\n            basis[:, 0] = a1.flatten()\n\n        # Radius lengths for the ellipsoid axes - a conservative inflated ellipse around start-goal line\n        r1 = c_min / 2\n        inflation = 1.5\n        r_others = [inflation * r1 for _ in range(self._dimension - 1)]\n        radii = torch.tensor([r1] + r_others)\n\n        # Sample random point inside unit n-sphere\n        rand_point = torch.randn(self._dimension)\n        rand_point /= torch.norm(rand_point)\n        rand_radius = torch.rand(1).item() ** (1.0 / self._dimension)  # uniform in volume\n        rand_point = rand_point * rand_radius\n\n        # Scale by ellipsoid radii\n        sample_vec = rand_point * radii\n\n        # Map back to global coordinates\n        if self._dimension == 2:\n            sample_coords = basis @ sample_vec + center\n        else:\n            sample_coords = basis @ sample_vec + center\n\n        # Clamp inside map bounds and cast to int for grid point\n        clamped_coords = []\n        for i in range(self._dimension):\n            val = int(sample_coords[i].item())\n            val = max(0, min(val, self._get_grid().size[i] - 1))\n            clamped_coords.append(val)\n\n        sample = Point(*clamped_coords)\n        if not self._get_grid().is_agent_valid_pos(sample):\n            # Retry uniform sampling fallback\n            while True:\n                sample_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    break\n        return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._start_vertex], q_sample)\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._start_vertex], q_new.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Optional[Vertex]:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir_vec)\n        if dir_norm == 0:\n            return None\n\n        if dir_norm <= max_dist:\n            q_new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / dir_norm\n            new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n            new_pos_coords = tuple(int(round(x.item())) for x in new_pos_tensor)\n            q_new_pos = Point(*new_pos_coords)\n\n        if self._get_grid().is_agent_valid_pos(q_new_pos):\n            return Vertex(q_new_pos)\n        return None\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Add goal vertex connected to current q_new\n        goal_v = Vertex(self._goal_vertex.position)\n        dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor()).item()\n        goal_v.cost = q_new.cost + dist_to_goal\n        self._graph.add_edge(q_new, goal_v)\n\n        # Build path by traversing parent links backwards\n        path: List[Vertex] = [goal_v]\n        current = goal_v\n        while current.parents:\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n\n        path.reverse()\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n        # After extraction, attempt to smooth path for better quality\n        self._smooth_path(path)\n\n    def _smooth_path(self, path: List[Vertex]) -> None:\n        # Perform shortcutting path smoothing by attempting to connect\n        # non-adjacent vertices directly if collision free\n        if len(path) < 3:\n            return\n\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_pts = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_pts):\n                    smoothed_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # No shortcut found, move one forward\n                smoothed_path.append(path[i + 1])\n                i += 1\n\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations = 15000\n        tic = time.time()\n\n        for iter_idx in range(max_iterations):\n\n            if (time.time() - tic) > 60.0:\n                # Timeout: treat as fail and exit\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            if q_new is None:\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Calculate adaptive neighborhood radius for rewiring\n            card_v = float(self._graph.size) if self._graph.size > 0 else 1.0\n            log_card_v = math.log(card_v)\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1/self._dimension)), self._max_radius)\n\n            nearby_vertices = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent with minimum cost\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor()).item()\n            for q_near in nearby_vertices:\n                if q_near == q_nearest:\n                    continue\n                line_seq_near_new = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_near_new):\n                    cost_through_near = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n                    if cost_through_near < c_min:\n                        q_min = q_near\n                        c_min = cost_through_near\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if possible\n            for q_near in nearby_vertices:\n                if q_near == q_min:\n                    continue\n                line_seq_new_near = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_new_near):\n                    continue\n                cost_through_new = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n                if cost_through_new < q_near.cost:\n                    # remove current parent edge and add new edge\n                    old_parent = next(iter(q_near.parents), None)\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = None\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Add q_new to the graph's vertices pool (root_vertices)\n            self._graph.root_vertices.append(q_new)\n\n            # Check if q_new is within goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "PathPlanning is a hybrid informed-sampling and rewiring algorithm inspired by RRT* and PRM,\n    leveraging adaptive sampling restricted to an ellipsoidal informed set to improve efficiency\n    and path quality. It dynamically focuses exploration on promising areas near the current best path\n    and continuously improves path smoothness by rewiring and shortcutting candidate paths.\n    The algorithm uses a forest graph structure to maintain a tree rooted at the start, performing\n    rewiring with radius scaling based on free vertices for better robustness.\n    The path search is terminated if it exceeds 60 seconds to ensure responsiveness.\n    Key Improvements:\n    - Informed sampling constrained within an ellipsoidal subset reducing unnecessary samples\n    - Dynamic radius calculation and rewiring improving path optimality\n    - Shortcutting applied on extracted paths for enhanced smoothness\n    - Time-limit enforced to abort long searches gracefully\n    - Uses valid motion and collision checks to guarantee feasible solutions",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _max_iterations: int\n    _max_radius: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _path_found: bool\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_dist = 12.0  # maximum edge length for extension\n        self._max_iterations = 15000  # upper limit on iterations\n        self._max_radius = 40.0  # maximum radius for rewiring neighbors\n        self._lambda_rrt_star = 45.0  # tuning parameter for radius calculation\n        self._dimension = self._get_grid().size.n_dim\n        self._path_found = False\n\n        self._init_displays()\n\n    def _get_random_sample(self, c_best: Optional[float] = None) -> Point:\n        \"\"\"\n        Samples a random valid point within the map.\n        If c_best (current best path cost) is given, samples in an ellipsoidal informed subset\n        between start and goal to focus search.\n        \"\"\"\n        grid = self._get_grid()\n        start = grid.agent.position.to_tensor()\n        goal = grid.goal.position.to_tensor()\n\n        if c_best is None:\n            # Uniform random sampling in entire grid\n            while True:\n                sample_vals = [torch.randint(0, grid.size[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*sample_vals)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Ellipsoidal informed sampling around start-goal line segment\n        c_min = torch.norm(goal - start).item()\n        if c_best < c_min:\n            # no path yet or invalid best cost, fallback uniform\n            return self._get_random_sample()\n\n        center = (start + goal) / 2\n        direction = (goal - start) / c_min\n\n        # Create rotation matrix aligning x-axis with start-goal line\n        # Only works for 2D and 3D (more dims would be more complex)\n        def rotation_matrix_2d(u):\n            # u assumed normalized\n            return torch.tensor([[u[0], -u[1]], [u[1], u[0]]])\n\n        def rotation_matrix_3d(u):\n            # Rodrigues rotation formula to align x-axis with u\n            x_axis = torch.tensor([1., 0., 0.])\n            v = torch.cross(x_axis, u)\n            s = torch.norm(v)\n            c = torch.dot(x_axis, u)\n            if s == 0:\n                return torch.eye(3)\n            vx = torch.tensor([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n            R = torch.eye(3) + vx + torch.mm(vx, vx) * ((1 - c) / s**2)\n            return R\n\n        # Ellipsoid parameters\n        a = c_best / 2\n        b = (torch.sqrt(torch.tensor(c_best ** 2 - c_min ** 2) / 2)).item() if c_best > c_min else 0.0\n        max_x = int(min(self._get_grid().size.width - 1, (center[0] + a).item()))\n        min_x = int(max(0, (center[0] - a).item()))\n        max_y = int(min(self._get_grid().size.height - 1, (center[1] + b).item()))\n        min_y = int(max(0, (center[1] - b).item()))\n        if self._dimension == 2:\n            R = rotation_matrix_2d(direction[:2])\n        else:\n            R = rotation_matrix_3d(direction)\n\n        attempts = 0\n        while True:\n            attempts += 1\n            # Sample point in unit circle/ellipse in local coord (2D slice)\n            sample_local = torch.zeros(self._dimension)\n            if self._dimension == 2:\n                # Sample inside unit circle scaled by ellipse axes\n                angle = 2 * torch.pi * torch.rand(1).item()\n                r = torch.sqrt(torch.rand(1).item())\n                x_local = r * torch.cos(torch.tensor(angle))\n                y_local = r * torch.sin(torch.tensor(angle))\n                sample_local[:2] = torch.tensor([x_local * a, y_local * b])  # ellipsoid scaled\n            else:\n                # 3D ball sample scaled\n                while True:\n                    p = torch.randn(3)\n                    if torch.norm(p) <= 1:\n                        break\n                p = p / torch.norm(p)\n                # scale axes: a, b, b\n                scaling = torch.tensor([a, b, b])\n                sample_local[:] = p * scaling\n\n            # Rotate back to world frame and translate\n            sample_world = torch.mv(R, sample_local) + center\n            sample_coords = tuple(min(max(int(round(val.item())), 0), self._get_grid().size[i] - 1)\n                                  for i, val in enumerate(sample_world))\n\n            sample_point = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n            if attempts > 250:\n                # fallback to uniform if ellipsoidal sampling struggling\n                return self._get_random_sample()\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Optional[Vertex]:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist == 0:\n            return None\n        dir_normalized = dir / dist\n        if dist <= max_dist:\n            q_new_pos = q_sample\n        else:\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n\n        if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new_pos)):\n            return None\n\n        return Vertex(q_new_pos)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Smooth the path by shortcutting: attempt to connect non-adjacent vertices directly.\n        \"\"\"\n        if len(path) < 3:\n            return path\n\n        grid = self._get_grid()\n\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if grid.is_valid_line_sequence(grid.get_line_sequence(path[i].position, path[j].position)):\n                    shortcut_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                shortcut_path.append(path[i + 1])\n                i += 1\n\n        # Remove duplicates if any arise\n        cleaned_path = []\n        last_pos = None\n        for v in shortcut_path:\n            if last_pos is None or v.position != last_pos:\n                cleaned_path.append(v)\n                last_pos = v.position\n\n        return cleaned_path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_pos = self._get_grid().goal.position\n\n        # Create goal vertex connected to q_new\n        goal_vertex = Vertex(goal_pos)\n        dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_vertex.position.to_tensor())\n        goal_vertex.cost = q_new.cost + dist_to_goal.item()\n        self._graph.add_edge(q_new, goal_vertex)\n\n        # Backtrack path from goal to root\n        path = [goal_vertex]\n        curr = goal_vertex\n        while len(curr.parents) > 0:\n            # Any parent since we have tree property\n            parent = next(iter(curr.parents))\n            path.append(parent)\n            curr = parent\n        path.reverse()\n\n        # Smooth path by shortcutting\n        path = self._shortcut_path(path)\n\n        # Move agent along path and keyframe each step\n        for v in path:\n            self.move_agent(v.position)\n            # For ROS integration - optional (not mandatory in base)\n            grid = self._get_grid()\n            if hasattr(grid, 'publish_wp'):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n        self._path_found = True\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        grid = self._get_grid()\n\n        best_cost = float('inf')\n        goal_pos = grid.goal.position\n\n        for iteration in range(self._max_iterations):\n\n            # Time limit check failing the search gracefully\n            if time.time() - start_time > 60.0:\n                # Failed due to timeout\n                return\n\n            # Sample with informed heuristic focused sampling if path exists\n            c_best = best_cost if best_cost < float('inf') else None\n            q_sample = self._get_random_sample(c_best=c_best)\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            if q_new is None:\n                continue\n\n            # Determine adaptive radius for rewiring (RRT* radius)\n            card_v = float(self._graph.size + 1)\n            radius = min(self._lambda_rrt_star * ((torch.log(torch.tensor(card_v)) / card_v) ** (1 / self._dimension)), self._max_radius)\n\n            # Find neighbors for rewiring\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n\n            # Initialize best parent as nearest vertex\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor()).item()\n            best_parent = q_nearest\n\n            # Choose best parent among neighbors (lowest cost and collision free)\n            for neighbor in neighbors:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, q_new.position)):\n                    cost_through_neighbor = neighbor.cost + torch.norm(neighbor.position.to_tensor() - q_new.position.to_tensor()).item()\n                    if cost_through_neighbor < c_min:\n                        best_parent = neighbor\n                        c_min = cost_through_neighbor\n\n            # Set q_new cost and add edge\n            q_new.cost = c_min\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors if the path through q_new is better\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position)):\n                    cost_through_new = q_new.cost + torch.norm(q_new.position.to_tensor() - neighbor.position.to_tensor()).item()\n\n                    if cost_through_new < neighbor.cost:\n                        # Remove old edge\n                        for p in neighbor.parents:\n                            self._graph.remove_edge(p, neighbor)\n                            break\n\n                        # Add new edge and update cost\n                        neighbor.cost = cost_through_new\n                        self._graph.add_edge(q_new, neighbor)\n\n            # Check if q_new is within goal radius\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Update best cost\n                dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_pos.to_tensor()).item()\n                path_cost = q_new.cost + dist_to_goal\n                if path_cost < best_cost:\n                    best_cost = path_cost\n                    self._extract_path(q_new)\n\n            self.key_frame()\n\n            if self._path_found:\n                break",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m3",
     "algorithm": "An improved sample-based path planning algorithm inspired by RRT* with these enhancements:\n     - Adaptive informed sampling focused around start-goal to increase sampling efficiency.\n     - Dynamic neighborhood radius based on graph size and dimension for optimal rewiring and connectivity.\n     - Goal biasing to speed early convergence.\n     - Efficient rewiring to improve path cost and quality.\n     - Path smoothing via shortcutting after path extraction.\n     - Timeout handling to fail gracefully after 60 seconds.\n     The algorithm maintains a forest graph rooted at start and attempts incremental tree expansions towards valid samples,\n     rewiring neighbor connections for better paths, and extracts a smooth, cost-efficient path once the goal region is reached.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _max_radius: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _start_vertex: Vertex\n    _goal_vertex: Vertex\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._start_vertex = Vertex(self._get_grid().agent.position)\n        self._start_vertex.cost = 0.0\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, self._start_vertex, self._goal_vertex, [])\n        self._max_dist = 12.0  # max extension length\n        self._max_radius = 40.0  # max neighbor radius\n        self._lambda_rrt_star = 40.0  # RRT* constant for adaptive radius\n        self._dimension = self._get_grid().size.n_dim\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Goal biasing with 10% probability\n        if torch.rand(1).item() < 0.1:\n            return self._goal_vertex.position\n\n        # 75% informed sampling, else uniform random\n        if torch.rand(1).item() < 0.75:\n            return self._informed_sample()\n        else:\n            return self._uniform_valid_sample()\n\n    def _uniform_valid_sample(self) -> Point:\n        while True:\n            coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _informed_sample(self) -> Point:\n        start = self._start_vertex.position.to_tensor()\n        goal = self._goal_vertex.position.to_tensor()\n        c_min = torch.norm(start - goal).item()\n        if c_min < 1e-5:\n            return self._uniform_valid_sample()\n\n        center = (start + goal) / 2\n        a1 = (goal - start) / c_min\n\n        if self._dimension == 2:\n            a2 = torch.tensor([-a1[1].item(), a1[0].item()])\n            basis = torch.stack([a1, a2], dim=1)  # 2x2 matrix\n        else:\n            basis = torch.eye(self._dimension)\n            basis[:, 0] = a1.flatten()\n\n        r1 = c_min / 2\n        inflation = 1.5\n        radii = torch.tensor([r1] + [inflation * r1] * (self._dimension - 1))\n\n        rand_point = torch.randn(self._dimension)\n        rand_point /= torch.norm(rand_point)\n        rand_radius = torch.rand(1).item() ** (1.0 / self._dimension)\n        rand_point = rand_point * rand_radius\n\n        sample_vec = rand_point * radii\n\n        sample_coords = basis @ sample_vec + center\n\n        clamped_coords = []\n        for i in range(self._dimension):\n            val = int(round(sample_coords[i].item()))\n            val = max(0, min(val, self._get_grid().size[i] - 1))\n            clamped_coords.append(val)\n\n        sample = Point(*clamped_coords)\n        if not self._get_grid().is_agent_valid_pos(sample):\n            return self._uniform_valid_sample()\n        return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        # Search among all existing vertices\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex | None:\n        diff = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(diff).item()\n        if dist == 0:\n            return None\n        if dist <= max_dist:\n            candidate_pos = q_sample\n        else:\n            dir_norm = diff / dist\n            new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_norm\n            coords = tuple(int(round(x.item())) for x in new_pos_tensor)\n            candidate_pos = Point(*coords)\n\n        if self._get_grid().is_agent_valid_pos(candidate_pos):\n            return Vertex(candidate_pos)\n        return None\n\n    def _extract_path(self, q_goal_vertex: Vertex) -> None:\n        path: List[Vertex] = [q_goal_vertex]\n        current = q_goal_vertex\n        while current.parents:\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n        self._smooth_path(path)\n\n    def _smooth_path(self, path: List[Vertex]) -> None:\n        if len(path) < 3:\n            return\n\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_points = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_points):\n                    smoothed_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                smoothed_path.append(path[i + 1])\n                i += 1\n\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import math\n\n        start_time = time.time()\n        max_iters = 15000\n\n        for _ in range(max_iters):\n            if (time.time() - start_time) > 60.0:\n                # Fail gracefully after 60 sec timeout\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            if q_new is None:\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cardinality = float(self._graph.size) if self._graph.size > 0 else 1.0\n            log_card = math.log(cardinality)\n            radius = min(\n                self._lambda_rrt_star * ((log_card / cardinality) ** (1.0 / self._dimension)),\n                self._max_radius,\n            )\n\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent minimizing cost\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor()).item()\n            for q_near in neighbors:\n                if q_near == q_nearest:\n                    continue\n                line_seq_near = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_near):\n                    cost = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n                    if cost < c_min:\n                        q_min = q_near\n                        c_min = cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to potentially better paths through q_new\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_back = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_back):\n                    continue\n                new_cost = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n                if q_near.cost is None or new_cost < q_near.cost:\n                    old_parent = next(iter(q_near.parents), None)\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n            self._graph.root_vertices.append(q_new)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm": "This algorithm is an enhanced bidirectional RRT* variant with adaptive step sizing,\n    dynamic rewiring radius scaling, and hybrid goal biasing for improved planning efficiency\n    and path quality. It grows two trees simultaneously from start and goal with alternating\n    expansions, utilizes a refined sampling strategy combining uniform and informed sampling\n    based on current best path cost, and performs rewiring to optimize connectivity and costs.\n    The algorithm dynamically adjusts exploration versus exploitation by gradually increasing\n    goal bias, employs shortcut smoothing post-processing for path smoothness, and includes\n    robust time-limited execution (60 seconds) to guarantee termination.\n\n    Key improvements include:\n    - Adaptive radius for rewiring considering vertex density and dimension\n    - Heuristic informed sampling around best-known path ball to accelerate convergence\n    - Gradual increase in goal bias probability to focus search as iterations grow\n    - Enhanced connectivity checks and cost updates for robustness\n    - Shortcut path smoothing after extraction for shorter, smoother solutions\n    - Early termination when goal is reached or time limit exceeded\n\n    Overall, it aims to improve success rate, reduce planning time, and generate high-quality,\n    smooth, and shorter paths than typical RRT* bidirectional planners.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    import time\n    import numpy as np\n    import torch\n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _timeout_seconds: float\n    _start_time: float\n    _goal_bias_min: float = 0.05\n    _goal_bias_max: float = 0.3\n    _goal_bias_inc_duration: int = 12000\n    _rewire_gamma: float = 40.0  # tuned for efficient radius scaling\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._iterations = 20000\n        self._max_dist = 14.0\n        self._timeout_seconds = 60.0\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            [],\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_goal_bias(self, iteration: int) -> float:\n        # Gradually increase goal bias with iterations up to max\n        if iteration < self._goal_bias_inc_duration:\n            return self._goal_bias_min + (self._goal_bias_max - self._goal_bias_min) * (iteration / self._goal_bias_inc_duration)\n        return self._goal_bias_max\n\n    def _get_random_sample(self, iteration: int) -> Point:\n        \"\"\"\n        Samples a random valid point within the map with adaptive goal bias.\n        Incorporates uniform and heuristic informed sampling based on path progress.\n        \"\"\"\n        grid = self._get_grid()\n        goal_pos = self._graph.root_vertex_goal.position\n        goal_bias = self._get_goal_bias(iteration)\n\n        if np.random.rand() < goal_bias:\n            return goal_pos\n\n        # If a path to goal is known, bias sampling around start-goal corridor (informed sampling)\n        if self._graph.root_vertex_goal.cost is not None and self._graph.root_vertex_goal.cost < float('inf'):\n            start_pos = self._graph.root_vertex_start.position\n            max_dist = self._graph.root_vertex_goal.cost\n            dim = grid.size.n_dim\n\n            # Sample a point inside an ellipsoid defined by start/goal and max_dist (in 2D circle approx)\n            center = (start_pos.to_tensor() + goal_pos.to_tensor()) / 2\n            a = max_dist / 2  # ellipse major axis approx\n            b = max_dist / 3  # ellipse minor axis approx\n\n            # Sample random point inside ellipse scaled to grid size\n            angle = np.random.uniform(0, 2 * np.pi)\n            r = np.random.uniform(0, 1)\n            r_sqrt = np.sqrt(r)\n            x_ellipse = r_sqrt * a * np.cos(angle)\n            y_ellipse = r_sqrt * b * np.sin(angle)\n\n            # In 2D only - fallback to uniform sample if dimension > 2\n            if dim == 2:\n                sample_tensor = center.clone()\n                sample_tensor[0] += x_ellipse\n                sample_tensor[1] += y_ellipse\n                sample_point = Point(*[int(round(c)) for c in sample_tensor.tolist()])\n                if grid.is_agent_valid_pos(sample_point):\n                    return sample_point\n\n        # Fallback uniform random valid position sampling\n        sz = grid.size\n        while True:\n            rand_coords = [np.random.randint(0, sz[i]) for i in range(sz.n_dim)]\n            sample = Point(*rand_coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        from_pos = from_vertex.position.to_tensor()\n        to_pos = to_point.to_tensor()\n        dir_vec = to_pos - from_pos\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(to_point, store_connectivity=True)\n        dir_unit = dir_vec / dist\n        new_pos_tensor = from_pos + dir_unit * max_dist\n        new_point = Point(*[int(round(c)) for c in new_pos_tensor.tolist()])\n        return Vertex(new_point, store_connectivity=True)\n\n    def _near_vertices(self, vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(vertices, point, radius)\n\n    def _choose_parent(self, near_vertices: List[Vertex], new_vertex: Vertex) -> Vertex:\n        best_parent = None\n        best_cost = float('inf')\n        grid = self._get_grid()\n\n        for vertex in near_vertices:\n            if vertex.position == new_vertex.position:\n                continue\n            line_seq = grid.get_line_sequence(vertex.position, new_vertex.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            if vertex.cost is None:\n                continue\n            cost_through_vertex = vertex.cost + grid.get_movement_cost(vertex.position, new_vertex.position)\n            if cost_through_vertex < best_cost:\n                best_cost = cost_through_vertex\n                best_parent = vertex\n\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], new_vertex: Vertex) -> None:\n        grid = self._get_grid()\n        for vertex in near_vertices:\n            if vertex is new_vertex or vertex.cost is None or new_vertex.cost is None:\n                continue\n            line_seq = grid.get_line_sequence(new_vertex.position, vertex.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            new_cost = new_vertex.cost + grid.get_movement_cost(new_vertex.position, vertex.position)\n            if new_cost < vertex.cost:\n                for p in list(vertex.parents):\n                    self._graph.remove_edge(p, vertex)\n                self._graph.add_edge(new_vertex, vertex)\n                vertex.cost = new_cost\n                # Ensure connectivity dictionaries exist\n                if new_vertex.connectivity is None:\n                    new_vertex.connectivity = {}\n                if vertex.connectivity is None:\n                    vertex.connectivity = {}\n                target = self._graph.root_vertex_goal\n                if target not in new_vertex.connectivity:\n                    new_vertex.connectivity[target] = new_vertex\n                vertex.connectivity[target] = new_vertex.connectivity[target]\n\n    def _can_connect(self, from_vertex: Vertex, to_vertex: Vertex) -> bool:\n        line_seq = self._get_grid().get_line_sequence(from_vertex.position, to_vertex.position)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _extract_path(self) -> None:\n        goal_vertex = self._graph.root_vertex_goal\n        if goal_vertex.cost is None or goal_vertex.cost == float('inf'):\n            return\n        path = []\n        current = goal_vertex\n        while current.parents:\n            path.append(current)\n            current = min(current.parents, key=lambda v: v.cost if v.cost is not None else float('inf'))\n        path.append(current)  # Append start\n        path.reverse()\n\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        shortened_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            while next_idx > idx + 1:\n                if self._can_connect(path[idx], path[next_idx]):\n                    break\n                next_idx -= 1\n            shortened_path.append(path[next_idx])\n            idx = next_idx\n        return shortened_path\n\n    def _try_connect_trees(self, start_vertices: List[Vertex], goal_vertices: List[Vertex]) -> bool:\n        grid = self._get_grid()\n        best_pair = None\n        best_cost = float('inf')\n        for v_start in start_vertices:\n            for v_goal in goal_vertices:\n                if v_start.cost is None or v_goal.cost is None:\n                    continue\n                if not self._can_connect(v_start, v_goal):\n                    continue\n                dist = grid.get_distance(v_start.position, v_goal.position)\n                total_cost = v_start.cost + dist + v_goal.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pair = (v_start, v_goal)\n\n        if best_pair is None:\n            return False\n\n        v_start, v_goal = best_pair\n        self._graph.add_edge(v_start, v_goal)\n        self._graph.add_edge(v_goal, v_start)\n\n        if v_start.cost is None:\n            v_start.cost = 0.0\n        if v_goal.cost is None or v_goal.cost > v_start.cost + grid.get_distance(v_start.position, v_goal.position):\n            v_goal.cost = v_start.cost + grid.get_distance(v_start.position, v_goal.position)\n        if self._graph.root_vertex_goal.cost is None:\n            self._graph.root_vertex_goal.cost = float('inf')\n\n        self._extract_path()\n        return True\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        self._start_time = time.time()\n\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')\n\n        start_vertices = [self._graph.root_vertex_start]\n        goal_vertices = [self._graph.root_vertex_goal]\n        grid = self._get_grid()\n        dimension = grid.size.n_dim\n\n        for iteration in range(self._iterations):\n            if time.time() - self._start_time > self._timeout_seconds:\n                # Failed: Timeout exceeded 60s\n                break\n\n            tree_index = iteration % 2\n            tree_root = self._graph.root_vertices[tree_index]\n            other_tree_root = self._graph.root_vertices[1 - tree_index]\n\n            # Sample with adaptive goal bias and informed sampling\n            q_rand = self._get_random_sample(iteration)\n\n            # Nearest vertex in current tree to q_rand\n            current_tree_vertices = start_vertices if tree_index == 0 else goal_vertices\n            q_near = self._graph.get_nearest_vertex([tree_root], q_rand)\n            q_new = self._steer(q_near, q_rand, self._max_dist)\n\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                self.key_frame()\n                continue\n\n            n_vertices = len(current_tree_vertices)\n            if n_vertices == 0:\n                radius = self._max_dist\n            else:\n                radius = min(self._max_dist,\n                             self._rewire_gamma * (np.log(n_vertices + 1) / (n_vertices + 1))**(1 / dimension))\n\n            near_vertices = self._near_vertices([tree_root], q_new.position, radius)\n            if q_near not in near_vertices:\n                near_vertices.append(q_near)\n\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                self.key_frame()\n                continue\n\n            q_new.cost = best_parent.cost + grid.get_movement_cost(best_parent.position, q_new.position)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Initialize connectivity dicts if missing\n            if tree_root.connectivity is None:\n                tree_root.connectivity = {}\n            if q_new.connectivity is None:\n                q_new.connectivity = {}\n\n            # Ensure root vertex connectivity entries\n            if tree_root not in tree_root.connectivity:\n                tree_root.connectivity[tree_root] = tree_root\n            if self._graph.root_vertex_goal not in self._graph.root_vertex_goal.connectivity:\n                self._graph.root_vertex_goal.connectivity[self._graph.root_vertex_goal] = self._graph.root_vertex_goal\n\n            # Add new vertex to tree and connectivity\n            tree_root.connectivity[q_new] = q_new\n            if tree_index == 0:\n                start_vertices.append(q_new)\n            else:\n                goal_vertices.append(q_new)\n\n            self._rewire(near_vertices, q_new)\n\n            # Attempt fast connect trees at new node\n            q_new_near_other_tree = self._graph.get_nearest_vertex([other_tree_root], q_new.position)\n            if self._can_connect(q_new, q_new_near_other_tree):\n                self._graph.add_edge(q_new, q_new_near_other_tree)\n                self._graph.add_edge(q_new_near_other_tree, q_new)\n                # Check for goal precision\n                if (grid.is_goal_reached(q_new.position) or grid.is_goal_reached(q_new_near_other_tree.position)):\n                    self._extract_path()\n                    return\n\n            # Attempt global connect between trees every 200 iterations for robustness\n            if iteration % 200 == 0:\n                if self._try_connect_trees(start_vertices, goal_vertices):\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm": "An improved hybrid bidirectional path planning algorithm combining the strengths of RRT-Connect and RRT*.\n    This algorithm utilizes two cyclic graphs growing from start and goal with goal biasing and adaptive sampling.\n    It alternates tree extensions and employs rewiring in both trees to improve path quality progressively.\n    It includes informed sampling within an ellipsoidal heuristic region after an initial solution is found,\n    focusing exploration on promising areas. The algorithm short-circuits when a path is found or after 60 seconds.\n    Post-processing with shortcut smoothing reduces waypoints for smoother, shorter paths.\n    This approach optimizes planning efficiency, path length, smoothness, and success rate, while bounding search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph_start: CyclicGraph\n    _graph_goal: CyclicGraph\n    _max_dist: float = 15.0\n    _iterations: int = 15000\n    _goal_sample_rate: float = 0.2\n    _rewire_radius_factor: float = 30.0  # Tuned for better rewiring in larger maps\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_v = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_v = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph_start = gen_cyclic_graph(self._services, start_v, Vertex(Point(0, 0)), [])\n        self._graph_goal = gen_cyclic_graph(self._services, goal_v, Vertex(Point(0, 0)), [])\n        self._graph_start.edges_removable = True\n        self._graph_goal.edges_removable = True\n        self._init_displays()\n\n        # Initialize cost roots\n        self._graph_start.root_vertex_start.cost = 0.0\n        self._graph_goal.root_vertex_start.cost = 0.0\n\n        # Track best path cost & vertices for heuristic sampling\n        self._best_path_cost = float('inf')\n        self._best_connection = None\n\n    def _get_random_sample(self, iteration: int) -> Point:\n        \"\"\"\n        Sample points with goal biasing and, once a path found, informed sampling inside ellipsoidal heuristic.\n        \"\"\"\n        grid = self._get_grid()\n        # If best path known, sample inside ellipsoid defined by start-goal and best cost\n        if self._best_path_cost < float('inf') and iteration > self._iterations // 10:\n            # Ellipsoidal informed sampling\n            start = self._graph_start.root_vertex_start.position.to_tensor()\n            goal = self._graph_goal.root_vertex_start.position.to_tensor()\n            c_best = self._best_path_cost\n            c_min = torch.norm(goal - start).item()\n            if c_best < float('inf') and c_min > 0 and c_best > c_min:\n                # Sample in unit ball and transform to ellipsoid\n                while True:\n                    sample_unit = torch.randn(start.shape)\n                    if torch.norm(sample_unit) <= 1.0:\n                        break\n                # Scale factor along x is c_best / 2; along y sqrt(c_best^2 - c_min^2)/2; rotation aligns x axis start->goal\n                center = (start + goal) / 2\n                a1 = (goal - start) / c_min\n                # Build rotation matrix (2D or 3D)\n                dim = start.shape[0]\n                if dim == 2:\n                    # Rotation matrix from basis vector a1 to x-axis unit vector\n                    cos_theta = a1[0].item()\n                    sin_theta = a1[1].item()\n                    R = torch.tensor([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n                elif dim == 3:\n                    # 3D rotation: build orthonormal basis with a1 as x-axis\n                    x_axis = a1 / torch.norm(a1)\n                    # Arbitrary orthogonal vectors using cross product\n                    if abs(x_axis[0]) < 1e-3 and abs(x_axis[1]) < 1e-3:\n                        temp = torch.tensor([0.0, 1.0, 0.0])\n                    else:\n                        temp = torch.tensor([0.0, 0.0, 1.0])\n                    y_axis = torch.cross(temp, x_axis)\n                    y_axis /= torch.norm(y_axis)\n                    z_axis = torch.cross(x_axis, y_axis)\n                    R = torch.stack([x_axis, y_axis, z_axis]).T  # Columns are basis vectors\n                else:\n                    # Fallback: no rotation\n                    R = torch.eye(dim)\n\n                L = torch.diag(torch.tensor([\n                    c_best / 2,\n                    (c_best ** 2 - c_min ** 2) ** 0.5 / 2] + [1.0] * (dim - 2)))\n\n                sample_ellipse = R @ (L @ sample_unit) + center\n                sample_np = sample_ellipse.numpy()\n                sample_pt = Point(*map(float, sample_np))\n                if grid.is_agent_valid_pos(sample_pt):\n                    return sample_pt\n\n        # Otherwise, goal biasing with uniform random sample\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist=None) -> Vertex:\n        if max_dist is None:\n            max_dist = self._max_dist\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        dir_norm = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_norm\n        q_new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(q_new_pos, store_connectivity=True)\n\n    def _nearest_vertex(self, graph: CyclicGraph, vertices: List[Vertex], point: Point) -> Vertex:\n        return graph.get_nearest_vertex(vertices, point)\n\n    def _get_neighborhood(self, graph: CyclicGraph, vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        return graph.get_vertices_within_radius(vertices, point, radius)\n\n    def _line_is_free(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _update_cost(self, q_new: Vertex, q_near: Vertex) -> None:\n        if q_near.cost is None:\n            q_new.cost = self._get_grid().get_distance(q_near.position, q_new.position)\n        else:\n            q_new.cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n\n    def _rewire(self, graph: CyclicGraph, q_new: Vertex, neighborhood: List[Vertex]) -> None:\n        for q_near in neighborhood:\n            if q_near == q_new:\n                continue\n            if not self._line_is_free(q_new.position, q_near.position):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, q_near.position)\n            if q_near.cost is None or new_cost < q_near.cost:\n                for p in set(q_near.parents):\n                    graph.remove_edge(p, q_near)\n                graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _try_connect_trees(self, graph_a: CyclicGraph, q_new: Vertex, vertices_b: List[Vertex]) -> tuple | None:\n        q_near_b = self._nearest_vertex(graph_a, vertices_b, q_new.position)\n        if q_near_b.position == q_new.position:\n            return None\n        if not self._line_is_free(q_new.position, q_near_b.position):\n            return None\n        return q_new, q_near_b\n\n    def _extract_path(self, connection_vertex_start: Vertex, connection_vertex_goal: Vertex) -> None:\n        # Trace path root to connection start\n        path_start = [connection_vertex_start]\n        while path_start[-1].parents:\n            for p in path_start[-1].parents:\n                path_start.append(p)\n                break\n        path_start.reverse()\n\n        # Trace path connection goal to root\n        path_goal = [connection_vertex_goal]\n        while path_goal[-1].children:\n            for c in path_goal[-1].children:\n                path_goal.append(c)\n                break\n\n        full_path = path_start + path_goal\n\n        full_path = self._shortcut_path(full_path)\n\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list[Vertex]) -> list[Vertex]:\n        if len(path) < 3:\n            return path\n        shortened_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            while next_idx > idx + 1:\n                if self._line_is_free(path[idx].position, path[next_idx].position):\n                    break\n                next_idx -= 1\n            shortened_path.append(path[next_idx])\n            idx = next_idx\n        return shortened_path\n\n    def _find_path_internal(self) -> None:\n        start_time = time.perf_counter()\n\n        start_vertices = [self._graph_start.root_vertex_start]\n        goal_vertices = [self._graph_goal.root_vertex_start]\n\n        self._graph_start.root_vertex_start.cost = 0.0\n        self._graph_goal.root_vertex_start.cost = 0.0\n\n        for i in range(self._iterations):\n            # Time limit check\n            if time.perf_counter() - start_time > 60.0:\n                break\n\n            # Sample point with adaptive informed sampling & goal bias\n            q_sample = self._get_random_sample(i)\n\n            # Alternate expansion direction: even iterations start tree, odd goal tree\n            if i % 2 == 0:\n                tree_a_vertices = start_vertices\n                tree_b_vertices = goal_vertices\n                graph_a = self._graph_start\n                graph_b = self._graph_goal\n            else:\n                tree_a_vertices = goal_vertices\n                tree_b_vertices = start_vertices\n                graph_a = self._graph_goal\n                graph_b = self._graph_start\n\n            # Extend tree A towards sample point\n            q_near_a = self._nearest_vertex(graph_a, tree_a_vertices, q_sample)\n            q_new_a = self._get_new_vertex(q_near_a, q_sample)\n            if not self._line_is_free(q_near_a.position, q_new_a.position):\n                self.key_frame()\n                continue\n            self._update_cost(q_new_a, q_near_a)\n            graph_a.add_edge(q_near_a, q_new_a)\n            tree_a_vertices.append(q_new_a)\n\n            # Rewire nearby vertices for better paths\n            size = len(tree_a_vertices)\n            radius = min(self._rewire_radius_factor * np.sqrt(np.log(size + 1) / (size + 1)), self._max_dist * 2)\n            neighborhood = self._get_neighborhood(graph_a, tree_a_vertices, q_new_a.position, radius)\n            self._rewire(graph_a, q_new_a, neighborhood)\n\n            # Attempt connection to other tree\n            conn = self._try_connect_trees(graph_a, q_new_a, tree_b_vertices)\n            if conn is not None:\n                graph_b.add_edge(conn[1], conn[0])  # Connect other tree node to q_new_a\n                # Compute path cost candidates and update best path if improved\n                path_cost_candidate = q_new_a.cost + conn[1].cost + self._get_grid().get_distance(q_new_a.position, conn[1].position)\n                if path_cost_candidate < self._best_path_cost:\n                    self._best_path_cost = path_cost_candidate\n                    self._best_connection = (conn[0], conn[1])\n\n                # Extract best path and finish\n                if i > 100:  # Allow some iterations before early termination for path quality\n                    if graph_a == self._graph_start:\n                        self._extract_path(conn[0], conn[1])\n                    else:\n                        self._extract_path(conn[1], conn[0])\n                    return\n\n            # Extend tree B towards q_new_a.position, tries to connect more aggressively\n            q_near_b = self._nearest_vertex(graph_b, tree_b_vertices, q_new_a.position)\n            q_new_b = self._get_new_vertex(q_near_b, q_new_a.position)\n            if self._line_is_free(q_near_b.position, q_new_b.position):\n                self._update_cost(q_new_b, q_near_b)\n                graph_b.add_edge(q_near_b, q_new_b)\n                tree_b_vertices.append(q_new_b)\n\n                # Rewire tree B neighbors\n                size_b = len(tree_b_vertices)\n                radius_b = min(self._rewire_radius_factor * np.sqrt(np.log(size_b + 1) / (size_b + 1)), self._max_dist * 2)\n                neighborhood_b = self._get_neighborhood(graph_b, tree_b_vertices, q_new_b.position, radius_b)\n                self._rewire(graph_b, q_new_b, neighborhood_b)\n\n                # Check connection between new vertex and tree A\n                conn2 = self._try_connect_trees(graph_b, q_new_b, tree_a_vertices)\n                if conn2 is not None:\n                    graph_a.add_edge(conn2[1], conn2[0])\n                    path_cost_2 = q_new_b.cost + conn2[1].cost + self._get_grid().get_distance(q_new_b.position, conn2[1].position)\n                    if path_cost_2 < self._best_path_cost:\n                        self._best_path_cost = path_cost_2\n                        self._best_connection = (conn2[0], conn2[1])\n                    if i > 100:\n                        if graph_a == self._graph_start:\n                            self._extract_path(conn2[0], conn2[1])\n                        else:\n                            self._extract_path(conn2[1], conn2[0])\n                        return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e2",
     "algorithm": "Hybrid Bidirectional RRT*-Informed Algorithm with Adaptive Radius, Dynamic Step Size,\n    and Heuristic Heavily Biased Sampling Combined with Path Smoothing.\n\n    This algorithm grows two trees from start and goal positions simultaneously. It uses an\n    adaptive sampling strategy inspired by informed sampling: samples are drawn either near\n    the current best path ellipse (informed subset) or randomly when no valid path exists yet,\n    to focus exploration on promising regions while maintaining global coverage.\n\n    Adaptive step size and radius computed dynamically according to the map size and iteration\n    count improve search efficiency and connectivity. Trees are rewired upon new vertex insertion\n    to reduce costs, and attempts to connect two trees frequently shorten the planning time.\n\n    Once a path is found, a post-processing smoothing step improves path quality and smoothness.\n\n    The whole planning is time-limited to 60 seconds to ensure robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_base: float\n    _iterations: int\n    _start_time: float\n    _timeout_seconds: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        # Adjusted max dist base as fraction of map diagonal later dynamically\n        self._iterations = 25000\n        self._timeout_seconds = 60.0\n        grid = self._get_grid()\n\n        start_vertex = Vertex(grid.agent.position, store_connectivity=True)\n        goal_vertex = Vertex(grid.goal.position, store_connectivity=True)\n        goal_vertex.cost = float('inf')\n        start_vertex.cost = 0.0\n        self._graph = gen_forest(services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._max_dist_base = None  # Will be set at runtime based on map diagonal\n\n        self._init_displays()\n\n    def _map_diagonal(self) -> float:\n        sz = self._get_grid().size\n        return (sum((v ** 2 for v in sz.values))) ** 0.5\n\n    def _informed_sample(self, c_best: float, start: Point, goal: Point) -> Point:\n        \"\"\"\n        Informed sampling inside an ellipsoid defined by current best cost.\n        If no path found (c_best=inf), fallback to uniform random sampling.\n        \"\"\"\n        grid = self._get_grid()\n        dim = grid.size.n_dim\n\n        if c_best == float('inf'):\n            # Uniform random in grid with validity check\n            while True:\n                coords = [np.random.randint(0, grid.size[i]) for i in range(dim)]\n                p = Point(*coords)\n                if grid.is_agent_valid_pos(p):\n                    return p\n\n        # Ellipsoid sampling\n        c_min = grid.get_distance(start, goal)\n        if c_best < c_min:\n            c_best = c_min * 1.0001  # avoid division by zero / degenerate\n\n        center_tensor = (start.to_tensor() + goal.to_tensor()) / 2\n        dir_line = (goal.to_tensor() - start.to_tensor())\n        e1 = dir_line / torch.norm(dir_line)\n\n        # Generate orthonormal basis U (dim x dim)\n        U = torch.eye(dim)\n        U[:, 0] = e1\n\n        # Lengths of ellipse axes\n        r1 = c_best / 2\n        other_r = (c_best ** 2 - c_min ** 2) ** 0.5 / 2 if c_best > c_min else 0.0\n\n        while True:\n            # Sample in unit n-ball\n            x_ball = torch.randn(dim)\n            x_ball /= torch.norm(x_ball)\n            radius = torch.pow(torch.rand(1), 1.0 / dim)\n            sample_ball = x_ball * radius\n\n            # Scale to ellipsoid\n            sample_scaled = sample_ball * torch.tensor([r1] + [other_r] * (dim - 1))\n\n            # Map to world coords\n            sample_point = center_tensor + U @ sample_scaled\n            sample_coords = tuple(int(max(0, min(self._get_grid().size[i]-1, sample_point[i].item()))) for i in range(dim))\n            point = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(point):\n                return point\n\n    def _steer(self, frm: Vertex, to: Point, max_dist: float) -> Vertex:\n        from_pos = frm.position.to_tensor()\n        to_pos = to.to_tensor()\n        direction = to_pos - from_pos\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            return Vertex(to, store_connectivity=True)\n        direction_unit = direction / dist\n        new_pos_tensor = from_pos + direction_unit * max_dist\n        new_point = Point(*[max(0, min(self._get_grid().size[i]-1, float(new_pos_tensor[i]))) for i in range(self._get_grid().size.n_dim)])\n        return Vertex(new_point, store_connectivity=True)\n\n    def _choose_parent(self, near_vertices, new_vertex) -> Vertex or None:\n        best_parent = None\n        best_cost = float('inf')\n        grid = self._get_grid()\n        for v in near_vertices:\n            if v.position == new_vertex.position:\n                continue\n            line_seq = grid.get_line_sequence(v.position, new_vertex.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            if v.cost is None:\n                continue\n            cost = v.cost + grid.get_movement_cost(v.position, new_vertex.position)\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = v\n        return best_parent\n\n    def _rewire(self, near_vertices, new_vertex):\n        grid = self._get_grid()\n        for v in near_vertices:\n            if v == new_vertex or v.cost is None or new_vertex.cost is None:\n                continue\n            line_seq = grid.get_line_sequence(new_vertex.position, v.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            new_cost = new_vertex.cost + grid.get_movement_cost(new_vertex.position, v.position)\n            if new_cost < v.cost:\n                # Remove old parent edges\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(new_vertex, v)\n                v.cost = new_cost\n                # Update connectivity for goal target to avoid key errors\n                target = self._graph.root_vertex_goal\n                if new_vertex.connectivity is None:\n                    new_vertex.connectivity = {}\n                if target not in new_vertex.connectivity:\n                    new_vertex.connectivity[target] = new_vertex\n                if v.connectivity is None:\n                    v.connectivity = {}\n                v.connectivity[target] = new_vertex.connectivity[target]\n\n    def _can_connect(self, from_vertex: Vertex, to_vertex: Vertex) -> bool:\n        line_seq = self._get_grid().get_line_sequence(from_vertex.position, to_vertex.position)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _extract_path(self) -> None:\n        \"\"\"\n        Trace back path from goal to start choosing parents with lowest cost.\n        Then move the agent along the found path with key frames.\n        Additionally run smoothing of path after extraction.\n        \"\"\"\n        goal_v = self._graph.root_vertex_goal\n        if goal_v.cost is None or goal_v.cost == float('inf'):\n            return  # no path found\n\n        # Reconstruct via cheapest parents path\n        path = []\n        current = goal_v\n        while current.parents:\n            path.append(current)\n            # Choose parent with least cost\n            current = min(current.parents, key=lambda v: v.cost if v.cost is not None else float('inf'))\n        path.append(current)  # start\n        path.reverse()\n\n        # Apply simple smoothing post-processing to path\n        smoothed_path = self._smooth_path(path)\n\n        # Move agent along smoothed path with key frames\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _smooth_path(self, path: list) -> list:\n        \"\"\"\n        Path smoothing by shortcutting: Try to connect non-adjacent vertices directly if no obstacles.\n        \"\"\"\n        if len(path) <= 2:\n            return path\n\n        grid = self._get_grid()\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            # Look for farthest vertex reachable from i without obstacles\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _try_connect_trees(self) -> bool:\n        \"\"\"\n        Try to connect any vertices from start tree with any vertices from goal tree.\n        If connected, update costs and extract path.\n        \"\"\"\n        start_root = self._graph.root_vertex_start\n        goal_root = self._graph.root_vertex_goal\n\n        # Gather full lists of vertices in both trees by BFS to improve performance\n        def gather_all_vertices(root):\n            visited = set()\n            queue = [root]\n            vertices = []\n            while queue:\n                v = queue.pop()\n                if v in visited:\n                    continue\n                visited.add(v)\n                vertices.append(v)\n                queue.extend(v.children)\n            return vertices\n\n        start_vertices = gather_all_vertices(start_root)\n        goal_vertices = gather_all_vertices(goal_root)\n\n        grid = self._get_grid()\n        for v_start in start_vertices:\n            if v_start.cost is None:\n                continue\n            for v_goal in goal_vertices:\n                if v_goal.cost is None:\n                    continue\n                if self._can_connect(v_start, v_goal):\n                    self._graph.add_edge(v_start, v_goal)\n                    self._graph.add_edge(v_goal, v_start)\n\n                    dist = grid.get_distance(v_start.position, v_goal.position)\n                    prev_cost_goal = v_goal.cost or float('inf')\n                    new_cost_goal = v_start.cost + dist\n                    if new_cost_goal < prev_cost_goal:\n                        v_goal.cost = new_cost_goal\n                        if self._graph.root_vertex_goal.cost is None or self._graph.root_vertex_goal.cost > new_cost_goal:\n                            self._graph.root_vertex_goal.cost = new_cost_goal\n\n                    self._extract_path()\n                    return True\n        return False\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        self._start_time = time.time()\n        grid = self._get_grid()\n        dim = grid.size.n_dim\n\n        # Precompute map diagonal and set max dist base as ~5% of diagonal capped\n        diag = self._map_diagonal()\n        self._max_dist_base = max(3.0, min(25.0, 0.05 * diag))\n\n        start_root = self._graph.root_vertex_start\n        goal_root = self._graph.root_vertex_goal\n\n        # Initialize vertex collections for radius computations\n        start_vertices = [start_root]\n        goal_vertices = [goal_root]\n\n        c_best = float('inf')  # Current best path cost to bias informed sampling\n\n        for it in range(self._iterations):\n            if time.time() - self._start_time > self._timeout_seconds:\n                # Timeout treated as failure, exit planning\n                break\n\n            # Alternate growing trees: 0 - start tree, 1 - goal tree\n            tree_idx = it % 2\n            tree_root = self._graph.root_vertices[tree_idx]\n            other_root = self._graph.root_vertices[1 - tree_idx]\n            tree_vertices = start_vertices if tree_idx == 0 else goal_vertices\n\n            # Adaptive max step size decreases slightly as iterations increase, min 3.0\n            max_dist = max(3.0, self._max_dist_base * (1 - 0.7 * (it / self._iterations)))\n\n            # Sample with heuristic informed sampling bias near current best cost\n            q_rand = self._informed_sample(c_best, start_root.position, goal_root.position)\n\n            q_near = self._graph.get_nearest_vertex([tree_root], q_rand)\n            q_new = self._steer(q_near, q_rand, max_dist)\n\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                self.key_frame()\n                continue\n\n            n_vertices = len(tree_vertices)\n            if n_vertices == 0:\n                radius = max_dist\n            else:\n                gamma = 25.0\n                radius = min(max_dist, gamma * ((np.log(n_vertices + 1) / (n_vertices + 1)) ** (1 / dim)))\n\n            near_vertices = self._graph.get_vertices_within_radius([tree_root], q_new.position, radius)\n            if q_near not in near_vertices:\n                near_vertices.append(q_near)\n\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                self.key_frame()\n                continue\n\n            q_new.cost = best_parent.cost + grid.get_movement_cost(best_parent.position, q_new.position)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Initiate connectivity dicts if needed\n            if tree_root.connectivity is None:\n                tree_root.connectivity = {}\n            if q_new.connectivity is None:\n                q_new.connectivity = {}\n\n            if tree_root not in tree_root.connectivity:\n                tree_root.connectivity[tree_root] = tree_root\n            if goal_root not in goal_root.connectivity:\n                goal_root.connectivity[goal_root] = goal_root\n\n            tree_root.connectivity[q_new] = q_new\n            tree_vertices.append(q_new)\n\n            # Rewire in local neighborhood to optimize paths\n            self._rewire(near_vertices, q_new)\n\n            # Attempt bridge connection to other tree\n            q_new_near_other = self._graph.get_nearest_vertex([other_root], q_new.position)\n            if self._can_connect(q_new, q_new_near_other):\n                self._graph.add_edge(q_new, q_new_near_other)\n                self._graph.add_edge(q_new_near_other, q_new)\n\n                # Update costs if necessary\n                dist_bridge = grid.get_distance(q_new.position, q_new_near_other.position)\n                if q_new_near_other.cost is None or q_new_near_other.cost > q_new.cost + dist_bridge:\n                    q_new_near_other.cost = q_new.cost + dist_bridge\n                    if other_root is goal_root:\n                        if c_best > q_new_near_other.cost:\n                            c_best = q_new_near_other.cost\n\n                if grid.is_goal_reached(q_new.position) or grid.is_goal_reached(q_new_near_other.position):\n                    c_best = min(c_best, q_new.cost + dist_bridge)\n                    self._extract_path()\n                    return\n\n            # Also attempt to connect trees generally to improve success rate\n            if it % 50 == 0:\n                connected = self._try_connect_trees()\n                if connected:\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
