{
     "operator": "e1",
     "algorithm": "This algorithm, named \"Balanced RRT*\", improves on classic RRT* by balancing incremental exploration with heuristic informed rewiring and lazy collision checking. \n    \n    Key features:\n    - Uses a Forest graph structure for efficient tree rewiring.\n    - Introduces goal-biased sampling to speed convergence.\n    - Uses adaptive sampling radius based on the current graph size.\n    - Employs lazy collision checking to reduce expensive validity checks.\n    - Early path quality improvements by local rewiring with cost and smoothness considerations.\n    - Time limit of 60 seconds for planning, marking failure if exceeded.\n    \n    This approach aims to improve planning efficiency, reduce search time, increase success rate,\n    and produce smoother, shorter paths via rewiring and heuristic sampling.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = None\n        self._max_dist = 15.0\n        self._max_radius = 30.0\n        self._lambda_star = 40.0\n        self._time_limit = 60.0  # seconds\n        self._init_graph()\n        self._init_displays()\n\n    def _init_graph(self):\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n    def _get_random_sample(self) -> Point:\n        # Goal biasing: sample goal fairly often to speed convergence\n        goal_bias_prob = 0.15\n        if torch.rand(1).item() < goal_bias_prob:\n            return self._get_grid().goal.position\n        # Uniform random sample within map size\n        size = self._get_grid().size\n        while True:\n            coords = [torch.randint(0, size[i], (1,)).item() for i in range(size.n_dim)]\n            pt = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(pt):\n                return pt\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _steer(self, from_v: Vertex, to_p: Point, max_dist: float) -> Vertex:\n        vec = to_p.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_dist:\n            return Vertex(to_p)\n        direction = vec / dist\n        new_pos = from_v.position.to_tensor() + max_dist * direction\n        new_point = Point.from_tensor(new_pos)\n        return Vertex(new_point)\n\n    def _vertices_within_radius(self, v: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], v.position, radius)\n\n    def _valid_path(self, p1: Point, p2: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        path: List[Vertex] = [goal_vertex]\n        while path[-1].parents:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n        path.reverse()\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        max_iterations = 12000\n        iter = 0\n\n        while iter < max_iterations:\n            iter += 1\n            elapsed = time.time() - start_time\n            if elapsed > self._time_limit:\n                # Planning failed due to timeout\n                break\n\n            q_rand = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_rand)\n            if q_nearest.position == q_rand:\n                continue\n\n            q_new = self._steer(q_nearest, q_rand, self._max_dist)\n\n            # Lazy collision checking: only check when connection to nearest vertex\n            if not self._valid_path(q_nearest.position, q_new.position):\n                continue\n\n            # Calculate adaptive radius based on graph size and map dims\n            n = max(self._graph.size, 1)\n            dim = self._get_grid().size.n_dim\n            rad = min(self._lambda_star * ((torch.log(torch.tensor(float(n))) / n) ** (1.0 / dim)), self._max_radius)\n\n            near_vertices = self._vertices_within_radius(q_new, rad)\n\n            # Find parent with minimum cost and collision-free edge\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._distance(q_nearest.position, q_new.position)\n            for q_near in near_vertices:\n                if self._valid_path(q_near.position, q_new.position):\n                    c_new = q_near.cost + self._distance(q_near.position, q_new.position)\n                    if c_new < c_min:\n                        q_min = q_near\n                        c_min = c_new\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewiring: check if q_new can improve cost to neighbors\n            for q_near in near_vertices:\n                if q_near is q_min:\n                    continue\n                if self._valid_path(q_new.position, q_near.position):\n                    c_through_new = q_new.cost + self._distance(q_new.position, q_near.position)\n                    if c_through_new < q_near.cost:\n                        # Remove previous edge\n                        parent_old = next(iter(q_near.parents), None)\n                        if parent_old:\n                            self._graph.remove_edge(parent_old, q_near)\n                        q_near.cost = c_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            # If within goal radius, construct path\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            # Mark a key frame occasionally\n            if iter % 50 == 0:\n                self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 276, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 235, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 216, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 154, in _find_path_internal\nTypeError: 'int' object is not callable\n"
     }
}
{
     "operator": "m3",
     "algorithm": "This algorithm implements an improved bidirectional RRT* variant with rewiring and adaptive step size control,\n    combined with heuristic biasing towards the goal to enhance path quality, planning efficiency, and path smoothness.\n    It grows two trees from start and goal, attempts to connect them continuously, and performs rewiring to optimize paths.\n    It also uses time-limited execution to ensure robustness by stopping if planning exceeds 60 seconds.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _start_time: float\n    _timeout_seconds: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._iterations = 20000\n        self._max_dist = 12.0\n        self._timeout_seconds = 60.0\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            [],\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Samples a random valid point within the map with heuristic bias towards the goal.\n        With probability 0.2, sample the goal explicitly to improve convergence speed.\n        \"\"\"\n        goal_pos = self._graph.root_vertex_goal.position\n        if np.random.rand() < 0.2:\n            return goal_pos\n        sz = self._get_grid().size\n        while True:\n            rand_coords = [np.random.randint(0, sz[i]) for i in range(sz.n_dim)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        \"\"\"\n        Attempts to create a new vertex in direction from from_vertex to to_point,\n        but no farther than max_dist. Returns the new vertex without edges.\n        \"\"\"\n        from_pos = from_vertex.position.to_tensor()\n        dir_vec = to_point.to_tensor() - from_pos\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(to_point, store_connectivity=True)\n        dir_unit = dir_vec / dist\n        new_pos_tensor = from_pos + dir_unit * max_dist\n        new_point = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_point, store_connectivity=True)\n\n    def _near_vertices(self, tree_vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        \"\"\"\n        Returns vertices in tree_vertices that are within radius of point.\n        \"\"\"\n        return self._graph.get_vertices_within_radius(tree_vertices, point, radius)\n\n    def _choose_parent(self, near_vertices: List[Vertex], new_vertex: Vertex) -> Optional[Vertex]:\n        \"\"\"\n        Chooses the best parent from near_vertices for new_vertex by minimizing cost plus traversal cost.\n        Returns the selected parent or None if no valid connection found.\n        \"\"\"\n        best_parent = None\n        best_cost = float('inf')\n        for vertex in near_vertices:\n            if vertex.position == new_vertex.position:\n                continue\n            line_seq = self._get_grid().get_line_sequence(vertex.position, new_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_vertex = vertex.cost + self._get_grid().get_movement_cost(vertex.position, new_vertex.position)\n            if cost_through_vertex < best_cost:\n                best_cost = cost_through_vertex\n                best_parent = vertex\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], new_vertex: Vertex) -> None:\n        \"\"\"\n        Tries to rewire near_vertices through new_vertex if it reduces cost and path is valid.\n        \"\"\"\n        for vertex in near_vertices:\n            if vertex is new_vertex:\n                continue\n            line_seq = self._get_grid().get_line_sequence(new_vertex.position, vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = new_vertex.cost + self._get_grid().get_movement_cost(new_vertex.position, vertex.position)\n            if new_cost < vertex.cost:\n                # update edge connections in graph\n                # Remove old parents' edge to vertex\n                for p in list(vertex.parents):\n                    if p in self._graph.root_vertices or p in self._graph.root_vertices:\n                        self._graph.remove_edge(p, vertex)\n                        vertex.parents.remove(p)\n                # Add new edge from new_vertex to vertex\n                self._graph.add_edge(new_vertex, vertex)\n                vertex.cost = new_cost\n                # Update connectivity to maintain consistency with our storage\n                if new_vertex.connectivity is not None and vertex.connectivity is not None:\n                    vertex.connectivity[self._graph.root_vertex_goal] = new_vertex.connectivity.get(self._graph.root_vertex_goal, new_vertex)\n\n    def _can_connect(self, from_vertex: Vertex, to_vertex: Vertex) -> bool:\n        \"\"\"\n        Checks if direct connection line is valid between two vertices.\n        \"\"\"\n        line_seq = self._get_grid().get_line_sequence(from_vertex.position, to_vertex.position)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _extract_path(self) -> None:\n        \"\"\"\n        Extracts the path by traversing parents from goal to start and moves the agent accordingly.\n        \"\"\"\n        goal_vertex = self._graph.root_vertex_goal\n        path = []\n        current = goal_vertex\n        # Trace parents until root start is reached\n        while current.parents:\n            path.append(current)\n            # Pick the parent with minimal cost (usually one)\n            current = min(current.parents, key=lambda v: v.cost if v.cost is not None else float('inf'))\n        path.append(current)  # Append start\n        path.reverse()\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _try_connect_trees(self) -> bool:\n        \"\"\"\n        Attempts to connect the two trees by checking nearest vertices from either tree\n        to see if a valid line sequence connects them. If so, path is extracted and True returned.\n        \"\"\"\n        start_roots = self._graph.root_vertex_start\n        goal_roots = self._graph.root_vertex_goal\n\n        start_vertices = self._graph.root_vertices[0].connectivity.keys() if self._graph.root_vertices else []\n        goal_vertices = self._graph.root_vertices[1].connectivity.keys() if len(self._graph.root_vertices) > 1 else []\n\n        # Because we store trees as root_vertices and edges, we iterate over actual vertices in roots:\n        start_all = [start_roots] + list(start_roots.children)\n        goal_all = [goal_roots] + list(goal_roots.children)\n\n        # Check for any connection between start_all and goal_all vertices that can be connected by valid line\n        for v_start in start_all:\n            for v_goal in goal_all:\n                if self._can_connect(v_start, v_goal):\n                    # Connect these two vertices in graph\n                    self._graph.add_edge(v_start, v_goal)\n                    self._graph.add_edge(v_goal, v_start)\n                    # Set cost if needed\n                    dist = self._get_grid().get_distance(v_start.position, v_goal.position)\n                    if v_start.cost is None:\n                        v_start.cost = 0.0\n                    if v_goal.cost is None or v_goal.cost > v_start.cost + dist:\n                        v_goal.cost = v_start.cost + dist\n                    # Mark goal vertex cost if not set\n                    if self._graph.root_vertex_goal.cost is None:\n                        self._graph.root_vertex_goal.cost = float('inf')\n                    # Extract path\n                    self._extract_path()\n                    return True\n        return False\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n\n        # Initialize costs for root vertices\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = 0.0\n\n        for iteration in range(self._iterations):\n\n            # Time limit check for robust failure\n            if time.time() - self._start_time > self._timeout_seconds:\n                # Failed to find path in time\n                break\n\n            # Alternate trees: 0 for start tree, 1 for goal tree\n            tree_index = iteration % 2\n            tree_root = self._graph.root_vertices[tree_index]\n            other_tree_root = self._graph.root_vertices[1 - tree_index]\n\n            # Sample random point with goal biasing\n            q_rand = self._get_random_sample()\n\n            # Nearest vertex in current tree to q_rand\n            q_near = self._graph.get_nearest_vertex([tree_root], q_rand)\n            q_new = self._steer(q_near, q_rand, self._max_dist)\n\n            # Check if path between q_near and q_new is valid\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                self.key_frame()\n                continue\n\n            # Gather near vertices for rewiring within adaptive radius\n            dimension = self._get_grid().size.n_dim\n            gamma_rrt_star = 30.0  # tuning parameter for radius scaling\n            radius = min(self._max_dist, gamma_rrt_star * (np.log(len(self._graph.root_vertices) + 1) / (len(self._graph.root_vertices) + 1))**(1/dimension))\n\n            near_vertices = self._near_vertices([tree_root], q_new.position, radius)\n            if q_near not in near_vertices:\n                near_vertices.append(q_near)  # Ensure q_near in near_vertices\n\n            # Choose best parent and set cost\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                self.key_frame()\n                continue\n\n            q_new.cost = best_parent.cost + self._get_grid().get_movement_cost(best_parent.position, q_new.position)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Add new vertex to the tree root's connectivity - simulate tree structure\n            tree_root.connectivity[q_new] = q_new\n\n            # Rewire nearby vertices for potential cost improvement\n            self._rewire(near_vertices, q_new)\n\n            # Try to connect the newly added vertex to the other tree\n            q_new_near_other_tree = self._graph.get_nearest_vertex([other_tree_root], q_new.position)\n            if self._can_connect(q_new, q_new_near_other_tree):\n                # Add connection edges in both directions\n                self._graph.add_edge(q_new, q_new_near_other_tree)\n                self._graph.add_edge(q_new_near_other_tree, q_new)\n\n                # Check goal reach condition\n                if self._get_grid().is_goal_reached(q_new.position) or self._get_grid().is_goal_reached(q_new_near_other_tree.position):\n                    self._extract_path()\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 276, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 235, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 216, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 254, in _find_path_internal\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\classic\\sample_based\\core\\graph.py\", line 89, in add_edge\n    parent.add_child(child)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\classic\\sample_based\\core\\vertex.py\", line 56, in add_child\n    self.__add_connectivity(child)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\classic\\sample_based\\core\\vertex.py\", line 48, in __add_connectivity\n    new_vertex_path_step = vertex_to_update.connectivity[new_vertex_path_target]\nKeyError: <algorithms.classic.sample_based.core.vertex.Vertex object at 0x000001B9E2952F70>\n"
     }
}
{
     "operator": "m3",
     "algorithm": "This algorithm implements an improved bidirectional RRT* variant with rewiring and adaptive step size control,\n    combined with heuristic biasing towards the goal to enhance path quality, planning efficiency, and path smoothness.\n    It grows two trees from start and goal, attempts to connect them continuously, and performs rewiring to optimize paths.\n    It also uses time-limited execution to ensure robustness by stopping if planning exceeds 60 seconds.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _start_time: float\n    _timeout_seconds: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._iterations = 20000\n        self._max_dist = 12.0\n        self._timeout_seconds = 60.0\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            [],\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Samples a random valid point within the map with heuristic bias towards the goal.\n        With probability 0.2, sample the goal explicitly to improve convergence speed.\n        \"\"\"\n        goal_pos = self._graph.root_vertex_goal.position\n        if np.random.rand() < 0.2:\n            return goal_pos\n        sz = self._get_grid().size\n        while True:\n            rand_coords = [np.random.randint(0, sz[i]) for i in range(sz.n_dim)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        \"\"\"\n        Attempts to create a new vertex in direction from from_vertex to to_point,\n        but no farther than max_dist. Returns the new vertex without edges.\n        \"\"\"\n        from_pos = from_vertex.position.to_tensor()\n        dir_vec = to_point.to_tensor() - from_pos\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(to_point, store_connectivity=True)\n        dir_unit = dir_vec / dist\n        new_pos_tensor = from_pos + dir_unit * max_dist\n        new_point = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_point, store_connectivity=True)\n\n    def _near_vertices(self, tree_vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        \"\"\"\n        Returns vertices in tree_vertices that are within radius of point.\n        \"\"\"\n        return self._graph.get_vertices_within_radius(tree_vertices, point, radius)\n\n    def _choose_parent(self, near_vertices: List[Vertex], new_vertex: Vertex) -> Optional[Vertex]:\n        \"\"\"\n        Chooses the best parent from near_vertices for new_vertex by minimizing cost plus traversal cost.\n        Returns the selected parent or None if no valid connection found.\n        \"\"\"\n        best_parent = None\n        best_cost = float('inf')\n        for vertex in near_vertices:\n            if vertex.position == new_vertex.position:\n                continue\n            line_seq = self._get_grid().get_line_sequence(vertex.position, new_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            if vertex.cost is None:\n                continue\n            cost_through_vertex = vertex.cost + self._get_grid().get_movement_cost(vertex.position, new_vertex.position)\n            if cost_through_vertex < best_cost:\n                best_cost = cost_through_vertex\n                best_parent = vertex\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], new_vertex: Vertex) -> None:\n        \"\"\"\n        Tries to rewire near_vertices through new_vertex if it reduces cost and path is valid.\n        \"\"\"\n        for vertex in near_vertices:\n            if vertex is new_vertex or vertex.cost is None or new_vertex.cost is None:\n                continue\n            line_seq = self._get_grid().get_line_sequence(new_vertex.position, vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = new_vertex.cost + self._get_grid().get_movement_cost(new_vertex.position, vertex.position)\n            if new_cost < vertex.cost:\n                # update edge connections in graph\n                # Remove old parents' edge to vertex\n                for p in list(vertex.parents):\n                    self._graph.remove_edge(p, vertex)\n                # Add new edge from new_vertex to vertex\n                self._graph.add_edge(new_vertex, vertex)\n                vertex.cost = new_cost\n                # Update connectivity to maintain consistency with our storage\n                # Defensive: check that connectivity dicts exist\n                if new_vertex.connectivity is not None and vertex.connectivity is not None:\n                    target = self._graph.root_vertex_goal\n                    # Use get with fallback to new_vertex if key missing\n                    new_value = new_vertex.connectivity.get(target, new_vertex)\n                    vertex.connectivity[target] = new_value\n\n    def _can_connect(self, from_vertex: Vertex, to_vertex: Vertex) -> bool:\n        \"\"\"\n        Checks if direct connection line is valid between two vertices.\n        \"\"\"\n        line_seq = self._get_grid().get_line_sequence(from_vertex.position, to_vertex.position)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _extract_path(self) -> None:\n        \"\"\"\n        Extracts the path by traversing parents from goal to start and moves the agent accordingly.\n        \"\"\"\n        goal_vertex = self._graph.root_vertex_goal\n        if goal_vertex.cost is None:\n            return  # No valid path found yet\n        path = []\n        current = goal_vertex\n        # Trace parents until root start is reached\n        while current.parents:\n            path.append(current)\n            # Pick the parent with minimal cost (usually one)\n            current = min(current.parents, key=lambda v: v.cost if v.cost is not None else float('inf'))\n        path.append(current)  # Append start\n        path.reverse()\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _try_connect_trees(self) -> bool:\n        \"\"\"\n        Attempts to connect the two trees by checking nearest vertices from either tree\n        to see if a valid line sequence connects them. If so, path is extracted and True returned.\n        \"\"\"\n        start_roots = self._graph.root_vertex_start\n        goal_roots = self._graph.root_vertex_goal\n\n        # Gather all vertices in start tree and goal tree by BFS or from connectivity keys\n        # Safer to gather all vertices from connectivity keys of roots if available\n        start_all = [start_roots] + list(start_roots.children)\n        goal_all = [goal_roots] + list(goal_roots.children)\n\n        for v_start in start_all:\n            for v_goal in goal_all:\n                # Make sure costs are assigned to vertices before connecting\n                if v_start.cost is None or v_goal.cost is None:\n                    continue\n                if self._can_connect(v_start, v_goal):\n                    # Connect these two vertices in graph\n                    self._graph.add_edge(v_start, v_goal)\n                    self._graph.add_edge(v_goal, v_start)\n                    # Update costs appropriately\n                    dist = self._get_grid().get_distance(v_start.position, v_goal.position)\n                    if v_start.cost is None:\n                        v_start.cost = 0.0\n                    if v_goal.cost is None or v_goal.cost > v_start.cost + dist:\n                        v_goal.cost = v_start.cost + dist\n                    # Mark goal vertex cost if not set\n                    if self._graph.root_vertex_goal.cost is None:\n                        self._graph.root_vertex_goal.cost = float('inf')\n                    # Extract path\n                    self._extract_path()\n                    return True\n        return False\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n\n        # Initialize costs for root vertices\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')\n\n        # Maintain a set of known vertices per tree for radius calculations\n        start_vertices = [self._graph.root_vertex_start]\n        goal_vertices = [self._graph.root_vertex_goal]\n\n        for iteration in range(self._iterations):\n\n            # Time limit check for robust failure\n            if time.time() - self._start_time > self._timeout_seconds:\n                # Failed to find path in time\n                break\n\n            # Alternate trees: 0 for start tree, 1 for goal tree\n            tree_index = iteration % 2\n            tree_root = self._graph.root_vertices[tree_index]\n            other_tree_root = self._graph.root_vertices[1 - tree_index]\n\n            # Sample random point with goal biasing\n            q_rand = self._get_random_sample()\n\n            # Nearest vertex in current tree to q_rand\n            q_near = self._graph.get_nearest_vertex([tree_root], q_rand)\n            q_new = self._steer(q_near, q_rand, self._max_dist)\n\n            # Check if path between q_near and q_new is valid\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                self.key_frame()\n                continue\n\n            # Gather near vertices for rewiring within adaptive radius\n            dimension = self._get_grid().size.n_dim\n            # Use the count of vertices in this tree for radius calculation\n            current_tree_vertices = start_vertices if tree_index == 0 else goal_vertices\n            n_vertices = len(current_tree_vertices)\n            gamma_rrt_star = 30.0  # tuning parameter for radius scaling\n            radius = min(self._max_dist, gamma_rrt_star * (np.log(n_vertices + 1) / (n_vertices + 1))**(1/dimension))\n\n            near_vertices = self._near_vertices([tree_root], q_new.position, radius)\n            if q_near not in near_vertices:\n                near_vertices.append(q_near)  # Ensure q_near in near_vertices\n\n            # Choose best parent and set cost\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                self.key_frame()\n                continue\n\n            q_new.cost = best_parent.cost + self._get_grid().get_movement_cost(best_parent.position, q_new.position)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Add new vertex to the tree root's connectivity and update list\n            if tree_root.connectivity is None:\n                tree_root.connectivity = {}\n            tree_root.connectivity[q_new] = q_new\n            if tree_index == 0:\n                start_vertices.append(q_new)\n            else:\n                goal_vertices.append(q_new)\n\n            # Rewire nearby vertices for potential cost improvement\n            self._rewire(near_vertices, q_new)\n\n            # Try to connect the newly added vertex to the other tree\n            q_new_near_other_tree = self._graph.get_nearest_vertex([other_tree_root], q_new.position)\n            if self._can_connect(q_new, q_new_near_other_tree):\n                # Add connection edges in both directions\n                self._graph.add_edge(q_new, q_new_near_other_tree)\n                self._graph.add_edge(q_new_near_other_tree, q_new)\n\n                # Check goal reach condition\n                if self._get_grid().is_goal_reached(q_new.position) or self._get_grid().is_goal_reached(q_new_near_other_tree.position):\n                    self._extract_path()\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 276, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 235, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 216, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 267, in _find_path_internal\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\classic\\sample_based\\core\\graph.py\", line 89, in add_edge\n    parent.add_child(child)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\classic\\sample_based\\core\\vertex.py\", line 56, in add_child\n    self.__add_connectivity(child)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\classic\\sample_based\\core\\vertex.py\", line 48, in __add_connectivity\n    new_vertex_path_step = vertex_to_update.connectivity[new_vertex_path_target]\nKeyError: <algorithms.classic.sample_based.core.vertex.Vertex object at 0x000001B9E9571DC0>\n"
     }
}
{
     "operator": "m3",
     "algorithm": "This algorithm implements an improved bidirectional RRT* variant with rewiring and adaptive step size control,\n    combined with heuristic biasing towards the goal to enhance path quality, planning efficiency, and path smoothness.\n    It grows two trees from start and goal, attempts to connect them continuously, and performs rewiring to optimize paths.\n    It also uses time-limited execution to ensure robustness by stopping if planning exceeds 60 seconds.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _start_time: float\n    _timeout_seconds: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._iterations = 20000\n        self._max_dist = 12.0\n        self._timeout_seconds = 60.0\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            [],\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Samples a random valid point within the map with heuristic bias towards the goal.\n        With probability 0.2, sample the goal explicitly to improve convergence speed.\n        \"\"\"\n        goal_pos = self._graph.root_vertex_goal.position\n        if np.random.rand() < 0.2:\n            return goal_pos\n        sz = self._get_grid().size\n        while True:\n            rand_coords = [np.random.randint(0, sz[i]) for i in range(sz.n_dim)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        \"\"\"\n        Attempts to create a new vertex in direction from from_vertex to to_point,\n        but no farther than max_dist. Returns the new vertex without edges.\n        \"\"\"\n        from_pos = from_vertex.position.to_tensor()\n        dir_vec = to_point.to_tensor() - from_pos\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(to_point, store_connectivity=True)\n        dir_unit = dir_vec / dist\n        new_pos_tensor = from_pos + dir_unit * max_dist\n        new_point = Point(*new_pos_tensor.tolist())\n        return Vertex(new_point, store_connectivity=True)\n\n    def _near_vertices(self, tree_vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        \"\"\"\n        Returns vertices in tree_vertices that are within radius of point.\n        \"\"\"\n        return self._graph.get_vertices_within_radius(tree_vertices, point, radius)\n\n    def _choose_parent(self, near_vertices: List[Vertex], new_vertex: Vertex) -> Optional[Vertex]:\n        \"\"\"\n        Chooses the best parent from near_vertices for new_vertex by minimizing cost plus traversal cost.\n        Returns the selected parent or None if no valid connection found.\n        \"\"\"\n        best_parent = None\n        best_cost = float('inf')\n        for vertex in near_vertices:\n            if vertex.position == new_vertex.position:\n                continue\n            line_seq = self._get_grid().get_line_sequence(vertex.position, new_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            if vertex.cost is None:\n                continue\n            cost_through_vertex = vertex.cost + self._get_grid().get_movement_cost(vertex.position, new_vertex.position)\n            if cost_through_vertex < best_cost:\n                best_cost = cost_through_vertex\n                best_parent = vertex\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], new_vertex: Vertex) -> None:\n        \"\"\"\n        Tries to rewire near_vertices through new_vertex if it reduces cost and path is valid.\n        \"\"\"\n        for vertex in near_vertices:\n            if vertex is new_vertex or vertex.cost is None or new_vertex.cost is None:\n                continue\n            line_seq = self._get_grid().get_line_sequence(new_vertex.position, vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = new_vertex.cost + self._get_grid().get_movement_cost(new_vertex.position, vertex.position)\n            if new_cost < vertex.cost:\n                # Remove old edges (parents) to vertex\n                for p in list(vertex.parents):\n                    self._graph.remove_edge(p, vertex)\n                # Add new edge from new_vertex to vertex\n                self._graph.add_edge(new_vertex, vertex)\n                vertex.cost = new_cost\n                # Initialize connectivity if missing\n                if new_vertex.connectivity is None:\n                    new_vertex.connectivity = {}\n                if vertex.connectivity is None:\n                    vertex.connectivity = {}\n                target = self._graph.root_vertex_goal\n                # Defensive: set connectivity for target if missing\n                new_value = new_vertex.connectivity.get(target, new_vertex)\n                vertex.connectivity[target] = new_value\n\n    def _can_connect(self, from_vertex: Vertex, to_vertex: Vertex) -> bool:\n        \"\"\"\n        Checks if direct connection line is valid between two vertices.\n        \"\"\"\n        line_seq = self._get_grid().get_line_sequence(from_vertex.position, to_vertex.position)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _extract_path(self) -> None:\n        \"\"\"\n        Extracts the path by traversing parents from goal to start and moves the agent accordingly.\n        \"\"\"\n        goal_vertex = self._graph.root_vertex_goal\n        if goal_vertex.cost is None:\n            return  # No valid path found yet\n        path = []\n        current = goal_vertex\n        # Trace parents until root start is reached\n        while current.parents:\n            path.append(current)\n            current = min(current.parents, key=lambda v: v.cost if v.cost is not None else float('inf'))\n        path.append(current)  # Append start\n        path.reverse()\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _try_connect_trees(self) -> bool:\n        \"\"\"\n        Attempts to connect the two trees by checking nearest vertices from either tree\n        to see if a valid line sequence connects them. If so, path is extracted and True returned.\n        \"\"\"\n        start_roots = self._graph.root_vertex_start\n        goal_roots = self._graph.root_vertex_goal\n\n        # Collect all vertices in start and goal trees\n        def gather_all_vertices(root: Vertex) -> List[Vertex]:\n            vertices = [root]\n            vertices.extend(list(root.children))\n            return vertices\n\n        start_all = gather_all_vertices(start_roots)\n        goal_all = gather_all_vertices(goal_roots)\n\n        for v_start in start_all:\n            for v_goal in goal_all:\n                if v_start.cost is None or v_goal.cost is None:\n                    continue\n                if self._can_connect(v_start, v_goal):\n                    self._graph.add_edge(v_start, v_goal)\n                    self._graph.add_edge(v_goal, v_start)\n                    dist = self._get_grid().get_distance(v_start.position, v_goal.position)\n                    if v_start.cost is None:\n                        v_start.cost = 0.0\n                    if v_goal.cost is None or v_goal.cost > v_start.cost + dist:\n                        v_goal.cost = v_start.cost + dist\n                    if self._graph.root_vertex_goal.cost is None:\n                        self._graph.root_vertex_goal.cost = float('inf')\n                    self._extract_path()\n                    return True\n        return False\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        import time  # needed for timing here since used but not explicitly imported\n\n        self._start_time = time.time()\n\n        # Initialize costs for root vertices\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')\n\n        # Maintain a set of known vertices per tree for radius calculations\n        start_vertices = [self._graph.root_vertex_start]\n        goal_vertices = [self._graph.root_vertex_goal]\n\n        for iteration in range(self._iterations):\n\n            # Time limit check for robust failure\n            if time.time() - self._start_time > self._timeout_seconds:\n                break\n\n            # Alternate trees: 0 for start tree, 1 for goal tree\n            tree_index = iteration % 2\n            tree_root = self._graph.root_vertices[tree_index]\n            other_tree_root = self._graph.root_vertices[1 - tree_index]\n\n            # Sample random point with goal biasing\n            q_rand = self._get_random_sample()\n\n            # Nearest vertex in current tree to q_rand\n            q_near = self._graph.get_nearest_vertex([tree_root], q_rand)\n            q_new = self._steer(q_near, q_rand, self._max_dist)\n\n            # Check if path between q_near and q_new is valid\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                self.key_frame()\n                continue\n\n            # Gather near vertices for rewiring within adaptive radius\n            dimension = self._get_grid().size.n_dim\n            current_tree_vertices = start_vertices if tree_index == 0 else goal_vertices\n            n_vertices = len(current_tree_vertices)\n\n            # Avoid division by zero\n            if n_vertices == 0:\n                radius = self._max_dist\n            else:\n                gamma_rrt_star = 30.0  # tuning parameter for radius scaling\n                radius = min(self._max_dist, gamma_rrt_star * (np.log(n_vertices + 1) / (n_vertices + 1))**(1/dimension))\n\n            near_vertices = self._near_vertices([tree_root], q_new.position, radius)\n            if q_near not in near_vertices:\n                near_vertices.append(q_near)\n\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                self.key_frame()\n                continue\n\n            q_new.cost = best_parent.cost + self._get_grid().get_movement_cost(best_parent.position, q_new.position)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Initialize connectivity dicts if missing\n            if tree_root.connectivity is None:\n                tree_root.connectivity = {}\n            if q_new.connectivity is None:\n                q_new.connectivity = {}\n\n            # Add new vertex to tree connectivity and vertices list\n            tree_root.connectivity[q_new] = q_new\n            if tree_index == 0:\n                start_vertices.append(q_new)\n            else:\n                goal_vertices.append(q_new)\n\n            # Rewire near vertices\n            self._rewire(near_vertices, q_new)\n\n            # Try connecting newly added vertex to the other tree\n            q_new_near_other_tree = self._graph.get_nearest_vertex([other_tree_root], q_new.position)\n            if self._can_connect(q_new, q_new_near_other_tree):\n                self._graph.add_edge(q_new, q_new_near_other_tree)\n                self._graph.add_edge(q_new_near_other_tree, q_new)\n\n                if self._get_grid().is_goal_reached(q_new.position) or self._get_grid().is_goal_reached(q_new_near_other_tree.position):\n                    self._extract_path()\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 276, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 235, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 216, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 270, in _find_path_internal\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\classic\\sample_based\\core\\graph.py\", line 89, in add_edge\n    parent.add_child(child)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\classic\\sample_based\\core\\vertex.py\", line 56, in add_child\n    self.__add_connectivity(child)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\classic\\sample_based\\core\\vertex.py\", line 48, in __add_connectivity\n    new_vertex_path_step = vertex_to_update.connectivity[new_vertex_path_target]\nKeyError: <algorithms.classic.sample_based.core.vertex.Vertex object at 0x000001B9E6B765E0>\n"
     }
}
{
     "operator": "m3",
     "algorithm": "This algorithm implements an improved bidirectional RRT* variant with rewiring and adaptive step size control,\n    combined with heuristic biasing towards the goal to enhance path quality, planning efficiency, and path smoothness.\n    It grows two trees from start and goal, attempts to connect them continuously, and performs rewiring to optimize paths.\n    It also uses time-limited execution to ensure robustness by stopping if planning exceeds 60 seconds.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _start_time: float\n    _timeout_seconds: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._iterations = 20000\n        self._max_dist = 12.0\n        self._timeout_seconds = 60.0\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            [],\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Samples a random valid point within the map with heuristic bias towards the goal.\n        With probability 0.2, sample the goal explicitly to improve convergence speed.\n        \"\"\"\n        goal_pos = self._graph.root_vertex_goal.position\n        if np.random.rand() < 0.2:\n            return goal_pos\n        sz = self._get_grid().size\n        while True:\n            rand_coords = [np.random.randint(0, sz[i]) for i in range(sz.n_dim)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        \"\"\"\n        Attempts to create a new vertex in direction from from_vertex to to_point,\n        but no farther than max_dist. Returns the new vertex without edges.\n        \"\"\"\n        from_pos = from_vertex.position.to_tensor()\n        dir_vec = to_point.to_tensor() - from_pos\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(to_point, store_connectivity=True)\n        dir_unit = dir_vec / dist\n        new_pos_tensor = from_pos + dir_unit * max_dist\n        new_point = Point(*new_pos_tensor.tolist())\n        return Vertex(new_point, store_connectivity=True)\n\n    def _near_vertices(self, tree_vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        \"\"\"\n        Returns vertices in tree_vertices that are within radius of point.\n        \"\"\"\n        return self._graph.get_vertices_within_radius(tree_vertices, point, radius)\n\n    def _choose_parent(self, near_vertices: List[Vertex], new_vertex: Vertex) -> Optional[Vertex]:\n        \"\"\"\n        Chooses the best parent from near_vertices for new_vertex by minimizing cost plus traversal cost.\n        Returns the selected parent or None if no valid connection found.\n        \"\"\"\n        best_parent = None\n        best_cost = float('inf')\n        for vertex in near_vertices:\n            if vertex.position == new_vertex.position:\n                continue\n            line_seq = self._get_grid().get_line_sequence(vertex.position, new_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            if vertex.cost is None:\n                continue\n            cost_through_vertex = vertex.cost + self._get_grid().get_movement_cost(vertex.position, new_vertex.position)\n            if cost_through_vertex < best_cost:\n                best_cost = cost_through_vertex\n                best_parent = vertex\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], new_vertex: Vertex) -> None:\n        \"\"\"\n        Tries to rewire near_vertices through new_vertex if it reduces cost and path is valid.\n        \"\"\"\n        for vertex in near_vertices:\n            if vertex is new_vertex or vertex.cost is None or new_vertex.cost is None:\n                continue\n            line_seq = self._get_grid().get_line_sequence(new_vertex.position, vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = new_vertex.cost + self._get_grid().get_movement_cost(new_vertex.position, vertex.position)\n            if new_cost < vertex.cost:\n                # Remove old edges (parents) to vertex\n                for p in list(vertex.parents):\n                    self._graph.remove_edge(p, vertex)\n                # Add new edge from new_vertex to vertex\n                self._graph.add_edge(new_vertex, vertex)\n                vertex.cost = new_cost\n                # Initialize connectivity if missing\n                if new_vertex.connectivity is None:\n                    new_vertex.connectivity = {}\n                if vertex.connectivity is None:\n                    vertex.connectivity = {}\n                target = self._graph.root_vertex_goal\n                # Defensive: set connectivity for target if missing\n                # Fix: assign new_vertex itself as the connectivity step to target,\n                # avoiding key error with vertex connectivity dictionary, by ensuring\n                # new_vertex.connectivity has target key set first.\n                if target not in new_vertex.connectivity:\n                    new_vertex.connectivity[target] = new_vertex\n                vertex.connectivity[target] = new_vertex.connectivity[target]\n\n    def _can_connect(self, from_vertex: Vertex, to_vertex: Vertex) -> bool:\n        \"\"\"\n        Checks if direct connection line is valid between two vertices.\n        \"\"\"\n        line_seq = self._get_grid().get_line_sequence(from_vertex.position, to_vertex.position)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _extract_path(self) -> None:\n        \"\"\"\n        Extracts the path by traversing parents from goal to start and moves the agent accordingly.\n        \"\"\"\n        goal_vertex = self._graph.root_vertex_goal\n        if goal_vertex.cost is None:\n            return  # No valid path found yet\n        path = []\n        current = goal_vertex\n        # Trace parents until root start is reached\n        while current.parents:\n            path.append(current)\n            current = min(current.parents, key=lambda v: v.cost if v.cost is not None else float('inf'))\n        path.append(current)  # Append start\n        path.reverse()\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _try_connect_trees(self) -> bool:\n        \"\"\"\n        Attempts to connect the two trees by checking nearest vertices from either tree\n        to see if a valid line sequence connects them. If so, path is extracted and True returned.\n        \"\"\"\n        start_roots = self._graph.root_vertex_start\n        goal_roots = self._graph.root_vertex_goal\n\n        # Collect all vertices in start and goal trees\n        def gather_all_vertices(root: Vertex) -> List[Vertex]:\n            vertices = [root]\n            vertices.extend(list(root.children))\n            return vertices\n\n        start_all = gather_all_vertices(start_roots)\n        goal_all = gather_all_vertices(goal_roots)\n\n        for v_start in start_all:\n            for v_goal in goal_all:\n                if v_start.cost is None or v_goal.cost is None:\n                    continue\n                if self._can_connect(v_start, v_goal):\n                    self._graph.add_edge(v_start, v_goal)\n                    self._graph.add_edge(v_goal, v_start)\n                    dist = self._get_grid().get_distance(v_start.position, v_goal.position)\n                    if v_start.cost is None:\n                        v_start.cost = 0.0\n                    if v_goal.cost is None or v_goal.cost > v_start.cost + dist:\n                        v_goal.cost = v_start.cost + dist\n                    if self._graph.root_vertex_goal.cost is None:\n                        self._graph.root_vertex_goal.cost = float('inf')\n                    self._extract_path()\n                    return True\n        return False\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        import time  # needed for timing here since used but not explicitly imported\n\n        self._start_time = time.time()\n\n        # Initialize costs for root vertices\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')\n\n        # Maintain a set of known vertices per tree for radius calculations\n        start_vertices = [self._graph.root_vertex_start]\n        goal_vertices = [self._graph.root_vertex_goal]\n\n        for iteration in range(self._iterations):\n\n            # Time limit check for robust failure\n            if time.time() - self._start_time > self._timeout_seconds:\n                break\n\n            # Alternate trees: 0 for start tree, 1 for goal tree\n            tree_index = iteration % 2\n            tree_root = self._graph.root_vertices[tree_index]\n            other_tree_root = self._graph.root_vertices[1 - tree_index]\n\n            # Sample random point with goal biasing\n            q_rand = self._get_random_sample()\n\n            # Nearest vertex in current tree to q_rand\n            q_near = self._graph.get_nearest_vertex([tree_root], q_rand)\n            q_new = self._steer(q_near, q_rand, self._max_dist)\n\n            # Check if path between q_near and q_new is valid\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                self.key_frame()\n                continue\n\n            # Gather near vertices for rewiring within adaptive radius\n            dimension = self._get_grid().size.n_dim\n            current_tree_vertices = start_vertices if tree_index == 0 else goal_vertices\n            n_vertices = len(current_tree_vertices)\n\n            # Avoid division by zero\n            if n_vertices == 0:\n                radius = self._max_dist\n            else:\n                gamma_rrt_star = 30.0  # tuning parameter for radius scaling\n                radius = min(self._max_dist, gamma_rrt_star * (np.log(n_vertices + 1) / (n_vertices + 1))**(1/dimension))\n\n            near_vertices = self._near_vertices([tree_root], q_new.position, radius)\n            if q_near not in near_vertices:\n                near_vertices.append(q_near)\n\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                self.key_frame()\n                continue\n\n            q_new.cost = best_parent.cost + self._get_grid().get_movement_cost(best_parent.position, q_new.position)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Initialize connectivity dicts if missing\n            if tree_root.connectivity is None:\n                tree_root.connectivity = {}\n            if q_new.connectivity is None:\n                q_new.connectivity = {}\n\n            # Make sure root vertex connectivity has its own entry targeting itself (fix)\n            if tree_root not in tree_root.connectivity:\n                tree_root.connectivity[tree_root] = tree_root\n            # Also ensure root goal vertex connectivity has an entry for itself (fix)\n            if self._graph.root_vertex_goal not in self._graph.root_vertex_goal.connectivity:\n                self._graph.root_vertex_goal.connectivity[self._graph.root_vertex_goal] = self._graph.root_vertex_goal\n\n            # Add new vertex to tree connectivity and vertices list\n            tree_root.connectivity[q_new] = q_new\n            if tree_index == 0:\n                start_vertices.append(q_new)\n            else:\n                goal_vertices.append(q_new)\n\n            # Rewire near vertices\n            self._rewire(near_vertices, q_new)\n\n            # Try connecting newly added vertex to the other tree\n            q_new_near_other_tree = self._graph.get_nearest_vertex([other_tree_root], q_new.position)\n            if self._can_connect(q_new, q_new_near_other_tree):\n                self._graph.add_edge(q_new, q_new_near_other_tree)\n                self._graph.add_edge(q_new_near_other_tree, q_new)\n\n                if self._get_grid().is_goal_reached(q_new.position) or self._get_grid().is_goal_reached(q_new_near_other_tree.position):\n                    self._extract_path()\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 276, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 235, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 216, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 274, in _find_path_internal\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\classic\\sample_based\\core\\graph.py\", line 89, in add_edge\n    parent.add_child(child)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\classic\\sample_based\\core\\vertex.py\", line 56, in add_child\n    self.__add_connectivity(child)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\classic\\sample_based\\core\\vertex.py\", line 48, in __add_connectivity\n    new_vertex_path_step = vertex_to_update.connectivity[new_vertex_path_target]\nKeyError: <algorithms.classic.sample_based.core.vertex.Vertex object at 0x000001B9E95CE370>\n"
     }
}
{
     "operator": "m3",
     "algorithm": "An improved sample-based path planning algorithm inspired by RRT* with these enhancements:\n     - Adaptive informed sampling focused around start-goal to increase sampling efficiency.\n     - Dynamic neighborhood radius based on graph size and dimension for optimal rewiring and connectivity.\n     - Goal biasing to speed early convergence.\n     - Efficient rewiring to improve path cost and quality.\n     - Path smoothing via shortcutting after path extraction.\n     - Timeout handling to fail gracefully after 60 seconds.\n     The algorithm maintains a forest graph rooted at start and attempts incremental tree expansions towards valid samples,\n     rewiring neighbor connections for better paths, and extracts a smooth, cost-efficient path once the goal region is reached.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _max_radius: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _start_vertex: Vertex\n    _goal_vertex: Vertex\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._start_vertex = Vertex(self._get_grid().agent.position)\n        self._start_vertex.cost = 0.0\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, self._start_vertex, self._goal_vertex, [])\n        self._max_dist = 12.0  # max extension length\n        self._max_radius = 40.0  # max neighbor radius\n        self._lambda_rrt_star = 40.0  # RRT* constant for adaptive radius\n        self._dimension = self._get_grid().size.n_dim\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Goal biasing with 10% probability\n        if torch.rand(1).item() < 0.1:\n            return self._goal_vertex.position\n\n        # 75% informed sampling, else uniform random\n        if torch.rand(1).item() < 0.75:\n            return self._informed_sample()\n        else:\n            return self._uniform_valid_sample()\n\n    def _uniform_valid_sample(self) -> Point:\n        while True:\n            coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _informed_sample(self) -> Point:\n        start = self._start_vertex.position.to_tensor()\n        goal = self._goal_vertex.position.to_tensor()\n        c_min = torch.norm(start - goal).item()\n        if c_min < 1e-5:\n            return self._uniform_valid_sample()\n\n        center = (start + goal) / 2\n        a1 = (goal - start) / c_min\n\n        if self._dimension == 2:\n            a2 = torch.tensor([-a1[1].item(), a1[0].item()])\n            basis = torch.stack([a1, a2], dim=1)  # 2x2 matrix\n        else:\n            basis = torch.eye(self._dimension)\n            basis[:, 0] = a1.flatten()\n\n        r1 = c_min / 2\n        inflation = 1.5\n        radii = torch.tensor([r1] + [inflation * r1] * (self._dimension - 1))\n\n        rand_point = torch.randn(self._dimension)\n        rand_point /= torch.norm(rand_point)\n        rand_radius = torch.rand(1).item() ** (1.0 / self._dimension)\n        rand_point = rand_point * rand_radius\n\n        sample_vec = rand_point * radii\n\n        sample_coords = basis @ sample_vec + center\n\n        clamped_coords = []\n        for i in range(self._dimension):\n            val = int(round(sample_coords[i].item()))\n            val = max(0, min(val, self._get_grid().size[i] - 1))\n            clamped_coords.append(val)\n\n        sample = Point(*clamped_coords)\n        if not self._get_grid().is_agent_valid_pos(sample):\n            return self._uniform_valid_sample()\n        return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        # Search among all existing vertices\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex | None:\n        diff = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(diff).item()\n        if dist == 0:\n            return None\n        if dist <= max_dist:\n            candidate_pos = q_sample\n        else:\n            dir_norm = diff / dist\n            new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_norm\n            coords = tuple(int(round(x.item())) for x in new_pos_tensor)\n            candidate_pos = Point(*coords)\n\n        if self._get_grid().is_agent_valid_pos(candidate_pos):\n            return Vertex(candidate_pos)\n        return None\n\n    def _extract_path(self, q_goal_vertex: Vertex) -> None:\n        path: List[Vertex] = [q_goal_vertex]\n        current = q_goal_vertex\n        while current.parents:\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n        self._smooth_path(path)\n\n    def _smooth_path(self, path: List[Vertex]) -> None:\n        if len(path) < 3:\n            return\n\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_points = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_points):\n                    smoothed_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                smoothed_path.append(path[i + 1])\n                i += 1\n\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import math\n\n        start_time = time.time()\n        max_iters = 15000\n\n        for _ in range(max_iters):\n            if (time.time() - start_time) > 60.0:\n                # Fail gracefully after 60 sec timeout\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            if q_new is None:\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cardinality = float(self._graph.size) if self._graph.size > 0 else 1.0\n            log_card = math.log(cardinality)\n            radius = min(\n                self._lambda_rrt_star * ((log_card / cardinality) ** (1.0 / self._dimension)),\n                self._max_radius,\n            )\n\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent minimizing cost\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor()).item()\n            for q_near in neighbors:\n                if q_near == q_nearest:\n                    continue\n                line_seq_near = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_near):\n                    cost = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n                    if cost < c_min:\n                        q_min = q_near\n                        c_min = cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to potentially better paths through q_new\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_back = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_back):\n                    continue\n                new_cost = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n                if q_near.cost is None or new_cost < q_near.cost:\n                    old_parent = next(iter(q_near.parents), None)\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n            self._graph.root_vertices.append(q_new)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 271, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 128, in PathPlanning\nTypeError: unsupported operand type(s) for |: 'type' and 'NoneType'\n"
     }
}
{
     "operator": "m1",
     "algorithm": "An improved hybrid bidirectional path planning algorithm combining the strengths of RRT-Connect and RRT*.\n    This algorithm utilizes two cyclic graphs growing from start and goal with goal biasing and adaptive sampling.\n    It alternates tree extensions and employs rewiring in both trees to improve path quality progressively.\n    It includes informed sampling within an ellipsoidal heuristic region after an initial solution is found,\n    focusing exploration on promising areas. The algorithm short-circuits when a path is found or after 60 seconds.\n    Post-processing with shortcut smoothing reduces waypoints for smoother, shorter paths.\n    This approach optimizes planning efficiency, path length, smoothness, and success rate, while bounding search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph_start: CyclicGraph\n    _graph_goal: CyclicGraph\n    _max_dist: float = 15.0\n    _iterations: int = 15000\n    _goal_sample_rate: float = 0.2\n    _rewire_radius_factor: float = 30.0  # Tuned for better rewiring in larger maps\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_v = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_v = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph_start = gen_cyclic_graph(self._services, start_v, Vertex(Point(0, 0)), [])\n        self._graph_goal = gen_cyclic_graph(self._services, goal_v, Vertex(Point(0, 0)), [])\n        self._graph_start.edges_removable = True\n        self._graph_goal.edges_removable = True\n        self._init_displays()\n\n        # Initialize cost roots\n        self._graph_start.root_vertex_start.cost = 0.0\n        self._graph_goal.root_vertex_start.cost = 0.0\n\n        # Track best path cost & vertices for heuristic sampling\n        self._best_path_cost = float('inf')\n        self._best_connection = None\n\n    def _get_random_sample(self, iteration: int) -> Point:\n        \"\"\"\n        Sample points with goal biasing and, once a path found, informed sampling inside ellipsoidal heuristic.\n        \"\"\"\n        grid = self._get_grid()\n        # If best path known, sample inside ellipsoid defined by start-goal and best cost\n        if self._best_path_cost < float('inf') and iteration > self._iterations // 10:\n            # Ellipsoidal informed sampling\n            start = self._graph_start.root_vertex_start.position.to_tensor()\n            goal = self._graph_goal.root_vertex_start.position.to_tensor()\n            c_best = self._best_path_cost\n            c_min = torch.norm(goal - start).item()\n            if c_best < float('inf') and c_min > 0 and c_best > c_min:\n                # Sample in unit ball and transform to ellipsoid\n                while True:\n                    sample_unit = torch.randn(start.shape)\n                    if torch.norm(sample_unit) <= 1.0:\n                        break\n                # Scale factor along x is c_best / 2; along y sqrt(c_best^2 - c_min^2)/2; rotation aligns x axis start->goal\n                center = (start + goal) / 2\n                a1 = (goal - start) / c_min\n                # Build rotation matrix (2D or 3D)\n                dim = start.shape[0]\n                if dim == 2:\n                    # Rotation matrix from basis vector a1 to x-axis unit vector\n                    cos_theta = a1[0].item()\n                    sin_theta = a1[1].item()\n                    R = torch.tensor([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n                elif dim == 3:\n                    # 3D rotation: build orthonormal basis with a1 as x-axis\n                    x_axis = a1 / torch.norm(a1)\n                    # Arbitrary orthogonal vectors using cross product\n                    if abs(x_axis[0]) < 1e-3 and abs(x_axis[1]) < 1e-3:\n                        temp = torch.tensor([0.0, 1.0, 0.0])\n                    else:\n                        temp = torch.tensor([0.0, 0.0, 1.0])\n                    y_axis = torch.cross(temp, x_axis)\n                    y_axis /= torch.norm(y_axis)\n                    z_axis = torch.cross(x_axis, y_axis)\n                    R = torch.stack([x_axis, y_axis, z_axis]).T  # Columns are basis vectors\n                else:\n                    # Fallback: no rotation\n                    R = torch.eye(dim)\n\n                L = torch.diag(torch.tensor([\n                    c_best / 2,\n                    (c_best ** 2 - c_min ** 2) ** 0.5 / 2] + [1.0] * (dim - 2)))\n\n                sample_ellipse = R @ (L @ sample_unit) + center\n                sample_np = sample_ellipse.numpy()\n                sample_pt = Point(*map(float, sample_np))\n                if grid.is_agent_valid_pos(sample_pt):\n                    return sample_pt\n\n        # Otherwise, goal biasing with uniform random sample\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist=None) -> Vertex:\n        if max_dist is None:\n            max_dist = self._max_dist\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        dir_norm = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_norm\n        q_new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(q_new_pos, store_connectivity=True)\n\n    def _nearest_vertex(self, graph: CyclicGraph, vertices: List[Vertex], point: Point) -> Vertex:\n        return graph.get_nearest_vertex(vertices, point)\n\n    def _get_neighborhood(self, graph: CyclicGraph, vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        return graph.get_vertices_within_radius(vertices, point, radius)\n\n    def _line_is_free(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _update_cost(self, q_new: Vertex, q_near: Vertex) -> None:\n        if q_near.cost is None:\n            q_new.cost = self._get_grid().get_distance(q_near.position, q_new.position)\n        else:\n            q_new.cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n\n    def _rewire(self, graph: CyclicGraph, q_new: Vertex, neighborhood: List[Vertex]) -> None:\n        for q_near in neighborhood:\n            if q_near == q_new:\n                continue\n            if not self._line_is_free(q_new.position, q_near.position):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, q_near.position)\n            if q_near.cost is None or new_cost < q_near.cost:\n                for p in set(q_near.parents):\n                    graph.remove_edge(p, q_near)\n                graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _try_connect_trees(self, graph_a: CyclicGraph, q_new: Vertex, vertices_b: List[Vertex]) -> tuple | None:\n        q_near_b = self._nearest_vertex(graph_a, vertices_b, q_new.position)\n        if q_near_b.position == q_new.position:\n            return None\n        if not self._line_is_free(q_new.position, q_near_b.position):\n            return None\n        return q_new, q_near_b\n\n    def _extract_path(self, connection_vertex_start: Vertex, connection_vertex_goal: Vertex) -> None:\n        # Trace path root to connection start\n        path_start = [connection_vertex_start]\n        while path_start[-1].parents:\n            for p in path_start[-1].parents:\n                path_start.append(p)\n                break\n        path_start.reverse()\n\n        # Trace path connection goal to root\n        path_goal = [connection_vertex_goal]\n        while path_goal[-1].children:\n            for c in path_goal[-1].children:\n                path_goal.append(c)\n                break\n\n        full_path = path_start + path_goal\n\n        full_path = self._shortcut_path(full_path)\n\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list[Vertex]) -> list[Vertex]:\n        if len(path) < 3:\n            return path\n        shortened_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            while next_idx > idx + 1:\n                if self._line_is_free(path[idx].position, path[next_idx].position):\n                    break\n                next_idx -= 1\n            shortened_path.append(path[next_idx])\n            idx = next_idx\n        return shortened_path\n\n    def _find_path_internal(self) -> None:\n        start_time = time.perf_counter()\n\n        start_vertices = [self._graph_start.root_vertex_start]\n        goal_vertices = [self._graph_goal.root_vertex_start]\n\n        self._graph_start.root_vertex_start.cost = 0.0\n        self._graph_goal.root_vertex_start.cost = 0.0\n\n        for i in range(self._iterations):\n            # Time limit check\n            if time.perf_counter() - start_time > 60.0:\n                break\n\n            # Sample point with adaptive informed sampling & goal bias\n            q_sample = self._get_random_sample(i)\n\n            # Alternate expansion direction: even iterations start tree, odd goal tree\n            if i % 2 == 0:\n                tree_a_vertices = start_vertices\n                tree_b_vertices = goal_vertices\n                graph_a = self._graph_start\n                graph_b = self._graph_goal\n            else:\n                tree_a_vertices = goal_vertices\n                tree_b_vertices = start_vertices\n                graph_a = self._graph_goal\n                graph_b = self._graph_start\n\n            # Extend tree A towards sample point\n            q_near_a = self._nearest_vertex(graph_a, tree_a_vertices, q_sample)\n            q_new_a = self._get_new_vertex(q_near_a, q_sample)\n            if not self._line_is_free(q_near_a.position, q_new_a.position):\n                self.key_frame()\n                continue\n            self._update_cost(q_new_a, q_near_a)\n            graph_a.add_edge(q_near_a, q_new_a)\n            tree_a_vertices.append(q_new_a)\n\n            # Rewire nearby vertices for better paths\n            size = len(tree_a_vertices)\n            radius = min(self._rewire_radius_factor * np.sqrt(np.log(size + 1) / (size + 1)), self._max_dist * 2)\n            neighborhood = self._get_neighborhood(graph_a, tree_a_vertices, q_new_a.position, radius)\n            self._rewire(graph_a, q_new_a, neighborhood)\n\n            # Attempt connection to other tree\n            conn = self._try_connect_trees(graph_a, q_new_a, tree_b_vertices)\n            if conn is not None:\n                graph_b.add_edge(conn[1], conn[0])  # Connect other tree node to q_new_a\n                # Compute path cost candidates and update best path if improved\n                path_cost_candidate = q_new_a.cost + conn[1].cost + self._get_grid().get_distance(q_new_a.position, conn[1].position)\n                if path_cost_candidate < self._best_path_cost:\n                    self._best_path_cost = path_cost_candidate\n                    self._best_connection = (conn[0], conn[1])\n\n                # Extract best path and finish\n                if i > 100:  # Allow some iterations before early termination for path quality\n                    if graph_a == self._graph_start:\n                        self._extract_path(conn[0], conn[1])\n                    else:\n                        self._extract_path(conn[1], conn[0])\n                    return\n\n            # Extend tree B towards q_new_a.position, tries to connect more aggressively\n            q_near_b = self._nearest_vertex(graph_b, tree_b_vertices, q_new_a.position)\n            q_new_b = self._get_new_vertex(q_near_b, q_new_a.position)\n            if self._line_is_free(q_near_b.position, q_new_b.position):\n                self._update_cost(q_new_b, q_near_b)\n                graph_b.add_edge(q_near_b, q_new_b)\n                tree_b_vertices.append(q_new_b)\n\n                # Rewire tree B neighbors\n                size_b = len(tree_b_vertices)\n                radius_b = min(self._rewire_radius_factor * np.sqrt(np.log(size_b + 1) / (size_b + 1)), self._max_dist * 2)\n                neighborhood_b = self._get_neighborhood(graph_b, tree_b_vertices, q_new_b.position, radius_b)\n                self._rewire(graph_b, q_new_b, neighborhood_b)\n\n                # Check connection between new vertex and tree A\n                conn2 = self._try_connect_trees(graph_b, q_new_b, tree_a_vertices)\n                if conn2 is not None:\n                    graph_a.add_edge(conn2[1], conn2[0])\n                    path_cost_2 = q_new_b.cost + conn2[1].cost + self._get_grid().get_distance(q_new_b.position, conn2[1].position)\n                    if path_cost_2 < self._best_path_cost:\n                        self._best_path_cost = path_cost_2\n                        self._best_connection = (conn2[0], conn2[1])\n                    if i > 100:\n                        if graph_a == self._graph_start:\n                            self._extract_path(conn2[0], conn2[1])\n                        else:\n                            self._extract_path(conn2[1], conn2[0])\n                        return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 271, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 171, in PathPlanning\nTypeError: unsupported operand type(s) for |: 'type' and 'NoneType'\n"
     }
}
{
     "operator": "m2",
     "algorithm": "This algorithm is an enhanced bidirectional RRT* variant with adaptive step sizing,\n    dynamic rewiring radius scaling, and hybrid goal biasing for improved planning efficiency\n    and path quality. It grows two trees simultaneously from start and goal with alternating\n    expansions, utilizes a refined sampling strategy combining uniform and informed sampling\n    based on current best path cost, and performs rewiring to optimize connectivity and costs.\n    The algorithm dynamically adjusts exploration versus exploitation by gradually increasing\n    goal bias, employs shortcut smoothing post-processing for path smoothness, and includes\n    robust time-limited execution (60 seconds) to guarantee termination.\n\n    Key improvements include:\n    - Adaptive radius for rewiring considering vertex density and dimension\n    - Heuristic informed sampling around best-known path ball to accelerate convergence\n    - Gradual increase in goal bias probability to focus search as iterations grow\n    - Enhanced connectivity checks and cost updates for robustness\n    - Shortcut path smoothing after extraction for shorter, smoother solutions\n    - Early termination when goal is reached or time limit exceeded\n\n    Overall, it aims to improve success rate, reduce planning time, and generate high-quality,\n    smooth, and shorter paths than typical RRT* bidirectional planners.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    import time\n    import numpy as np\n    import torch\n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _timeout_seconds: float\n    _start_time: float\n    _goal_bias_min: float = 0.05\n    _goal_bias_max: float = 0.3\n    _goal_bias_inc_duration: int = 12000\n    _rewire_gamma: float = 40.0  # tuned for efficient radius scaling\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._iterations = 20000\n        self._max_dist = 14.0\n        self._timeout_seconds = 60.0\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            [],\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_goal_bias(self, iteration: int) -> float:\n        # Gradually increase goal bias with iterations up to max\n        if iteration < self._goal_bias_inc_duration:\n            return self._goal_bias_min + (self._goal_bias_max - self._goal_bias_min) * (iteration / self._goal_bias_inc_duration)\n        return self._goal_bias_max\n\n    def _get_random_sample(self, iteration: int) -> Point:\n        \"\"\"\n        Samples a random valid point within the map with adaptive goal bias.\n        Incorporates uniform and heuristic informed sampling based on path progress.\n        \"\"\"\n        grid = self._get_grid()\n        goal_pos = self._graph.root_vertex_goal.position\n        goal_bias = self._get_goal_bias(iteration)\n\n        if np.random.rand() < goal_bias:\n            return goal_pos\n\n        # If a path to goal is known, bias sampling around start-goal corridor (informed sampling)\n        if self._graph.root_vertex_goal.cost is not None and self._graph.root_vertex_goal.cost < float('inf'):\n            start_pos = self._graph.root_vertex_start.position\n            max_dist = self._graph.root_vertex_goal.cost\n            dim = grid.size.n_dim\n\n            # Sample a point inside an ellipsoid defined by start/goal and max_dist (in 2D circle approx)\n            center = (start_pos.to_tensor() + goal_pos.to_tensor()) / 2\n            a = max_dist / 2  # ellipse major axis approx\n            b = max_dist / 3  # ellipse minor axis approx\n\n            # Sample random point inside ellipse scaled to grid size\n            angle = np.random.uniform(0, 2 * np.pi)\n            r = np.random.uniform(0, 1)\n            r_sqrt = np.sqrt(r)\n            x_ellipse = r_sqrt * a * np.cos(angle)\n            y_ellipse = r_sqrt * b * np.sin(angle)\n\n            # In 2D only - fallback to uniform sample if dimension > 2\n            if dim == 2:\n                sample_tensor = center.clone()\n                sample_tensor[0] += x_ellipse\n                sample_tensor[1] += y_ellipse\n                sample_point = Point(*[int(round(c)) for c in sample_tensor.tolist()])\n                if grid.is_agent_valid_pos(sample_point):\n                    return sample_point\n\n        # Fallback uniform random valid position sampling\n        sz = grid.size\n        while True:\n            rand_coords = [np.random.randint(0, sz[i]) for i in range(sz.n_dim)]\n            sample = Point(*rand_coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        from_pos = from_vertex.position.to_tensor()\n        to_pos = to_point.to_tensor()\n        dir_vec = to_pos - from_pos\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(to_point, store_connectivity=True)\n        dir_unit = dir_vec / dist\n        new_pos_tensor = from_pos + dir_unit * max_dist\n        new_point = Point(*[int(round(c)) for c in new_pos_tensor.tolist()])\n        return Vertex(new_point, store_connectivity=True)\n\n    def _near_vertices(self, vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(vertices, point, radius)\n\n    def _choose_parent(self, near_vertices: List[Vertex], new_vertex: Vertex) -> Vertex:\n        best_parent = None\n        best_cost = float('inf')\n        grid = self._get_grid()\n\n        for vertex in near_vertices:\n            if vertex.position == new_vertex.position:\n                continue\n            line_seq = grid.get_line_sequence(vertex.position, new_vertex.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            if vertex.cost is None:\n                continue\n            cost_through_vertex = vertex.cost + grid.get_movement_cost(vertex.position, new_vertex.position)\n            if cost_through_vertex < best_cost:\n                best_cost = cost_through_vertex\n                best_parent = vertex\n\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], new_vertex: Vertex) -> None:\n        grid = self._get_grid()\n        for vertex in near_vertices:\n            if vertex is new_vertex or vertex.cost is None or new_vertex.cost is None:\n                continue\n            line_seq = grid.get_line_sequence(new_vertex.position, vertex.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            new_cost = new_vertex.cost + grid.get_movement_cost(new_vertex.position, vertex.position)\n            if new_cost < vertex.cost:\n                for p in list(vertex.parents):\n                    self._graph.remove_edge(p, vertex)\n                self._graph.add_edge(new_vertex, vertex)\n                vertex.cost = new_cost\n                # Ensure connectivity dictionaries exist\n                if new_vertex.connectivity is None:\n                    new_vertex.connectivity = {}\n                if vertex.connectivity is None:\n                    vertex.connectivity = {}\n                target = self._graph.root_vertex_goal\n                if target not in new_vertex.connectivity:\n                    new_vertex.connectivity[target] = new_vertex\n                vertex.connectivity[target] = new_vertex.connectivity[target]\n\n    def _can_connect(self, from_vertex: Vertex, to_vertex: Vertex) -> bool:\n        line_seq = self._get_grid().get_line_sequence(from_vertex.position, to_vertex.position)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _extract_path(self) -> None:\n        goal_vertex = self._graph.root_vertex_goal\n        if goal_vertex.cost is None or goal_vertex.cost == float('inf'):\n            return\n        path = []\n        current = goal_vertex\n        while current.parents:\n            path.append(current)\n            current = min(current.parents, key=lambda v: v.cost if v.cost is not None else float('inf'))\n        path.append(current)  # Append start\n        path.reverse()\n\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        shortened_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            while next_idx > idx + 1:\n                if self._can_connect(path[idx], path[next_idx]):\n                    break\n                next_idx -= 1\n            shortened_path.append(path[next_idx])\n            idx = next_idx\n        return shortened_path\n\n    def _try_connect_trees(self, start_vertices: List[Vertex], goal_vertices: List[Vertex]) -> bool:\n        grid = self._get_grid()\n        best_pair = None\n        best_cost = float('inf')\n        for v_start in start_vertices:\n            for v_goal in goal_vertices:\n                if v_start.cost is None or v_goal.cost is None:\n                    continue\n                if not self._can_connect(v_start, v_goal):\n                    continue\n                dist = grid.get_distance(v_start.position, v_goal.position)\n                total_cost = v_start.cost + dist + v_goal.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pair = (v_start, v_goal)\n\n        if best_pair is None:\n            return False\n\n        v_start, v_goal = best_pair\n        self._graph.add_edge(v_start, v_goal)\n        self._graph.add_edge(v_goal, v_start)\n\n        if v_start.cost is None:\n            v_start.cost = 0.0\n        if v_goal.cost is None or v_goal.cost > v_start.cost + grid.get_distance(v_start.position, v_goal.position):\n            v_goal.cost = v_start.cost + grid.get_distance(v_start.position, v_goal.position)\n        if self._graph.root_vertex_goal.cost is None:\n            self._graph.root_vertex_goal.cost = float('inf')\n\n        self._extract_path()\n        return True\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        self._start_time = time.time()\n\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')\n\n        start_vertices = [self._graph.root_vertex_start]\n        goal_vertices = [self._graph.root_vertex_goal]\n        grid = self._get_grid()\n        dimension = grid.size.n_dim\n\n        for iteration in range(self._iterations):\n            if time.time() - self._start_time > self._timeout_seconds:\n                # Failed: Timeout exceeded 60s\n                break\n\n            tree_index = iteration % 2\n            tree_root = self._graph.root_vertices[tree_index]\n            other_tree_root = self._graph.root_vertices[1 - tree_index]\n\n            # Sample with adaptive goal bias and informed sampling\n            q_rand = self._get_random_sample(iteration)\n\n            # Nearest vertex in current tree to q_rand\n            current_tree_vertices = start_vertices if tree_index == 0 else goal_vertices\n            q_near = self._graph.get_nearest_vertex([tree_root], q_rand)\n            q_new = self._steer(q_near, q_rand, self._max_dist)\n\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                self.key_frame()\n                continue\n\n            n_vertices = len(current_tree_vertices)\n            if n_vertices == 0:\n                radius = self._max_dist\n            else:\n                radius = min(self._max_dist,\n                             self._rewire_gamma * (np.log(n_vertices + 1) / (n_vertices + 1))**(1 / dimension))\n\n            near_vertices = self._near_vertices([tree_root], q_new.position, radius)\n            if q_near not in near_vertices:\n                near_vertices.append(q_near)\n\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                self.key_frame()\n                continue\n\n            q_new.cost = best_parent.cost + grid.get_movement_cost(best_parent.position, q_new.position)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Initialize connectivity dicts if missing\n            if tree_root.connectivity is None:\n                tree_root.connectivity = {}\n            if q_new.connectivity is None:\n                q_new.connectivity = {}\n\n            # Ensure root vertex connectivity entries\n            if tree_root not in tree_root.connectivity:\n                tree_root.connectivity[tree_root] = tree_root\n            if self._graph.root_vertex_goal not in self._graph.root_vertex_goal.connectivity:\n                self._graph.root_vertex_goal.connectivity[self._graph.root_vertex_goal] = self._graph.root_vertex_goal\n\n            # Add new vertex to tree and connectivity\n            tree_root.connectivity[q_new] = q_new\n            if tree_index == 0:\n                start_vertices.append(q_new)\n            else:\n                goal_vertices.append(q_new)\n\n            self._rewire(near_vertices, q_new)\n\n            # Attempt fast connect trees at new node\n            q_new_near_other_tree = self._graph.get_nearest_vertex([other_tree_root], q_new.position)\n            if self._can_connect(q_new, q_new_near_other_tree):\n                self._graph.add_edge(q_new, q_new_near_other_tree)\n                self._graph.add_edge(q_new_near_other_tree, q_new)\n                # Check for goal precision\n                if (grid.is_goal_reached(q_new.position) or grid.is_goal_reached(q_new_near_other_tree.position)):\n                    self._extract_path()\n                    return\n\n            # Attempt global connect between trees every 200 iterations for robustness\n            if iteration % 200 == 0:\n                if self._try_connect_trees(start_vertices, goal_vertices):\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 276, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 235, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 216, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 304, in _find_path_internal\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\classic\\sample_based\\core\\graph.py\", line 89, in add_edge\n    parent.add_child(child)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\classic\\sample_based\\core\\vertex.py\", line 56, in add_child\n    self.__add_connectivity(child)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\classic\\sample_based\\core\\vertex.py\", line 48, in __add_connectivity\n    new_vertex_path_step = vertex_to_update.connectivity[new_vertex_path_target]\nKeyError: <algorithms.classic.sample_based.core.vertex.Vertex object at 0x000001B9E7EBC3D0>\n"
     }
}
{
     "operator": "e2",
     "algorithm": "Hybrid Bidirectional RRT*-Informed Algorithm with Adaptive Radius, Dynamic Step Size,\n    and Heuristic Heavily Biased Sampling Combined with Path Smoothing.\n\n    This algorithm grows two trees from start and goal positions simultaneously. It uses an\n    adaptive sampling strategy inspired by informed sampling: samples are drawn either near\n    the current best path ellipse (informed subset) or randomly when no valid path exists yet,\n    to focus exploration on promising regions while maintaining global coverage.\n\n    Adaptive step size and radius computed dynamically according to the map size and iteration\n    count improve search efficiency and connectivity. Trees are rewired upon new vertex insertion\n    to reduce costs, and attempts to connect two trees frequently shorten the planning time.\n\n    Once a path is found, a post-processing smoothing step improves path quality and smoothness.\n\n    The whole planning is time-limited to 60 seconds to ensure robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_base: float\n    _iterations: int\n    _start_time: float\n    _timeout_seconds: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        # Adjusted max dist base as fraction of map diagonal later dynamically\n        self._iterations = 25000\n        self._timeout_seconds = 60.0\n        grid = self._get_grid()\n\n        start_vertex = Vertex(grid.agent.position, store_connectivity=True)\n        goal_vertex = Vertex(grid.goal.position, store_connectivity=True)\n        goal_vertex.cost = float('inf')\n        start_vertex.cost = 0.0\n        self._graph = gen_forest(services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._max_dist_base = None  # Will be set at runtime based on map diagonal\n\n        self._init_displays()\n\n    def _map_diagonal(self) -> float:\n        sz = self._get_grid().size\n        return (sum((v ** 2 for v in sz.values))) ** 0.5\n\n    def _informed_sample(self, c_best: float, start: Point, goal: Point) -> Point:\n        \"\"\"\n        Informed sampling inside an ellipsoid defined by current best cost.\n        If no path found (c_best=inf), fallback to uniform random sampling.\n        \"\"\"\n        grid = self._get_grid()\n        dim = grid.size.n_dim\n\n        if c_best == float('inf'):\n            # Uniform random in grid with validity check\n            while True:\n                coords = [np.random.randint(0, grid.size[i]) for i in range(dim)]\n                p = Point(*coords)\n                if grid.is_agent_valid_pos(p):\n                    return p\n\n        # Ellipsoid sampling\n        c_min = grid.get_distance(start, goal)\n        if c_best < c_min:\n            c_best = c_min * 1.0001  # avoid division by zero / degenerate\n\n        center_tensor = (start.to_tensor() + goal.to_tensor()) / 2\n        dir_line = (goal.to_tensor() - start.to_tensor())\n        e1 = dir_line / torch.norm(dir_line)\n\n        # Generate orthonormal basis U (dim x dim)\n        U = torch.eye(dim)\n        U[:, 0] = e1\n\n        # Lengths of ellipse axes\n        r1 = c_best / 2\n        other_r = (c_best ** 2 - c_min ** 2) ** 0.5 / 2 if c_best > c_min else 0.0\n\n        while True:\n            # Sample in unit n-ball\n            x_ball = torch.randn(dim)\n            x_ball /= torch.norm(x_ball)\n            radius = torch.pow(torch.rand(1), 1.0 / dim)\n            sample_ball = x_ball * radius\n\n            # Scale to ellipsoid\n            sample_scaled = sample_ball * torch.tensor([r1] + [other_r] * (dim - 1))\n\n            # Map to world coords\n            sample_point = center_tensor + U @ sample_scaled\n            sample_coords = tuple(int(max(0, min(self._get_grid().size[i]-1, sample_point[i].item()))) for i in range(dim))\n            point = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(point):\n                return point\n\n    def _steer(self, frm: Vertex, to: Point, max_dist: float) -> Vertex:\n        from_pos = frm.position.to_tensor()\n        to_pos = to.to_tensor()\n        direction = to_pos - from_pos\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            return Vertex(to, store_connectivity=True)\n        direction_unit = direction / dist\n        new_pos_tensor = from_pos + direction_unit * max_dist\n        new_point = Point(*[max(0, min(self._get_grid().size[i]-1, float(new_pos_tensor[i]))) for i in range(self._get_grid().size.n_dim)])\n        return Vertex(new_point, store_connectivity=True)\n\n    def _choose_parent(self, near_vertices, new_vertex) -> Vertex or None:\n        best_parent = None\n        best_cost = float('inf')\n        grid = self._get_grid()\n        for v in near_vertices:\n            if v.position == new_vertex.position:\n                continue\n            line_seq = grid.get_line_sequence(v.position, new_vertex.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            if v.cost is None:\n                continue\n            cost = v.cost + grid.get_movement_cost(v.position, new_vertex.position)\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = v\n        return best_parent\n\n    def _rewire(self, near_vertices, new_vertex):\n        grid = self._get_grid()\n        for v in near_vertices:\n            if v == new_vertex or v.cost is None or new_vertex.cost is None:\n                continue\n            line_seq = grid.get_line_sequence(new_vertex.position, v.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            new_cost = new_vertex.cost + grid.get_movement_cost(new_vertex.position, v.position)\n            if new_cost < v.cost:\n                # Remove old parent edges\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(new_vertex, v)\n                v.cost = new_cost\n                # Update connectivity for goal target to avoid key errors\n                target = self._graph.root_vertex_goal\n                if new_vertex.connectivity is None:\n                    new_vertex.connectivity = {}\n                if target not in new_vertex.connectivity:\n                    new_vertex.connectivity[target] = new_vertex\n                if v.connectivity is None:\n                    v.connectivity = {}\n                v.connectivity[target] = new_vertex.connectivity[target]\n\n    def _can_connect(self, from_vertex: Vertex, to_vertex: Vertex) -> bool:\n        line_seq = self._get_grid().get_line_sequence(from_vertex.position, to_vertex.position)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _extract_path(self) -> None:\n        \"\"\"\n        Trace back path from goal to start choosing parents with lowest cost.\n        Then move the agent along the found path with key frames.\n        Additionally run smoothing of path after extraction.\n        \"\"\"\n        goal_v = self._graph.root_vertex_goal\n        if goal_v.cost is None or goal_v.cost == float('inf'):\n            return  # no path found\n\n        # Reconstruct via cheapest parents path\n        path = []\n        current = goal_v\n        while current.parents:\n            path.append(current)\n            # Choose parent with least cost\n            current = min(current.parents, key=lambda v: v.cost if v.cost is not None else float('inf'))\n        path.append(current)  # start\n        path.reverse()\n\n        # Apply simple smoothing post-processing to path\n        smoothed_path = self._smooth_path(path)\n\n        # Move agent along smoothed path with key frames\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _smooth_path(self, path: list) -> list:\n        \"\"\"\n        Path smoothing by shortcutting: Try to connect non-adjacent vertices directly if no obstacles.\n        \"\"\"\n        if len(path) <= 2:\n            return path\n\n        grid = self._get_grid()\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            # Look for farthest vertex reachable from i without obstacles\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _try_connect_trees(self) -> bool:\n        \"\"\"\n        Try to connect any vertices from start tree with any vertices from goal tree.\n        If connected, update costs and extract path.\n        \"\"\"\n        start_root = self._graph.root_vertex_start\n        goal_root = self._graph.root_vertex_goal\n\n        # Gather full lists of vertices in both trees by BFS to improve performance\n        def gather_all_vertices(root):\n            visited = set()\n            queue = [root]\n            vertices = []\n            while queue:\n                v = queue.pop()\n                if v in visited:\n                    continue\n                visited.add(v)\n                vertices.append(v)\n                queue.extend(v.children)\n            return vertices\n\n        start_vertices = gather_all_vertices(start_root)\n        goal_vertices = gather_all_vertices(goal_root)\n\n        grid = self._get_grid()\n        for v_start in start_vertices:\n            if v_start.cost is None:\n                continue\n            for v_goal in goal_vertices:\n                if v_goal.cost is None:\n                    continue\n                if self._can_connect(v_start, v_goal):\n                    self._graph.add_edge(v_start, v_goal)\n                    self._graph.add_edge(v_goal, v_start)\n\n                    dist = grid.get_distance(v_start.position, v_goal.position)\n                    prev_cost_goal = v_goal.cost or float('inf')\n                    new_cost_goal = v_start.cost + dist\n                    if new_cost_goal < prev_cost_goal:\n                        v_goal.cost = new_cost_goal\n                        if self._graph.root_vertex_goal.cost is None or self._graph.root_vertex_goal.cost > new_cost_goal:\n                            self._graph.root_vertex_goal.cost = new_cost_goal\n\n                    self._extract_path()\n                    return True\n        return False\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        self._start_time = time.time()\n        grid = self._get_grid()\n        dim = grid.size.n_dim\n\n        # Precompute map diagonal and set max dist base as ~5% of diagonal capped\n        diag = self._map_diagonal()\n        self._max_dist_base = max(3.0, min(25.0, 0.05 * diag))\n\n        start_root = self._graph.root_vertex_start\n        goal_root = self._graph.root_vertex_goal\n\n        # Initialize vertex collections for radius computations\n        start_vertices = [start_root]\n        goal_vertices = [goal_root]\n\n        c_best = float('inf')  # Current best path cost to bias informed sampling\n\n        for it in range(self._iterations):\n            if time.time() - self._start_time > self._timeout_seconds:\n                # Timeout treated as failure, exit planning\n                break\n\n            # Alternate growing trees: 0 - start tree, 1 - goal tree\n            tree_idx = it % 2\n            tree_root = self._graph.root_vertices[tree_idx]\n            other_root = self._graph.root_vertices[1 - tree_idx]\n            tree_vertices = start_vertices if tree_idx == 0 else goal_vertices\n\n            # Adaptive max step size decreases slightly as iterations increase, min 3.0\n            max_dist = max(3.0, self._max_dist_base * (1 - 0.7 * (it / self._iterations)))\n\n            # Sample with heuristic informed sampling bias near current best cost\n            q_rand = self._informed_sample(c_best, start_root.position, goal_root.position)\n\n            q_near = self._graph.get_nearest_vertex([tree_root], q_rand)\n            q_new = self._steer(q_near, q_rand, max_dist)\n\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                self.key_frame()\n                continue\n\n            n_vertices = len(tree_vertices)\n            if n_vertices == 0:\n                radius = max_dist\n            else:\n                gamma = 25.0\n                radius = min(max_dist, gamma * ((np.log(n_vertices + 1) / (n_vertices + 1)) ** (1 / dim)))\n\n            near_vertices = self._graph.get_vertices_within_radius([tree_root], q_new.position, radius)\n            if q_near not in near_vertices:\n                near_vertices.append(q_near)\n\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                self.key_frame()\n                continue\n\n            q_new.cost = best_parent.cost + grid.get_movement_cost(best_parent.position, q_new.position)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Initiate connectivity dicts if needed\n            if tree_root.connectivity is None:\n                tree_root.connectivity = {}\n            if q_new.connectivity is None:\n                q_new.connectivity = {}\n\n            if tree_root not in tree_root.connectivity:\n                tree_root.connectivity[tree_root] = tree_root\n            if goal_root not in goal_root.connectivity:\n                goal_root.connectivity[goal_root] = goal_root\n\n            tree_root.connectivity[q_new] = q_new\n            tree_vertices.append(q_new)\n\n            # Rewire in local neighborhood to optimize paths\n            self._rewire(near_vertices, q_new)\n\n            # Attempt bridge connection to other tree\n            q_new_near_other = self._graph.get_nearest_vertex([other_root], q_new.position)\n            if self._can_connect(q_new, q_new_near_other):\n                self._graph.add_edge(q_new, q_new_near_other)\n                self._graph.add_edge(q_new_near_other, q_new)\n\n                # Update costs if necessary\n                dist_bridge = grid.get_distance(q_new.position, q_new_near_other.position)\n                if q_new_near_other.cost is None or q_new_near_other.cost > q_new.cost + dist_bridge:\n                    q_new_near_other.cost = q_new.cost + dist_bridge\n                    if other_root is goal_root:\n                        if c_best > q_new_near_other.cost:\n                            c_best = q_new_near_other.cost\n\n                if grid.is_goal_reached(q_new.position) or grid.is_goal_reached(q_new_near_other.position):\n                    c_best = min(c_best, q_new.cost + dist_bridge)\n                    self._extract_path()\n                    return\n\n            # Also attempt to connect trees generally to improve success rate\n            if it % 50 == 0:\n                connected = self._try_connect_trees()\n                if connected:\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 276, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 235, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 216, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 338, in _find_path_internal\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\classic\\sample_based\\core\\graph.py\", line 89, in add_edge\n    parent.add_child(child)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\classic\\sample_based\\core\\vertex.py\", line 56, in add_child\n    self.__add_connectivity(child)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\classic\\sample_based\\core\\vertex.py\", line 48, in __add_connectivity\n    new_vertex_path_step = vertex_to_update.connectivity[new_vertex_path_target]\nKeyError: <algorithms.classic.sample_based.core.vertex.Vertex object at 0x000001B9E2C858B0>\n"
     }
}
{
     "operator": "m3",
     "algorithm": "An improved sample-based path planning algorithm inspired by RRT* with these enhancements:\n     - Adaptive informed sampling focused around start-goal to increase sampling efficiency.\n     - Dynamic neighborhood radius based on graph size and dimension for optimal rewiring and connectivity.\n     - Goal biasing to speed early convergence.\n     - Efficient rewiring to improve path cost and quality.\n     - Path smoothing via shortcutting after path extraction.\n     - Timeout handling to fail gracefully after 60 seconds.\n     The algorithm maintains a forest graph rooted at start and attempts incremental tree expansions towards valid samples,\n     rewiring neighbor connections for better paths, and extracts a smooth, cost-efficient path once the goal region is reached.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _max_radius: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _start_vertex: Vertex\n    _goal_vertex: Vertex\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._start_vertex = Vertex(self._get_grid().agent.position)\n        self._start_vertex.cost = 0.0\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, self._start_vertex, self._goal_vertex, [])\n        self._max_dist = 12.0  # max extension length\n        self._max_radius = 40.0  # max neighbor radius\n        self._lambda_rrt_star = 40.0  # RRT* constant for adaptive radius\n        self._dimension = self._get_grid().size.n_dim\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Goal biasing with 10% probability\n        if torch.rand(1).item() < 0.1:\n            return self._goal_vertex.position\n\n        # 75% informed sampling, else uniform random\n        if torch.rand(1).item() < 0.75:\n            return self._informed_sample()\n        else:\n            return self._uniform_valid_sample()\n\n    def _uniform_valid_sample(self) -> Point:\n        while True:\n            coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _informed_sample(self) -> Point:\n        start = self._start_vertex.position.to_tensor()\n        goal = self._goal_vertex.position.to_tensor()\n        c_min = torch.norm(start - goal).item()\n        if c_min < 1e-5:\n            return self._uniform_valid_sample()\n\n        center = (start + goal) / 2\n        a1 = (goal - start) / c_min\n\n        if self._dimension == 2:\n            a2 = torch.tensor([-a1[1].item(), a1[0].item()])\n            basis = torch.stack([a1, a2], dim=1)  # 2x2 matrix\n        else:\n            basis = torch.eye(self._dimension)\n            basis[:, 0] = a1.flatten()\n\n        r1 = c_min / 2\n        inflation = 1.5\n        radii = torch.tensor([r1] + [inflation * r1] * (self._dimension - 1))\n\n        rand_point = torch.randn(self._dimension)\n        rand_point /= torch.norm(rand_point)\n        rand_radius = torch.rand(1).item() ** (1.0 / self._dimension)\n        rand_point = rand_point * rand_radius\n\n        sample_vec = rand_point * radii\n\n        sample_coords = basis @ sample_vec + center\n\n        clamped_coords = []\n        for i in range(self._dimension):\n            val = int(round(sample_coords[i].item()))\n            val = max(0, min(val, self._get_grid().size[i] - 1))\n            clamped_coords.append(val)\n\n        sample = Point(*clamped_coords)\n        if not self._get_grid().is_agent_valid_pos(sample):\n            return self._uniform_valid_sample()\n        return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        # Search among all existing vertices\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> list:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        diff = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(diff).item()\n        if dist == 0:\n            return None\n        if dist <= max_dist:\n            candidate_pos = q_sample\n        else:\n            dir_norm = diff / dist\n            new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_norm\n            coords = tuple(int(round(x.item())) for x in new_pos_tensor)\n            candidate_pos = Point(*coords)\n\n        if self._get_grid().is_agent_valid_pos(candidate_pos):\n            return Vertex(candidate_pos)\n        return None\n\n    def _extract_path(self, q_goal_vertex: Vertex) -> None:\n        path: list = [q_goal_vertex]\n        current = q_goal_vertex\n        while current.parents:\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n        self._smooth_path(path)\n\n    def _smooth_path(self, path: list) -> None:\n        if len(path) < 3:\n            return\n\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_points = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_points):\n                    smoothed_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                smoothed_path.append(path[i + 1])\n                i += 1\n\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import math\n\n        start_time = time.time()\n        max_iters = 15000\n\n        for _ in range(max_iters):\n            if (time.time() - start_time) > 60.0:\n                # Fail gracefully after 60 sec timeout\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            if q_new is None:\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cardinality = float(self._graph.size) if self._graph.size > 0 else 1.0\n            log_card = math.log(cardinality)\n            radius = min(\n                self._lambda_rrt_star * ((log_card / cardinality) ** (1.0 / self._dimension)),\n                self._max_radius,\n            )\n\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent minimizing cost\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor()).item()\n            for q_near in neighbors:\n                if q_near == q_nearest:\n                    continue\n                line_seq_near = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_near):\n                    cost = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n                    if cost < c_min:\n                        q_min = q_near\n                        c_min = cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to potentially better paths through q_new\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_back = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_back):\n                    continue\n                new_cost = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n                if q_near.cost is None or new_cost < q_near.cost:\n                    old_parent = next(iter(q_near.parents), None)\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n            self._graph.root_vertices.append(q_new)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 276, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 235, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 216, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 217, in _find_path_internal\nTypeError: unsupported operand type(s) for +: 'NoneType' and 'float'\n"
     }
}
