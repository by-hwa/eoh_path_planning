[
     {
          "algorithm": "This is the RRT algorithm, a sample-based pathfinding algorithm that explores the space by randomly sampling points and connecting them to the nearest vertex.",
          "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\n\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.basic_testing import BasicTesting\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\n\nfrom simulator.services.services import Services\n\nfrom structures import Point\n\n\nclass RRT(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        if torch.norm(dir) <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / torch.norm(dir)\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self, q_new):\n\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)    #connect the last sampled point that's close to goal vertex and connet point to goal vertex with edge\n        path: List[Vertex] = [goal_v]    \n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        #get animation of path tracing from start to goal\n        for p in path:\n            self.move_agent(p.position)   \n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n\n        max_dist: float = 10\n        iterations: int = 10000\n\n        for i in range(iterations):\n\n            q_sample: Point = self._get_random_sample()     #sample a random point and return it if it's in valid position\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample) \n            if q_near.position == q_sample:\n                continue    #restart the while loop right away if sample point same as nearest vertex point\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)    #get new vertex\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):    \n                continue    #restart the while loop right away if the straight line path from nearest vertex to new sample point is invalid \n            self._graph.add_edge(q_near, q_new)    #add edge between 2 points\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):    #if agent is in goal radius, then run _extract_path method \n                self._extract_path(q_new)\n                break\n\n            self.key_frame()    #add the new vertex and edge if the new sample point is not at goal yet\n",
          "objective": 0,
          "other_inf": null
     },
     {
          "operator": "e1",
          "algorithm": "PathPlanning is an improved sampling-based algorithm combining ideas from RRT*, informed sampling,\n    and lazy collision checking with shortcut smoothing for better efficiency, path quality, and robustness.\n    It incrementally builds a tree from start to goal, biased by an ellipsoidal informed sampling region once\n    a feasible path is found, reducing unnecessary exploration. Lazy collision checking postpones expensive\n    validations until necessary, improving speed. After reaching the goal, a path smoothing phase shortcutting\n    unnecessary vertices is executed for improved path smoothness and shorter path length.\n    The search stops and fails gracefully if exceeding 10 seconds runtime.",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _max_radius: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _start_time: float\n    _samples_taken: int\n    _found_path: bool\n    _best_goal_vertex: Optional[Vertex]\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        self._max_dist = 12.0\n        self._max_radius = 40.0\n        self._lambda_rrt_star = 40.0\n        self._dimension = self._get_grid().size.n_dim\n\n        self._start_time = 0\n        self._samples_taken = 0\n        self._found_path = False\n        self._best_goal_vertex = None\n\n        self._init_displays()\n\n    def _get_random_sample(self, informed_ball: Optional[tuple] = None) -> Point:\n        \"\"\"\n        Samples either uniformly from the entire workspace or \n        inside an ellipsoidal informed subset if informed_ball is specified.\n        informed_ball = (center: Point, c_best: float, c_min: float)\n        \"\"\"\n        grid_size = self._get_grid().size\n        if informed_ball is None:\n            # Uniform random sampling valid for whole space\n            while True:\n                rand_coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(grid_size.n_dim)]\n                sample = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Sample inside informed ellipsoid between start and goal\n            c_best = informed_ball[1]\n            c_min = informed_ball[2]\n            center = informed_ball[0]\n            \n            # Major axis length: c_best\n            # Minor axis lengths: sqrt(c_best^2 - c_min^2)\n            # For simplicity, handle 2D only ellipsoid sampling (works well in 2D):\n            # If higher dims exist, revert to uniform sampling\n            \n            if grid_size.n_dim != 2:\n                # fallback to uniform if not 2D\n                return self._get_random_sample(None)\n            \n            success = False\n            sample = None\n            \n            for _ in range(200):  # limit to attempts\n                rx = torch.FloatTensor(1).uniform_(-1,1).item()\n                ry = torch.FloatTensor(1).uniform_(-1,1).item()\n                norm = (rx**2 + ry**2)**0.5\n                if norm > 1e-5:\n                    break\n            if norm < 1e-5:\n                # fallback to uniform\n                return self._get_random_sample(None)\n            rx /= norm\n            ry /= norm\n\n            # Sample radius uniformly between 0 and 1, cube root for volume preservation\n            r = torch.FloatTensor(1).uniform_(0,1).item() ** (1/2)\n            a1 = c_best / 2\n            a2 = (c_best**2 - c_min**2)**0.5 / 2\n\n            x = r * a1 * rx\n            y = r * a2 * ry\n\n            # Rotation: from the vector start -> goal angle\n            start = self._graph.root_vertex_start.position\n            goal = self._graph.root_vertex_goal.position\n            delta = torch.tensor([goal.x - start.x, goal.y - start.y])\n            angle = torch.atan2(delta[1], delta[0]).item()\n\n            cos_ang = torch.cos(torch.tensor(angle))\n            sin_ang = torch.sin(torch.tensor(angle))\n            rot_x = cos_ang * x - sin_ang * y\n            rot_y = sin_ang * x + cos_ang * y\n\n            sample_x = int(round(center.x + rot_x))\n            sample_y = int(round(center.y + rot_y))\n\n            # Clamp sample inside grid\n            sample_x = max(0, min(sample_x, grid_size[0] - 1))\n            sample_y = max(0, min(sample_y, grid_size[1] - 1))\n\n            sample = Point(sample_x, sample_y)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            else:\n                # fallback uniform sampling if invalid\n                return self._get_random_sample(None)\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Optional[Vertex]:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec)\n        if length < 1e-6:\n            return None\n        if length <= self._max_dist:\n            new_vertex_pos = q_sample\n        else:\n            dir_normalized = dir_vec / length\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n            new_vertex_pos = Point.from_tensor(new_pos_tensor)\n\n        if not self._get_grid().is_agent_valid_pos(new_vertex_pos):\n            return None\n\n        return Vertex(new_vertex_pos)\n\n    def _line_collision_free_lazy(self, frm: Point, to: Point) -> bool:\n        \"\"\"\n        Lazy collision check postpones detailed checking when possible.\n        Here, fast line validity check with early stop at first obstacle.\n        \"\"\"\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        # Instead of fully calling is_valid_line_sequence (which might be thorough),\n        # iterate and check for obstacles directly, early stop on collision\n        for pt in line_seq:\n            if not self._get_grid().is_agent_valid_pos(pt):\n                return False\n        return True\n\n    def _rewire(self, q_new: Vertex, Q_near: List[Vertex]) -> None:\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n            if dist > self._max_dist:\n                continue\n            new_cost = q_new.cost + dist\n            if new_cost < q_near.cost:\n                if self._line_collision_free_lazy(q_new.position, q_near.position):\n                    # Remove old parent edge\n                    old_parent = None\n                    for p in q_near.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    # Add new edge\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, goal_vertex: Vertex) -> List[Vertex]:\n        path = [goal_vertex]\n        while len(path[-1].parents) > 0:\n            # choose parent with lowest cost (usually one parent in tree)\n            min_parent = None\n            min_cost = float('inf')\n            for parent in path[-1].parents:\n                if parent.cost is not None and parent.cost < min_cost:\n                    min_cost = parent.cost\n                    min_parent = parent\n            if min_parent is None:\n                break\n            path.append(min_parent)\n        path.reverse()\n        return path\n\n    def _smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Path shortcutting: tries to replace longer path segments with direct edges,\n        removing intermediate unnecessary vertices.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            # Move backward to find furthest reachable vertex without collision\n            while j > i + 1:\n                if self._line_collision_free_lazy(path[i].position, path[j].position):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.perf_counter()\n        max_time_sec = 10.0\n\n        start: Vertex = self._graph.root_vertex_start\n        goal: Vertex = self._graph.root_vertex_goal\n\n        start.cost = 0.0\n        best_cost = float('inf')\n        best_goal_vertex: Optional[Vertex] = None\n\n        max_iterations = 15000\n        self._found_path = False\n\n        for iteration in range(max_iterations):\n            if time.perf_counter() - self._start_time > max_time_sec:\n                # Fail safe: terminate search and fail\n                break\n\n            # After path found, use informed sampling in ellipse around start and goal\n            if self._found_path and best_goal_vertex and best_cost < float('inf'):\n                c_min = torch.norm(start.position.to_tensor() - goal.position.to_tensor()).item()\n                c_best = best_cost\n                center = Point((start.position.x + goal.position.x)/2, (start.position.y + goal.position.y)/2)\n                q_sample = self._get_random_sample(informed_ball=(center, c_best, c_min))\n            else:\n                q_sample = self._get_random_sample()\n\n            q_near = self._get_nearest_vertex(q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample)\n            if q_new is None:\n                continue\n\n            # Lazy collision checking line from q_near to q_new\n            if not self._line_collision_free_lazy(q_near.position, q_new.position):\n                continue\n\n            cost_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = cost_to_new\n\n            # Nearby vertices for rewiring\n            card_V = max(1, self._graph.size)\n            log_card_V = torch.log(torch.tensor(float(card_V) + 1e-8))\n            radius = min(self._lambda_rrt_star * ((log_card_V / card_V) ** (1.0 / self._dimension)), self._max_radius)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent with minimum cost + collision-free connection\n            q_min = q_near\n            c_min_vertex = q_near.cost\n            for q_near_candidate in Q_near:\n                if q_near_candidate == q_new:\n                    continue\n                dist = torch.norm(q_near_candidate.position.to_tensor() - q_new.position.to_tensor()).item()\n                if dist > self._max_dist:\n                    continue\n                cost_candidate = q_near_candidate.cost + dist\n                if cost_candidate < c_min_vertex:\n                    if self._line_collision_free_lazy(q_near_candidate.position, q_new.position):\n                        q_min = q_near_candidate\n                        c_min_vertex = cost_candidate\n\n            q_new.cost = c_min_vertex\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire the tree around q_new\n            self._rewire(q_new, Q_near)\n\n            # Check if q_new reached goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Update best solution if better\n                dist_to_goal = torch.norm(q_new.position.to_tensor() - goal.position.to_tensor()).item()\n                total_cost = q_new.cost + dist_to_goal\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_goal_vertex = q_new\n                    self._found_path = True\n\n            self.key_frame()\n\n        # If found path, extract and smooth, then move agent on path\n        if self._found_path and best_goal_vertex is not None:\n            path_vertices = self._extract_path(best_goal_vertex)\n            path_vertices = self._smooth_path(path_vertices)\n            for vertex in path_vertices:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # Mark failure by raising or not moving - here do nothing, implicit fail\n            pass",
          "objective": Infinity,
          "other_inf": null,
          "results": {}
     }
]