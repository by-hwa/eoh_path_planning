[
     {
          "algorithm": "This is the RRT algorithm, a sample-based pathfinding algorithm that explores the space by randomly sampling points and connecting them to the nearest vertex.",
          "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\n\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.basic_testing import BasicTesting\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\n\nfrom simulator.services.services import Services\n\nfrom structures import Point\n\n\nclass RRT(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        if torch.norm(dir) <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / torch.norm(dir)\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self, q_new):\n\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)    #connect the last sampled point that's close to goal vertex and connet point to goal vertex with edge\n        path: List[Vertex] = [goal_v]    \n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        #get animation of path tracing from start to goal\n        for p in path:\n            self.move_agent(p.position)   \n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n\n        max_dist: float = 10\n        iterations: int = 10000\n\n        for i in range(iterations):\n\n            q_sample: Point = self._get_random_sample()     #sample a random point and return it if it's in valid position\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample) \n            if q_near.position == q_sample:\n                continue    #restart the while loop right away if sample point same as nearest vertex point\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)    #get new vertex\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):    \n                continue    #restart the while loop right away if the straight line path from nearest vertex to new sample point is invalid \n            self._graph.add_edge(q_near, q_new)    #add edge between 2 points\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):    #if agent is in goal radius, then run _extract_path method \n                self._extract_path(q_new)\n                break\n\n            self.key_frame()    #add the new vertex and edge if the new sample point is not at goal yet\n",
          "objective": 0,
          "other_inf": null
     },
     {
          "operator": "e1",
          "algorithm": "This algorithm is a hybrid advanced sample-based planner named Adaptive Informed RRT* (AIRRT*), combining adaptive sampling \n    with a focus on an informed ellipsoidal subset around the current best solution. \n    It improves planning efficiency by sampling mostly in the promising region (informed subset) shrinking as better paths \n    are discovered, drastically reducing unnecessary exploration.\n    It builds a forest with rewiring like RRT*, but adds heuristics:\n     - Adaptive dynamic informed sampling based on current best cost (path length).\n     - Early pruning by ignoring samples outside the informed ellipsoidal region.\n     - Biased rewiring selecting parents and children by cost+heuristic.\n     - Path smoothing post-processing using shortcut attempts.\n    The planner also monitors elapsed time and fails gracefully if exceeding 60 seconds.\n    This results in higher success rate, shorter smoother paths, reduced search time, and improved robustness.",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: Optional[float]\n    _best_goal_vertex: Optional[Vertex]\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._dimension = self._get_grid().size.n_dim\n        self._max_dist = float(max(self._get_grid().size.values)) / 10.0  # max step length scaled by map size\n        self._lambda_rrt_star = 40.0  # constant for radius calculation\n        self._max_radius = max(self._get_grid().size.values) / 3  # max radius for rewiring neighbors\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._start_time = 0.0\n        self._timeout = 60.0  # seconds time limit\n        self._best_cost = None  # best cost found so far\n        self._best_goal_vertex = None\n\n        self._init_displays()\n\n    # Helper: Get Euclidean distance between points\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    # Helper: Sample uniformly in informed ellipsoid subset if best_cost known, else whole space\n    def _informed_sample(self) -> Point:\n        # If no best solution yet, sample uniformly over map\n        if self._best_cost is None:\n            return self._uniform_sample()\n        else:\n            return self._ellipsoidal_sample()\n\n    def _uniform_sample(self) -> Point:\n        while True:\n            coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _ellipsoidal_sample(self) -> Point:\n        \"\"\"\n        Samples within an n-D ellipsoid defined by start and goal and radius equal to current best cost.\n        Algorithm briefly:\n          1) Construct ellipsoid in Cartesian coordinates where foci = start and goal positions.\n          2) Generate random point inside unit n-ball, scale and rotate to fit ellipsoid.\n          3) Translate to center between foci.\n        \"\"\"\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n        c_best = torch.tensor(self._best_cost)\n        c_min = self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n        if c_best < c_min:\n            c_best = c_min + 1e-3  # prevent numerical error\n\n        # Compute center and unit vector from start to goal (ellipse major axis)\n        center = (start + goal) / 2.0\n        foci_vec = (goal - start)\n        e_axis = foci_vec / torch.norm(foci_vec)\n\n        # Build orthonormal basis (rotation matrix) for the ellipsoid\n        # For 2D or 3D only; general n-D could be extended if needed\n        if self._dimension == 2:\n            # Rotate unit vector to get perpendicular vector\n            rotation_basis = torch.zeros((2, 2))\n            rotation_basis[:, 0] = e_axis\n            rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])  # perpendicular in 2D\n        elif self._dimension == 3:\n            # Use Gram-Schmidt for basis vectors\n            # First axis is e_axis\n            z_axis = e_axis\n            # Pick arbitrary vector not colinear with z_axis\n            arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n            y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n            y_axis = y_axis / torch.norm(y_axis)\n            x_axis = torch.cross(y_axis, z_axis)\n            rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)  # 3x3 matrix\n        else:\n            # For higher dimensions fallback to uniform sampling (rare)\n            return self._uniform_sample()\n\n        # Length of ellipsoid axes\n        r1 = c_best / 2.0  # major axis radius\n        r2 = torch.sqrt(c_best * c_best - c_min * c_min) / 2.0  # minor axis radius\n\n        # Construct diagonal scaling matrix for ellipsoid axis lengths\n        if self._dimension == 2:\n            L = torch.diag(torch.tensor([r1, r2]))\n        elif self._dimension == 3:\n            # assume rotationally symmetric about major axis for simplicity\n            L = torch.diag(torch.tensor([r2, r2, r1]))\n        else:\n            # fallback\n            return self._uniform_sample()\n\n        # Sample random point inside unit n-ball\n        while True:\n            u = torch.randn(self._dimension)\n            norm_u = torch.norm(u)\n            if norm_u > 1e-6:\n                break\n        unit_ball_sample = u / norm_u * torch.rand(1).item() ** (1.0 / self._dimension)\n\n        # Map sample into ellipsoid coordinate frame: center + rotation * L * unit_ball_sample\n        sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n\n        # Round and clamp to grid bounds\n        sample_coords = [int(float(torch.clamp(sample_in_ellipsoid[i], 0, self._get_grid().size[i] - 1).round())) for i in range(self._dimension)]\n        sample_point = Point(*sample_coords)\n\n        if self._get_grid().is_agent_valid_pos(sample_point):\n            return sample_point\n        else:\n            # Fallback to uniform when invalid sample in ellipsoid region\n            return self._uniform_sample()\n\n    # Rewiring radius calculation (adaptive)\n    def _calc_rewire_radius(self) -> float:\n        card_v = torch.tensor(float(self._graph.size + 1))\n        log_card_v = torch.log(card_v)\n        radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1.0 / self._dimension)), self._max_radius)\n        return radius.item()\n\n    # Given a new vertex, select best parent from neighbors minimizing cost+heuristic\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Tuple[Optional[Vertex], float]:\n        c_min = float('inf')\n        q_min = None\n        for q_near in neighbors:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost = q_near.cost + self._dist(q_near.position, q_new.position)\n            if cost < c_min:\n                c_min = cost\n                q_min = q_near\n        return q_min, c_min\n\n    # Attempt shortcut smoothing of path by trying to connect nonconsecutive vertices in path directly\n    def _shortcut_path(self, path: List[Vertex], max_attempts=30) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            attempts += 1\n            if len(new_path) < 3:\n                break\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = self._get_grid().get_line_sequence(p_i, p_j)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                # Remove intermediates and link directly\n                new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    # Extract final path from goal vertex back to start and smooth it\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            # pick parent with lowest cost (usually only one)\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # shortcut smoothing\n        path = self._shortcut_path(path, max_attempts=40)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n\n        max_iterations = 15000\n        radius = self._calc_rewire_radius()\n\n        for iter in range(max_iterations):\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Path search failed due to timeout\n                return\n\n            q_sample = self._informed_sample()\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n            if q_min is None:\n                # fallback: connect to nearest vertex directly\n                q_min = q_nearest\n                c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Make a list copy of parents to be able to remove edges without error\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                    continue\n                cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n                if cost_through_new < q_near.cost:\n                    # Remove previous edge(s) safely by list copy\n                    parents_copy = list(q_near.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, q_near)\n                    # Add edge from new vertex\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if q_new reaches goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = self._dist(q_new.position, self._graph.root_vertex_goal.position)\n                possible_cost = q_new.cost + dist_to_goal\n                if (self._best_cost is None) or (possible_cost < self._best_cost):\n                    # Update best cost and attach goal vertex\n                    self._best_cost = possible_cost\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = possible_cost\n                    # Remove previous parents safely by list copy\n                    parents_copy = list(goal_vertex.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()\n\n    # Method from existing samples to generate intermediate point toward sample (same as RRT_Star and SPRM style)\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*[int(round(float(c))) for c in new_pos_tensor])\n        return Vertex(new_pos)",
          "objective": Infinity,
          "other_inf": null,
          "results": {}
     }
]