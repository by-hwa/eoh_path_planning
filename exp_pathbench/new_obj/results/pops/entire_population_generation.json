{
     "operator": "e1",
     "algorithm": "PathPlanning is a hybrid sample-based algorithm combining adaptive informed sampling with batch rewiring and \n    multi-radius neighborhood strategy inspired by RRT*, but improving planning efficiency and path quality by:\n    - Biased sampling in ellipsoidal region focused towards the goal to reduce search space and improve convergence speed.\n    - Batch exploration with rewiring to continually reduce path costs and improve path smoothness.\n    - Multi-radius neighborhood sampling for flexible connectivity and robustness in cluttered environments.\n    - Early termination if goal reached or if planning time exceeds 10 seconds to ensure time-bound planning.\n    - Using cost propagation and informed pruning for path quality and shorter path lengths.\n    This algorithm aims for improved success rate, smoother and shorter paths with reduced execution time, \n    making it suitable for complex environments with obstacles.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _max_radius: float\n    _batch_size: int\n    _lambda_rrt_star: float\n    _dimension: int\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        # Parameters tuning\n        self._max_dist = 12.0  # max step length toward sample\n        self._max_radius = 40.0  # max neighbor radius for rewiring\n        self._batch_size = 30  # number of samples per batch iteration\n        self._lambda_rrt_star = 50.0  # parameter for radius calculation\n        self._dimension = self._get_grid().size.n_dim\n\n        self._init_displays()\n\n    def _get_random_sample(self, informed_center: Optional[Point] = None, informed_radii: Optional[List[float]] = None) -> Point:\n        \"\"\"\n        Samples point uniformly within either full map or within an ellipsoidal region around the start and goal.\n\n        :param informed_center: Center of the ellipsoid (often midpoint between start and goal).\n        :param informed_radii: Radii of the ellipsoid.\n        :return: Point sampled respecting obstacle validity.\n        \"\"\"\n        grid_size = self._get_grid().size\n\n        # Informed sampling inside ellipsoid if parameters provided\n        if informed_center is not None and informed_radii is not None:\n            for _ in range(100):\n                # Sample random point inside unit ball (normal distribution method)\n                direction = torch.randn(self._dimension)\n                direction /= torch.norm(direction)\n                r = torch.rand(1).item() ** (1 / self._dimension)\n                sample_unit_ball = direction * r\n                # Scale by radii in each dimension and translate by center\n                sample_coords = informed_center.to_tensor() + torch.tensor(informed_radii) * sample_unit_ball\n                sample_coords_int = torch.clamp(sample_coords.round().long(), min=0, max=torch.tensor(grid_size).long()-1)\n                sample = Point.from_tensor(sample_coords_int)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        # fallback uniform random sampling on full grid space\n        while True:\n            rand_coords = [np.random.randint(0, grid_size[i]) for i in range(self._dimension)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n    def _steer(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        direction_normalized = direction / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + direction_normalized * max_dist)\n        return Vertex(new_pos)\n\n    def _rewire_neighbors(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        for q_near in neighbors:\n            if q_near is q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n            if q_near.cost is None or new_cost < q_near.cost:\n                # remove old parent edge if exists\n                old_parent = None\n                for parent in q_near.parents:\n                    old_parent = parent\n                    break\n                if old_parent:\n                    self._graph.remove_edge(old_parent, q_near)\n                q_near.cost = new_cost\n                self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Connect to goal if possible and retrieve path\n        goal_point = self._get_grid().goal.position\n        dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_point.to_tensor())\n        goal_vertex = Vertex(goal_point)\n        goal_vertex.cost = q_new.cost + dist_to_goal\n\n        line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_point)\n        if not self._get_grid().is_valid_line_sequence(line_seq_goal):\n            return\n\n        self._graph.add_edge(q_new, goal_vertex)\n\n        # Trace back path from goal to start\n        path: List[Vertex] = [goal_vertex]\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n        # Remove the last appended vertex (duplicate start)\n        path.pop()\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _calculate_informed_parameters(self) -> (Point, List[float]):\n        \"\"\"\n        Calculate ellipsoidal sampling region parameters (center and radii) for informed sampling.\n\n        Returns:\n            center: midpoint between start and goal.\n            radii: list of ellipsoid radii per dimension.\n        \"\"\"\n        start = self._get_grid().agent.position.to_tensor()\n        goal = self._get_grid().goal.position.to_tensor()\n\n        center = (start + goal) / 2\n        c_dist = torch.norm(goal - start).item()\n\n        # If already have a path, use path cost to limit ellipse size\n        best_cost = None\n        if hasattr(self, \"_best_path_cost\") and self._best_path_cost is not None:\n            best_cost = self._best_path_cost\n        else:\n            best_cost = float('inf')\n\n        # Radii define ellipsoid stretching for each dimension.\n        # Use best_cost or distance to goal for a, b radii\n        # For 2D: a = best_cost/2, b = sqrt(best_cost^2 - c_dist^2)/2\n        # For higher dims, approximate as hyper-ellipsoid with same radii\n\n        if best_cost == float('inf') or best_cost < c_dist:\n            # No valid path yet or cost lower than distance (impossible), so use large radii\n            radii = [(c_dist / 2.0) * 3 for _ in range(self._dimension)]\n        else:\n            a = best_cost / 2.0\n            b_sq = max(best_cost**2 - c_dist**2, 0)\n            b = (b_sq ** 0.5) / 2.0\n            # Set all radii to b except first dimension to a (principal axis)\n            radii = [a] + [b] * (self._dimension - 1)\n\n        center_point = Point.from_tensor(center)\n        return center_point, radii\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        iterations = 1500  # cap on iterations for stable performance, can be tuned\n        found_goal = False\n\n        # Initialize best path cost to infinite (no path found yet)\n        self._best_path_cost = None\n\n        for _ in range(iterations):\n            current_time = time.time()\n            if current_time - start_time > 10:\n                # Timeout exceeded, fail planning\n                return\n\n            # Inform sampling region parameters (adaptive)\n            informed_center, informed_radii = self._calculate_informed_parameters()\n\n            # Batch sampling for exploration\n            samples: List[Point] = [self._get_random_sample(informed_center, informed_radii) for _ in range(self._batch_size)]\n\n            vertices_to_add: List[Vertex] = []\n            for q_sample in samples:\n                q_nearest = self._get_nearest_vertex(q_sample)\n\n                if q_nearest.position == q_sample:\n                    continue\n\n                q_new = self._steer(q_nearest, q_sample, self._max_dist)\n\n                line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n\n                cost_to_new = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n                q_new.cost = cost_to_new\n\n                # Find neighbors for rewiring with adaptive radius\n                card_v = torch.tensor(float(self._graph.size + 1))\n                radius = min(self._lambda_rrt_star * ((torch.log(card_v) / card_v)**(1 / self._dimension)), self._max_radius)\n\n                neighbors = self._get_vertices_within_radius(q_new, radius)\n                # Choose parent with minimum cost\n                q_min = q_nearest\n                c_min = cost_to_new\n                for q_near in neighbors:\n                    line_seq_near_new = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                    if not self._get_grid().is_valid_line_sequence(line_seq_near_new):\n                        continue\n\n                    new_cost = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                    if new_cost < c_min:\n                        c_min = new_cost\n                        q_min = q_near\n                # Assign min cost parent\n                q_new.cost = c_min\n                self._graph.add_edge(q_min, q_new)\n\n                # Rewire neighbors to potentially reduce cost\n                self._rewire_neighbors(q_new, neighbors)\n                vertices_to_add.append(q_new)\n\n                # Check for goal proximity and update best path cost\n                if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                    path_cost_candidate = q_new.cost + torch.norm(q_new.position.to_tensor() - self._get_grid().goal.position.to_tensor())\n                    if self._best_path_cost is None or path_cost_candidate < self._best_path_cost:\n                        self._best_path_cost = path_cost_candidate\n                        self._extract_path(q_new)\n                        found_goal = True\n                        break\n\n            self.key_frame()\n            if found_goal:\n                break",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "Adaptive Batch-Optimized Path Planning (ABOPP):\n\n    This algorithm improves path planning by combining adaptive bidirectional sampling,\n    dynamic batch sizes, hierarchical informed ellipsoidal sampling, and iterative cost-based rewiring.\n\n    Key features:\n    - Bidirectional search between agent and goal trees for faster convergence.\n    - Adaptive batch sampling: batch size grows with iterations to balance exploration/exploitation.\n    - Hierarchical informed sampling: samples preferentially within ellipsoids around current best path segments,\n      refining exploration near promising regions.\n    - Dynamic neighborhood radius based on vertex density for flexible local connectivity.\n    - Cost-aware rewiring leveraging multi-parent graphs to improve path quality iteratively.\n    - Early termination after goal reached or 10 seconds elapsed.\n\n    This approach yields improved efficiency, better path quality with smoother trajectories,\n    increased success rates, and reduced search times in cluttered or high-dimensional spaces.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _batch_base_size: int\n    _batch_max_size: int\n    _lambda_rrt_star: float\n    _dimension: int\n    _start_vertex: Vertex\n    _goal_vertex: Vertex\n    _best_path_cost: float | None\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._start_vertex = Vertex(self._get_grid().agent.position)\n        self._start_vertex.cost = 0.0\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, self._start_vertex, self._goal_vertex, [])\n\n        self._max_dist = 14.0\n        self._batch_base_size = 20\n        self._batch_max_size = 80\n        self._lambda_rrt_star = 40.0\n        self._dimension = self._get_grid().size.n_dim\n        self._best_path_cost = None\n\n        self._init_displays()\n\n    def _get_random_sample(self, informed_center: Point = None, informed_radii: list = None) -> Point:\n        grid_size = self._get_grid().size\n        if informed_center is not None and informed_radii is not None:\n            for _ in range(120):\n                direction = torch.randn(self._dimension)\n                direction /= torch.norm(direction)\n                r = torch.rand(1).item() ** (1 / self._dimension)\n                sample_unit_ball = direction * r  \n                sample_coords = informed_center.to_tensor() + torch.tensor(informed_radii) * sample_unit_ball\n                sample_coords_int = torch.clamp(sample_coords.round().long(), min=0, max=torch.tensor(grid_size).long() - 1)\n                sample = Point.from_tensor(sample_coords_int)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        # fallback uniform random sampling\n        while True:\n            rand_coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _calculate_ellipsoid_parameters(self, start: Point, goal: Point, cost_bound: float | None) -> (Point, list):\n        start_tensor = start.to_tensor()\n        goal_tensor = goal.to_tensor()\n        center = (start_tensor + goal_tensor) / 2\n        dist = torch.norm(goal_tensor - start_tensor).item()\n        if cost_bound is None or cost_bound < dist:\n            radii = [(dist / 2.0) * 4 for _ in range(self._dimension)]\n        else:\n            a = cost_bound / 2.0\n            b_sq = max(cost_bound * cost_bound - dist * dist, 0)\n            b = (b_sq ** 0.5) / 2.0\n            radii = [a] + [b] * (self._dimension - 1)\n        return Point.from_tensor(center), radii\n\n    def _steer(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        direction_normalized = direction / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + direction_normalized * max_dist)\n        return Vertex(new_pos)\n\n    def _get_vertices_within_radius_dynamic(self, q_new: Vertex) -> list:\n        card_v = float(self._graph.size + 1)\n        radius = min(self._lambda_rrt_star * ((torch.log(torch.tensor(card_v)) / card_v) ** (1.0 / self._dimension)), self._max_dist * 3.5)\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _rewire(self, q_new: Vertex, neighbors: list) -> None:\n        for q_near in neighbors:\n            if q_near is q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n            if q_near.cost is None or new_cost < q_near.cost:\n                # Remove old parent edge if any\n                if q_near.parents:\n                    old_parent = next(iter(q_near.parents))\n                    self._graph.remove_edge(old_parent, q_near)\n                q_near.cost = new_cost\n                self._graph.add_edge(q_new, q_near)\n\n    def _extract_bidirectional_path(self, meet_vertex: Vertex, from_start: bool = True) -> None:\n        # Trace path from meet_vertex back to start and goal (bidirectional)\n        path_start = []\n        cur = meet_vertex\n        while cur.parents:\n            path_start.append(cur)\n            cur = next(iter(cur.parents))\n        path_start.append(cur)\n        path_start.reverse()\n\n        path_goal = []\n        # In the other tree, follow children now to goal\n        cur = meet_vertex\n        while cur.children:\n            child = next(iter(cur.children))\n            path_goal.append(child)\n            cur = child\n\n        full_path = path_start + path_goal\n        # Move agent through the extracted path\n        for v in full_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n        max_time_sec = 10\n\n        # Initialization: trees rooted at start and goal\n        tree_start = [self._start_vertex]\n        tree_goal = [self._goal_vertex]\n\n        self._best_path_cost = None\n        iterations = 0\n        max_iterations = 2000\n        found_path = False\n\n        while iterations < max_iterations:\n            current_time = time.time()\n            if current_time - start_time > max_time_sec:\n                # Fail after timeout\n                return\n\n            # Adaptive batch size growing progressively (20 to 80)\n            batch_size = min(self._batch_base_size + (iterations // 30)*5, self._batch_max_size)\n\n            # Determine ellipsoid for start-to-goal informed sampling using current best path cost if any\n            ellipsoid_center, ellipsoid_radii = self._calculate_ellipsoid_parameters(\n                self._start_vertex.position, self._goal_vertex.position, self._best_path_cost)\n\n            # Alternate growth direction: even iterations grow start tree, odd grow goal tree\n            grow_start_tree = (iterations % 2 == 0)\n\n            if grow_start_tree:\n                root_vertices = [self._start_vertex]\n                opposite_tree = tree_goal\n            else:\n                root_vertices = [self._goal_vertex]\n                opposite_tree = tree_start\n\n            samples = []\n            for _ in range(batch_size):\n                sample = self._get_random_sample(ellipsoid_center, ellipsoid_radii)\n                samples.append(sample)\n\n            new_vertices = []\n            for q_sample in samples:\n                q_nearest = self._graph.get_nearest_vertex(root_vertices, q_sample)\n                if q_nearest.position == q_sample:\n                    continue\n                \n                q_new = self._steer(q_nearest, q_sample, self._max_dist)\n                line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n\n                cost_to_new = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n                q_new.cost = cost_to_new\n\n                neighbors = self._get_vertices_within_radius_dynamic(q_new)\n                # Choose min cost parent from neighbors (including q_nearest)\n                q_min = q_nearest\n                c_min = cost_to_new\n                for q_near in neighbors:\n                    line_seq_neighbor = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                    if not self._get_grid().is_valid_line_sequence(line_seq_neighbor):\n                        continue\n                    new_cost = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                    if new_cost < c_min:\n                        c_min = new_cost\n                        q_min = q_near\n\n                q_new.cost = c_min\n                self._graph.add_edge(q_min, q_new)\n                self._rewire(q_new, neighbors)\n                new_vertices.append(q_new)\n\n                # Add newly created vertex to proper tree list\n                if grow_start_tree:\n                    tree_start.append(q_new)\n                else:\n                    tree_goal.append(q_new)\n\n            # Check for connection between trees via new vertices\n            meet_candidates = []\n            for q_new in new_vertices:\n                close_in_opp = self._graph.get_vertices_within_radius(opposite_tree, q_new.position, self._max_dist*1.5)\n                for q_opp in close_in_opp:\n                    line_seq = self._get_grid().get_line_sequence(q_new.position, q_opp.position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        meet_candidates.append((q_new, q_opp))\n\n            if meet_candidates:\n                # Find pair with minimum combined path cost\n                best_pair = None\n                best_cost = float('inf')\n                for (v_start, v_goal) in meet_candidates:\n                    total_cost = v_start.cost + torch.norm(v_start.position.to_tensor() - v_goal.position.to_tensor()) + v_goal.cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_pair = (v_start, v_goal)\n\n                if best_pair:\n                    v_start, v_goal = best_pair\n                    self._best_path_cost = best_cost\n\n                    # Connect the two trees by adding edges between the meeting vertices\n                    self._graph.add_edge(v_start, v_goal)\n                    self._graph.add_edge(v_goal, v_start)\n\n                    # Extract and follow path from start to goal through meeting vertices\n                    # To extract complete path, temporarily create merged connectivity\n                    # We'll do a simple BFS to restore the path starting from start vertex toward goal vertex\n\n                    # To avoid infinite loops, store parents manually for extracted path:\n                    # For extraction, recreate parents for meeting vertices\n                    # Temporarily mark connectivity to allow tracing path start->goal:\n                    # Use BFS from start vertex to goal vertex over graph connectivity\n\n                    from collections import deque\n\n                    parent_map = {self._start_vertex: None}\n                    visited = set([self._start_vertex])\n                    q = deque([self._start_vertex])\n                    reached_goal = False\n                    while q and not reached_goal:\n                        curr = q.popleft()\n                        if curr.position == self._goal_vertex.position:\n                            reached_goal = True\n                            break\n                        for child in curr.connectivity:\n                            if child not in visited:\n                                visited.add(child)\n                                parent_map[child] = curr\n                                q.append(child)\n\n                    if not reached_goal:\n                        # fallback: follow original meeting vertices path partial extraction\n                        self._extract_bidirectional_path(v_start, from_start=True)\n                        found_path = True\n                        break\n\n                    # Reconstruct path from goal to start\n                    path = []\n                    node = self._goal_vertex\n                    while node is not None:\n                        path.append(node)\n                        node = parent_map.get(node, None)\n                    path.reverse()\n\n                    for vert in path:\n                        self.move_agent(vert.position)\n                        self.key_frame(ignore_key_frame_skip=True)\n                    found_path = True\n                    break\n\n            self.key_frame()\n            if found_path:\n                break\n\n            iterations += 1",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "Improved Path Planning Algorithm: Adaptive Informed Batch Sampling Tree (AIBST)\n\n    This algorithm enhances sampling-based planning by combining informed sampling in ellipsoidal regions \n    around the current best path, adaptive batch sampling for faster exploration, and rewiring for path quality. \n    It extends RRT* principles with:\n    - Informed sampling around best cost to goal for efficiency and path shortening.\n    - Batch sampling to improve branching and convergence speed.\n    - Early stopping if no improvement in cost for a number of iterations.\n    - Timeout enforcement to fail gracefully after 10 seconds.\n    This approach improves planning efficiency, success rate, path smoothness and path length while \n    robustly handling obstacles through direct collision checking.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: Optional['BasicTesting'] = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n        # Algorithm parameters\n        self._max_dist = 15.0             # max extension distance per step\n        self._max_iter = 15000            # maximum iterations for search\n        self._batch_size = 25             # number of samples per batch\n        self._improvement_wait = 1500     # iterations to wait without improvement before stopping\n        self._dimension = self._get_grid().size.n_dim\n\n        # Track best solution stats\n        self._best_vertex: Optional[Vertex] = None\n        self._best_cost: float = float('inf')\n\n\n    def _get_informed_sample(self, cost_best: float) -> Point:\n        \"\"\"\n        Generate an informed random sample inside ellipse defined by agent and goal positions and current best cost.\n        If no current path found (cost_best == inf), sample uniformly.\n\n        Ellipse parameters:\n        - Center at midpoint between start and goal.\n        - Major axis length = cost_best (best path cost).\n        - Minor axis lengths computed from ellipse formula.\n        \"\"\"\n\n        start_pos = self._graph.root_vertex_start.position.to_tensor()\n        goal_pos = self._graph.root_vertex_goal.position.to_tensor()\n\n        if cost_best == float('inf'):\n            # No solution found yet: sample uniformly in the grid\n            while True:\n                rand_coords = torch.tensor([\n                    np.random.randint(0, self._get_grid().size[i]) \n                    for i in range(self._dimension)\n                ], dtype=torch.float32)\n                sample = Point.from_tensor(rand_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling inside prolate hyperspheroid with focal points start and goal, cost_best as major axis length\n\n        c = (start_pos + goal_pos) / 2.0\n        foci_dist = torch.norm(goal_pos - start_pos) / 2.0\n        if cost_best < foci_dist:\n            # No feasible ellipse possible if current cost < distance between foci\n            return self._get_informed_sample(float('inf'))\n\n        r1 = cost_best / 2.0\n        # Axis lengths for ellipse: r1 = major half axis, r2 = minor half axis\n        r2 = torch.sqrt(cost_best**2 - (2*foci_dist)**2) / 2.0 if cost_best > 2*foci_dist else 0\n\n        # Sample random point in unit n-dim ball\n        while True:\n            direction = torch.randn(self._dimension)\n            direction = direction / torch.norm(direction)\n            radius = torch.rand(1).pow(1/self._dimension).item()  # Uniform sample inside unit ball\n            point_in_ball = direction * radius\n\n            # Construct point in ellipse frame\n            # Rotate and scale ball point according to ellipse axes orientation\n            # We use the direction from start to goal as major axis\n            major_axis = (goal_pos - start_pos)\n            if torch.norm(major_axis) < 1e-8:\n                # start and goal coincide, uniform sample\n                return self._get_informed_sample(float('inf'))\n\n            e1 = major_axis / torch.norm(major_axis)\n            # Construct orthonormal basis via Gram-Schmidt if dimension >1\n            # For simplicity, build rotation matrix with e1 as first column, rest arbitrary orthonormal basis\n            # Here only 2D and 3D considered (2D most common); general n-D can use SVD but restricted environment\n            if self._dimension == 2:\n                # e1 = major axis unit vector\n                # e2 = perpendicular vector\n                e2 = torch.tensor([-e1[1], e1[0]])\n                rot = torch.stack([e1, e2], dim=1)\n                radii = torch.tensor([r1, r2])\n                local_point = rot @ (point_in_ball * radii)\n                sample_point = c + local_point\n            elif self._dimension ==3:\n                # Create e2 orthogonal to e1\n                tmp = torch.tensor([1., 0., 0.])\n                if abs(torch.dot(e1, tmp)) > 0.9:\n                    tmp = torch.tensor([0.,1.,0.])\n                e2 = tmp - e1*torch.dot(e1,tmp)\n                e2 = e2 / torch.norm(e2)\n                e3 = torch.cross(e1, e2)\n                rot = torch.stack([e1, e2, e3], dim=1)\n                radii = torch.tensor([r1, r2, r2])\n                local_point = rot @ (point_in_ball * radii)\n                sample_point = c + local_point\n            else:\n                # For >3D, fallback to uniform sampling if complexity high\n                return self._get_random_sample()\n\n            # Round and cast to int to get grid point\n            sample_point_int = Point.from_tensor(sample_point)\n            if self._get_grid().is_agent_valid_pos(sample_point_int):\n                return sample_point_int\n\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"Uniform random sampling inside grid with collision-free check.\"\"\"\n        while True:\n            rand_coords = torch.tensor([\n                np.random.randint(0, self._get_grid().size[i])\n                for i in range(self._dimension)\n            ])\n            sample = Point(*rand_coords.tolist())\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= self._max_dist:\n            return Vertex(q_sample)\n        direction_normalized = direction / dist\n        new_pos_tensor = q_near.position.to_tensor() + self._max_dist * direction_normalized\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n\n    def _check_collision_free(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n\n    def _rebuild_graph_better_path(self, q_new: Vertex, radius: float):\n        # Try rewiring neighbors to q_new for improving cost, per RRT* principles\n\n        Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            if self._check_collision_free(q_new.position, q_near.position):\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if cost_new_to_near < q_near.cost:\n                    # Rewire q_near to new parent q_new\n                    # Remove old parent link\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n\n    def _extract_path(self, q_goal: Vertex):\n        # Build path from q_goal back to start\n        path: List[Vertex] = [q_goal]\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n        path.reverse()\n\n        # Move agent through path for visualization and execution\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid: Map = self._get_grid()\n            # If RosMap, publish new waypoint (optional)\n            try:\n                from algorithms.configuration.maps.ros_map import RosMap\n                if isinstance(grid, RosMap):\n                    grid.publish_wp(grid.agent.position)\n            except ImportError:\n                pass\n            self.key_frame(ignore_key_frame_skip=True)\n\n\n    def _find_path_internal(self) -> None:\n\n        start_time = time.time()\n\n        # Initialization\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        \n        radius_const = 30.0  # Max neighbor search radius for rewiring\n        no_improve_count = 0\n        \n        for iteration in range(self._max_iter):\n\n            # Check for timeout to fail path search after 10 seconds\n            if time.time() - start_time > 10.0:\n                # Failed to find path within time limit\n                break\n\n            # Batch sampling (informed sampling around current best cost)\n            samples: List[Point] = []\n            for _ in range(self._batch_size):\n                sample = self._get_informed_sample(self._best_cost)\n                samples.append(sample)\n\n            for q_sample in samples:\n                q_nearest = self._get_nearest_vertex(q_sample)\n                if q_nearest.position == q_sample:\n                    continue\n\n                q_new = self._get_new_vertex(q_nearest, q_sample)\n                if not self._check_collision_free(q_nearest.position, q_new.position):\n                    continue\n\n                # Calculate cost of path through q_nearest to q_new\n                dist = torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n                cost_through_nearest = q_nearest.cost + dist\n\n                # Get nearby vertices for potential better parent selection and rewiring\n                radius = min(radius_const, self._max_dist * (torch.log(torch.tensor(self._graph.size + 1)).item() / (self._graph.size + 1))**(1/self._dimension))\n\n                Q_near = self._get_vertices_within_radius(q_new, radius)\n                \n                # Choose parent with minimum cost + collision free\n                q_min = q_nearest\n                c_min = cost_through_nearest\n\n                for q_near in Q_near:\n                    dist_near_new = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                    cost_new = q_near.cost + dist_near_new\n                    if cost_new < c_min and self._check_collision_free(q_near.position, q_new.position):\n                        c_min = cost_new\n                        q_min = q_near\n\n                q_new.cost = c_min\n                self._graph.add_edge(q_min, q_new)\n\n                # Rewire neighbors if beneficial\n                self._rebuild_graph_better_path(q_new, radius)\n\n                # Check if reached goal radius\n                if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                    # If this is better than previous best, update best path\n                    if q_new.cost < self._best_cost:\n                        self._best_cost = q_new.cost\n                        self._best_vertex = q_new\n                        self._extract_path(q_new)\n                        no_improve_count = 0\n                        # Continue search to improve further if time permits\n                    else:\n                        no_improve_count += 1\n\n                else:\n                    # No immediate improvement, count iterations without improvement\n                    no_improve_count += 1\n\n            # Early exit if no improvement for many iterations to save time\n            if no_improve_count > self._improvement_wait:\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This algorithm implements an Enhanced Bidirectional RRT* (Rapidly-exploring Random Tree Star) inspired planner optimized for grid-based maps.\n    It builds two trees: one rooted at the agent start and one at the goal position, simultaneously expanding them with controlled random sampling.\n    Key improvements include:\n    - Bidirectional tree growth for faster convergence.\n    - RRT* style rewiring for improved path quality and shorter paths.\n    - Adaptive sampling of promising regions near the trees to improve exploration efficiency and robustness.\n    - Use of a connection radius that scales with environment size and iteration count.\n    - Early stopping and timeout mechanism to abort after 10 seconds.\n    The final path is extracted by connecting the two trees at their closest pair of vertices with a valid collision-free path.\n    This ensures improved planning efficiency, success rate, path smoothness and shorter path lengths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_iter = 1000\n        # Connection radius (tunable, scales with map max dimension)\n        grid_size = self._get_grid().size\n        max_dim = max(grid_size)\n        self._connection_radius = max_dim * 0.2\n        # Initialized tree vertex sets\n        self._tree_start: Forest = None  # type: ignore\n        self._tree_goal: Forest = None   # type: ignore\n        self._timeout_sec = 10.0\n\n    def _get_random_sample(self) -> Point:\n        # Biased random sampling: 70% uniform, 15% near tree_start vertices, 15% near tree_goal vertices\n        p_uniform = 0.7\n        grid = self._get_grid()\n        if torch.rand(1).item() < p_uniform or self._tree_start is None or self._tree_goal is None:\n            # Uniform random sample in valid space\n            while True:\n                sample = Point(*[torch.randint(0, grid.size[i], (1,)).item() for i in range(grid.size.n_dim)])\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Sample near one tree randomly\n            tree = self._tree_start if torch.rand(1).item() < 0.5 else self._tree_goal\n            vertices = tree.root_vertices\n            if not vertices:\n                return self._get_random_sample()\n            v = vertices[torch.randint(len(vertices), (1,)).item()]\n            # Sample in sphere of connection radius around vertex\n            dim = grid.size.n_dim\n            for _ in range(10):\n                offset = torch.randn(dim) * (self._connection_radius / 2)\n                candidate_vals = torch.clamp(v.position.to_tensor() + offset, min=0, max=torch.tensor(grid.size.values) - 1)\n                candidate = Point.from_tensor(candidate_vals)\n                if grid.is_agent_valid_pos(candidate):\n                    return candidate\n            # fallback uniform\n            return self._get_random_sample()\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, max_dist: Optional[float] = None) -> Vertex:\n        # Returns a new vertex towards to_point limited by max_dist\n        dir_vec = to_point.to_tensor() - from_vertex.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if max_dist is None or dist <= max_dist:\n            new_pos = to_point\n        else:\n            dir_unit = dir_vec / dist\n            new_pos = Point.from_tensor(from_vertex.position.to_tensor() + dir_unit * max_dist)\n        return Vertex(new_pos)\n\n    def _get_near_vertices(self, tree: Forest, point: Point) -> List[Vertex]:\n        return tree.get_vertices_within_radius(tree.root_vertices, point, self._connection_radius)\n\n    def _choose_parent(self, near_vertices: List[Vertex], new_vertex: Vertex, tree: Forest) -> Optional[Vertex]:\n        # Choose a parent that produces minimum cost path and has valid line\n        best_parent = None\n        best_cost = float(\"inf\")\n        grid = self._get_grid()\n        for v in near_vertices:\n            line_seq = grid.get_line_sequence(v.position, new_vertex.position)\n            if v.position != new_vertex.position and grid.is_valid_line_sequence(line_seq):\n                cost = v.cost + grid.get_movement_cost(v.position, new_vertex.position)\n                if cost < best_cost:\n                    best_cost = cost\n                    best_parent = v\n        return best_parent\n\n    def _rewire(self, tree: Forest, new_vertex: Vertex, near_vertices: List[Vertex]) -> None:\n        # For RRT* style rewiring of near vertices to new_vertex if better cost found\n        grid = self._get_grid()\n        for v in near_vertices:\n            if v is new_vertex:\n                continue\n            line_seq = grid.get_line_sequence(new_vertex.position, v.position)\n            if grid.is_valid_line_sequence(line_seq):\n                new_cost = new_vertex.cost + grid.get_movement_cost(new_vertex.position, v.position)\n                if new_cost < v.cost:\n                    # Remove old parent edges and connect new_vertex as parent\n                    for p in list(v.parents):\n                        tree.remove_edge(p, v)\n                    tree.add_edge(new_vertex, v)\n                    v.cost = new_cost\n\n    def _extract_path(self, connection_start: Vertex, connection_goal: Vertex) -> None:\n        # Extract path by tracing parents from connection points to roots and combine\n        path_start = []\n        current = connection_start\n        while True:\n            path_start.append(current.position)\n            if not current.parents:\n                break\n            current = next(iter(current.parents))  # Single parent in tree\n        path_start.reverse()\n\n        path_goal = []\n        current = connection_goal\n        while True:\n            path_goal.append(current.position)\n            if not current.parents:\n                break\n            current = next(iter(current.parents))\n\n        path = path_start + path_goal\n\n        for p in path:\n            self.move_agent(p)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        agent_pos = grid.agent.position\n        goal_pos = grid.goal.position\n\n        # Initialize two forests: start and goal trees\n        v_start = Vertex(agent_pos)\n        v_start.cost = 0.0\n        v_goal = Vertex(goal_pos)\n        v_goal.cost = 0.0\n\n        self._tree_start = Forest(root_vertex_start=v_start, root_vertex_goal=v_goal, root_vertices=[v_start])\n        self._tree_goal = Forest(root_vertex_start=v_start, root_vertex_goal=v_goal, root_vertices=[v_goal])\n\n        start_time = time.time()\n\n        for iter_i in range(self._max_iter):\n            if time.time() - start_time > self._timeout_sec:\n                # Fail condition: aborted after timeout\n                return\n\n            # Alternate tree expanding: expand start tree on even iterations, goal tree on odd iterations\n            if iter_i % 2 == 0:\n                tree_from = self._tree_start\n                tree_to = self._tree_goal\n            else:\n                tree_from = self._tree_goal\n                tree_to = self._tree_start\n\n            q_rand = self._get_random_sample()\n\n            # Extend tree_from towards q_rand\n            q_near = tree_from.get_nearest_vertex(tree_from.root_vertices, q_rand)\n            q_new = self._steer(q_near, q_rand, max_dist=self._connection_radius)\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                self.key_frame()\n                continue\n\n            near_vertices = self._get_near_vertices(tree_from, q_new.position)\n            parent = self._choose_parent(near_vertices, q_new, tree_from)\n            if parent is None:\n                parent = q_near\n            tree_from.add_edge(parent, q_new)\n            q_new.cost = parent.cost + grid.get_movement_cost(parent.position, q_new.position)\n            tree_from.root_vertices.append(q_new)\n            self._rewire(tree_from, q_new, near_vertices)\n\n            self.key_frame()\n\n            # Try to connect q_new to the other tree (tree_to)\n            near_vertices_to = self._get_near_vertices(tree_to, q_new.position)\n            connected = False\n            min_connection_cost = float(\"inf\")\n            connection_pair = None\n            for v_to in near_vertices_to:\n                line_seq_connect = grid.get_line_sequence(q_new.position, v_to.position)\n                if grid.is_valid_line_sequence(line_seq_connect):\n                    cost_connect = q_new.cost + grid.get_movement_cost(q_new.position, v_to.position) + v_to.cost\n                    if cost_connect < min_connection_cost:\n                        min_connection_cost = cost_connect\n                        connection_pair = (q_new, v_to)\n                        connected = True\n\n            if connected and connection_pair is not None:\n                # Connect edge both ways for tracking\n                tree_from.add_edge(connection_pair[0], connection_pair[1])\n                tree_to.add_edge(connection_pair[1], connection_pair[0])\n                # Extract path by merging two trees at connection point\n                self._extract_path(connection_pair[0], connection_pair[1])\n                return\n\n        # If loop finishes without path, consider planning failed\n        return",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This algorithm implements an improved and hybrid RRT* inspired approach with vertex rewiring to reduce path cost,\n    enhanced sampling bias towards the goal for more directed search, and collision-checked incremental connection steps.\n    It also uses a priority queue (min-heap) to efficiently keep track of vertices to explore next by their cost + heuristic,\n    akin to an informed RRT* with A*-like search guidance.\n\n    Key improvements:\n    - Uses rewiring to improve path quality by dynamically reducing costs.\n    - Samples towards the goal with adjustable probability to improve convergence speed.\n    - Checks line-of-sight with Bresenham's line sequences for collision-free edges.\n    - Maintains a cost-to-come and heuristic cost framework for better vertex connection decisions.\n    - Limits maximum connection length to keep sampling local and reduce collisions.\n    - Enforces 10 seconds maximum planning time to guarantee termination.\n    - Extracts and moves the agent along the best found path once goal is reached.\n\n    The algorithm balances exploration and exploitation, ensuring better robustness, path smoothness,\n    and shorter path lengths than vanilla RRT by also leveraging local rewiring and heuristic guiding.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: \"Services\", testing: \"BasicTesting\" = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            [],\n        )\n        self._graph.edges_removable = True  # enable edge rewiring\n        self._init_displays()\n\n        self._max_edge_length = 12.0  # max distance between connected vertices (controls granularity)\n        self._goal_sample_rate = 0.15  # probability of sampling the goal directly (bias)\n        self._search_radius = 20.0  # radius for neighbors rewiring\n\n    def _heuristic_cost(self, pos: Point) -> float:\n        # Heuristic: Euclidean distance to goal\n        return self._get_grid().get_distance(pos, self._get_grid().goal.position)\n\n    def _get_new_vertex_towards(\n        self, q_near: Vertex, q_sample: Point, max_dist: float\n    ) -> Vertex:\n        # Attempts to move from q_near toward q_sample with a step limited to max_dist.\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new = Point.from_tensor(new_pos_tensor)\n        return Vertex(q_new, store_connectivity=True)\n\n    def _get_random_sample(self) -> Point:\n        # Sample random point with goal bias to enhance efficiency.\n        import random\n\n        if random.random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n\n        size = self._get_grid().size\n        n_dim = size.n_dim\n        while True:\n            rand_coords = tuple(int(np.random.randint(0, size[i])) for i in range(n_dim))\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _find_near_vertices(\n        self, vertices: List[Vertex], q_new: Vertex, radius: float\n    ) -> List[Vertex]:\n        # Returns all vertices within radius of q_new.position\n        result = []\n        for v in vertices:\n            if self._get_grid().get_distance(v.position, q_new.position) <= radius:\n                result.append(v)\n        return result\n\n    def _line_is_free(self, frm: Point, to: Point) -> bool:\n        # Check if the straight line path frm->to is valid (collision free)\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _cost_from_to(self, frm: Vertex, to: Vertex) -> float:\n        # Returns the movement cost between two vertices.\n        return self._get_grid().get_movement_cost(frm.position, to.position)\n\n    def _extract_path(self, last_vertex: Vertex) -> None:\n        path: List[Vertex] = [last_vertex]\n        while len(path[-1].parents) != 0:\n            # Since parents is a set, pick the parent with minimum cost for path extraction\n            parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(parent)\n        path.reverse()\n\n        # Move agent along found path with frames for animation\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        # Priority queue for vertices to explore: (cost+heuristic, cost, Vertex)\n        open_set: List[Tuple[float, float, Vertex]] = []\n        heapq.heappush(\n            open_set,\n            (self._heuristic_cost(start_vertex.position), 0.0, start_vertex),\n        )\n\n        visited: Dict[Tuple[int, ...], Vertex] = {\n            tuple(start_vertex.position): start_vertex\n        }  # key: position tuple\n\n        goal_reached_vertex: Optional[Vertex] = None\n\n        while len(open_set) > 0:\n            if time.time() - start_time > 10.0:\n                # Fail condition if takes over 10 seconds\n                break\n\n            _, curr_cost, current = heapq.heappop(open_set)\n\n            # If current vertex is within goal radius, finish search\n            if self._get_grid().is_agent_in_goal_radius(current.position):\n                goal_reached_vertex = current\n                break\n\n            # Sample new point biased toward goal\n            q_sample = self._get_random_sample()\n\n            # Get nearest existing vertex from graph roots\n            q_nearest = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex_towards(q_nearest, q_sample, self._max_edge_length)\n\n            # Discard if line from q_nearest to q_new is not valid\n            if not self._line_is_free(q_nearest.position, q_new.position):\n                continue\n\n            # Calculate cost to reach new vertex through q_nearest\n            tentative_cost = q_nearest.cost + self._cost_from_to(q_nearest, q_new)\n\n            pos_key = tuple(q_new.position)\n            if pos_key in visited:\n                existing_vertex = visited[pos_key]\n                if tentative_cost < existing_vertex.cost:\n                    # Rewire existing vertex with new parent q_nearest with better cost\n                    # Remove old edges from old parents\n                    for p in existing_vertex.parents:\n                        p.children.discard(existing_vertex)\n                        existing_vertex.parents.discard(p)\n                    existing_vertex.cost = tentative_cost\n                    existing_vertex.add_parent(q_nearest)\n                    q_nearest.add_child(existing_vertex)\n\n                    # Propagate cost update to children recursively\n                    self._rewire_costs(existing_vertex)\n\n                    heapq.heappush(\n                        open_set,\n                        (\n                            tentative_cost + self._heuristic_cost(existing_vertex.position),\n                            tentative_cost,\n                            existing_vertex,\n                        ),\n                    )\n                # else: existing vertex cheaper path, skip\n                continue\n\n            # New vertex discovered, add to forest and visited dictionary\n            q_new.cost = tentative_cost\n            q_new.add_parent(q_nearest)\n            q_nearest.add_child(q_new)\n\n            self._graph.root_vertices.append(q_new)\n            visited[pos_key] = q_new\n\n            # Rewire near vertices within radius if they can be reached cheaper via q_new\n            nearby_vertices = self._find_near_vertices(self._graph.root_vertices, q_new, self._search_radius)\n            for near_v in nearby_vertices:\n                if near_v is q_new:\n                    continue\n                if not self._line_is_free(q_new.position, near_v.position):\n                    continue\n                cost_through_new = q_new.cost + self._cost_from_to(q_new, near_v)\n                if cost_through_new < near_v.cost:\n                    # Remove old edges from parents of near_v\n                    for p in near_v.parents:\n                        p.children.discard(near_v)\n                    near_v.parents.clear()\n\n                    # Add q_new as new parent\n                    near_v.cost = cost_through_new\n                    near_v.add_parent(q_new)\n                    q_new.add_child(near_v)\n\n                    # Recursively update children's cost after rewiring\n                    self._rewire_costs(near_v)\n\n                    heapq.heappush(\n                        open_set,\n                        (\n                            near_v.cost + self._heuristic_cost(near_v.position),\n                            near_v.cost,\n                            near_v,\n                        ),\n                    )\n\n            # Push q_new to open set\n            heapq.heappush(\n                open_set,\n                (q_new.cost + self._heuristic_cost(q_new.position), q_new.cost, q_new),\n            )\n\n            self.key_frame()  # visualize expansion progress\n\n        if goal_reached_vertex is not None:\n            self._extract_path(goal_reached_vertex)\n        # else: planning failed due to timeout or no feasible path found\n\n    def _rewire_costs(self, vertex: Vertex) -> None:\n        \"\"\"\n        Recursively update cost of vertex's children after rewiring.\n        Only update if child's cost can be improved.\n        \"\"\"\n        for child in vertex.children:\n            new_cost = vertex.cost + self._cost_from_to(vertex, child)\n            if new_cost < child.cost:\n                child.cost = new_cost\n                # Remove other parents - keep only vertex as parent for simplicity\n                for p in list(child.parents):\n                    if p != vertex:\n                        p.children.discard(child)\n                        child.parents.discard(p)\n\n                if vertex not in child.parents:\n                    child.add_parent(vertex)\n                self._rewire_costs(child)",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "Adaptive Dynamic Multi-Resolution Informed Rapidly-exploring Random Tree (ADMIRRT*)\n    \n    This algorithm combines multi-resolution grid-adaptive sampling with dynamically shrinking informed regions \n    for rapid convergence to high-quality paths. It uses adaptive batch sizes increasing with iteration count \n    for exploration, and local smoothing to improve path quality and smoothness during planning.\n    \n    Key innovations:\n    - Multi-resolution progressive sampling: alternates between large step and fine local refinement.\n    - Dynamic elliptical informed sampling with radius shrinking after improvements.\n    - Adaptive batch sampling with growing number of samples per iteration to balance exploration/exploitation.\n    - Early pruning of costly branches via cost thresholds and radius-based neighborhood rewiring.\n    - Local path smoothing by shortcutting feasible edges after every improvement.\n    - Timeout enforcement to fail path search gracefully after 10 seconds.\n    \n    Improves path planning performance with efficiency, path smoothness, shorter paths, and robust obstacle handling.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n        # Algorithm parameters\n        self._dimension = self._get_grid().size.n_dim\n        self._max_iter = 12000               # max iterations (reduce a bit from 15k)\n        self._base_max_dist = 18.0           # base max extension distance\n        self._max_batch_size = 60            # max batch size grows adaptively\n        self._min_batch_size = 15            # minimum batch size\n        self._improvement_wait = 1000        # early stopping iterations without improvement\n        self._timeout_seconds = 10.0         # fail after 10 seconds\n\n        self._best_vertex = None\n        self._best_cost = float('inf')\n        self._no_improve_count = 0\n        self._informed_radius = float('inf') # dynamic radius of informed elliptical region\n\n\n    def _get_dynamic_max_dist(self, iteration: int) -> float:\n        # Alternate between large jumps and finer steps by iteration parity\n        if iteration % 10 < 7:\n            # Most iterations use larger max dist for faster exploration\n            return self._base_max_dist\n        else:\n            # Every few iterations use smaller max dist for local refinement\n            return self._base_max_dist / 3.0\n\n    def _adaptive_batch_size(self, iteration: int) -> int:\n        # Increase batch size with iteration progress for denser exploration over time\n        batch = int(self._min_batch_size + (self._max_batch_size - self._min_batch_size) * (iteration / self._max_iter))\n        return max(self._min_batch_size, min(batch, self._max_batch_size))\n\n    def _sample_in_informed_region(self, cost_best: float) -> Point:\n        # Sample inside an informed elliptical region around start & goal with adjustable radius\n        start_tensor = self._graph.root_vertex_start.position.to_tensor()\n        goal_tensor = self._graph.root_vertex_goal.position.to_tensor()\n\n        if cost_best == float('inf') or self._informed_radius == float('inf'):\n            # No solution: uniform random sampling\n            while True:\n                coords = torch.tensor([np.random.randint(0, self._get_grid().size[i]) for i in range(self._dimension)])\n                p = Point(*coords.tolist())\n                if self._get_grid().is_agent_valid_pos(p):\n                    return p\n\n        # Compute ellipse parameters with dynamic radius (informed radius < cost_best)\n        c = (start_tensor + goal_tensor) / 2.0\n        half_foci_dist = torch.norm(goal_tensor - start_tensor) / 2.0\n        r_major = max(self._informed_radius / 2.0, half_foci_dist + 1e-5)\n        r_minor = torch.sqrt(max(r_major**2 - half_foci_dist**2, torch.tensor(0.0)))\n\n        # Sample random point inside unit ball in self._dimension\n        while True:\n            direction = torch.randn(self._dimension)\n            norm_direction = torch.norm(direction)\n            if norm_direction < 1e-8:\n                continue\n            direction = direction / norm_direction\n            radius = torch.rand(1).item() ** (1.0 / self._dimension)\n            sampled_ball = direction * radius\n\n            # Rotation basis construction: major axis e1 along start->goal\n            e1 = (goal_tensor - start_tensor)\n            norm_e1 = torch.norm(e1)\n            if norm_e1 < 1e-8:\n                # Start and goal coincide, fallback\n                return self._sample_in_informed_region(float('inf'))\n\n            e1 = e1 / norm_e1\n\n            if self._dimension == 2:\n                e2 = torch.tensor([-e1[1], e1[0]])\n                rot = torch.stack([e1, e2], dim=1)\n                radii = torch.tensor([r_major, r_minor])\n                local_point = rot @ (sampled_ball * radii)\n            elif self._dimension == 3:\n                tmp = torch.tensor([1., 0., 0.])\n                if abs(torch.dot(e1, tmp)) > 0.9:\n                    tmp = torch.tensor([0., 1., 0.])\n                e2 = tmp - e1 * torch.dot(e1, tmp)\n                e2 = e2 / torch.norm(e2)\n                e3 = torch.cross(e1, e2)\n                rot = torch.stack([e1, e2, e3], dim=1)\n                radii = torch.tensor([r_major, r_minor, r_minor])\n                local_point = rot @ (sampled_ball * radii)\n            else:\n                # Fallback to uniform if dimension unsupported\n                return self._get_random_sample()\n\n            candidate = c + local_point\n            p_int = Point.from_tensor(candidate)\n            if self._get_grid().is_agent_valid_pos(p_int):\n                return p_int\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_coords = torch.tensor([np.random.randint(0, self._get_grid().size[i]) for i in range(self._dimension)])\n            p = Point(*rand_coords.tolist())\n            if self._get_grid().is_agent_valid_pos(p):\n                return p\n\n    def _get_nearest_vertex(self, sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], sample)\n\n    def _new_vertex_towards(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        diff = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(diff)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        direction = diff / dist\n        new_point = q_near.position.to_tensor() + direction * max_dist\n        return Vertex(Point.from_tensor(new_point))\n\n    def _check_collision_free(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _vertices_in_radius(self, q_new: Vertex, radius: float) -> list:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n    def _rewire(self, q_new: Vertex, radius: float):\n        neighbors = self._vertices_in_radius(q_new, radius)\n        for q_near in neighbors:\n            if q_near is q_new:\n                continue\n            if self._check_collision_free(q_new.position, q_near.position):\n                cost_through_new = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if cost_through_new < q_near.cost:\n                    # Rewire: remove old parent and add new edge\n                    for p in q_near.parents:\n                        self._graph.remove_edge(p, q_near)\n                        break\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, q_goal: Vertex) -> list:\n        path = [q_goal]\n        while len(path[-1].parents) > 0:\n            for p in path[-1].parents:\n                path.append(p)\n                break\n        path.reverse()\n        return path\n\n    def _shortcut_path(self, path: list) -> list:\n        # Attempt to shortcut path by connecting non-adjacent vertices directly if collision-free\n        if len(path) < 3:\n            return path\n\n        shortened = [path[0]]\n        idx = 0\n        while idx < len(path)-1:\n            # Find farthest reachable vertex directly from current\n            next_idx = idx + 1\n            for j in range(len(path)-1, idx, -1):\n                if self._check_collision_free(path[idx].position, path[j].position):\n                    next_idx = j\n                    break\n            shortened.append(path[next_idx])\n            idx = next_idx\n        return shortened\n\n    def _move_agent_along_path(self, path: list) -> None:\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid = self._get_grid()\n            # Optional: publish waypoint for ROS map if available\n            try:\n                from algorithms.configuration.maps.ros_map import RosMap\n                if isinstance(grid, RosMap):\n                    grid.publish_wp(grid.agent.position)\n            except ImportError:\n                pass\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n\n        self._best_cost = float('inf')\n        self._best_vertex = None\n        self._no_improve_count = 0\n        self._informed_radius = float('inf')\n\n        iteration = 0\n\n        while iteration < self._max_iter:\n            iteration += 1\n\n            # Timeout check (fail after 10 seconds)\n            if time.time() - start_time > self._timeout_seconds:\n                # Failed to find path in time\n                break\n\n            # Dynamic parameters\n            max_dist = self._get_dynamic_max_dist(iteration)\n            batch_size = self._adaptive_batch_size(iteration)\n\n            samples = []\n            for _ in range(batch_size):\n                sample_point = self._sample_in_informed_region(self._best_cost)\n                samples.append(sample_point)\n\n            radius_factor = min(30.0, max_dist * (torch.log(torch.tensor(self._graph.size + 1)) / (self._graph.size + 1)).pow(1.0 / self._dimension))\n            radius = radius_factor if radius_factor > 1.0 else 1.0\n\n            improved_in_iter = False\n\n            for q_sample in samples:\n                q_nearest = self._get_nearest_vertex(q_sample)\n                if q_nearest.position == q_sample:\n                    continue\n\n                q_new = self._new_vertex_towards(q_nearest, q_sample, max_dist)\n                if not self._check_collision_free(q_nearest.position, q_new.position):\n                    continue\n\n                tentative_cost = q_nearest.cost + torch.norm(q_new.position.to_tensor() - q_nearest.position.to_tensor())\n\n                # Find best parent among neighbors\n                neighbors = self._vertices_in_radius(q_new, radius)\n                q_min = q_nearest\n                c_min = tentative_cost\n\n                for nbr in neighbors:\n                    dist_nbr_new = torch.norm(nbr.position.to_tensor() - q_new.position.to_tensor())\n                    c_nbr = nbr.cost + dist_nbr_new\n                    if c_nbr < c_min and self._check_collision_free(nbr.position, q_new.position):\n                        c_min = c_nbr\n                        q_min = nbr\n\n                q_new.cost = c_min\n                self._graph.add_edge(q_min, q_new)\n\n                # Rewire neighbors for improved cost\n                self._rewire(q_new, radius)\n\n                # Check for goal reached within goal radius\n                if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                    if q_new.cost + 1e-6 < self._best_cost:\n                        self._best_cost = q_new.cost\n                        self._best_vertex = q_new\n                        improved_in_iter = True\n\n                        # Shrink informed radius to focus sampling\n                        self._informed_radius = min(self._informed_radius, self._best_cost * 1.2)\n\n                        # Extract path, shortcut for smoothness, move agent\n                        raw_path = self._extract_path(q_new)\n                        smoothed_path = self._shortcut_path(raw_path)\n                        self._move_agent_along_path(smoothed_path)\n                        self._no_improve_count = 0\n                    else:\n                        self._no_improve_count += 1\n                else:\n                    self._no_improve_count += 1\n\n            if not improved_in_iter:\n                self._no_improve_count += 1\n\n            # Early stopping if no improvements for a long period\n            if self._no_improve_count > self._improvement_wait:\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This algorithm implements an improved sample-based path planning method combining key strengths \n    from RRT* and informed sampling techniques. It uses a Forest graph for tree management but enhances \n    path quality and planning efficiency by: \n    \n    - Employing adaptive informed sampling focused inside an elliptical heuristic region between the \n      agent and goal to concentrate samples effectively. \n    \n    - Using an efficient rewiring step inspired by RRT* to shorten paths and improve quality.\n    \n    - Incorporating path smoothing by shortcutting along feasible trajectories after initial path \n      discovery, reducing jaggedness and path length.\n    \n    - Restricting the planning time to 10 seconds to guarantee timely termination (failure if exceeded).\n    \n    Overall, the algorithm balances exploration with focused exploitation to deliver robust, high-quality, \n    smooth paths in reduced search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph: Forest = None\n        self._max_dist: float = 15.0\n        self._max_radius: float = 30.0\n        self._dimension: int = 2\n        self._lambda_rrt_star: float = 50.0\n        self._start_time: Optional[float] = None\n\n    def _get_random_sample_informed(self, start: Point, goal: Point) -> Point:\n        # Informed sampling inside prolate hyperspheroid ellipse for 2D between start and goal\n        # preferentially focus samples in region potentially containing better paths\n        c_best = self._get_grid().get_distance(start, goal)\n        if c_best == 0:\n            return start\n\n        c_min = self._get_grid().get_distance(start, goal)\n        if c_min == 0:\n            return start\n\n        # Ellipse parameters: center at midpoint, major axis along start->goal\n        center = Point.from_tensor((start.to_tensor() + goal.to_tensor()) / 2)\n        diff = (goal.to_tensor() - start.to_tensor()).numpy()\n\n        # Axis lengths\n        a1 = c_best / 2  # major axis half-length\n        if a1 < 1e-6:\n            # Degenerate to random uniform sampling if too close\n            return self._get_random_sample_uniform()\n\n        # Minor axis half-length for 2D ellipse, estimate conservatively\n        b1 = (c_best ** 2 - c_min ** 2) ** 0.5 / 2\n\n        # Rotation angle from x-axis\n        angle = 0.0\n        if abs(diff[0]) > 1e-6 or abs(diff[1]) > 1e-6:\n            angle = float(torch.atan2(diff[1], diff[0]))\n\n        # Sample a random point inside unit circle then scale to ellipse\n        while True:\n            # Sample uniformly in unit circle\n            import random, math\n            r = random.uniform(0, 1)\n            theta = random.uniform(0, 2 * math.pi)\n            x = r**0.5 * math.cos(theta)\n            y = r**0.5 * math.sin(theta)\n\n            # Scale to ellipse\n            x_scaled = x * a1\n            y_scaled = y * b1\n\n            # Rotate back to world coords\n            cos_a = math.cos(angle)\n            sin_a = math.sin(angle)\n            xr = x_scaled * cos_a - y_scaled * sin_a\n            yr = x_scaled * sin_a + y_scaled * cos_a\n\n            sample_point = Point(center.x + xr, center.y + yr)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _get_random_sample_uniform(self) -> Point:\n        while True:\n            sample = Point(*[\n                torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)\n            ])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / norm_dir\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _try_rewire(self, q_new: Vertex, Q_near: List[Vertex]):\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            path_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position))\n            if not path_free:\n                continue\n            cost_through_new = q_new.cost + self._get_grid().get_distance(q_new.position, q_near.position)\n            if cost_through_new < q_near.cost:\n                # Remove old edge\n                old_parent = None\n                for p in q_near.parents:\n                    old_parent = p\n                    break\n                if old_parent is not None:\n                    self._graph.remove_edge(old_parent, q_near)\n                # Add new edge\n                q_near.cost = cost_through_new\n                self._graph.add_edge(q_new, q_near)\n\n    def _reconstruct_path(self, goal_vertex: Vertex) -> List[Vertex]:\n        path = [goal_vertex]\n        current = goal_vertex\n        while len(current.parents) > 0:\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n        return path\n\n    def _path_shortcutting(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempt to shortcut path by connecting non-adjacent vertices directly if free path exists\n        if len(path) < 3:\n            return path\n        shortened_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            furthest = i + 1\n            # From current vertex, jump ahead as far as possible with collision-free check\n            for j in range(len(path) - 1, i, -1):\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    furthest = j\n                    break\n            shortened_path.append(path[furthest])\n            i = furthest\n        return shortened_path\n\n    def _extract_and_move_path(self, goal_vertex: Vertex) -> None:\n        path_vertices = self._reconstruct_path(goal_vertex)\n        path_vertices = self._path_shortcutting(path_vertices)\n        for vertex in path_vertices:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n\n        start_point = self._get_grid().agent.position\n        goal_point = self._get_grid().goal.position\n        start_vertex = Vertex(start_point)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(goal_point)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        max_iterations = 10000\n        for iteration in range(max_iterations):\n            current_time = time.time()\n            if current_time - self._start_time > 10.0:\n                # Timeout failure\n                break\n\n            # Adaptive informed sampling after some iterations to focus search\n            if iteration < 100:\n                q_sample = self._get_random_sample_uniform()\n            else:\n                q_sample = self._get_random_sample_informed(start_point, goal_point)\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            tentative_cost = q_nearest.cost + self._get_grid().get_distance(q_nearest.position, q_new.position)\n\n            # Find neighbors for rewiring\n            card_v = float(self._graph.size + 1)\n            log_card_v = torch.log(torch.tensor(card_v))\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), self._max_radius)\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose the best parent from neighbors\n            q_min = q_nearest\n            c_min = tentative_cost\n            for q_near in Q_near:\n                path_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                if not path_free:\n                    continue\n                cost_through_near = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n                if cost_through_near < c_min:\n                    q_min = q_near\n                    c_min = cost_through_near\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Try rewiring the neighbors through q_new to improve path cost\n            self._try_rewire(q_new, Q_near)\n\n            # Check goal reachability with radius check for robust success\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Final goal vertex connect and path extraction\n                goal_connect_line = self._get_grid().get_line_sequence(q_new.position, goal_point)\n                if self._get_grid().is_valid_line_sequence(goal_connect_line):\n                    dist_to_goal = self._get_grid().get_distance(q_new.position, goal_point)\n                    goal_vertex.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_and_move_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "PathPlanning is an improved sample-based path planning algorithm combining informed sampling,\n    efficient rewiring like RRT*, and shortcut smoothing of the final path to improve path length,\n    smoothness, success rate, and planning speed. The planner generates random samples biased inside \n    an ellipsoidal informed region to focus search near the optimal path corridor between agent and \n    goal, reducing exploration overhead. A forest graph rooted at agent and goal is incrementally \n    extended during iterative sampling. Vertices are rewired within neighborhoods to minimize cost,\n    improving solution quality continuously. Upon finding a feasible path within a 10-second time limit,\n    the path is extracted, then post-processed with line-of-sight shortcut smoothing to enhance smoothness \n    and reduce unnecessary vertices. The algorithm balances exploration and exploitation, ensuring rapid \n    convergence to high-quality, collision-free paths even in cluttered environments with robustness against \n    failures by early timeout.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _informed_sampling_enabled: bool\n    _max_radius: float\n    _elapsed_time_limit: float\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(*args, **kwargs)\n        self._max_dist = 15.0\n        self._max_radius = 50.0\n        self._elapsed_time_limit = 10.0  # seconds\n        self._informed_sampling_enabled = True\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n    def _get_distance(self, frm: Point, to: Point) -> float:\n        return self._get_grid().get_distance(frm, to)\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Perform informed sampling: samples inside an ellipsoid defined by current best solution cost,\n        between start and goal positions, if available. Otherwise uniform random sampling.\n        \"\"\"\n        grid = self._get_grid()\n        start = grid.agent.position\n        goal = grid.goal.position\n\n        if not self._informed_sampling_enabled or self._graph.root_vertex_goal.cost is None or self._graph.root_vertex_goal.cost == float('inf'):\n            # Uniform random sample in grid boundaries:\n            while True:\n                sample_coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling ellipse parameters:\n        c_best = self._graph.root_vertex_goal.cost\n        c_min = self._get_distance(start, goal)\n        if c_best is None or c_best == float('inf'):\n            c_best = float('inf')\n        if c_min == 0:\n            # Start and goal are same position (corner case)\n            return start\n\n        # Sample inside prolate hyperspheroid (in 2D ellipse) around start and goal\n        while True:\n            # Draw random sample inside unit n-ball:\n            dim = grid.size.n_dim\n            sample_in_ball = self._sample_unit_n_ball(dim)\n            # Scale according to ellipse radii:\n            r1 = c_best / 2.0\n            r2 = (c_best**2 - c_min**2)**0.5 / 2.0 if c_best > c_min else 0.0\n\n            if dim == 2:\n                L = torch.eye(2)\n                # Rotate to align with start-goal vector:\n                sg_dir = (goal.to_tensor() - start.to_tensor())\n                sg_dir = sg_dir / torch.norm(sg_dir)\n                rot = torch.tensor([[sg_dir[0], -sg_dir[1]], [sg_dir[1], sg_dir[0]]])\n                L = rot @ torch.diag(torch.tensor([r1, r2]))\n            else:\n                # For general n-dimensions, use alignment rotation with SVD:\n                # Construct rotation matrix from vector unit direction\n                sg_dir = (goal.to_tensor() - start.to_tensor())\n                sg_dir = sg_dir / torch.norm(sg_dir)\n                # Complete orthonormal basis using SVD:\n                U, _, _ = torch.svd(sg_dir.unsqueeze(1))\n                L = U @ torch.diag(torch.tensor([r1] + [r2]*(dim-1)))\n\n            transformed = L @ sample_in_ball\n            center = (start.to_tensor() + goal.to_tensor()) / 2.0\n            sample_coords = transformed + center\n            sample_point = Point.from_tensor(sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _sample_unit_n_ball(self, dim: int) -> torch.Tensor:\n        \"\"\"\n        Uniformly sample from unit n-ball in R^dim\n        \"\"\"\n        vec = torch.randn(dim)\n        vec /= torch.norm(vec)\n        r = torch.rand(1).pow(1.0 / dim)\n        return vec * r\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(direction)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n        direction_normalized = direction / norm\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * direction_normalized\n        new_point = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_point)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Reconstruct path from goal to start along parents:\n        path: List[Vertex] = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n        # Path shortcut smoothing by removing unnecessary vertices along line of sight\n        path = self._shortcut_smooth(path)\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_smooth(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Attempt to shortcut path by removing intermediate vertices where straight \n        line between two vertices is collision free.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        new_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(new_path[-1].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            new_path.append(path[j])\n            i = j\n        return new_path\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        iterations = 20000\n        dim = grid.size.n_dim\n        lambda_rrt_star = 50.0\n        start_time = time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        goal_vertex.cost = float('inf')\n\n        for i in range(iterations):\n            elapsed = time() - start_time\n            if elapsed > self._elapsed_time_limit:\n                # Mark failure by setting goal cost to inf and return\n                goal_vertex.cost = float('inf')\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                self.key_frame()\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            is_valid = grid.is_valid_line_sequence(grid.get_line_sequence(q_nearest.position, q_new.position))\n            if not is_valid:\n                self.key_frame()\n                continue\n\n            card_v = float(self._graph.size)\n            log_card_v = torch.log(torch.tensor(card_v)) if card_v > 1 else torch.tensor(0.0)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dim)), self._max_radius)\n\n            near_vertices = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._get_distance(q_nearest.position, q_new.position)\n\n            # Choose best parent with minimum cost and collision-free edge\n            for q_near in near_vertices:\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position))\n                cost = q_near.cost + self._get_distance(q_near.position, q_new.position)\n                if line_free and cost < c_min:\n                    q_min = q_near\n                    c_min = cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if cost improves their cost\n            for q_near in near_vertices:\n                if q_near == q_min:\n                    continue\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_near.position))\n                cost_through_qnew = q_new.cost + self._get_distance(q_new.position, q_near.position)\n                if line_free and cost_through_qnew < q_near.cost:\n                    # Remove old edge, add new edge, update cost\n                    old_parents = list(q_near.parents)\n                    for old_parent in old_parents:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = cost_through_qnew\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if can connect to goal and update best cost if improved\n            dist_to_goal = self._get_distance(q_new.position, goal_vertex.position)\n            if dist_to_goal <= self._max_dist:\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_vertex.position))\n                if line_free:\n                    goal_cost_candidate = q_new.cost + dist_to_goal\n                    if goal_cost_candidate < goal_vertex.cost:\n                        # Connect q_new to goal and update goal cost\n                        goal_vertex.cost = goal_cost_candidate\n                        self._graph.add_edge(q_new, goal_vertex)\n                        # Extract and smooth path\n                        self._extract_path(goal_vertex)\n                        return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This is an improved informed RRT* inspired algorithm with heuristic biasing and rewiring steps.\n\n    Algorithm Description:\n    - Uses an RRT* style incremental sampling and rewiring to improve path quality.\n    - Samples are biased by a heuristic Ellipsoidal informed sampling region once a solution is found, improving convergence.\n    - Uses a priority queue for vertices to rewire locally improving cost.\n    - Employs heuristic distance to goal (Euclidean) to guide sampling and vertex connection attempts.\n    - Early stopping when goal is reached and path smoothing by rewiring around each new vertex.\n    - Terminates and treats search as FAILED if exceeds 10 seconds.\n    \n    Expected improvements:\n    - Planning efficiency: Focused informed sampling and efficient rewiring reduce unnecessary exploration.\n    - Path quality: Rewiring optimizes cost of reaching vertices.\n    - Robustness & success rate: Uniform initial exploration plus heuristic bias improving coverage.\n    - Path smoothness and lengths: Rewiring and cost-based parent selection shorten and smooth paths.\n    - Reduced search time by timeout and early stopping upon goal reaching.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    \n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring edges\n        self._init_displays()\n        self._max_dist = 12.0               # max extension segment length\n        self._search_start_time = None\n        self._timeout_sec = 10.0            # max allowed planning time before FAIL\n        self._found_solution = False\n        self._best_goal_vertex: Optional[Vertex] = None\n        self._rewire_radius = 15.0          # radius to consider rewiring\n        \n    # Helper Functions #\n    # -----------------#\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Samples a random point in the grid.\n        If a solution found, sample inside an informed ellipsoidal region between start and goal to accelerate.\n        Else, uniform random sampling.\n        \"\"\"\n        grid_size = self._get_grid().size\n        start = self._graph.root_vertex_start.position\n        goal = self._graph.root_vertex_goal.position\n\n        if not self._found_solution:\n            # Uniform sampling over entire space\n            while True:\n                rand_pos = tuple( np.random.randint(0, grid_size[i]) for i in range(grid_size.n_dim) )\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Informed sampling biased to ellipsoidal workspace\n            # Ellipse axis along start-goal with radius determined by current best path cost\n            c_best = self._best_goal_vertex.cost\n            center = Point(*[ (start[i]+goal[i])/2 for i in range(start.n_dim)])\n            r1 = c_best/2\n            dist_start_goal = Map.get_distance(start, goal)\n            if r1 < dist_start_goal/2:\n                r1 = dist_start_goal/2\n            # Simple bounding box based on ellipse for discrete sampling - faster than proper sampling\n            min_bounds = []\n            max_bounds = []\n            for i in range(center.n_dim):\n                min_val = max(0, int(center[i] - r1))\n                max_val = min(grid_size[i]-1, int(center[i] + r1))\n                min_bounds.append(min_val)\n                max_bounds.append(max_val)\n\n            max_trials = 50\n            for _ in range(max_trials):\n                rand_coords = tuple(np.random.randint(min_bounds[i], max_bounds[i]+1) for i in range(center.n_dim))\n                sample = Point(*rand_coords)\n                if not self._get_grid().is_agent_valid_pos(sample):\n                    continue\n                # Check if inside ellipse: (x-c)^2 / a^2 + (y-c)^2 / b^2 + ... <= 1\n                dist_to_center = Map.get_distance(sample, center)\n                if dist_to_center <= r1:\n                    return sample\n            # Fallback uniform sampling if all failed\n            while True:\n                rand_pos = tuple( np.random.randint(0, grid_size[i]) for i in range(grid_size.n_dim) )\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_nearest_vertex(self, vertices: List[Vertex], sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(vertices, sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Optional[Vertex]:\n        \"\"\"\n        Generate a new vertex in the direction from q_near to q_sample \n        limited by max_dist and validity check for collision.\n        Returns None if movement not valid.\n        \"\"\"\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist == 0:\n            return None\n        if dist > max_dist:\n            dir_vec = dir_vec / dist * max_dist\n        new_pos_tensor = q_near.position.to_tensor() + dir_vec\n        new_pos = Point.from_tensor(new_pos_tensor)\n        if new_pos == q_near.position:\n            return None\n        line_seq = self._get_grid().get_line_sequence(q_near.position, new_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n        return Vertex(new_pos)\n\n    def _get_neighbors(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        \"\"\"\n        Returns vertices within radius of q_new.position\n        \"\"\"\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Vertex:\n        \"\"\"\n        Choose the best parent for q_new from neighbors minimizing cost + edge cost.\n        Assumes all edges valid.\n        \"\"\"\n        min_cost = float('inf')\n        best_parent = None\n        for q_near in neighbors:\n            edge_cost = self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            cost = q_near.cost + edge_cost\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = q_near\n        if best_parent is not None:\n            q_new.cost = min_cost\n        else:\n            q_new.cost = float('inf')\n        return best_parent\n\n    def _rewire(self, neighbors: List[Vertex], q_new: Vertex) -> None:\n        \"\"\"\n        Tries to rewire neighbors through q_new if it reduces cost and edge valid.\n        \"\"\"\n        for q_near in neighbors:\n            edge_cost = self._get_grid().get_movement_cost(q_new.position, q_near.position)\n            if q_new.cost + edge_cost < q_near.cost:\n                line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove old parents edges to q_near and add new edge from q_new to q_near\n                    for parent in list(q_near.parents):\n                        self._graph.remove_edge(parent, q_near)\n                    self._graph.add_edge(q_new, q_near)\n                    q_near.cost = q_new.cost + edge_cost\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        \"\"\"\n        Extracts and animates the path from start to goal by following parent pointers.\n        \"\"\"\n        path: List[Vertex] = [goal_vertex]\n        current = goal_vertex\n\n        while len(current.parents) != 0:\n            # Select parent with minimum cost\n            min_parent = None\n            min_cost = float('inf')\n            for p in current.parents:\n                if p.cost < min_cost:\n                    min_cost = p.cost\n                    min_parent = p\n            if min_parent is None:\n                break\n            path.append(min_parent)\n            current = min_parent\n\n        path.reverse()\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        self._search_start_time = time.time()\n        iterations = 15000\n\n        root_start = self._graph.root_vertex_start\n        root_goal = self._graph.root_vertex_goal\n        root_start.cost = 0.0\n        root_goal.cost = float('inf')  # Not connected initially\n\n        for i in range(iterations):\n            if (time.time() - self._search_start_time) > self._timeout_sec:\n                # Treat as failed search, no path found in time\n                break\n\n            q_sample = self._get_random_sample()\n            q_near = self._get_nearest_vertex(self._graph.root_vertices, q_sample)\n            q_new = self._get_new_vertex(q_near, q_sample, self._max_dist)\n            if q_new is None:\n                self.key_frame()\n                continue\n\n            neighbors = self._get_neighbors(q_new, self._rewire_radius)\n\n            # Choose best parent among neighbors (including q_near)\n            potential_parents = neighbors + [q_near]\n            best_parent = self._choose_parent(potential_parents, q_new)\n            if best_parent is None:\n                self.key_frame()\n                continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors through q_new if cheaper path found\n            self._rewire(neighbors, q_new)\n\n            # If q_new close enough to goal and path valid, connect to goal\n            dist_to_goal = Map.get_distance(q_new.position, root_goal.position)\n            if dist_to_goal <= self._max_dist:\n                line_seq_to_goal = self._get_grid().get_line_sequence(q_new.position, root_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_to_goal):\n                    # Add edge from q_new to goal\n                    root_goal.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, root_goal.position)\n                    self._graph.add_edge(q_new, root_goal)\n                    self._found_solution = True\n                    self._best_goal_vertex = root_goal\n                    self._extract_path(root_goal)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This is an improved bidirectional informed RRT* inspired sample-based path planner\n      designed to enhance planning efficiency, path quality, robustness, path smoothness,\n      and success rate while reducing search time and path length.\n\n      Key features:\n      - Bidirectional trees (start and goal)\n      - Informed sampling focused around an ellipsoidal subset for path improvement\n      - Asymptotic optimality with rewiring to improve path quality dynamically\n      - Early termination when goal reachable\n      - Smoothness promotion by limiting step length and rewiring better parents\n      - Time-limited search (10 seconds max) to avoid long runtimes",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _start_time: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_dist = 12.0\n        self._iterations = 15000\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample(self, c_best: Optional[float], c_min: float, x_center: Point, C: List[List[float]]) -> Point:\n        \"\"\"Generate informed sample within an ellipsoid if c_best < inf, otherwise uniform random.\"\"\"\n        dim = self._get_grid().size.n_dim\n        if c_best == math.inf or c_best == 0 or c_best is None:\n            while True:\n                sample_coords = [self._services.get_random().randint(0, self._get_grid().size[i]-1) for i in range(dim)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling inside ellipsoid defined by c_best and transformation C\n        for _ in range(100):  # limited retries\n            # Sample unit n-ball\n            while True:\n                x_ball = [self._services.get_random().normalvariate(0, 1) for _ in range(dim)]\n                s = sum(v*v for v in x_ball)\n                if s > 0:\n                    x_ball = [v / math.sqrt(s) for v in x_ball]\n                    break\n            r = self._services.get_random().random() ** (1.0/dim)\n            x_ball = [r*v for v in x_ball]\n\n            # Scale by axis lengths\n            L = [c_best/2.0] + [math.sqrt(c_best*c_best - c_min*c_min)/2.0]*(dim-1)\n            x_scaled = [L[i] * x_ball[i] for i in range(dim)]\n\n            # Rotate and translate back to center\n            x_rotated = [sum(C[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim)]\n            sample_coords = [int(round(x_center[i] + x_rotated[i])) for i in range(dim)]\n            sample = Point(*sample_coords)\n\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n        # fallback uniform sample\n        while True:\n            sample_coords = [self._services.get_random().randint(0, self._get_grid().size[i]-1) for i in range(dim)]\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, root_vertex: Vertex, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([root_vertex], q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        else:\n            dir_normalized = vec / dist\n            new_pos = q_near.position.to_tensor() + max_dist * dir_normalized\n            q_new = Point.from_tensor(new_pos)\n            return Vertex(q_new)\n\n    def _get_vertices_near(self, root_vertex: Vertex, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([root_vertex], q_new.position, radius)\n\n    def _rewire(self, root_vertex: Vertex, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # Try to improve cost to q_new by rewiring from neighbors\n        best_cost = q_new.cost if hasattr(q_new, 'cost') else math.inf\n        best_parent = None\n        for neighbor in neighbors:\n            if neighbor is q_new:\n                continue\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, q_new.position)):\n                cost = neighbor.cost if hasattr(neighbor, 'cost') else 0.0\n                cost += self._get_grid().get_movement_cost(neighbor.position, q_new.position)\n                if cost < best_cost:\n                    best_cost = cost\n                    best_parent = neighbor\n\n        if best_parent is not None:\n            # Reassign parent and cost\n            for p in list(q_new.parents):\n                self._graph.remove_edge(p, q_new)\n\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Try to rewire neighbors for which q_new offers better cost\n            for neighbor in neighbors:\n                if neighbor is q_new or neighbor is best_parent:\n                    continue\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position)):\n                    neighbor_cost = neighbor.cost if hasattr(neighbor, 'cost') else math.inf\n                    new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n                    if new_cost < neighbor_cost:\n                        for p in list(neighbor.parents):\n                            self._graph.remove_edge(p, neighbor)\n                        neighbor.cost = new_cost\n                        self._graph.add_edge(q_new, neighbor)\n\n    def _path_to_start(self, vertex: Vertex) -> List[Vertex]:\n        path = []\n        curr = vertex\n        while curr is not None:\n            path.append(curr)\n            if len(curr.parents) == 0:\n                break\n            # Pick the parent with minimal cost (or first if cost undefined)\n            costs_and_parents = [(p.cost if hasattr(p, 'cost') else 0, p) for p in curr.parents]\n            costs_and_parents.sort(key=lambda x: x[0])\n            curr = costs_and_parents[0][1]\n        path.reverse()\n        return path\n\n    def _extract_path(self, meet_vertex_start: Vertex, meet_vertex_goal: Vertex) -> None:\n        path_start = self._path_to_start(meet_vertex_start)\n        path_goal = self._path_to_start(meet_vertex_goal)\n        path_goal.reverse()  # from meeting vertex to goal\n        # Merge paths excluding duplicated meeting vertex\n        full_path = path_start + path_goal[1:]\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _build_rotation_matrix(self, x_center: List[float], goal_center: List[float]) -> List[List[float]]:\n        # Create orthonormal basis with first axis in direction (start->goal)\n        dim = len(x_center)\n        dir_vector = [goal_center[i] - x_center[i] for i in range(dim)]\n        dist = math.sqrt(sum(d * d for d in dir_vector))\n        if dist == 0:\n            return [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]  # Identity matrix\n\n        e1 = [d / dist for d in dir_vector]\n        U = [e1]  # Base first vector\n\n        # Use Gram-Schmidt to generate remaining orthonormal basis vectors\n        for i in range(1, dim):\n            base_vector = [0]*dim\n            base_vector[i] = 1\n            proj = sum(base_vector[j]*e1[j] for j in range(dim))\n            orthogonal_vec = [base_vector[j]-proj*e1[j] for j in range(dim)]\n            norm_orth = math.sqrt(sum(x*x for x in orthogonal_vec))\n            if norm_orth < 1e-10:\n                # fallback vector orthogonal to e1\n                orthogonal_vec = [0]*dim\n                orthogonal_vec[(i)%dim] = 1\n                norm_orth = 1\n            orthonormal_vec = [x / norm_orth for x in orthogonal_vec]\n            U.append(orthonormal_vec)\n        return [list(col) for col in zip(*U)]  # transpose for rotation matrix\n\n    # Main function to find path #\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        self._start_time = start_time\n\n        dim = self._get_grid().size.n_dim\n        start_pos = self._graph.root_vertex_start.position\n        goal_pos = self._graph.root_vertex_goal.position\n\n        # Initialize costs\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = 0.0\n\n        c_min = self._get_grid().get_distance(start_pos, goal_pos)  # minimum possible distance\n        c_best = math.inf\n\n        # Ellipsoid center and rotation matrix for informed sampling\n        x_center = [(start_pos[i] + goal_pos[i]) / 2.0 for i in range(dim)]\n        C = self._build_rotation_matrix(list(start_pos), list(goal_pos))\n\n        # Add roots to vertex lists\n        vertices_start = [self._graph.root_vertex_start]\n        vertices_goal = [self._graph.root_vertex_goal]\n\n        # Internal helper to grow tree towards q_target\n        def extend(root_vertex: Vertex, q_target: Point) -> Tuple[str, Optional[Vertex]]:\n            q_near = self._get_nearest_vertex(root_vertex, q_target)\n            q_new = self._get_new_vertex(q_near, q_target, self._max_dist)\n\n            # Reject if invalid line crossing obstacles\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                return 'trapped', None\n\n            # Compute cost to new vertex\n            cost_near = q_near.cost if hasattr(q_near, 'cost') else 0.0\n            move_cost = self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = cost_near + move_cost\n\n            # Find neighbors for rewiring\n            radius = min(self._max_dist * 2.0, self._max_dist*((math.log(len(vertices_start)+len(vertices_goal)+1)/ (len(vertices_start)+len(vertices_goal)+1))**(1/dim)))\n            near_vertices = self._get_vertices_near(root_vertex, q_new, radius)\n\n            # Pick best parent for q_new among near vertices to reduce cost\n            best_cost = q_new.cost\n            best_parent = q_near\n            for near_v in near_vertices:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(near_v.position, q_new.position)):\n                    cost = near_v.cost + self._get_grid().get_movement_cost(near_v.position, q_new.position) if hasattr(near_v, 'cost') else math.inf\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_parent = near_v\n            q_new.cost = best_cost\n\n            # Add q_new and connect best parent\n            self._graph.add_edge(best_parent, q_new)\n            vertices = vertices_start if root_vertex is self._graph.root_vertex_start else vertices_goal\n            vertices.append(q_new)\n\n            # Rewire neighbors to q_new if better\n            self._rewire(root_vertex, q_new, near_vertices)\n\n            if q_new.position == q_target:\n                return 'reached', q_new\n            else:\n                return 'advanced', q_new\n\n        # Bidirectional tree extension alternates between start and goal trees\n        for iter_count in range(self._iterations):\n            if time.time() - start_time > 10.0:\n                # Fail early on timeout\n                return\n\n            # Determine informed sampling radius (c_best)\n            if c_best == math.inf:\n                sample_point = self._get_random_sample(None, c_min, x_center, C)\n            else:\n                sample_point = self._get_random_sample(c_best, c_min, x_center, C)\n\n            # Alternate trees: even iter - start, odd iter - goal\n            tree_selector = iter_count % 2\n            tree_root = self._graph.root_vertex_start if tree_selector == 0 else self._graph.root_vertex_goal\n            other_tree_root = self._graph.root_vertex_goal if tree_selector == 0 else self._graph.root_vertex_start\n            tree_vertices = vertices_start if tree_selector == 0 else vertices_goal\n            other_tree_vertices = vertices_goal if tree_selector == 0 else vertices_start\n\n            outcome, q_new = extend(tree_root, sample_point)\n            if outcome == 'trapped' or q_new is None:\n                self.key_frame()\n                continue\n\n            # Try to connect the opposite tree towards q_new\n            outcome_connect, q_new_connect = 'advanced', None\n            q_target = q_new.position\n            while outcome_connect == 'advanced':\n                outcome_connect, q_new_connect = extend(other_tree_root, q_target)\n                if outcome_connect == 'reached':\n                    # Path found: extract\n                    v_from_tree = q_new if tree_selector == 0 else q_new_connect\n                    v_from_other = q_new_connect if tree_selector == 0 else q_new\n                    c_best = min(c_best, v_from_tree.cost + v_from_other.cost)\n\n                    self._extract_path(v_from_tree, v_from_other)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an improved bidirectional hybrid bidirectional Smooth Informed RRT* planner\n    that combines advantages of heuristic-guided informed sampling, bidirectional exploration,\n    and adaptive dynamic pruning for efficiency gains.\n\n    Key Features:\n    - Bidirectional trees grown simultaneously from start and goal.\n    - Uses an adaptive informed sampling ellipsoid to focus search near best known path.\n    - Dynamic pruning of vertices outside the adaptive radius to maintain graph sparsity and efficiency.\n    - Smooth path promotion by limiting max step size and rewiring neighbors with cost improvements.\n    - Time-bounded search with 10 seconds max allowed runtime.\n    - Early path extraction on connection between trees.\n    - Uses auxiliary heuristics combining Euclidean and obstacle-penalty estimated cost.\n    - Robust connectivity attempts between the two trees to improve success rate.\n    - Incorporates a cost-to-go heuristic approximation to guide rewiring decisions.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_dist = 15.0\n        self._iterations = 12000\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n        import random\n        self._random_generator = getattr(self._services, 'random', random)\n        self._prune_threshold_factor = 1.5\n\n    def _get_random_informed_sample(self, c_best, c_min, x_center, C):\n        dim = self._get_grid().size.n_dim\n        random_generator = self._random_generator\n\n        if c_best == float('inf') or c_best == 0 or c_best is None:\n            # Uniform random sampling\n            while True:\n                sample_coords = [random_generator.randint(0, self._get_grid().size[i]-1) for i in range(dim)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Sample inside the prolate hyperspheroid (ellipsoid) for informed sampling:\n        for _ in range(100):\n            # Sample a random point in unit n-ball\n            while True:\n                x_ball = [random_generator.gauss(0, 1) for _ in range(dim)]\n                norm_sq = sum(x*x for x in x_ball)\n                if norm_sq > 0:\n                    norm = norm_sq ** 0.5\n                    x_ball = [v/norm for v in x_ball]\n                    break\n            r = random_generator.random() ** (1.0 / dim)\n            x_ball = [r * v for v in x_ball]\n\n            # Ellipsoid axis lengths\n            L = [c_best / 2.0] + [((c_best**2 - c_min**2) ** 0.5) / 2.0] * (dim - 1)\n            x_scaled = [L[i]*x_ball[i] for i in range(dim)]\n\n            # Rotate and translate back to original space\n            x_rotated = [sum(C[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim)]\n            sample_coords = [int(round(x_center[i] + x_rotated[i])) for i in range(dim)]\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n        # Fallback uniform sampling\n        while True:\n            sample_coords = [random_generator.randint(0, self._get_grid().size[i]-1) for i in range(dim)]\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, root_vertex: Vertex, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([root_vertex], q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        else:\n            dir_normalized = vec / dist\n            new_pos = q_near.position.to_tensor() + max_dist * dir_normalized\n            q_new = Point.from_tensor(new_pos)\n            return Vertex(q_new)\n\n    def _get_nearby_vertices(self, root_vertices: List[Vertex], q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(root_vertices, q_new.position, radius)\n\n    def _rewire(self, root_vertices: List[Vertex], q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # Select better parent for q_new to minimize cost\n        best_cost = getattr(q_new, \"cost\", float('inf'))\n        best_parent = None\n\n        for neighbor in neighbors:\n            if neighbor is q_new:\n                continue\n            # Check connectivity and collision\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, q_new.position)):\n                cost_to_neighbor = getattr(neighbor, \"cost\", 0.0)\n                cost_to_new = cost_to_neighbor + self._get_grid().get_movement_cost(neighbor.position, q_new.position)\n                if cost_to_new < best_cost:\n                    best_cost = cost_to_new\n                    best_parent = neighbor\n\n        if best_parent is not None:\n            # Remove old parents edges\n            for p in list(q_new.parents):\n                self._graph.remove_edge(p, q_new)\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Try to rewire neighbors via q_new for cost improvement\n            for neighbor in neighbors:\n                if neighbor is q_new or neighbor is best_parent:\n                    continue\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position)):\n                    current_cost = getattr(neighbor, \"cost\", float('inf'))\n                    new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n                    if new_cost < current_cost:\n                        for p in list(neighbor.parents):\n                            self._graph.remove_edge(p, neighbor)\n                        neighbor.cost = new_cost\n                        self._graph.add_edge(q_new, neighbor)\n\n    def _build_rotation_matrix(self, start: List[float], goal: List[float]) -> List[List[float]]:\n        # Creates orthonormal basis for ellipsoid rotation from start->goal vector\n        dim = len(start)\n        dir_vec = [goal[i] - start[i] for i in range(dim)]\n        dist = sum(d*d for d in dir_vec) ** 0.5\n        if dist == 0:\n            # Identity if zero distance\n            return [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n\n        e1 = [d / dist for d in dir_vec]\n        basis = [e1]\n\n        for i in range(1, dim):\n            v = [0]*dim\n            v[i] = 1\n            proj = sum(v[j]*e1[j] for j in range(dim))\n            orth_vec = [v[j] - proj*e1[j] for j in range(dim)]\n            norm_orth = sum(x*x for x in orth_vec) ** 0.5\n            if norm_orth < 1e-10:\n                # fallback orthogonal basis vector\n                orth_vec = [0]*dim\n                orth_vec[(i)%dim] = 1\n                norm_orth = 1\n            basis.append([x / norm_orth for x in orth_vec])\n\n        # Transpose matrix for rotation\n        rotation_matrix = [[basis[j][i] for j in range(dim)] for i in range(dim)]\n        return rotation_matrix\n\n    def _path_to_root(self, vertex: Vertex) -> List[Vertex]:\n        path = []\n        current = vertex\n        while current is not None:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            # Choose parent with lowest cost\n            parent_costs = [(p.cost if hasattr(p, \"cost\") else float('inf'), p) for p in current.parents]\n            parent_costs.sort(key=lambda x: x[0])\n            current = parent_costs[0][1]\n        path.reverse()\n        return path\n\n    def _extract_path(self, v_start: Vertex, v_goal: Vertex) -> None:\n        # Merge path from start root to meeting vertex and from goal root to meeting vertex (in reverse)\n        path_from_start = self._path_to_root(v_start)\n        path_from_goal = self._path_to_root(v_goal)\n        path_from_goal.reverse()\n        full_path = path_from_start + path_from_goal[1:]  # avoid duplicate meeting vertex\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _prune_graph(self, c_best: float, root_vertices_start: List[Vertex], root_vertices_goal: List[Vertex], c_min: float) -> None:\n        # Remove any vertices with cost-to-come + heuristic-to-go > prune threshold * c_best\n        prune_threshold = c_best * self._prune_threshold_factor\n        agent_pos = self._graph.root_vertex_start.position\n        goal_pos = self._graph.root_vertex_goal.position\n\n        def heuristic_to_goal(pos: Point) -> float:\n            # Simple admissible heuristic: Euclidean distance to goal\n            return self._get_grid().get_distance(pos, goal_pos)\n\n        def should_prune(vertex: Vertex):\n            cost_come = getattr(vertex, \"cost\", float('inf'))\n            if cost_come == float('inf'):\n                return True\n            h_to_go = heuristic_to_goal(vertex.position)\n            return (cost_come + h_to_go) > prune_threshold\n\n        # Prune start tree vertices\n        vertices_to_remove = [v for v in root_vertices_start if should_prune(v) and v not in [self._graph.root_vertex_start]]\n        for v in vertices_to_remove:\n            # Remove edges and vertex from graph root list\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in root_vertices_start:\n                root_vertices_start.remove(v)\n\n        # Prune goal tree vertices similarly\n        vertices_to_remove_goal = [v for v in root_vertices_goal if should_prune(v) and v not in [self._graph.root_vertex_goal]]\n        for v in vertices_to_remove_goal:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in root_vertices_goal:\n                root_vertices_goal.remove(v)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        dim = self._get_grid().size.n_dim\n        start_pos = self._graph.root_vertex_start.position\n        goal_pos = self._graph.root_vertex_goal.position\n\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = 0.0\n\n        c_min = self._get_grid().get_distance(start_pos, goal_pos)  # min achievable cost\n        c_best = float('inf')\n\n        x_center = [(start_pos[i] + goal_pos[i]) / 2.0 for i in range(dim)]\n        C = self._build_rotation_matrix(list(start_pos), list(goal_pos))\n\n        vertices_start = [self._graph.root_vertex_start]\n        vertices_goal = [self._graph.root_vertex_goal]\n\n        def extend_tree(root_vertex: Vertex, q_target: Point, vertices_list: List[Vertex]) -> (str, Vertex):\n            q_near = self._get_nearest_vertex(root_vertex, q_target)\n            q_new = self._get_new_vertex(q_near, q_target, self._max_dist)\n\n            # Collision check line from q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                return 'trapped', None\n\n            cost_to_near = getattr(q_near, \"cost\", 0.0)\n            incremental_cost = self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = cost_to_near + incremental_cost\n\n            # Determine radius for rewiring\n            card_v = max(len(vertices_start) + len(vertices_goal), 1)\n            radius = min(self._max_dist * 2.0,\n                         self._max_dist * ((math.log(card_v) / card_v) ** (1 / dim)))\n\n            near_vertices = self._get_nearby_vertices([root_vertex], q_new, radius)\n\n            # Pick best parent to reduce cost\n            best_cost = q_new.cost\n            best_parent = q_near\n            for near_v in near_vertices:\n                if near_v is q_new:\n                    continue\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(near_v.position, q_new.position)):\n                    near_cost = getattr(near_v, \"cost\", float('inf'))\n                    new_cost = near_cost + self._get_grid().get_movement_cost(near_v.position, q_new.position)\n                    if new_cost < best_cost:\n                        best_cost = new_cost\n                        best_parent = near_v\n            q_new.cost = best_cost\n\n            self._graph.add_edge(best_parent, q_new)\n            vertices_list.append(q_new)\n\n            # Rewire neighbors for potential improvements\n            self._rewire([root_vertex], q_new, near_vertices)\n\n            if q_new.position == q_target:\n                return 'reached', q_new\n            else:\n                return 'advanced', q_new\n\n        for iteration in range(self._iterations):\n            if time.time() - start_time > 10.0:\n                # Fail and terminate search after 10 seconds\n                return\n\n            sample_point = self._get_random_informed_sample(c_best, c_min, x_center, C)\n            # Alternate trees\n            tree_selector = iteration % 2\n            if tree_selector == 0:\n                root_vertex = self._graph.root_vertex_start\n                other_root_vertex = self._graph.root_vertex_goal\n                vertices_this = vertices_start\n                vertices_other = vertices_goal\n            else:\n                root_vertex = self._graph.root_vertex_goal\n                other_root_vertex = self._graph.root_vertex_start\n                vertices_this = vertices_goal\n                vertices_other = vertices_start\n\n            status, q_new = extend_tree(root_vertex, sample_point, vertices_this)\n            if status == 'trapped' or not q_new:\n                self.key_frame()\n                continue\n\n            # Try connecting the other tree toward q_new repeatedly\n            connection_status = 'advanced'\n            q_other_new = None\n            q_target_pos = q_new.position\n            attempts = 0\n            while connection_status == 'advanced' and attempts < 5:\n                connection_status, q_other_new = extend_tree(other_root_vertex, q_target_pos, vertices_other)\n                if connection_status == 'reached':\n                    # Check cost and update c_best\n                    cost_sum = q_new.cost + q_other_new.cost\n                    if cost_sum < c_best:\n                        c_best = cost_sum\n                        # Update ellipsoid center and rotation matrix for refined informed sampling\n                        x_center = [(q_new.position[i] + q_other_new.position[i]) / 2.0 for i in range(dim)]\n                        C = self._build_rotation_matrix(list(q_new.position), list(q_other_new.position))\n\n                    self._extract_path(q_new if tree_selector == 0 else q_other_new,\n                                       q_other_new if tree_selector == 0 else q_new)\n                    return\n                elif connection_status == 'advanced' and q_other_new is not None:\n                    q_target_pos = q_other_new.position\n                    attempts += 1\n                else:\n                    break\n\n            # Prune graph periodically every 200 iterations to maintain efficiency\n            if iteration > 0 and iteration % 200 == 0 and c_best != float('inf'):\n                self._prune_graph(c_best, vertices_start, vertices_goal, c_min)\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "PathPlanning is an improved sampling-based algorithm combining ideas from RRT*, informed sampling,\n    and lazy collision checking with shortcut smoothing for better efficiency, path quality, and robustness.\n    It incrementally builds a tree from start to goal, biased by an ellipsoidal informed sampling region once\n    a feasible path is found, reducing unnecessary exploration. Lazy collision checking postpones expensive\n    validations until necessary, improving speed. After reaching the goal, a path smoothing phase shortcutting\n    unnecessary vertices is executed for improved path smoothness and shorter path length.\n    The search stops and fails gracefully if exceeding 10 seconds runtime.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _max_radius: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _start_time: float\n    _samples_taken: int\n    _found_path: bool\n    _best_goal_vertex: Optional[Vertex]\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        self._max_dist = 12.0\n        self._max_radius = 40.0\n        self._lambda_rrt_star = 40.0\n        self._dimension = self._get_grid().size.n_dim\n\n        self._start_time = 0\n        self._samples_taken = 0\n        self._found_path = False\n        self._best_goal_vertex = None\n\n        self._init_displays()\n\n    def _get_random_sample(self, informed_ball: Optional[tuple] = None) -> Point:\n        \"\"\"\n        Samples either uniformly from the entire workspace or \n        inside an ellipsoidal informed subset if informed_ball is specified.\n        informed_ball = (center: Point, c_best: float, c_min: float)\n        \"\"\"\n        grid_size = self._get_grid().size\n        if informed_ball is None:\n            # Uniform random sampling valid for whole space\n            while True:\n                rand_coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(grid_size.n_dim)]\n                sample = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Sample inside informed ellipsoid between start and goal\n            c_best = informed_ball[1]\n            c_min = informed_ball[2]\n            center = informed_ball[0]\n            \n            # Major axis length: c_best\n            # Minor axis lengths: sqrt(c_best^2 - c_min^2)\n            # For simplicity, handle 2D only ellipsoid sampling (works well in 2D):\n            # If higher dims exist, revert to uniform sampling\n            \n            if grid_size.n_dim != 2:\n                # fallback to uniform if not 2D\n                return self._get_random_sample(None)\n            \n            success = False\n            sample = None\n            \n            for _ in range(200):  # limit to attempts\n                rx = torch.FloatTensor(1).uniform_(-1,1).item()\n                ry = torch.FloatTensor(1).uniform_(-1,1).item()\n                norm = (rx**2 + ry**2)**0.5\n                if norm > 1e-5:\n                    break\n            if norm < 1e-5:\n                # fallback to uniform\n                return self._get_random_sample(None)\n            rx /= norm\n            ry /= norm\n\n            # Sample radius uniformly between 0 and 1, cube root for volume preservation\n            r = torch.FloatTensor(1).uniform_(0,1).item() ** (1/2)\n            a1 = c_best / 2\n            a2 = (c_best**2 - c_min**2)**0.5 / 2\n\n            x = r * a1 * rx\n            y = r * a2 * ry\n\n            # Rotation: from the vector start -> goal angle\n            start = self._graph.root_vertex_start.position\n            goal = self._graph.root_vertex_goal.position\n            delta = torch.tensor([goal.x - start.x, goal.y - start.y])\n            angle = torch.atan2(delta[1], delta[0]).item()\n\n            cos_ang = torch.cos(torch.tensor(angle))\n            sin_ang = torch.sin(torch.tensor(angle))\n            rot_x = cos_ang * x - sin_ang * y\n            rot_y = sin_ang * x + cos_ang * y\n\n            sample_x = int(round(center.x + rot_x))\n            sample_y = int(round(center.y + rot_y))\n\n            # Clamp sample inside grid\n            sample_x = max(0, min(sample_x, grid_size[0] - 1))\n            sample_y = max(0, min(sample_y, grid_size[1] - 1))\n\n            sample = Point(sample_x, sample_y)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            else:\n                # fallback uniform sampling if invalid\n                return self._get_random_sample(None)\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Optional[Vertex]:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec)\n        if length < 1e-6:\n            return None\n        if length <= self._max_dist:\n            new_vertex_pos = q_sample\n        else:\n            dir_normalized = dir_vec / length\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n            new_vertex_pos = Point.from_tensor(new_pos_tensor)\n\n        if not self._get_grid().is_agent_valid_pos(new_vertex_pos):\n            return None\n\n        return Vertex(new_vertex_pos)\n\n    def _line_collision_free_lazy(self, frm: Point, to: Point) -> bool:\n        \"\"\"\n        Lazy collision check postpones detailed checking when possible.\n        Here, fast line validity check with early stop at first obstacle.\n        \"\"\"\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        # Instead of fully calling is_valid_line_sequence (which might be thorough),\n        # iterate and check for obstacles directly, early stop on collision\n        for pt in line_seq:\n            if not self._get_grid().is_agent_valid_pos(pt):\n                return False\n        return True\n\n    def _rewire(self, q_new: Vertex, Q_near: List[Vertex]) -> None:\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n            if dist > self._max_dist:\n                continue\n            new_cost = q_new.cost + dist\n            if new_cost < q_near.cost:\n                if self._line_collision_free_lazy(q_new.position, q_near.position):\n                    # Remove old parent edge\n                    old_parent = None\n                    for p in q_near.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    # Add new edge\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, goal_vertex: Vertex) -> List[Vertex]:\n        path = [goal_vertex]\n        while len(path[-1].parents) > 0:\n            # choose parent with lowest cost (usually one parent in tree)\n            min_parent = None\n            min_cost = float('inf')\n            for parent in path[-1].parents:\n                if parent.cost is not None and parent.cost < min_cost:\n                    min_cost = parent.cost\n                    min_parent = parent\n            if min_parent is None:\n                break\n            path.append(min_parent)\n        path.reverse()\n        return path\n\n    def _smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Path shortcutting: tries to replace longer path segments with direct edges,\n        removing intermediate unnecessary vertices.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            # Move backward to find furthest reachable vertex without collision\n            while j > i + 1:\n                if self._line_collision_free_lazy(path[i].position, path[j].position):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.perf_counter()\n        max_time_sec = 10.0\n\n        start: Vertex = self._graph.root_vertex_start\n        goal: Vertex = self._graph.root_vertex_goal\n\n        start.cost = 0.0\n        best_cost = float('inf')\n        best_goal_vertex: Optional[Vertex] = None\n\n        max_iterations = 15000\n        self._found_path = False\n\n        for iteration in range(max_iterations):\n            if time.perf_counter() - self._start_time > max_time_sec:\n                # Fail safe: terminate search and fail\n                break\n\n            # After path found, use informed sampling in ellipse around start and goal\n            if self._found_path and best_goal_vertex and best_cost < float('inf'):\n                c_min = torch.norm(start.position.to_tensor() - goal.position.to_tensor()).item()\n                c_best = best_cost\n                center = Point((start.position.x + goal.position.x)/2, (start.position.y + goal.position.y)/2)\n                q_sample = self._get_random_sample(informed_ball=(center, c_best, c_min))\n            else:\n                q_sample = self._get_random_sample()\n\n            q_near = self._get_nearest_vertex(q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample)\n            if q_new is None:\n                continue\n\n            # Lazy collision checking line from q_near to q_new\n            if not self._line_collision_free_lazy(q_near.position, q_new.position):\n                continue\n\n            cost_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = cost_to_new\n\n            # Nearby vertices for rewiring\n            card_V = max(1, self._graph.size)\n            log_card_V = torch.log(torch.tensor(float(card_V) + 1e-8))\n            radius = min(self._lambda_rrt_star * ((log_card_V / card_V) ** (1.0 / self._dimension)), self._max_radius)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent with minimum cost + collision-free connection\n            q_min = q_near\n            c_min_vertex = q_near.cost\n            for q_near_candidate in Q_near:\n                if q_near_candidate == q_new:\n                    continue\n                dist = torch.norm(q_near_candidate.position.to_tensor() - q_new.position.to_tensor()).item()\n                if dist > self._max_dist:\n                    continue\n                cost_candidate = q_near_candidate.cost + dist\n                if cost_candidate < c_min_vertex:\n                    if self._line_collision_free_lazy(q_near_candidate.position, q_new.position):\n                        q_min = q_near_candidate\n                        c_min_vertex = cost_candidate\n\n            q_new.cost = c_min_vertex\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire the tree around q_new\n            self._rewire(q_new, Q_near)\n\n            # Check if q_new reached goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Update best solution if better\n                dist_to_goal = torch.norm(q_new.position.to_tensor() - goal.position.to_tensor()).item()\n                total_cost = q_new.cost + dist_to_goal\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_goal_vertex = q_new\n                    self._found_path = True\n\n            self.key_frame()\n\n        # If found path, extract and smooth, then move agent on path\n        if self._found_path and best_goal_vertex is not None:\n            path_vertices = self._extract_path(best_goal_vertex)\n            path_vertices = self._smooth_path(path_vertices)\n            for vertex in path_vertices:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # Mark failure by raising or not moving - here do nothing, implicit fail\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an advanced sample-based planner combining adaptive hybrid sampling,\n    dynamic radius graph construction, and anytime path optimization.\n    It integrates:\n    - Hybrid sampling: mixes uniform and obstacle-informed guided samples (using obstacle boundaries)\n      to improve exploration efficiency and obstacle avoidance.\n    - Dynamic neighbor radius based on sampling density and iteration count for adaptive rewiring.\n    - Anytime incremental search: progressively refines path quality by rewiring and smoothing during planning.\n    - Lazy collision checking combined with incremental path validation for speed.\n    - Early termination if no improvement after some iterations or 10 seconds limit.\n    This approach improves path quality, success rate, and reduces planning time, while maintaining robustness and smooth paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        # Parameters (tunable)\n        self._max_dist = 10.0\n        self._max_radius = 35.0\n        self._lambda_rrt_star = 40.0\n        self._dimension = self._get_grid().size.n_dim\n\n        # For hybrid sampling\n        self._obstacle_boundaries = self._compute_obstacle_boundaries()\n\n        self._start_time = 0\n        self._max_time_sec = 10.0\n        self._samples_taken = 0\n\n        self._found_path = False\n        self._best_goal_vertex = None\n        self._best_cost = float('inf')\n\n        self._improvement_iter = 0  # Counts iterations without improvement for early stop\n        self._max_no_improve_iter = 300  # After these, terminate search early\n\n        self._init_displays()\n\n    def _compute_obstacle_boundaries(self) -> List[Point]:\n        \"\"\"\n        Compute boundary points of all obstacles to inform hybrid sampling.\n        Returns a combined list of obstacle boundary points.\n        \"\"\"\n        boundaries = []\n        visited = set()\n        for obs in self._get_grid().obstacles:\n            bound = self._get_grid().get_obstacle_bound(obs.position, visited)\n            boundaries.extend(bound)\n            visited.update(bound)\n        return boundaries\n\n    def _sample_from_obstacle_boundaries(self) -> Point:\n        \"\"\"\n        Sample near obstacle boundaries with Gaussian noise.\n        This encourages samples close but not inside obstacles.\n        \"\"\"\n        import random\n        import torch\n\n        if not self._obstacle_boundaries:\n            return self._get_random_sample_uniform()\n\n        # Choose random boundary point\n        base_pt = random.choice(self._obstacle_boundaries)\n\n        # Add small Gaussian offset to avoid exact obstacles and promote clearance\n        offset_scale = 3.0  # tunable\n        noise = []\n        for i in range(self._dimension):\n            noise.append(torch.normal(mean=0.0, std=offset_scale).item())\n        new_coords = []\n        grid_size = self._get_grid().size\n        for i in range(self._dimension):\n            c = base_pt[i] + noise[i]\n            c = max(0, min(c, grid_size[i] - 1))\n            new_coords.append(int(round(c)))\n\n        new_point = Point(*new_coords)\n        if self._get_grid().is_agent_valid_pos(new_point):\n            return new_point\n        else:\n            # Fallback uniform sample\n            return self._get_random_sample_uniform()\n\n    def _get_random_sample_uniform(self) -> Point:\n        \"\"\"Uniform random sample anywhere valid in workspace.\"\"\"\n        grid_size = self._get_grid().size\n        import torch\n        while True:\n            coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(self._dimension)]\n            p = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(p):\n                return p\n\n    def _get_hybrid_sample(self, p_obstacle_prob=0.3) -> Point:\n        \"\"\"\n        Hybrid sample: with probability p_obstacle_prob sample near obstacle boundaries,\n        else uniform random.\n        \"\"\"\n        import random\n        if random.random() < p_obstacle_prob:\n            return self._sample_from_obstacle_boundaries()\n        else:\n            return self._get_random_sample_uniform()\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        import torch\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec).item()\n        if length < 1e-6:\n            return None\n        if length <= self._max_dist:\n            new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / length\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n            new_pos = Point.from_tensor(new_pos_tensor)\n\n        if not self._get_grid().is_agent_valid_pos(new_pos):\n            return None\n\n        return Vertex(new_pos)\n\n    def _line_collision_free_lazy(self, frm: Point, to: Point) -> bool:\n        \"\"\"\n        Lazy collision check: quickly reject invalid edges by stepping over line points.\n        Early exit on first invalid point.\n        \"\"\"\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        for p in line_seq:\n            if not self._get_grid().is_agent_valid_pos(p):\n                return False\n        return True\n\n    def _rewire(self, q_new: Vertex, Q_near: List[Vertex]) -> None:\n        import torch\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n            if dist > self._max_dist:\n                continue\n            new_cost = q_new.cost + dist\n            if q_near.cost is None or new_cost < q_near.cost:\n                if self._line_collision_free_lazy(q_new.position, q_near.position):\n                    # Remove old parent edge\n                    old_parent = None\n                    for p in q_near.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    # Add new edge\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, goal_vertex: Vertex) -> List[Vertex]:\n        path = [goal_vertex]\n        while len(path[-1].parents) > 0:\n            min_parent = None\n            min_cost = float('inf')\n            for parent in path[-1].parents:\n                if parent.cost is not None and parent.cost < min_cost:\n                    min_cost = parent.cost\n                    min_parent = parent\n            if min_parent is None:\n                break\n            path.append(min_parent)\n        path.reverse()\n        return path\n\n    def _smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_collision_free_lazy(path[i].position, path[j].position):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _dynamic_radius(self, n_vertices: int) -> float:\n        import torch\n        if n_vertices <= 1:\n            return self._max_radius\n        log_n = torch.log(torch.tensor(float(n_vertices) + 1e-8))\n        radius = min(self._lambda_rrt_star * ((log_n / n_vertices) ** (1.0 / self._dimension)), self._max_radius)\n        return radius.item()\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        self._start_time = time.perf_counter()\n\n        start = self._graph.root_vertex_start\n        goal = self._graph.root_vertex_goal\n\n        start.cost = 0.0\n        self._found_path = False\n        self._best_goal_vertex = None\n        self._best_cost = float('inf')\n        self._improvement_iter = 0\n\n        max_iterations = 15000\n\n        for iteration in range(max_iterations):\n            if time.perf_counter() - self._start_time > self._max_time_sec:\n                # Time limit exceeded, fail gracefully\n                break\n\n            # Hybrid sampling improves exploration and obstacle avoidance\n            q_sample = self._get_hybrid_sample()\n\n            q_near = self._get_nearest_vertex(q_sample)\n            if q_near is None:\n                continue\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample)\n            if q_new is None:\n                continue\n\n            # Lazy collision check before further processing\n            if not self._line_collision_free_lazy(q_near.position, q_new.position):\n                continue\n\n            cost_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = cost_to_new\n\n            # Dynamic radius based on current graph size\n            radius = self._dynamic_radius(self._graph.size)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent from Q_near minimizing cost and collision-free\n            q_min = q_near\n            c_min_vertex = cost_to_new\n            for q_near_cand in Q_near:\n                if q_near_cand == q_new:\n                    continue\n                dist = torch.norm(q_near_cand.position.to_tensor() - q_new.position.to_tensor()).item()\n                if dist > self._max_dist:\n                    continue\n                cand_cost = q_near_cand.cost + dist\n                if q_near_cand.cost is not None and cand_cost < c_min_vertex:\n                    if self._line_collision_free_lazy(q_near_cand.position, q_new.position):\n                        q_min = q_near_cand\n                        c_min_vertex = cand_cost\n\n            q_new.cost = c_min_vertex\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors for improved paths\n            self._rewire(q_new, Q_near)\n\n            # Insert new vertex into graph root vertices so it expands graph size\n            self._graph.root_vertices.append(q_new)\n\n            # Check goal proximity\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Evaluate path cost including cost to goal point\n                dist_goal = torch.norm(q_new.position.to_tensor() - goal.position.to_tensor()).item()\n                total_cost = q_new.cost + dist_goal\n                if total_cost + 1e-6 < self._best_cost:  # Allow tiny improvement tolerance\n                    self._best_cost = total_cost\n                    self._best_goal_vertex = q_new\n                    self._found_path = True\n                    self._improvement_iter = 0  # reset no improvement count\n                else:\n                    self._improvement_iter += 1\n            else:\n                self._improvement_iter += 1\n\n            self.key_frame()\n\n            # Early stop if no improvement for too long\n            if self._improvement_iter > self._max_no_improve_iter:\n                break\n\n        # After main loop finishes\n        if self._found_path and self._best_goal_vertex is not None:\n            raw_path = self._extract_path(self._best_goal_vertex)\n            smooth_path = self._smooth_path(raw_path)\n            for vertex in smooth_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # Failed to find path within constraints\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "Improved Path Planning Algorithm - Hybrid Anytime RRT* with informed sampling and replanning:\n    \n    This algorithm combines the benefits of RRT* style incremental asymptotic optimality with an informed sampling heuristic (ellipsoidal sampling)\n    to improve planning efficiency and path quality. It uses rewiring to reduce path cost iteratively, dynamically adapts sampling regions as solution\n    improves, and prunes the search space to focus on promising nodes. It includes an anytime framework that updates and smooths the path whenever a better\n    solution is found. The algorithm halts after 10 seconds without solution to declare failure, improving robustness and bounded runtime.\n    \n    Key improvements:\n    - Uses RRT* rewiring for better path quality and smoothness.\n    - Employs informed ellipsoidal sampling guided by current best path cost to focus search.\n    - Prunes vertices outside the informed set to reduce computational overhead.\n    - Uses cost-to-come and cost-to-go heuristics for rewiring and edge creation.\n    - Terminates early on solution improvements to provide anytime behavior.\n    - Limits total planning time to 10 seconds for robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n    _max_dist: float\n    _iteration_limit: int\n    _best_cost: float\n    _best_vertex: Optional[Vertex]\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_dist = 15.0\n        self._iteration_limit = 15000\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._best_cost = float(\"inf\")\n        self._best_vertex = None\n        self._init_displays()\n\n    def _get_random_sample(self, c_max: float) -> Point:\n        \"\"\"\n        Returns either a random point within the ellipsoidal informed search space if a solution exists,\n        or a uniformly random sample if no solution yet.\n        \"\"\"\n        grid_size = self._get_grid().size\n        agent_pos = self._graph.root_vertex_start.position\n        goal_pos = self._graph.root_vertex_goal.position\n        start = agent_pos.to_tensor()\n        goal = goal_pos.to_tensor()\n        dim = start.numel()\n\n        if c_max == float(\"inf\"):\n            # No solution yet, uniform random sample\n            while True:\n                sample_coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(dim)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling inside an ellipsoid around start and goal, with c_max defining length\n        c_min = torch.norm(goal - start)\n        if c_min == 0:\n            # start == goal\n            return Point.from_tensor(start)\n\n        # Compose rotation matrix C from x axis to unit vector from start to goal\n        e1 = (goal - start) / c_min  # unit vector pointing from start to goal\n        # Build orthonormal basis for R^n with e1 as first basis vector using Gram-Schmidt\n        # Only 2D or 3D supported here from given classes assumptions\n        if dim == 2:\n            # 2D orthonormal basis matrix C\n            C = torch.zeros((dim, dim))\n            C[0, :] = e1\n            C[1, :] = torch.tensor([-e1[1], e1[0]])\n        elif dim == 3:\n            # 3D orthonormal basis using e1, and perpendicular vectors\n            # Use arbitrary vector for Gram-Schmidt\n            a = torch.tensor([1., 0., 0.])\n            if torch.allclose(e1, a):\n                a = torch.tensor([0., 1., 0.])\n            u2 = a - (a @ e1) * e1\n            u2 = u2 / torch.norm(u2)\n            u3 = torch.cross(e1, u2)\n            C = torch.stack([e1, u2, u3], dim=0)\n        else:\n            # For higher dimension, fall back to uniform sampling\n            while True:\n                sample_coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(dim)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Radii of the hyperellipse\n        r1 = c_max / 2.0\n        r_other = torch.sqrt(torch.tensor(c_max ** 2 - c_min ** 2)) / 2.0\n        L = torch.diag(torch.cat([torch.tensor([r1]), r_other.repeat(dim - 1)]))\n\n        # Sample uniformly a unit n-ball point\n        while True:\n            x_ball = torch.randn(dim)\n            norm_x_ball = torch.norm(x_ball)\n            if norm_x_ball > 1e-5:\n                x_ball = x_ball / norm_x_ball\n                break\n        u = torch.rand(1).item()\n        sample_unit_ball = (u ** (1.0 / dim)) * x_ball  # uniform in unit ball\n\n        # Map sample to informed ellipsoid\n        sample_tf = (C.T @ (L @ sample_unit_ball)) + ((start + goal) / 2.0)\n        sample_tf = torch.clamp(sample_tf, min=0, max=torch.tensor([grid_size[i]-1 for i in range(dim)]))\n\n        candidate = Point.from_tensor(sample_tf)\n        if self._get_grid().is_agent_valid_pos(candidate):\n            return candidate\n        else:\n            # fallback uniform sampling\n            while True:\n                sample_coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(dim)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_near_vertices(self, point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, point, radius)\n\n    def _line_cost(self, frm: Point, to: Point) -> float:\n        return self._get_grid().get_movement_cost(frm, to)\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        \"\"\"\n        Tries to improve the cost of vertices in neighbors by connecting them through q_new if cheaper.\n        \"\"\"\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                continue\n            potential_cost = q_new.cost + self._line_cost(q_new.position, q_near.position)\n            if potential_cost < q_near.cost:\n                # Remove old parent edges\n                for p in list(q_near.parents):\n                    self._graph.remove_edge(p, q_near)\n                # Add new edge\n                self._graph.add_edge(q_new, q_near)\n                # Update cost\n                q_near.cost = potential_cost\n\n    def _extract_path(self, end_vertex: Vertex) -> None:\n        path: List[Vertex] = [end_vertex]\n        while len(path[-1].parents) != 0:\n            # pick parent with lowest cost:\n            parent = min(path[-1].parents, key=lambda v: v.cost)\n            path.append(parent)\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _prune_vertices_outside_ellipsoid(self, c_max: float) -> None:\n        \"\"\"\n        Removes vertices from the graph that are outside the current informed set defined by the ellipsoid.\n        Keeps start and goal vertices always.\n        \"\"\"\n        if c_max == float(\"inf\"):\n            return  # no pruning if no solution\n\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n        dim = start.numel()\n        c_min = torch.norm(goal - start)\n\n        if c_min == 0:\n            return  # start == goal; no pruning needed\n\n        # Build rotation matrix C as in sampling\n        e1 = (goal - start) / c_min\n        if dim == 2:\n            C = torch.zeros((dim, dim))\n            C[0, :] = e1\n            C[1, :] = torch.tensor([-e1[1], e1[0]])\n        elif dim == 3:\n            a = torch.tensor([1., 0., 0.])\n            if torch.allclose(e1, a):\n                a = torch.tensor([0., 1., 0.])\n            u2 = a - (a @ e1) * e1\n            u2 = u2 / torch.norm(u2)\n            u3 = torch.cross(e1, u2)\n            C = torch.stack([e1, u2, u3], dim=0)\n        else:\n            # No pruning for higher dimensions\n            return\n\n        r1 = c_max / 2.0\n        r_other = torch.sqrt(torch.tensor(c_max ** 2 - c_min ** 2)) / 2.0\n        L = torch.diag(torch.cat([torch.tensor([r1]), r_other.repeat(dim - 1)]))\n\n        # Check each vertex if inside ellipsoid, if not remove\n        to_remove = []\n        for v in list(self._graph.root_vertices[2:]):  # exclude start (0) and goal (1)\n            p = v.position.to_tensor()\n            p_trans = C @ (p - (start + goal) / 2.0)\n            val = torch.norm(torch.linalg.solve(L, p_trans))  # Equivalent to norm(inv(L)*p_trans)\n            if val > 1.0:\n                to_remove.append(v)\n\n        for v in to_remove:\n            # Remove edges connected to this vertex\n            parents_backup = list(v.parents)\n            for p in parents_backup:\n                self._graph.remove_edge(p, v)\n            children_backup = list(v.children)\n            for c in children_backup:\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        grid = self._get_grid()\n        start = self._graph.root_vertex_start.position\n        goal = self._graph.root_vertex_goal.position\n\n        # Initialize costs\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float(\"inf\")\n        self._best_cost = float(\"inf\")\n        self._best_vertex = None\n\n        for iteration in range(self._iteration_limit):\n            elapsed = time.time() - start_time\n            if elapsed > 10.0:\n                # Timeout failure\n                return\n\n            # Sample a new point within the informed set if possible\n            q_rand_pos = self._get_random_sample(self._best_cost)\n            # Find nearest vertex to q_rand\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_rand_pos)\n\n            if q_near.position == q_rand_pos:\n                continue\n\n            # Generate a new vertex in the direction of q_rand but clipped by max_dist\n            direction = q_rand_pos.to_tensor() - q_near.position.to_tensor()\n            dist = torch.norm(direction)\n            if dist <= self._max_dist:\n                q_new_pos = q_rand_pos\n            else:\n                direction_normalized = direction / dist\n                q_new_pos = Point.from_tensor(q_near.position.to_tensor() + self._max_dist * direction_normalized)\n\n            # Validate line from q_near to q_new\n            line_seq = grid.get_line_sequence(q_near.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            # Cost from start to q_new via q_near\n            cost_to_q_new = q_near.cost + self._line_cost(q_near.position, q_new.position)\n            q_new.cost = cost_to_q_new\n\n            # Near vertices for rewiring within radius\n            radius = max(self._max_dist * 1.5, 20.0)\n            neighbors = self._get_near_vertices(q_new.position, radius)\n\n            # Choose best parent among neighbors\n            min_cost = cost_to_q_new\n            best_parent = q_near\n            for q_near_candidate in neighbors:\n                if q_near_candidate == q_near:\n                    continue\n                if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near_candidate.position, q_new.position)):\n                    continue\n                temp_cost = q_near_candidate.cost + self._line_cost(q_near_candidate.position, q_new.position)\n                if temp_cost < min_cost:\n                    min_cost = temp_cost\n                    best_parent = q_near_candidate\n\n            # Update q_new attributes with best parent and cost\n            q_new.cost = min_cost\n            self._graph.add_edge(best_parent, q_new)\n            self._graph.root_vertices.append(q_new)\n\n            # Rewire neighbors if can improve cost through q_new\n            self._rewire(q_new, neighbors)\n\n            # Check if q_new can connect to goal with better cost\n            dist_to_goal = torch.norm(q_new.position.to_tensor() - goal.to_tensor())\n            if dist_to_goal <= self._max_dist:\n                goal_line = grid.get_line_sequence(q_new.position, goal)\n                if grid.is_valid_line_sequence(goal_line):\n                    cost_to_goal = q_new.cost + self._line_cost(q_new.position, goal)\n                    if cost_to_goal < self._best_cost:\n                        # Update best solution\n                        self._best_cost = cost_to_goal\n                        # Remove old edges to goal\n                        old_goal_parents = list(self._graph.root_vertex_goal.parents)\n                        for p in old_goal_parents:\n                            self._graph.remove_edge(p, self._graph.root_vertex_goal)\n                        # Add edge from q_new to goal vertex\n                        self._graph.add_edge(q_new, self._graph.root_vertex_goal)\n                        self._graph.root_vertex_goal.cost = cost_to_goal\n                        self._best_vertex = self._graph.root_vertex_goal\n\n                        # Prune vertices outside informed set\n                        self._prune_vertices_outside_ellipsoid(self._best_cost)\n\n                        # Extract path and move agent\n                        self._extract_path(self._best_vertex)\n                        # Mark keyframe for visualization after path extraction\n                        self.key_frame(ignore_key_frame_skip=True)\n\n                        # Anytime - allow continuation to find potentially better paths\n                        # But break early if time is close to limit\n                        if (time.time() - start_time) > 9.8:\n                            break\n\n            # Keyframe for visualization of tree growth\n            self.key_frame()\n\n        # If no path found within iterations/time, fail silently\n        return",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This algorithm proposes an Adaptive Informed RRT* variant enhanced by:\n    - Early pruning of non-promising samples via heuristic informed sampling inside an ellipsoidal informed subset.\n    - Incorporating obstacle boundary guided local sampling around the current best path for improved refinement.\n    - Dynamic radius and rewiring balancing exploration and exploitation adapted by iteration count and graph density.\n    - Lazy collision checking combined with incremental smoothing on path improvement.\n    - Dual sampling strategy mixing uniform sampling for coverage and guided sampling near obstacles/the best path.\n    - Early stopping if no improvement or timeout at 10 seconds.\n    This method aims at better planning efficiency, robustness, faster convergence to high-quality smooth paths, \n    and improved success rate through adaptive and progressive sampling strategies.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        self._max_dist = 12.0\n        self._max_radius = 30.0\n        self._lambda_rrt_star = 35.0\n        self._dimension = self._get_grid().size.n_dim\n\n        # Obstacle boundary points for guided local sampling\n        self._obstacle_boundaries = self._compute_obstacle_boundaries()\n\n        self._start_time = 0\n        self._max_time_sec = 10.0\n\n        self._found_path = False\n        self._best_goal_vertex = None\n        self._best_cost = float('inf')\n\n        self._improvement_iter = 0\n        self._max_no_improve_iter = 250\n\n        # Store current best path vertices for local informed sampling\n        self._best_path_vertices = []\n\n        self._init_displays()\n\n    def _compute_obstacle_boundaries(self) -> list:\n        boundaries = []\n        visited = set()\n        for obs in self._get_grid().obstacles:\n            bound = self._get_grid().get_obstacle_bound(obs.position, visited)\n            boundaries.extend(bound)\n            visited.update(bound)\n        return boundaries\n\n    def _sample_near_obstacle_boundaries(self) -> Point:\n        import random\n        import torch\n\n        if not self._obstacle_boundaries:\n            return self._sample_uniform()\n\n        base_pt = random.choice(self._obstacle_boundaries)\n        offset_scale = 2.5\n        noise = [torch.normal(mean=torch.tensor(0.0), std=offset_scale).item() for _ in range(self._dimension)]\n\n        new_coords = []\n        grid_size = self._get_grid().size\n        for i in range(self._dimension):\n            c = base_pt[i] + noise[i]\n            c = max(0, min(c, grid_size[i] - 1))\n            new_coords.append(int(round(c)))\n\n        new_point = Point(*new_coords)\n        if self._get_grid().is_agent_valid_pos(new_point):\n            return new_point\n        else:\n            return self._sample_uniform()\n\n    def _sample_uniform(self) -> Point:\n        import torch\n        grid_size = self._get_grid().size\n        while True:\n            coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(self._dimension)]\n            p = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(p):\n                return p\n\n    def _ellipsoid_sample(self, c_best: float, c_min: float, start: Point, goal: Point) -> Point:\n        \"\"\"\n        Samples within an ellipsoid defined by start and goal,\n        where the sum distance to start and goal <= c_best (current best cost).\n        If c_best is inf, revert to uniform sampling.\n        \"\"\"\n        import torch\n        import math\n        if math.isinf(c_best):\n            return self._sample_uniform()\n\n        c_best = max(c_best, c_min + 1e-6)  # prevent div by zero or degenerate ellipsoid\n\n        center = (start.to_tensor() + goal.to_tensor()) / 2.0\n        diff = (goal.to_tensor() - start.to_tensor())\n        dist_start_goal = torch.norm(diff).item()\n        if dist_start_goal < 1e-8:\n            return start  # start==goal rare case\n\n        # Ellipsoid axis lengths\n        a1 = c_best / 2.0\n        a2 = math.sqrt(c_best ** 2 - dist_start_goal ** 2) / 2.0\n\n        # Unit vector from start to goal\n        e1 = (diff / dist_start_goal).view(-1, 1)  # column vector\n\n        # Rotation matrix from unit vector e1 to coordinate frame (using SVD)\n        # This builds a basis where first vector aligns with e1\n        n = self._dimension\n        U, _, Vt = torch.svd(torch.eye(n))\n        # Set U[:,0] to e1 and fill rest orthonormally\n        # We'll construct an orthonormal basis with e1 first (Gram-Schmidt)\n        basis = torch.eye(n)\n        basis[:, 0] = e1.flatten()\n        # Gram-Schmidt for basis\n        for i in range(1, n):\n            proj = torch.dot(basis[:, i], basis[:, 0]) * basis[:, 0]\n            basis[:, i] = basis[:, i] - proj\n            norm = torch.norm(basis[:, i])\n            if norm > 1e-8:\n                basis[:, i] = basis[:, i] / norm\n            else:\n                basis[:, i] = torch.zeros(n)  # fallback\n\n        # Sampling random point inside unit n-ball\n        # Use normal Gaussian and normalize, then scale by radius**(1/n_dim)\n        direction = torch.randn(n)\n        radius = torch.rand(1).pow(1.0 / n).item()\n        direction = direction / torch.norm(direction)\n        unit_ball_sample = direction * radius\n\n        # Scale sample to ellipsoid axes: a1 on e1 axis, a2 on others\n        L = torch.diag(torch.tensor([a1] + [a2] * (n - 1)))\n        sample = basis @ (L @ unit_ball_sample)\n\n        final_point_tensor = center + sample.view(-1)\n        # Clamp coordinates and round for discrete map\n        grid_size = self._get_grid().size\n        coords = []\n        for i in range(n):\n            c = final_point_tensor[i].item()\n            c = max(0, min(c, grid_size[i] - 1))\n            coords.append(int(round(c)))\n        p = Point(*coords)\n        if self._get_grid().is_agent_valid_pos(p):\n            return p\n        else:\n            # fallback uniform\n            return self._sample_uniform()\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> list:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        import torch\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec).item()\n        if length < 1e-6:\n            return None\n        if length <= self._max_dist:\n            new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / length\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n            new_pos = Point.from_tensor(new_pos_tensor)\n\n        if not self._get_grid().is_agent_valid_pos(new_pos):\n            return None\n\n        return Vertex(new_pos)\n\n    def _line_collision_free_lazy(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        for p in line_seq:\n            if not self._get_grid().is_agent_valid_pos(p):\n                return False\n        return True\n\n    def _rewire(self, q_new: Vertex, Q_near: list) -> None:\n        import torch\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n            if dist > self._max_dist:\n                continue\n            new_cost = q_new.cost + dist\n            if q_near.cost is None or new_cost < q_near.cost:\n                if self._line_collision_free_lazy(q_new.position, q_near.position):\n                    old_parent = None\n                    for p in q_near.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, goal_vertex: Vertex) -> list:\n        path = [goal_vertex]\n        while len(path[-1].parents) > 0:\n            min_parent = None\n            min_cost = float('inf')\n            for parent in path[-1].parents:\n                if parent.cost is not None and parent.cost < min_cost:\n                    min_cost = parent.cost\n                    min_parent = parent\n            if min_parent is None:\n                break\n            path.append(min_parent)\n        path.reverse()\n        return path\n\n    def _smooth_path(self, path: list) -> list:\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_collision_free_lazy(path[i].position, path[j].position):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _dynamic_radius(self, n_vertices: int, iteration: int) -> float:\n        import torch\n        if n_vertices <= 1:\n            return self._max_radius\n        log_n = torch.log(torch.tensor(float(n_vertices) + 1e-8))\n        base_radius = self._lambda_rrt_star * ((log_n / n_vertices) ** (1.0 / self._dimension))\n        # Gradually shrink radius as iterations progress to focus rewiring locally\n        shrink_factor = max(0.5, 1.0 - iteration / 15000.0)\n        radius = min(base_radius * shrink_factor, self._max_radius)\n        return radius.item()\n\n    def _sample_near_best_path(self) -> Point:\n        \"\"\"\n        Sample locally around vertices of the best path to refine paths near current best solution.\n        Uses Gaussian perturbation around random vertex on best path.\n        \"\"\"\n        import random\n        import torch\n\n        if not self._best_path_vertices:\n            return self._sample_uniform()\n\n        base_vertex = random.choice(self._best_path_vertices)\n        base_pt = base_vertex.position\n        offset_scale = 2.0\n        noise = [torch.normal(mean=torch.tensor(0.0), std=offset_scale).item() for _ in range(self._dimension)]\n\n        grid_size = self._get_grid().size\n        new_coords = []\n        for i in range(self._dimension):\n            c = base_pt[i] + noise[i]\n            c = max(0, min(c, grid_size[i] - 1))\n            new_coords.append(int(round(c)))\n\n        p = Point(*new_coords)\n        if self._get_grid().is_agent_valid_pos(p):\n            return p\n        else:\n            return self._sample_uniform()\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n        import random\n\n        self._start_time = time.perf_counter()\n        start = self._graph.root_vertex_start\n        goal = self._graph.root_vertex_goal\n        start.cost = 0.0\n\n        c_min = self._get_grid().get_distance(start.position, goal.position).item()\n        best_cost = float('inf')\n        best_goal_vertex = None\n        found_path = False\n        no_improve_iter = 0\n        max_iterations = 15000\n\n        # Mix ratios for sampling strategies\n        uniform_prob = 0.4\n        obstacle_prob = 0.3\n        best_path_prob = 0.3\n\n        # Reset best path vertices cache\n        self._best_path_vertices = []\n\n        for iteration in range(max_iterations):\n            elapsed = time.perf_counter() - self._start_time\n            if elapsed > self._max_time_sec:\n                break  # Time limit reached: fail safely\n\n            # After first solution: informed sampling inside ellipsoid, else mix uniform & guided sampling\n            if found_path and best_cost < float('inf'):\n                q_sample = self._ellipsoid_sample(best_cost, c_min, start.position, goal.position)\n                # With small probability sample near obstacles or best path for local improvements\n                r = random.random()\n                if r < obstacle_prob:\n                    q_sample = self._sample_near_obstacle_boundaries()\n                elif r < obstacle_prob + best_path_prob:\n                    q_sample = self._sample_near_best_path()\n            else:\n                # No solution found yet: mixed sampling for coverage & obstacle avoidance\n                r = random.random()\n                if r < uniform_prob:\n                    q_sample = self._sample_uniform()\n                elif r < uniform_prob + obstacle_prob:\n                    q_sample = self._sample_near_obstacle_boundaries()\n                else:\n                    q_sample = self._sample_uniform()\n\n            q_near = self._get_nearest_vertex(q_sample)\n            if q_near is None:\n                continue\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample)\n            if q_new is None:\n                continue\n\n            # Lazy collision checking on the edge\n            if not self._line_collision_free_lazy(q_near.position, q_new.position):\n                continue\n\n            cost_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = cost_to_new\n\n            radius = self._dynamic_radius(self._graph.size + 1, iteration)\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Best parent selection for cost minimization with collision check\n            q_min = q_near\n            c_min_vertex = cost_to_new\n            for q_near_cand in Q_near:\n                if q_near_cand == q_new:\n                    continue\n                dist = torch.norm(q_near_cand.position.to_tensor() - q_new.position.to_tensor()).item()\n                if dist > self._max_dist:\n                    continue\n                cand_cost = q_near_cand.cost + dist\n                if q_near_cand.cost is not None and cand_cost < c_min_vertex:\n                    if self._line_collision_free_lazy(q_near_cand.position, q_new.position):\n                        q_min = q_near_cand\n                        c_min_vertex = cand_cost\n\n            q_new.cost = c_min_vertex\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to improve cost\n            self._rewire(q_new, Q_near)\n\n            # Add new vertex to root vertices for further expansion\n            self._graph.root_vertices.append(q_new)\n\n            # Goal proximity check\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_goal = torch.norm(q_new.position.to_tensor() - goal.position.to_tensor()).item()\n                total_cost = q_new.cost + dist_goal\n                if total_cost + 1e-6 < best_cost:\n                    best_cost = total_cost\n                    best_goal_vertex = q_new\n                    found_path = True\n                    no_improve_iter = 0\n\n                    # Refresh best path vertex cache for local refinement sampling\n                    path_vertices = self._extract_path(best_goal_vertex)\n                    self._best_path_vertices = path_vertices\n\n                    # After path improvement, smooth path incrementally\n                    smoothed_path = self._smooth_path(path_vertices)\n\n                    # Update path vertices cache to smoothed path for next local sampling\n                    self._best_path_vertices = smoothed_path\n\n                else:\n                    no_improve_iter += 1\n            else:\n                no_improve_iter += 1\n\n            self.key_frame()\n\n            if no_improve_iter > self._max_no_improve_iter:\n                break  # Early stop no improvement\n\n        if found_path and best_goal_vertex is not None:\n            path = self._extract_path(best_goal_vertex)\n            smooth_path = self._smooth_path(path)\n            for vertex in smooth_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # No path found within constraints\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an improved sampling-based planner inspired by RRT* with informed sampling and lazy collision checking. \n    It maintains a forest graph and incrementally builds paths by sampling points biased towards the goal using ellipsoidal \n    informed sampling, connecting vertices within a neighborhood radius. It uses a rewiring step to improve path quality \n    continuously and performs lazy collision checking only when connecting edges to reduce computation. Search terminates \n    successfully when a valid path to the goal is found or fails if exceeding a 10-second time limit. The approach balances \n    efficient sampling, path quality, smoothness, and computational efficiency to improve over plain SPRM methods.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        self._V_size = 300                  # Larger sample size for better coverage\n        self._max_radius = 20.0             # Neighborhood search radius for rewiring\n        self._goal_bias_prob = 0.2          # Probability to sample the goal point directly\n        self._graph = None\n\n        V = []\n        for _ in range(self._V_size):\n            q_rand = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = True\n\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Samples a point in the grid with goal bias and informed ellipsoidal sampling \n        around the current best path for efficiency.\n        \"\"\"\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        agent_pos = grid.agent.position\n\n        # Sampling box bounds\n        bounds = [grid.size[i] for i in range(grid.size.n_dim)]\n\n        # Goal biasing: with some probability sample goal directly\n        if torch.rand(1).item() < self._goal_bias_prob:\n            return Point(*goal_pos)\n\n        # If no path found yet, uniform random sampling\n        if not hasattr(self, \"_best_cost\"):\n            while True:\n                sample_coords = [torch.randint(0, bounds[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed Ellipsoidal Sampling (hypersphere around start-goal)\n        dist_start_goal = Map.get_distance(agent_pos, goal_pos)\n        c_best = getattr(self, \"_best_cost\", float(\"inf\"))\n\n        # If no feasible path cost known, just uniform sampling\n        if not (c_best < float(\"inf\")):\n            while True:\n                sample_coords = [torch.randint(0, bounds[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        c_min = dist_start_goal\n        center = Point(*[(agent_pos[i] + goal_pos[i]) / 2.0 for i in range(agent_pos.n_dim)])\n\n        # Define lengths of ellipse axes - major axis = c_best/2, others = sqrt(c_best\u00b2 - c_min\u00b2)/2\n        r1 = c_best / 2.0\n        if agent_pos.n_dim == 2:\n            r2 = ( (c_best**2 - c_min**2) ** 0.5 ) / 2.0 if c_best > c_min else 0.0\n            # Sample in unit circle then scale into ellipse\n            while True:\n                theta = 2 * 3.14159265359 * torch.rand(1).item()\n                rad = torch.rand(1).item() ** 0.5\n                x = rad * torch.cos(torch.tensor(theta))\n                y = rad * torch.sin(torch.tensor(theta))\n                sample_x = center.x + r1 * x.item()\n                sample_y = center.y + r2 * y.item()\n                sample_pt = Point(int(round(sample_x)), int(round(sample_y)))\n                if 0 <= sample_pt.x < bounds[0] and 0 <= sample_pt.y < bounds[1]:\n                    if grid.is_agent_valid_pos(sample_pt):\n                        return sample_pt\n        else:\n            # For n_dim > 2 uniform sampling inside hyperellipsoid (approximate)\n            while True:\n                rand_dir = torch.randn(agent_pos.n_dim)\n                rand_dir = rand_dir / torch.norm(rand_dir)\n                mag = torch.rand(1).item() ** (1.0 / agent_pos.n_dim)\n                scaled_dir = rand_dir * mag\n                # Scale major axis only along first dimension (approximation)\n                scaled_dir[0] = scaled_dir[0] * r1\n                # For other dims, scale to radius sqrt(c_best\u00b2 - c_min\u00b2)/2\n                scale_minor = ((c_best ** 2 - c_min ** 2) ** 0.5 / 2.0) if c_best > c_min else 0.0\n                for i in range(1, agent_pos.n_dim):\n                    scaled_dir[i] *= scale_minor\n                sample_coords = [center[i] + scaled_dir[i].item() for i in range(agent_pos.n_dim)]\n                sample_coords_int = [int(round(x)) for x in sample_coords]\n                sample_pt = Point(*sample_coords_int)\n                if all(0 <= sample_pt[i] < bounds[i] for i in range(agent_pos.n_dim)):\n                    if grid.is_agent_valid_pos(sample_pt):\n                        return sample_pt\n\n    def _get_near_vertices(self, position: Point) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, position, self._max_radius)\n\n    def _get_cost(self, from_vertex: Vertex, to_vertex: Vertex) -> float:\n        return self._get_grid().get_movement_cost(from_vertex.position, to_vertex.position)\n\n    def _can_connect(self, p1: Point, p2: Point) -> bool:\n        \"\"\"Lazy collision check via Bresenham line with grid validation.\"\"\"\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        Rewires the graph to improve path costs by connecting new_vertex to better parents,\n        and potentially reconnect children to new_vertex if beneficial.\n        \"\"\"\n        improved_parents = []\n        for near_vertex in near_vertices:\n            if near_vertex == new_vertex:\n                continue\n            if self._can_connect(near_vertex.position, new_vertex.position):\n                new_cost = near_vertex.cost + self._get_cost(near_vertex, new_vertex)\n                if new_cost < new_vertex.cost:\n                    new_vertex.parents.clear()\n                    new_vertex.cost = new_cost\n                    new_vertex.add_parent(near_vertex)\n                    near_vertex.add_child(new_vertex)\n                    improved_parents.append(near_vertex)\n\n        # Rewire children\n        for near_vertex in near_vertices:\n            if near_vertex == new_vertex:\n                continue\n            if self._can_connect(new_vertex.position, near_vertex.position):\n                new_cost = new_vertex.cost + self._get_cost(new_vertex, near_vertex)\n                if new_cost < near_vertex.cost:\n                    for p in list(near_vertex.parents):\n                        p.children.discard(near_vertex)\n                        near_vertex.parents.discard(p)\n                    near_vertex.cost = new_cost\n                    near_vertex.add_parent(new_vertex)\n                    new_vertex.add_child(near_vertex)\n\n    def _extract_path(self) -> None:\n        \"\"\"\n        Extracts the best path from the start vertex to the goal vertex using BFS \n        along parents with lowest cost, and moves the agent stepwise along it.\n        \"\"\"\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        # BFS from goal to start by walking parents to build path backward\n        path = deque()\n        current = goal_vertex\n        if current.cost == float(\"inf\"):\n            # No path exists\n            return\n        while current != start_vertex:\n            path.appendleft(current)\n            # Choose the lowest cost parent\n            parents_sorted = sorted(current.parents, key=lambda v: v.cost)\n            if not parents_sorted:\n                # Disconnected, no valid path\n                return\n            current = parents_sorted[0]\n        path.appendleft(start_vertex)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _initialize_costs(self) -> None:\n        \"\"\"Initialize vertex costs: zero for start, infinity else.\"\"\"\n        for v in self._graph.root_vertices:\n            v.cost = float(\"inf\")\n            v.parents.clear()\n            v.children.clear()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n    def _find_path_internal(self) -> None:\n        \"\"\"\n        Main function implementing RRT*-style informed path planning with time limit.\n        Samples, connects, rewires, and updates best path dynamically.\n        \"\"\"\n        grid = self._get_grid()\n        start_time = time()\n        max_duration = 10.0  # seconds timeout\n\n        self._initialize_costs()\n\n        # Insert edges from start and goal roots to their neighbors initially\n        for root in self._graph.root_vertices:\n            near_vertices = self._get_near_vertices(root.position)\n            for near_v in near_vertices:\n                if near_v == root:\n                    continue\n                if self._can_connect(root.position, near_v.position):\n                    cost_edge = self._get_cost(root, near_v)\n                    if root.cost + cost_edge < near_v.cost:\n                        near_v.cost = root.cost + cost_edge\n                        near_v.parents.clear()\n                        near_v.add_parent(root)\n                        root.add_child(near_v)\n\n        vertices = list(self._graph.root_vertices)\n\n        # Main iterative sampling, connecting, rewiring loop\n        while True:\n            if (time() - start_time) > max_duration:\n                return  # timeout/failure\n\n            # Sample new point\n            q_rand = self._get_random_sample()\n\n            # Find nearest vertex to the sampled point\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_rand)\n\n            # Steer towards q_rand with maximum step limited by max_radius (step size)\n            direction = q_rand.to_tensor() - q_near.position.to_tensor()\n            dist = torch.norm(direction).item()\n            if dist == 0:\n                continue\n            if dist > self._max_radius:\n                direction = direction / dist * self._max_radius\n                q_new_pt = Point.from_tensor(q_near.position.to_tensor() + direction)\n            else:\n                q_new_pt = q_rand\n\n            if not grid.is_agent_valid_pos(q_new_pt):\n                continue\n\n            if not self._can_connect(q_near.position, q_new_pt):\n                continue\n\n            q_new = Vertex(q_new_pt, store_connectivity=True)\n            # Cost from start to q_new through q_near\n            tentative_cost = q_near.cost + self._get_cost(q_near, q_new)\n\n            # Find near vertices for rewiring\n            near_vertices = self._get_near_vertices(q_new.position)\n\n            # Choose the best parent for q_new\n            min_cost = tentative_cost\n            best_parent = q_near\n            for near_v in near_vertices:\n                if near_v == q_near:\n                    continue\n                if self._can_connect(near_v.position, q_new.position):\n                    cost_through_near = near_v.cost + self._get_cost(near_v, q_new)\n                    if cost_through_near < min_cost:\n                        min_cost = cost_through_near\n                        best_parent = near_v\n\n            q_new.cost = min_cost\n            q_new.add_parent(best_parent)\n            best_parent.add_child(q_new)\n\n            # Add q_new to vertices and graph root vertices list to maintain structure\n            self._graph.root_vertices.append(q_new)\n            vertices.append(q_new)\n\n            # Rewire neighbors to improve paths\n            self._rewire(q_new, near_vertices)\n\n            # Check if can connect q_new to goal root vertex (possibly shortcut)\n            goal_vertex = self._graph.root_vertex_goal\n            if self._can_connect(q_new.position, goal_vertex.position):\n                cost_to_goal = q_new.cost + self._get_cost(q_new, goal_vertex)\n                if cost_to_goal < goal_vertex.cost:\n                    for p in list(goal_vertex.parents):\n                        p.children.discard(goal_vertex)\n                    goal_vertex.parents.clear()\n                    goal_vertex.cost = cost_to_goal\n                    goal_vertex.add_parent(q_new)\n                    q_new.add_child(goal_vertex)\n\n                    # Update best known cost for informed sampling\n                    self._best_cost = cost_to_goal\n\n                    # Extract and follow path\n                    self._extract_path()\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an improved sampling-based planner integrating RRT*-style rewiring, \n    adaptive informed sampling, bidirectional search, and path smoothing. \n    \n    Key improvements:\n    1. Bidirectional tree growth from start and goal, reducing convergence time and improving success rate.\n    2. Adaptive informed sampling ellipsoids from both directions after initial connection, focusing search.\n    3. RRT* rewiring in both trees for path quality improvement.\n    4. Lazy collision checking with early abandon for efficiency.\n    5. Dynamic radius for rewiring based on vertex count and dimensionality.\n    6. After connection, smooth shortcutting path to improve path smoothness and length.\n    7. Strict 10 seconds timeout to fail gracefully.\n\n    The algorithm grows two forests (from start and goal), tries to connect them efficiently, extracts best path, smooths it,\n    and moves the agent along the final planned trajectory.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._max_dist = 12.0\n        self._max_radius = 40.0\n        self._lambda_rrt_star = 40.0\n        self._dimension = self._get_grid().size.n_dim\n        self._start_time = 0\n        self._samples_taken = 0\n        self._found_path = False\n        self._best_start_vertex: Vertex = None\n        self._best_goal_vertex: Vertex = None\n        self._best_cost = float('inf')\n        self._init_displays()\n\n    def _get_random_sample(self, informed_ball_start: tuple = None, informed_ball_goal: tuple = None) -> Point:\n        \"\"\"\n        Samples a point either uniformly or inside combined ellipsoids from start and goal informed sampling.\n        If informed balls for both trees are provided, probabilistically sample from one or uniform.\n        Otherwise uniform sampling.\n        \"\"\"\n        grid_size = self._get_grid().size\n        # Simple logic: 40% from start ellipsoid, 40% from goal ellipsoid, 20% uniform if informed balls exist\n        import random\n        prob = random.random()\n\n        def sample_ellipsoid(center: Point, c_best: float, c_min: float) -> Point:\n            if grid_size.n_dim != 2:\n                # fallback to uniform\n                return None\n            a1 = c_best / 2\n            try:\n                a2 = (c_best**2 - c_min**2)**0.5 / 2\n            except Exception:\n                return None\n            for _ in range(200):\n                rx = torch.FloatTensor(1).uniform_(-1,1).item()\n                ry = torch.FloatTensor(1).uniform_(-1,1).item()\n                norm = (rx**2 + ry**2)**0.5\n                if norm > 1e-5:\n                    break\n            else:\n                return None\n            rx /= norm\n            ry /= norm\n            r = torch.FloatTensor(1).uniform_(0,1).item() ** (1 / 2)\n            x = r * a1 * rx\n            y = r * a2 * ry\n            # Rotation: along vector start -> goal\n            start = self._graph_start.root_vertex_start.position\n            goal = self._graph_start.root_vertex_goal.position\n            delta = torch.tensor([goal.x - start.x, goal.y - start.y])\n            angle = torch.atan2(delta[1], delta[0]).item()\n            cos_ang = torch.cos(torch.tensor(angle))\n            sin_ang = torch.sin(torch.tensor(angle))\n            rot_x = cos_ang * x - sin_ang * y\n            rot_y = sin_ang * x + cos_ang * y\n            sample_x = int(round(center.x + rot_x))\n            sample_y = int(round(center.y + rot_y))\n            sample_x = max(0, min(sample_x, grid_size[0] - 1))\n            sample_y = max(0, min(sample_y, grid_size[1] - 1))\n            sample = Point(sample_x, sample_y)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            return None\n\n        if informed_ball_start and informed_ball_goal:\n            if prob < 0.4:\n                s = sample_ellipsoid(*informed_ball_start)\n                if s is not None:\n                    return s\n            elif prob < 0.8:\n                s = sample_ellipsoid(*informed_ball_goal)\n                if s is not None:\n                    return s\n            # fallback uniform\n        elif informed_ball_start:\n            s = sample_ellipsoid(*informed_ball_start)\n            if s is not None:\n                return s\n        elif informed_ball_goal:\n            s = sample_ellipsoid(*informed_ball_goal)\n            if s is not None:\n                return s\n\n        # uniform sampling fallback\n        attempts = 0\n        while attempts < 500:\n            rand_coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(grid_size.n_dim)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n        # As a last resort fallback to agent's position to prevent error\n        return self._get_grid().agent.position\n\n    def _get_nearest_vertex(self, graph: Forest, q_sample: Point) -> Vertex:\n        return graph.get_nearest_vertex(graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, graph: Forest, position: Point, radius: float) -> list:\n        return graph.get_vertices_within_radius(graph.root_vertices, position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec)\n        if length < 1e-6:\n            return None\n        if length <= self._max_dist:\n            new_vertex_pos = q_sample\n        else:\n            dir_normalized = dir_vec / length\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n            new_vertex_pos = Point.from_tensor(new_pos_tensor)\n        if not self._get_grid().is_agent_valid_pos(new_vertex_pos):\n            return None\n        return Vertex(new_vertex_pos)\n\n    def _line_collision_free_lazy(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        for pt in line_seq:\n            if not self._get_grid().is_agent_valid_pos(pt):\n                return False\n        return True\n\n    def _rewire(self, graph: Forest, q_new: Vertex, Q_near: list) -> None:\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n            if dist > self._max_dist:\n                continue\n            new_cost = q_new.cost + dist\n            if new_cost < q_near.cost:\n                if self._line_collision_free_lazy(q_new.position, q_near.position):\n                    old_parent = None\n                    for p in q_near.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    graph.add_edge(q_new, q_near)\n\n    def _connect_trees(self, v_start: Vertex, v_goal: Vertex) -> (Vertex, Vertex, float):\n        \"\"\"\n        Attempts to connect two vertices from start and goal trees directly if collision-free.\n        Returns tuple (start_vertex, goal_vertex, cost) if successful; else None.\n        \"\"\"\n        if not self._line_collision_free_lazy(v_start.position, v_goal.position):\n            return None\n        dist = torch.norm(v_start.position.to_tensor() - v_goal.position.to_tensor()).item()\n        total_cost = v_start.cost + dist + v_goal.cost\n        return (v_start, v_goal, total_cost)\n\n    def _extract_bidirectional_path(self, start_vertex: Vertex, goal_vertex: Vertex) -> list:\n        \"\"\"\n        Extract path from start vertex in start tree and from goal vertex in goal tree,\n        concatenating paths at meeting point.\n        \"\"\"\n        path_start = []\n        cur = start_vertex\n        while cur is not None:\n            path_start.append(cur)\n            if not cur.parents:\n                break\n            # Choose parent with minimal cost (should usually be one)\n            min_cost = float('inf')\n            min_p = None\n            for p in cur.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_p = p\n            cur = min_p\n        path_start.reverse()\n\n        path_goal = []\n        cur = goal_vertex\n        while cur is not None:\n            path_goal.append(cur)\n            if not cur.parents:\n                break\n            min_cost = float('inf')\n            min_p = None\n            for p in cur.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_p = p\n            cur = min_p\n\n        # Reverse path_goal for correct direction\n        path_goal.reverse()\n        # Remove duplicate meeting vertex at join\n        if len(path_goal) > 0 and len(path_start) > 0 and path_start[-1].position == path_goal[0].position:\n            path_goal = path_goal[1:]\n\n        return path_start + path_goal\n\n    def _smooth_path(self, path: list) -> list:\n        \"\"\"\n        Shortcut smoothing removing unnecessary vertices by connecting farther apart vertices directly.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_collision_free_lazy(path[i].position, path[j].position):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.perf_counter()\n        max_time_sec = 10.0\n        max_iterations = 15000\n\n        start_tree = self._graph_start\n        goal_tree = self._graph_goal\n\n        start_root = start_tree.root_vertex_start\n        goal_root = goal_tree.root_vertex_start\n\n        start_root.cost = 0.0\n        goal_root.cost = 0.0\n\n        self._found_path = False\n        self._best_cost = float('inf')\n        self._best_start_vertex = None\n        self._best_goal_vertex = None\n\n        for iteration in range(max_iterations):\n            if time.perf_counter() - self._start_time > max_time_sec:\n                # timeout -> fail gracefully\n                break\n\n            # Setup informed sampling ellipsoids if path found\n            informed_start = None\n            informed_goal = None\n            if self._found_path and self._best_cost < float('inf'):\n                c_min = torch.norm(start_root.position.to_tensor() - goal_root.position.to_tensor()).item()\n                c_best = self._best_cost\n                center_start = Point((start_root.position.x + goal_root.position.x) / 2,\n                                     (start_root.position.y + goal_root.position.y) / 2)\n                informed_start = (center_start, c_best, c_min)\n                informed_goal = (center_start, c_best, c_min)\n\n            # Alternate tree growth: odd iteration grow start tree, even grow goal tree\n            growing_start_tree = (iteration % 2 == 0)\n            graph = start_tree if growing_start_tree else goal_tree\n            other_graph = goal_tree if growing_start_tree else start_tree\n            root_vertex = graph.root_vertex_start\n\n            q_sample = self._get_random_sample(informed_ball_start=informed_start, informed_ball_goal=informed_goal)\n            q_near = self._get_nearest_vertex(graph, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample)\n            if not q_new:\n                continue\n\n            if not self._line_collision_free_lazy(q_near.position, q_new.position):\n                continue\n\n            dist = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = q_near.cost + dist\n\n            card_V = max(1, graph.size)\n            log_card_V = torch.log(torch.tensor(float(card_V) + 1e-8))\n            radius = min(self._lambda_rrt_star * ((log_card_V / card_V) ** (1.0 / self._dimension)), self._max_radius)\n\n            Q_near = self._get_vertices_within_radius(graph, q_new.position, radius)\n\n            # Choose parent with minimum cost + collision free\n            q_min = q_near\n            c_min_vertex = q_near.cost\n            for q_near_candidate in Q_near:\n                if q_near_candidate == q_new:\n                    continue\n                dist_candidate = torch.norm(q_near_candidate.position.to_tensor() - q_new.position.to_tensor()).item()\n                if dist_candidate > self._max_dist:\n                    continue\n                cost_candidate = q_near_candidate.cost + dist_candidate\n                if cost_candidate < c_min_vertex:\n                    if self._line_collision_free_lazy(q_near_candidate.position, q_new.position):\n                        q_min = q_near_candidate\n                        c_min_vertex = cost_candidate\n            q_new.cost = c_min_vertex\n            graph.add_edge(q_min, q_new)\n            self._rewire(graph, q_new, Q_near)\n\n            # Try to connect the other tree's nearest vertex to q_new\n            q_near_other = self._get_nearest_vertex(other_graph, q_new.position)\n\n            connection = self._connect_trees(q_new, q_near_other)\n            if connection is not None:\n                (start_v, goal_v, total_cost) = connection\n                if total_cost < self._best_cost:\n                    self._best_cost = total_cost\n                    if growing_start_tree:\n                        self._best_start_vertex = start_v\n                        self._best_goal_vertex = goal_v\n                    else:\n                        self._best_start_vertex = goal_v\n                        self._best_goal_vertex = start_v\n                    self._found_path = True\n\n            self.key_frame()\n\n        if self._found_path and self._best_start_vertex and self._best_goal_vertex:\n            path_vertices = self._extract_bidirectional_path(self._best_start_vertex, self._best_goal_vertex)\n            smoothed_path = self._smooth_path(path_vertices)\n            for vertex in smoothed_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # fail silently\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This improved path planning algorithm combines bidirectional RRT* with anytime informed sampling, dynamic rewiring,\n    and path smoothing using Dubins-like shortcutting. Key improvements:\n    1. Uses two forests (start and goal) grown alternately for fast convergence.\n    2. Anytime Informed Sampling: dynamically restricts sampling space using ellipsoids updated after each found path to focus search region and improve efficiency.\n    3. Dynamic rewiring radius adaptive to increase in vertex count and dimension, improving path quality.\n    4. Lazy collision checking on edges with early abandon, reducing costly collision checks.\n    5. Uses heuristic cost-to-go and cost-from-start to guide edge selection in rewiring, improving robustness.\n    6. After a solution is found, aggressively shortcutting path with multiple iterations to produce smooth and short paths.\n    7. Strict 10-second timeout for graceful fail.\n    This algorithm targets planning efficiency, path quality, robustness, success rate, path smoothness and length, and reduced search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._graph = self._graph_start  # placeholder for compatibility\n        self._max_dist = 15.0\n        self._max_radius = 50.0\n        self._lambda_rrt_star = 50.0\n        self._dimension = self._get_grid().size.n_dim\n        self._start_time = 0.0\n        self._found_path = False\n        self._best_cost = float('inf')\n        self._best_start_vertex = None\n        self._best_goal_vertex = None\n        self._max_time_sec = 10.0\n        self._path_smooth_iterations = 30\n        self._init_displays()\n\n    def _get_nearest_vertex(self, graph: Forest, q_sample: Point) -> Vertex:\n        return graph.get_nearest_vertex(graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, graph: Forest, position: Point, radius: float) -> list:\n        return graph.get_vertices_within_radius(graph.root_vertices, position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec)\n        if length < 1e-6:\n            return None\n        if length <= self._max_dist:\n            new_vertex_pos = q_sample\n        else:\n            dir_normalized = dir_vec / length\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n            new_vertex_pos = Point.from_tensor(new_pos_tensor)\n        if not self._get_grid().is_agent_valid_pos(new_vertex_pos):\n            return None\n        return Vertex(new_vertex_pos)\n\n    def _line_collision_free_lazy(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        for pt in line_seq:\n            if not self._get_grid().is_agent_valid_pos(pt):\n                return False\n        return True\n\n    def _rewire(self, graph: Forest, q_new: Vertex, Q_near: list) -> None:\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n            if dist > self._max_dist:\n                continue\n            new_cost = q_new.cost + dist\n            if new_cost + self._heuristic_cost(q_near.position) < q_near.cost:\n                if self._line_collision_free_lazy(q_new.position, q_near.position):\n                    old_parent = None\n                    for p in q_near.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    graph.add_edge(q_new, q_near)\n\n    def _heuristic_cost(self, pos: Point) -> float:\n        # Euclidean heuristic to goal\n        goal_pos = self._get_grid().goal.position\n        return torch.norm(pos.to_tensor() - goal_pos.to_tensor()).item()\n\n    def _connect_trees(self, v_start: Vertex, v_goal: Vertex) -> (tuple or None):\n        if not self._line_collision_free_lazy(v_start.position, v_goal.position):\n            return None\n        dist = torch.norm(v_start.position.to_tensor() - v_goal.position.to_tensor()).item()\n        total_cost = v_start.cost + dist + v_goal.cost\n        return (v_start, v_goal, total_cost)\n\n    def _extract_bidirectional_path(self, start_vertex: Vertex, goal_vertex: Vertex) -> list:\n        path_start = []\n        cur = start_vertex\n        while cur:\n            path_start.append(cur)\n            if not cur.parents:\n                break\n            # choose parent with min cost\n            min_cost = float('inf')\n            min_p = None\n            for p in cur.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_p = p\n            cur = min_p\n        path_start.reverse()\n\n        path_goal = []\n        cur = goal_vertex\n        while cur:\n            path_goal.append(cur)\n            if not cur.parents:\n                break\n            min_cost = float('inf')\n            min_p = None\n            for p in cur.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_p = p\n            cur = min_p\n        path_goal.reverse()\n\n        if len(path_goal) > 0 and len(path_start) > 0 and path_start[-1].position == path_goal[0].position:\n            path_goal = path_goal[1:]\n\n        return path_start + path_goal\n\n    def _smooth_path(self, path: list) -> list:\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = min(len(path) - 1, i + 10)\n            improved = False\n            while j > i + 1:\n                if self._line_collision_free_lazy(path[i].position, path[j].position):\n                    smoothed.append(path[j])\n                    i = j\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                smoothed.append(path[i + 1])\n                i += 1\n        # Remove duplicates if any\n        final = []\n        seen = set()\n        for v in smoothed:\n            if v.position not in seen:\n                final.append(v)\n                seen.add(v.position)\n        return final\n\n    def _sample_informed_ellipsoid(self, center: Point, c_best: float, c_min: float) -> Point:\n        # Only works correctly in 2D, fallback to uniform random if failure\n        grid_size = self._get_grid().size\n        if self._dimension != 2:\n            return None\n        try:\n            diff = c_best**2 - c_min**2\n            if diff < 0:\n                return None\n            a1 = c_best / 2\n            a2 = (diff)**0.5 / 2\n        except Exception:\n            return None\n        for _ in range(50):\n            rx, ry = torch.FloatTensor(2).uniform_(-1, 1)\n            norm = torch.norm(torch.tensor([rx.item(), ry.item()]))\n            if norm > 1e-5:\n                rx /= norm\n                ry /= norm\n                r = torch.rand(1).item() ** 0.5\n                x = r * a1 * rx.item()\n                y = r * a2 * ry.item()\n                start = self._graph_start.root_vertex_start.position\n                goal = self._graph_start.root_vertex_goal.position\n                delta = torch.tensor([goal.x - start.x, goal.y - start.y])\n                angle = torch.atan2(delta[1], delta[0]).item()\n                cos_ang = torch.cos(torch.tensor(angle)).item()\n                sin_ang = torch.sin(torch.tensor(angle)).item()\n                rot_x = cos_ang * x - sin_ang * y\n                rot_y = sin_ang * x + cos_ang * y\n                sample_x = int(round(center.x + rot_x))\n                sample_y = int(round(center.y + rot_y))\n                sample_x = max(0, min(sample_x, grid_size[0] - 1))\n                sample_y = max(0, min(sample_y, grid_size[1] - 1))\n                sample = Point(sample_x, sample_y)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        return None\n\n    def _get_random_sample(self, informed_ball_start=None, informed_ball_goal=None) -> Point:\n        import random\n        prob = random.random()\n\n        if informed_ball_start and informed_ball_goal:\n            if prob < 0.45:\n                s = self._sample_informed_ellipsoid(*informed_ball_start)\n                if s:\n                    return s\n            elif prob < 0.9:\n                s = self._sample_informed_ellipsoid(*informed_ball_goal)\n                if s:\n                    return s\n            # fallback uniform\n        elif informed_ball_start:\n            s = self._sample_informed_ellipsoid(*informed_ball_start)\n            if s:\n                return s\n        elif informed_ball_goal:\n            s = self._sample_informed_ellipsoid(*informed_ball_goal)\n            if s:\n                return s\n\n        grid_size = self._get_grid().size\n        for _ in range(400):\n            rand_coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(grid_size.n_dim)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n        return self._get_grid().agent.position\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.perf_counter()\n\n        max_iterations = 20000\n        start_tree = self._graph_start\n        goal_tree = self._graph_goal\n        start_root = start_tree.root_vertex_start\n        goal_root = goal_tree.root_vertex_start\n        start_root.cost = 0.0\n        goal_root.cost = 0.0\n        self._found_path = False\n        self._best_cost = float('inf')\n        self._best_start_vertex = None\n        self._best_goal_vertex = None\n\n        for iteration in range(max_iterations):\n            if time.perf_counter() - self._start_time > self._max_time_sec:\n                break  # fail by timeout\n\n            informed_start = None\n            informed_goal = None\n\n            if self._found_path and self._best_cost < float('inf'):\n                c_min = torch.norm(start_root.position.to_tensor() - goal_root.position.to_tensor()).item()\n                c_best = self._best_cost\n                center = Point((start_root.position.x + goal_root.position.x) / 2,\n                               (start_root.position.y + goal_root.position.y) / 2)\n                informed_start = (center, c_best, c_min)\n                informed_goal = (center, c_best, c_min)\n\n            growing_start = (iteration % 2 == 0)\n            graph = start_tree if growing_start else goal_tree\n            other_graph = goal_tree if growing_start else start_tree\n\n            q_sample = self._get_random_sample(informed_ball_start=informed_start, informed_ball_goal=informed_goal)\n            q_near = self._get_nearest_vertex(graph, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample)\n            if not q_new:\n                continue\n\n            if not self._line_collision_free_lazy(q_near.position, q_new.position):\n                continue\n\n            dist_to_near = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = q_near.cost + dist_to_near\n\n            card_V = max(1, graph.size)\n            log_card_V = torch.log(torch.tensor(float(card_V) + 1e-8))\n            radius = min(self._lambda_rrt_star * ((log_card_V / card_V) ** (1.0 / self._dimension)), self._max_radius)\n\n            Q_near = self._get_vertices_within_radius(graph, q_new.position, radius)\n\n            q_min = q_near\n            c_min_vertex = q_near.cost\n            for q_near_candidate in Q_near:\n                if q_near_candidate == q_new:\n                    continue\n                dist_candidate = torch.norm(q_near_candidate.position.to_tensor() - q_new.position.to_tensor()).item()\n                if dist_candidate > self._max_dist:\n                    continue\n                cost_candidate = q_near_candidate.cost + dist_candidate\n                if cost_candidate < c_min_vertex:\n                    if self._line_collision_free_lazy(q_near_candidate.position, q_new.position):\n                        q_min = q_near_candidate\n                        c_min_vertex = cost_candidate\n\n            q_new.cost = c_min_vertex\n            graph.add_edge(q_min, q_new)\n            self._rewire(graph, q_new, Q_near)\n\n            q_near_other = self._get_nearest_vertex(other_graph, q_new.position)\n            connection = self._connect_trees(q_new, q_near_other)\n            if connection is not None:\n                (start_v, goal_v, total_cost) = connection\n                if total_cost < self._best_cost:\n                    self._best_cost = total_cost\n                    if growing_start:\n                        self._best_start_vertex = start_v\n                        self._best_goal_vertex = goal_v\n                    else:\n                        self._best_start_vertex = goal_v\n                        self._best_goal_vertex = start_v\n                    self._found_path = True\n\n            self.key_frame()\n\n        if self._found_path and self._best_start_vertex and self._best_goal_vertex:\n            path_vertices = self._extract_bidirectional_path(self._best_start_vertex, self._best_goal_vertex)\n\n            for _ in range(self._path_smooth_iterations):\n                path_vertices = self._smooth_path(path_vertices)\n\n            for vertex in path_vertices:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # fail silently after timeout or no path\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "Improved Path Planning Algorithm based on an enhanced RRT* concept with informed sampling and rewiring:\n    - Uses goal-biased sampling to focus exploration towards goal, improving planning efficiency.\n    - Applies rewiring to locally optimize path connections, improving path quality and smoothness.\n    - Uses adaptive neighborhood radius for rewiring to balance exploration vs. exploitation.\n    - Employs early termination if path to goal found, minimizing search time.\n    - Integrates timeout check ensuring search fails if exceeding 10 seconds for robustness.\n    - Uses precise collision checking via line validation for robustness.\n    - Maintains a forest graph structure for flexible path representations and fast nearest neighbor queries.\n    - Overall, this approach improves success rate, reduces path length, and smooths the resulting trajectory.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = Forest(\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n        )\n        self._graph.edges_removable = True\n        self._max_extend_dist = 12.0\n        self._rewire_radius_factor = 30.0  # factor to scale radius adaptively\n        self._goal_sample_rate = 0.2  # probability to sample goal directly\n        self._timeout_seconds = 10.0\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling with probability self._goal_sample_rate\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        dim = self._get_grid().size.n_dim\n        while True:\n            rand_coords = np.random.randint(0, self._get_grid().size, dim)\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_v: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        dir_vec = to_point.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            new_pos = to_point\n        else:\n            dir_norm = dir_vec / dist\n            new_pos_tensor = from_v.position.to_tensor() + max_dist * dir_norm\n            new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _collision_free(self, from_point: Point, to_point: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(from_point, to_point)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _near_vertices(self, new_vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], new_vertex.position, radius)\n\n    def _choose_parent(self, near_vertices: List[Vertex], new_vertex: Vertex) -> Optional[Vertex]:\n        min_cost = float('inf')\n        best_parent = None\n        for near_v in near_vertices:\n            if self._collision_free(near_v.position, new_vertex.position):\n                cost = near_v.cost + self._get_grid().get_movement_cost(near_v.position, new_vertex.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = near_v\n        if best_parent is not None:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: List[Vertex]) -> None:\n        for near_v in near_vertices:\n            if near_v == new_vertex:\n                continue\n            if self._collision_free(new_vertex.position, near_v.position):\n                new_cost = new_vertex.cost + self._get_grid().get_movement_cost(new_vertex.position, near_v.position)\n                if new_cost < near_v.cost:\n                    # Remove old edge(s) leading to near_v and add new edge from new_vertex\n                    for p in list(near_v.parents):\n                        self._graph.remove_edge(p, near_v)\n                    self._graph.add_edge(new_vertex, near_v)\n                    near_v.cost = new_cost\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        # Extract path backward from goal to start via parents\n        path: List[Vertex] = [goal_vertex]\n        current = goal_vertex\n        while current.position != self._graph.root_vertex_start.position:\n            if not current.parents:\n                # No path to start\n                break\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Animate path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n\n        start_time = time()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        max_iter = 20000\n        found_goal = False\n\n        for iter_count in range(max_iter):\n            if time() - start_time > self._timeout_seconds:\n                # Treat as failed search due to timeout\n                break\n\n            q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._steer(q_near, q_sample, self._max_extend_dist)\n\n            if not self._collision_free(q_near.position, q_new.position):\n                continue\n\n            # Adaptive radius for rewiring (RRT* style): gamma * (log(n)/n)^(1/d)\n            n_vertices = self._graph.size + 1\n            dim = self._get_grid().size.n_dim\n            gamma = self._rewire_radius_factor\n            radius = gamma * (np.log(n_vertices) / n_vertices) ** (1.0 / dim)\n            radius = max(radius, self._max_extend_dist)\n\n            near_vertices = self._near_vertices(q_new, radius)\n            parent = self._choose_parent(near_vertices, q_new)\n            if parent is None:\n                parent = q_near\n                q_new.cost = parent.cost + self._get_grid().get_movement_cost(parent.position, q_new.position)\n\n            self._graph.add_edge(parent, q_new)\n\n            self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex explicitly and extract path\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                goal_vertex.cost = float('inf')\n                if self._collision_free(q_new.position, goal_vertex.position):\n                    cost_to_goal = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n                    found_goal = True\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()\n\n        if not found_goal:\n            # No path found within constraints and timeout\n            pass  # Could raise or log failure if needed",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This algorithm integrates elements from RRT*-Smart with dynamic informed sampling and adaptive rewiring,\n    enriched with strategic goal biasing and progressive vertex pruning to boost search efficiency and path quality.\n    Key improvements:\n    - Adaptive radius shrinking for rewiring reflecting graph density growth.\n    - Periodic pruning of vertices too far from the current best path to reduce search space.\n    - Dynamic goal bias increasing as iterations progress to enhance success rate.\n    - Employs fast lazy collision checking and caching of verified edges for robustness.\n    - Implements a post-processing smoothing phase with recursive shortcut attempts.\n    The algorithm stops if it takes longer than 10 seconds and gracefully fails.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _max_radius: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _start_time: float\n    _found_path: bool\n    _best_goal_vertex: Vertex\n    _collision_cache: dict\n    _last_prune_iter: int\n    _goal_bias_increment: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        # initialize graph and parameters same as original but add new variables for improvements\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        self._max_dist = 12.0\n        self._max_radius = 40.0\n        self._lambda_rrt_star = 60.0  # slightly larger lambda to allow more rewiring radius early on\n        self._dimension = self._get_grid().size.n_dim\n\n        self._start_time = 0\n        self._found_path = False\n        self._best_goal_vertex = None\n\n        # New members\n        self._collision_cache = {}  # cache for line collision checks: (start_pos, end_pos) -> bool\n        self._last_prune_iter = 0\n        self._goal_bias_increment = 0.0\n\n        self._init_displays()\n\n\n    def _check_collision_cached(self, frm: Point, to: Point) -> bool:\n        key = (frm.values, to.values)\n        if key in self._collision_cache:\n            return self._collision_cache[key]\n        # Check reverse key as well (undirected validity)\n        key_rev = (to.values, frm.values)\n        if key_rev in self._collision_cache:\n            return self._collision_cache[key_rev]\n\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        # fast lazy collision check with early stopping\n        for pt in line_seq:\n            if not self._get_grid().is_agent_valid_pos(pt):\n                self._collision_cache[key] = False\n                return False\n        self._collision_cache[key] = True\n        return True\n\n\n    def _get_random_sample(self, informed_ball: tuple = None, goal_bias: float = 0.05) -> Point:\n        \"\"\"\n        Modified sampling with goal bias: with probability goal_bias returns goal position.\n        Uses previously provided informed ellipsoid sampling if informed_ball is defined.\n        \"\"\"\n        import random\n        if random.random() < goal_bias:\n            return self._graph.root_vertex_goal.position\n\n        grid_size = self._get_grid().size\n        if informed_ball is None:\n            # Uniform random sampling valid for whole space\n            while True:\n                rand_coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(grid_size.n_dim)]\n                sample = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            c_best = informed_ball[1]\n            c_min = informed_ball[2]\n            center = informed_ball[0]\n\n            if grid_size.n_dim != 2:\n                # fallback to uniform if not 2D\n                return self._get_random_sample(None, goal_bias=goal_bias)\n\n            for _ in range(200):\n                rx = torch.FloatTensor(1).uniform_(-1, 1).item()\n                ry = torch.FloatTensor(1).uniform_(-1, 1).item()\n                norm = (rx ** 2 + ry ** 2) ** 0.5\n                if norm > 1e-5:\n                    break\n            else:\n                return self._get_random_sample(None, goal_bias=goal_bias)\n\n            rx /= norm\n            ry /= norm\n\n            r = torch.FloatTensor(1).uniform_(0, 1).item() ** (1 / 2)\n            a1 = c_best / 2\n            a2 = (c_best ** 2 - c_min ** 2) ** 0.5 / 2\n\n            x = r * a1 * rx\n            y = r * a2 * ry\n\n            start = self._graph.root_vertex_start.position\n            goal = self._graph.root_vertex_goal.position\n            delta = torch.tensor([goal.x - start.x, goal.y - start.y])\n            angle = torch.atan2(delta[1], delta[0]).item()\n\n            cos_ang = torch.cos(torch.tensor(angle))\n            sin_ang = torch.sin(torch.tensor(angle))\n            rot_x = cos_ang * x - sin_ang * y\n            rot_y = sin_ang * x + cos_ang * y\n\n            sample_x = int(round(center.x + rot_x))\n            sample_y = int(round(center.y + rot_y))\n\n            # Clamp inside grid\n            sample_x = max(0, min(sample_x, grid_size[0] - 1))\n            sample_y = max(0, min(sample_y, grid_size[1] - 1))\n\n            sample = Point(sample_x, sample_y)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            else:\n                return self._get_random_sample(None, goal_bias=goal_bias)\n\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        # Use graph's nearest vertex search starting from root start vertices only\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> list:\n        # Returns vertices within radius from given vertex position\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec)\n        if length < 1e-6:\n            return None\n        if length <= self._max_dist:\n            new_vertex_pos = q_sample\n        else:\n            dir_normalized = dir_vec / length\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n            new_vertex_pos = Point.from_tensor(new_pos_tensor)\n\n        if not self._get_grid().is_agent_valid_pos(new_vertex_pos):\n            return None\n        return Vertex(new_vertex_pos)\n\n\n    def _rewire(self, q_new: Vertex, Q_near: list) -> None:\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n            if dist > self._max_dist:\n                continue\n            new_cost = q_new.cost + dist\n            if q_near.cost is None or new_cost < q_near.cost:\n                if self._check_collision_cached(q_new.position, q_near.position):\n                    old_parent = None\n                    for p in q_near.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n\n    def _extract_path(self, goal_vertex: Vertex) -> list:\n        path = [goal_vertex]\n        while len(path[-1].parents) > 0:\n            min_parent = None\n            min_cost = float('inf')\n            for parent in path[-1].parents:\n                if parent.cost is not None and parent.cost < min_cost:\n                    min_cost = parent.cost\n                    min_parent = parent\n            if min_parent is None:\n                break\n            path.append(min_parent)\n        path.reverse()\n        return path\n\n\n    def _recursive_smooth_path(self, path: list, start_idx: int = 0) -> list:\n        if len(path) < 3 or start_idx >= len(path) - 2:\n            return path\n        i = start_idx\n        j = len(path) - 1\n        while j > i + 1:\n            if self._check_collision_cached(path[i].position, path[j].position):\n                # Remove intermediate vertices between i and j\n                new_path = path[: i + 1] + path[j:]\n                # Continue smoothing recursively on new path starting at i\n                return self._recursive_smooth_path(new_path, i)\n            j -= 1\n        # No shortcut found, continue smoothing from next vertex\n        return self._recursive_smooth_path(path, start_idx + 1)\n\n\n    def _prune_vertices(self, best_cost: float, start: Vertex, goal: Vertex) -> None:\n        # Prune vertices whose cost estimate (cost + heuristic) exceeds current best_cost * 1.05 margin\n        margin = 1.05\n        to_remove = []\n        for v in list(self._graph.root_vertex_start.children) + [self._graph.root_vertex_start]:\n            # Use heuristic as straight-line distance to goal\n            heuristic = torch.norm(v.position.to_tensor() - goal.position.to_tensor()).item()\n            if v.cost is None or (v.cost + heuristic) > best_cost * margin:\n                to_remove.append(v)\n        # Remove pruned vertices & detach from graph\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n        # No guarantee all pruned vertices removed from root vertices list, but they won't be connected\n\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.perf_counter()\n        max_time_sec = 10.0\n\n        start: Vertex = self._graph.root_vertex_start\n        goal: Vertex = self._graph.root_vertex_goal\n\n        start.cost = 0.0\n        best_cost = float('inf')\n        best_goal_vertex: Vertex = None\n\n        max_iterations = 20000  # Increased iterations to allow more refinement\n        self._found_path = False\n\n        for iteration in range(max_iterations):\n            elapsed = time.perf_counter() - self._start_time\n            if elapsed > max_time_sec:\n                # Fail safely on timeout\n                break\n\n            # Gradually increase goal bias from 5% up to 30%\n            goal_bias = min(0.05 + 0.000012 * iteration, 0.3)\n\n            if self._found_path and best_goal_vertex is not None and best_cost < float('inf'):\n                c_min = torch.norm(start.position.to_tensor() - goal.position.to_tensor()).item()\n                c_best = best_cost\n                center = Point((start.position.x + goal.position.x) / 2, (start.position.y + goal.position.y) / 2)\n                informed_ball = (center, c_best, c_min)\n                q_sample = self._get_random_sample(informed_ball=informed_ball, goal_bias=goal_bias)\n            else:\n                q_sample = self._get_random_sample(goal_bias=goal_bias)\n\n            q_near = self._get_nearest_vertex(q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample)\n            if q_new is None:\n                continue\n\n            if not self._check_collision_cached(q_near.position, q_new.position):\n                continue\n\n            cost_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = cost_to_new\n\n            card_V = max(1, self._graph.size)\n            log_card_V = torch.log(torch.tensor(float(card_V) + 1e-8))\n            # Adaptive rewiring radius shrinks slightly as graph grows\n            radius = min(\n                self._lambda_rrt_star * ((log_card_V / card_V) ** (1.0 / self._dimension)),\n                self._max_radius,\n                self._max_dist * 5\n            )\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent in Q_near by cost + collision-free check\n            q_min = q_near\n            c_min_vertex = q_near.cost\n            for q_near_candidate in Q_near:\n                if q_near_candidate == q_new:\n                    continue\n                dist = torch.norm(q_near_candidate.position.to_tensor() - q_new.position.to_tensor()).item()\n                if dist > self._max_dist:\n                    continue\n                cost_candidate = q_near_candidate.cost + dist\n                if cost_candidate < c_min_vertex:\n                    if self._check_collision_cached(q_near_candidate.position, q_new.position):\n                        q_min = q_near_candidate\n                        c_min_vertex = cost_candidate\n\n            q_new.cost = c_min_vertex\n            self._graph.add_edge(q_min, q_new)\n\n            self._rewire(q_new, Q_near)\n\n            # Check if q_new reached goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = torch.norm(q_new.position.to_tensor() - goal.position.to_tensor()).item()\n                total_cost = q_new.cost + dist_to_goal\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_goal_vertex = q_new\n                    self._found_path = True\n\n            # Periodic pruning of vertices every 500 iterations to keep graph compact\n            if self._found_path and (iteration - self._last_prune_iter) >= 500:\n                self._prune_vertices(best_cost, start, goal)\n                self._last_prune_iter = iteration\n\n            self.key_frame()\n\n        if self._found_path and best_goal_vertex is not None:\n            path_vertices = self._extract_path(best_goal_vertex)\n            path_vertices = self._recursive_smooth_path(path_vertices)\n            for vertex in path_vertices:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # No path found or timed out, implicit fail (do nothing)\n            pass",
     "objective": null,
     "other_inf": null
}
